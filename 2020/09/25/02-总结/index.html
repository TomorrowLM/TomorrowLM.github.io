<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>总结 | TomorrowLM-Web</title><meta name="author" content="LMTomorrow,120329698@qq.com"><meta name="copyright" content="LMTomorrow"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于一些实战常用的html,css,es5的总结"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tomorrowlm.github.io/2020/09/25/02-%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"总结",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-05-30 11:32:09"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom/custom.css"><link rel="stylesheet" href="/css/custom/universe.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>目录</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw anzhiyu-icon-music"></i> <span>音乐馆</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover_1.gif)"><nav id="nav"><span id="blog-info"><a href="/" title="TomorrowLM-Web"><span class="site-name">TomorrowLM-Web</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>目录</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i> <span>其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw anzhiyu-icon-music"></i> <span>音乐馆</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-24T16:00:00.000Z" title="发表于 2020-09-25 00:00:00">2020-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-30T03:32:09.769Z" title="更新于 2023-05-30 11:32:09">2023-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">68k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>242分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//message提示</span><br><span class="line">&#123;</span><br><span class="line">    code:&#x27;&#x27;,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    message:&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数类型：json对象，application/x-www-form-urlencoded</li></ul><ul><li>常用值定义：<ul><li>状态(0开启，1关闭)</li></ul></li><li>table表格传参格式定义，页数，页码</li></ul><ul><li><p>校验方式：后端校验，前端message展示。</p></li><li><p>错误码规范</p></li></ul><ul><li>增删改查code码，获取表格数据和操作成功的数据返回的code码需要不一致，这样就可以统一的在axios中去message了</li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul><li>开发同一个组件，需要协调同步，防止代码冲突</li></ul><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul><li><p>开发规范</p><ul><li>每个页面需要注释这个页面的作用，方法的作用</li><li>api接口方法用/**/注释，才有提示</li><li>注意后期的维护</li></ul></li><li><p>代码规范</p><ul><li>生命周期，布尔值放在开头</li><li>循环数据过多，不要用框架带的组件，用原生的标签。</li></ul></li><li><p>接口规范</p><ul><li>提前和后端定义好数据格式，不然前端写好再去联调，参数不一致加大开发成本</li><li>重复请求：加节流</li><li>定义好一些下拉框数据是前端保存还是后端数据库保存</li></ul></li><li><p>表单</p><ul><li>表单校验，哪些是必填，提示信息是什么</li><li>提交成功后需要清空表单数据</li><li>弹框中表单提交成功后，需要关闭弹框</li></ul></li><li><p>table</p><ul><li>查询时页码要置为1</li><li>修改条数时页码要置为1</li></ul></li><li><p>逻辑</p><ul><li>增删改要加提示信息</li><li>tab切换，查询条件需要重置</li><li>按钮请求loading（写个公共模块）</li><li>某些按钮需要根据状态启用和禁用</li><li>操作成功后，是否需要刷新table</li><li>注意修改某个地方之后，其他地方是否需要同步修改，最好是能去再走一遍流程</li><li>添加需求或者某个逻辑的时候要思考一下是否合理。</li></ul></li><li><p>回显</p><ul><li>树的回显</li></ul></li><li><p>组件</p><ul><li>可维护性，可扩展性</li><li>写代码的时候需要注意，多个页面会有公共的模块可以提出来</li><li>拒绝同一个业务写多个组件，统一用一个语法，一个组件，同一个图片。防止后期维护他人代码时，影响效率</li></ul></li><li><p>注意判断条件，前因后果是否符合逻辑</p></li></ul><h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ul><li><strong>注意需要根据用户账号去保持状态</strong></li></ul><h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="你在公司做啥"><a href="#你在公司做啥" class="headerlink" title="你在公司做啥"></a>你在公司做啥</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul><li><p>阿里云上传图片组件的研发，一个是插件，一个是阿里云链接</p></li><li><p>下拉框搜索变成输入自定义邮箱后缀。他有搜索事件，和选择事件，通过输入字段不断触发搜索事件，失去焦点之后，执行blur事件，通过循环遍历默认的邮箱后缀来判断是否是自定义的邮箱后缀。最后将自定义的邮箱后缀加到邮箱后缀列表中。</p></li><li><p>指向问题。react-xarrows，react-draggable。开始的需求是textarea和笑脸图标用箭头符号相连。制作的话可以用svg或者xarrows来制作箭头符号。但是根据上手时间的情况，以及能完美呈现效果还是使用xarrows。根据GitHubxarrows文档，因为需求textarea图标能被拖拽，看到xarrows文档使用draggable配合xarrows拖拽，箭头能保持指向。所以将原来的拖拽功能注释了。遇到箭头指向错误，codesandbox测试是没找到指向对象。应该把Xarrow放在const创建的jsx对象里面。应该就是渲染时候，没找到对象就执行箭头事件了。在文本框拖拽区域的盒子上使用mousemove，事件对象的offsetX/Y是以文本框定位的</p><p>在mousedown中修改文本框层级之后，文本框没有触发焦点。mousedown,focus,mouseup,click事件的执行顺序。</p></li><li><p>g2,label,分行</p></li></ul><h3 id="cisdi"><a href="#cisdi" class="headerlink" title="cisdi"></a>cisdi</h3><ul><li><p>防抖</p></li><li><p>监听数据没有更新</p></li><li><p>行车终端，行车系统发送给服务器，后端通过Websocket给到前端。初始化时发送uid，后端存入这个ws对象并绑定这个uid（后端做了检验，判断只会对最早的那一个对应的uid的ws对象发送消息，所以新建立的对象收不到消息）。所以刷新页面的时候需要删除这个通道，还需要传给后端关闭通道的消息。不然，后端发送消息还是会发给旧的ws对象。这里我会在beforeunload把所有绑定的id去做注销，然后在mounted去初始化ws,并发送绑定的行车id</p><p>因为只能给唯一一个id绑定，不太符合现实，可以设置uuid设置唯一标识，服务器可以为每个标识绑定的uid发送信息</p></li><li><p>tag导航栏，路由导航</p></li><li><p>指令：vue本身是不推荐我们直接操作DOM的,既然你选择了使用vue，尽量考虑可以从数据层面去驱动，另外，DOM的操作是很昂贵的，每次操作DOM都会引起浏览器的重绘，虽然说现在的电脑或者手机的性能已经很好，但是，我猜测没有一个人会建议你大量操作DOM的。你可以看到现在流行的框架VUE、react，都是操作数据而不是直接操作DOM的</p></li><li><p>tablepane,onresize,height</p></li><li><p>大地图</p><ul><li>如何循环渲染库位<ul><li>for循环渲染行列（这是因为要定位），再根据后端给的数据循环判断，一个格子就要循环所有的数据。<code>100*100*100</code></li><li>后端返回所有位置，再根据给的数据循环渲染（根据行列定位）</li><li>偶数列放在线交叉的位置，盒子大小的一半就可以</li></ul></li><li>组件<ul><li>根据区域封装</li><li>特殊结构封装</li><li>库位做一个封装</li><li>公用模块封装。比如，所有的位置都有钢卷可以做一个封装。运输连的托盘做一个封装</li></ul></li><li>性能渲染<ul><li>v-show,v-if</li><li>分片渲染</li><li>图片</li></ul></li></ul></li><li><p>小地图，渲染绿色钢卷。储位和绿色钢卷的接口执行顺序同步。所以有时候显示有时候不显示</p></li><li><p>bufferarray 和 blob</p></li><li><p>数字平台</p><ul><li>审批流程</li><li>树状</li></ul></li></ul><h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul><li><p>闭包</p></li><li><p>异步</p></li><li><p>一些优化的方案</p></li><li><p>构造函数</p></li><li><p>react this指向</p></li><li><p>面向对象</p></li><li><p>作用域链</p></li><li><p>设计模式</p></li><li><p>原理</p><ul><li><p>vue,install</p></li><li><p>this.$set的原理，<a target="_blank" rel="noopener" href="https://jishuin.proginn.com/p/763bfbd75fd7">https://jishuin.proginn.com/p/763bfbd75fd7</a></p><p>Object.assign方法有很多用处。</p><p>（1）为对象添加属性</p><p>class Point {<br> constructor(x, y) {</p><pre><code>Object.assign(this, &#123;x, y&#125;);
</code></pre><p> }<br>}<br>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实</p></li></ul></li></ul><h2 id="前端初中高评级"><a href="#前端初中高评级" class="headerlink" title="前端初中高评级"></a>前端初中高评级</h2><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p>初级：</p><ol><li>知道组合寄生继承，知道class继承。</li><li>知道怎么创建类function + class。</li><li>知道闭包在实际场景中怎么用，常见的坑。</li><li>知道模块、组件是什么，怎么用。</li><li>知道event loop是什么，能举例说明event loop怎么影响平时的编码。</li><li>掌握基础数据结构，比如堆、栈、树，并了解这些数据结构计算机基础中的作用。</li><li>知道ES6数组相关方法，比如forEach，map，reduce。</li></ol><p>中级：</p><ol><li>知道class继承与组合寄生继承的差别，并能举例说明。</li><li>知道event loop原理，知道宏微任务，并且能从个人理解层面说出为什么要区分。知道node和浏览器在实现loop时候的差别。</li><li>能将继承、作用域、闭包、模块这些概念融汇贯通，并且结合实际例子说明这几个概念怎样结合在一起。</li><li>能脱口而出2种以上设计模式的核心思想，并结合js语言特性举例或口喷基础实现。</li><li>掌握一些基础算法核心思想或简单算法问题，比如排序，大数相加。</li></ol><h3 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a><strong>工程化工具</strong></h3><p>初级：</p><ol><li>知道webpack，rollup以及他们适用的场景。</li><li>知道webpack v3、v4和v5的区别。</li><li>webpack基础配置。</li><li>知道webpack打包结果的代码结构和执行流程，知道index.js，runtime.js是干嘛的。</li><li>知道amd，cmd，commonjs，es module分别是什么。</li><li>知道所有模块化标准定义一个模块怎么写。给出2个文件，能口喷一段代码完成模块打包和执行的核心逻辑</li></ol><p>中级：</p><ol><li>知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。</li><li>知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。</li><li>能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。</li><li>了解异步模块加载的实现原理，能口喷代码实现核心逻辑。</li></ol><p>高级：</p><ol><li>项目脚手架搭建，及如何以工具形态共享。</li><li>工具化打包发布流程，包括本地调试、云构建、线上发布体系、一键部署能力。同时，方案不仅限于前端工程部分，包含相关服务端基础设施，比如cdn服务搭建，接入层缓存方案设计，域名管控等。</li></ol><h3 id="React（ng-vue）"><a href="#React（ng-vue）" class="headerlink" title="React（ng/vue）"></a>React（ng/vue）</h3><p>react替换为vue或angular同样适用</p><p>初级：</p><ol><li>知道react常见优化方案，脱口而出常用生命周期，知道他们是干什么的。</li><li>知道react大致实现思路，能对比react和js控制原生dom的差异，能口喷一个简化版的react。</li><li>知道diff算法大致实现思路。</li><li>对state和props有自己的使用心得，结合受控组件、hoc等特性描述，需要说明各种方案的适用场景。</li></ol><p>中级：</p><ol><li>能说明白为什么要实现fiber，以及可能带来的坑。</li><li>能说明白为什么要实现hook。</li><li>能说明白为什么要用immutable，以及用或者不用的考虑。</li><li>知道react不常用的特性，比如context，portal。</li><li>能用自己的理解说明白react like框架的本质，能说明白如何让这些框架共存。</li></ol><p>高级：</p><ol><li>能设计出框架无关的技术架构。包括但不限于：</li><li>说明如何解决可能存在的冲突问题，需要结合实际案例。</li><li>能说明架构分层逻辑、各层的核心模块，以及核心模块要解决的问题。能结合实际场景例举一些坑或者优雅的处理方案则更佳。</li></ol><h3 id="react生态工具（ng-vue同理）"><a href="#react生态工具（ng-vue同理）" class="headerlink" title="react生态工具（ng/vue同理）"></a><strong>react生态工具（ng/vue同理）</strong></h3><p>初级：</p><ol><li>知道react-router，redux，redux-thunk，react-redux，immutable，antd或同级别社区组件库。（全家桶）</li><li>知道浏览器react相关插件有什么，怎么用。</li><li>知道react-router 各个版本的差异。</li><li>知道antd组件化设计思路。</li><li>知道thunk干嘛用的，怎么实现的。</li></ol><p>中级：</p><ol><li>看过全家桶源码，不要求每行都看，但是知道核心实现原理和底层依赖。能口喷几行关键代码把对应类库实现即达标。</li><li>能从数据驱动角度透彻的说明白redux，能够口喷原生js和redux结合要怎么做。</li><li>能结合redux，vuex，mobx等数据流谈谈自己对vue和react的异同。</li></ol><p>高级：</p><ol><li>有基于全家桶构建复杂应用的经验，比如微前端和这些类库结合的时候要注意什么，会有什么坑，怎么解决</li></ol><h3 id="各种Web前端技术"><a href="#各种Web前端技术" class="headerlink" title="各种Web前端技术"></a><strong>各种Web前端技术</strong></h3><p>初级：</p><ol><li>HTML方面包括但不限于：语义化标签，history api，storage，ajax2.0等。</li><li>CSS方面包括但不限于：文档流，重绘重排，flex，BFC，IFC，before/after，动画，keyframe，画三角，优先级矩阵等。</li><li>知道axios或同级别网络请求库，知道axios的核心功能。</li><li>能口喷xhr用法，知道网络请求相关技术和技术底层，包括但不限于：content-type，不同type的作用；restful设计理念；cors处理方案，以及浏览器和服务端执行流程；口喷文件上传实现；</li><li>知道如何完成登陆模块，包括但不限于：登陆表单如何实现；cookie登录态维护方案；token base登录态方案；session概念；</li></ol><p>中级：</p><ol><li>HTML方面能够结合各个浏览器api描述常用类库的实现。</li><li>css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理。</li><li>能说明白接口请求的前后端整体架构和流程，包括：业务代码，浏览器原理，http协议，服务端接入层，rpc服务调用，负载均衡。</li><li>知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等。</li><li>知道pc端与移动端登录态维护方案，知道token base登录态实现细节，知道服务端session控制实现，关键字：refresh token。</li><li>知道oauth2.0轻量与完整实现原理。</li><li>知道移动端api请求与socket如何通过native发送，知道如何与native进行数据交互，知道ios与安卓jsbridge实现原理。</li></ol><p>eslint的使用</p><p>ts的使用</p><p>浏览器的一些使用和原理</p><p>学习资源和路径</p><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA">https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA</a></p><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/cqlhO6N8pGCjNkdHNSio4g">https://mp.weixin.qq.com/s/cqlhO6N8pGCjNkdHNSio4g</a></p><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程和线程的概念可以这样理解：</p><blockquote><p>- 进程是一个工厂，工厂有它的独立资源</p><p>- 工厂之间相互独立</p><p>- 线程是工厂中的工人，多个工人协作完成任务</p><p>- 工厂内有一个或多个工人</p><p>- 工人之间共享空间</p></blockquote><blockquote><p>- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</p><p>- 工厂之间的相互独立 -&gt; 进程之间相互独立</p><p>- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</p><p>- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</p><p>- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p></blockquote> <img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KzcDnDRlicWl0V3fV9Qtzg8n4segZjiaiaCqr982pXRSEIGOq7ics1CRm4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%"><p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存）</p><p>线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p><h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KDibJqU6bBoWCNcT6QS22cFxOygakR1519HdRzOp2iagK5ibfJQWm2e4xA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%"><p><strong>浏览器是多进程的</strong>，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p><h4 id="浏览器包含的进程"><a href="#浏览器包含的进程" class="headerlink" title="浏览器包含的进程"></a>浏览器包含的进程</h4><ol><li><p><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有：</p><ul><li><p>负责浏览器的界面显示，与用户交互，如前进，后退等</p></li><li><p>负责各个页面的管理，创建和销毁其它进程</p></li><li><p>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>,绘制到用户界面上</p></li><li><p>网络资源的管理，下载</p></li></ul></li><li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</p></li><li><p><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</p></li><li><p>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等</p></li></ol><p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p><p>浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTcxWjP4iaMWw41pMxuEfjju2K8EkkWh1bgSgNfibdBVwNia4IaicBdUk0rsLXS094QmiaHiawgr3Jfb8GJTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h4><ul><li>避免单个<code>page crash</code>影响整个浏览器</li><li>避免第三方插件<code>crash</code>影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ul><p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器; 当然，内存等资源消耗也会更大，像空间换时间一样。</p><h3 id="浏览器内核-渲染进程"><a href="#浏览器内核-渲染进程" class="headerlink" title="浏览器内核(渲染进程)"></a>浏览器内核(渲染进程)</h3><p>浏览器内核：浏览器所采用的渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</p><ul><li><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等。</li><li><code>Gecko</code>内核：<code>Netscape6</code>及以 上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</li><li><code>Presto</code>内核：<code>Opera7</code>及以上。 [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</li><li><code>Webkit</code>内核：<code>Safari,Chrome</code>等。 [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</li></ul><p><strong>浏览器是多进程的，浏览器的渲染进程是多线程的（浏览器的内核是多线程的）；</strong></p><p>渲染进程如下：</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KO3Pmiabeq4UPvMSR2fM00YkQAicSmHoXtezy928XErvNLpFlBwcVXic0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><p><strong>虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</strong></p><h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a><code>GUI</code>渲染线程</h4><ul><li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>,构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li><li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li><li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li></ul><blockquote><p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p><p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p></blockquote><h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a><code>JS</code>引擎线程</h4><blockquote><p>javascript是单线程的， 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点。所以javascript是单线程的。</p></blockquote><ul><li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li><li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li><li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，<strong>一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</strong></li><li><strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li></ul><h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul><li><strong>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</strong></li><li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li><li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li><li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li></ul><h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><ul><li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li><li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（<strong>因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确</strong>）</li><li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li><li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li></ul><h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步<code>http</code>请求线程</h4><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</li></ul><h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><h4 id="浏览器主进程"><a href="#浏览器主进程" class="headerlink" title="浏览器主进程"></a>浏览器主进程</h4><p>浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程</p><h4 id="浏览器渲染进程"><a href="#浏览器渲染进程" class="headerlink" title="浏览器渲染进程"></a>浏览器渲染进程</h4><h6 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h6><p>浏览器内核拿到响应报文之后，渲染大概分为以下步骤</p><ol><li>解析html生产DOM树。</li><li>解析CSS规则。</li><li>根据DOM Tree和CSS Tree生成Render Tree。</li><li>根据Render树进行layout，负责各个元素节点的尺寸、位置计算。</li><li>绘制Render树(painting)，绘制页面像素信息。</li><li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li></ol><h6 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a><strong>详细版</strong></h6><ol><li><p>在浏览器地址栏输入URL</p></li><li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p><ol><li><p>如果资源未缓存，发起新请求</p></li><li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p></li><li><p>检验新鲜通常有两个HTTP头进行控制</p><p>Expires和Cache-Control：</p><ul><li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li><li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li></ul></li></ol></li><li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p></li><li><p>浏览器获取主机ip地址，过程如下：</p><ol><li>浏览器缓存</li><li>本机缓存</li><li>hosts文件</li><li>路由器缓存</li><li>ISP DNS缓存</li><li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li></ol></li><li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p></li><li><p>打开一个socket与目标IP地址，端口建立TCP链接</p><p>三次握手如下：</p><ol><li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li><li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li><li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li></ol></li><li><p>TCP链接建立后<strong>发送HTTP请求</strong></p></li><li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p></li><li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p></li><li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p></li><li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p></li><li><p>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</p><ol><li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li><li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li><li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li><li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li></ol></li><li><p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p></li><li><p>如果资源可缓存，<strong>进行缓存</strong></p></li><li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p></li><li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p></li><li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p></li><li><p>构建DOM树：</p><ol><li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li><li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li><li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li></ol></li><li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p></li><li><p>构建CSSOM树：</p><ol><li><strong>Tokenizing</strong>：字符流转换为标记流</li><li><strong>Node</strong>：根据标记创建节点</li><li><strong>CSSOM</strong>：节点创建CSSOM树</li></ol></li><li><p><a target="_blank" rel="noopener" href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树</a>:</p><ol><li><p>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：</p><p>1）<code>script</code>,<code>meta</code>这样本身不可见的标签。</p><p>2)被css隐藏的节点，如<code>display: none</code></p></li><li><p>对每一个可见节点，找到恰当的CSSOM规则并应用</p></li><li><p>发布可视节点的内容和计算样式</p></li></ol></li></ol><h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul><li>DOM Tree： 浏览器将HTML解析成树形的数据结构。</li><li>CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</li><li>Render Tree：DOM树和CSS规则树合并后生产Render树。</li><li>layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</li><li>painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</li><li>重排（重构/回流/reflow）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 <code>reflow</code>。reflow 会从<html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</html></li><li>重绘（repaint或redraw）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></li></ul><h5 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h5><p>浏览器渲染的图层一般包含两大类：<code>渲染图层（普通图层）</code>以及<code>复合图层</code></p><p>渲染图层：是页面普通的文档流。无论添加多少元素，还在在同一个默认复合层。<br>虽然绝对定位（absolute），相对定位（fixed），浮动定位（float）会让元素成为脱离文档流，但它仍然属于<code>默认复合层</code>，共用同一个绘图上下文对象（GraphicsContext）。</p><p>复合图层，又称图形层。它会单独分配系统资源，每个复合图层都有一个独立的GraphicsContext。（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响<code>默认复合层</code>里的回流Reflow重绘Repaint）</p><p><strong>通过<code>硬件加速</code>就可以使渲染图层提升为复合图层，GPU中，各个复合图层是单独绘制的，所以互不影响</strong></p><p>将元素变成一个复合图层，就是传说中的硬件加速技术</p><ul><li><p>最常用的方式：<code>translate3d</code>,<code>translatez</code></p></li><li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p></li><li><p><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p></li><li><p>```<br><video><iframe><canvas><webgl>等元素</webgl></canvas></iframe></video></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 其它，譬如以前的`flash`插件</span><br><span class="line"></span><br><span class="line">**复合图层的作用**</span><br><span class="line"></span><br><span class="line">一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Browser主进程和渲染进程的通信</span><br><span class="line"></span><br><span class="line">打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开`Tab`页的渲染进程）</span><br><span class="line"></span><br><span class="line">- `Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过`RendererHost`接口传递给`Render`渲染进程</span><br><span class="line">- `Render`渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染</span><br><span class="line">- `GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染</span><br><span class="line">- 当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）</span><br><span class="line">- 最后`Render`渲染进程将结果传递给`Browser`主进程</span><br><span class="line">- `Browser`主进程接收到结果并将结果绘制出来</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KHgay7bNfvibNicDvJGvOhbupYVh19Vgbbm37TxbgqxYgMtEJwdIibolsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">### JS的多线程WebWorker</span><br><span class="line"></span><br><span class="line">`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？</span><br><span class="line"></span><br><span class="line">所以，后来`HTML5`中支持了`WebWorker`。</span><br><span class="line"></span><br><span class="line">来自MDN的官方解释</span><br><span class="line"></span><br><span class="line">&gt; Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面</span><br><span class="line">&gt;</span><br><span class="line">&gt; 一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 </span><br><span class="line">&gt;</span><br><span class="line">&gt; 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误</span><br><span class="line"></span><br><span class="line">这样理解下：</span><br><span class="line"></span><br><span class="line">- 创建Worker时，JS引擎向浏览器申请开一个子线程**（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）**</span><br><span class="line">- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</span><br><span class="line"></span><br><span class="line">所以，如果需要进行一些高耗时的计算时，可以单独开启一个WebWorker线程，这样不管这个WebWorker子线程怎么密集计算、怎么阻塞，都不会影响JS引擎主线程，只需要等计算结束，将结果通过postMessage传输给主线程就可以了。</span><br><span class="line"></span><br><span class="line">而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**`WebWorker`与`SharedWorker`**</span><br><span class="line"></span><br><span class="line">既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）</span><br><span class="line"></span><br><span class="line">- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</span><br><span class="line"></span><br><span class="line">- - 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</span><br><span class="line"></span><br><span class="line">- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</span><br><span class="line"></span><br><span class="line">- - 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</span><br><span class="line"></span><br><span class="line">看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</span><br><span class="line"></span><br><span class="line">### Event Loop事件循环机制</span><br><span class="line"></span><br><span class="line">事件触发线程去执行事件循环机制</span><br><span class="line"></span><br><span class="line">![yuque_diagram.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52fed7e3ab8643e885034e6f03e5e36d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)</span><br><span class="line"></span><br><span class="line">#### Event Loop目的</span><br><span class="line"></span><br><span class="line">`Event Loop`即事件循环，是指浏览器或`Node`的一种**解决`javaScript`单线程运行时不会阻塞的**一种机制，也就是我们经常使用**异步**的原理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">单线程是必要的，如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</span><br><span class="line"></span><br><span class="line">#### macrotask与microtask</span><br><span class="line"></span><br><span class="line">在ECMAScript中，macrotask可称为`task`，microtask称为`jobs`</span><br><span class="line"></span><br><span class="line">**MacroTask（宏任务）**:</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>script(整体代码)<br>setTimeout<br>setInterval<br>nodejs的setImmediate<br>网络I/O、文件I/O<br>UI渲染事件（DOM解析、布局计算、绘制）<br>MessageChannel（react的fiber用到）<br>postMessage<br>requestAnimationFrame</p></blockquote></li></ul><p><em>宿主环境：node、浏览器</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**MicroTask（微任务）**</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>process.nextTick<br>Promise<br>Async/Await(实际就是promise)<br>MutationObserver(html5新特性</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Event Loop流程</span><br><span class="line"></span><br><span class="line">1. 执行script代码块</span><br><span class="line">   1. 将同步任务放到主线程直接执行</span><br><span class="line">   2. 执行过程中如果遇到微任务(异步任务)，就将它添加到微任务的任务队列中</span><br><span class="line">   3. 执行过程中如果遇到宏任务(异步任务)，就将它添加到宏任务的任务队列中</span><br><span class="line">   4. 同步任务，执行完成，执行当前微任务队列</span><br><span class="line">2. script代码块执行结束，检查宏任务队列，取下一个宏任务执行，执行完检查微任务队列，重复执行步骤</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/6a2d22cc2af84f84ac072e89dc7dee90.png#pic_center)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 调用`setTimeout`后，是如何等待特定时间后才添加到事件队列中的？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 由定时器线程控制，因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时</span><br><span class="line">&gt;</span><br><span class="line">&gt; 当使用`setTimeout`或`setInterval`时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Node事件循环</span><br><span class="line"></span><br><span class="line">##### 特点</span><br><span class="line"></span><br><span class="line">- 分为6个阶段</span><br><span class="line">- 每个阶段对应一个宏任务队列。</span><br><span class="line">- 每个阶段都要等对应的宏任务队列执行完毕才会进入到下一个阶段的宏任务队列</span><br><span class="line">- 每两个阶段之间执行微任务队列</span><br><span class="line"></span><br><span class="line">##### 流程</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/e4b35b71625e4070adf93a8417e6a634.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">定时器（timers）：本阶段执行 setTimeout和 setInterval的回调函数。</span><br><span class="line">待定回调（pending callback）：执行某些操作的回调</span><br><span class="line">idle, prepare：仅系统内部使用。</span><br><span class="line">轮询（poll）：计算应该阻塞和轮询 I/O 的时间，然后，处理 轮询 队列里的事件</span><br><span class="line">检测（check）：setImmediate() 回调函数在这里执行。</span><br><span class="line">关闭的回调函数（close callback）：一些关闭的回调函数，如：socket.on(‘close’, …)</span><br><span class="line"></span><br><span class="line">## JS和TS编译</span><br><span class="line"></span><br><span class="line">https://mp.weixin.qq.com/s/qMLRyru1qxKige9GuVZ0Xw</span><br><span class="line"></span><br><span class="line">### V8 引擎</span><br><span class="line"></span><br><span class="line">**编程语言可以分为机器语言、汇编语言、高级语言。**</span><br><span class="line"></span><br><span class="line">- 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性。</span><br><span class="line"></span><br><span class="line">- 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识。</span><br><span class="line">- 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行。</span><br><span class="line"></span><br><span class="line">**高级语言又可以分为解释型语言、编译型语言。**</span><br><span class="line"></span><br><span class="line">- 编译型语言：需要编译器进行一次编译，被编译过的文件可以多次执行。如 C++、C 语言。编译执行的特点是启动速度慢，但是执行时的速度快。</span><br><span class="line"></span><br><span class="line">- 解释型语言：不需要事先编译，通过解释器一边解释一边执行。启动快，但执行慢。</span><br><span class="line"></span><br><span class="line">&gt; 我们知道 JavaScript 是一门高级语言，并且是动态类型语言，我们在定义一个变量时不需要关心它的类型，并且可以随意的修改变量的类型。而在像 C++这样的静态类型语言中，我们必须提前声明变量的类型并且赋予正确的值才行。也正是因为 JavaScript 没有像 C++那样可以事先提供足够的信息供编译器编译出更加低级的机器代码，它只能在运行阶段收集类型信息，然后根据这些信息进行编译再执行，所以 JavaScript 也是解释型语言。</span><br><span class="line"></span><br><span class="line">这也就意味着 JavaScript 要想被计算机执行，需要一个能够快速解析并且执行 JavaScript 脚本的程序，这个程序就是我们平时所说的 JavaScript 引擎。这里我们给出 V8 引擎的概念:**V8 是 Google 基于 C++ 编写的开源高性能 Javascript 与 WebAssembly 引擎。用于 Google Chrome（Google 的开源浏览器） 以及 Node.js 等。**</span><br><span class="line"></span><br><span class="line">### V8 引擎的编译流水线</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_png/anMXc7ia02zOq3m8u7diavjWEkJaZpKb2hbpNePdNI1rMC4WR1B5gYjxoia1sVypf8KiarLfSDZ4ZC5NWZ0b6V8qAw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">#### 初始化基础环境</span><br><span class="line"></span><br><span class="line">V8 执行 Js 代码是离不开宿主环境的，V8 的宿主可以是浏览器，也可以是 Node.js。下图是浏览器的组成结构，其中渲染引擎就是平时所说的浏览器内核，它包括网络模块，Js 解释器等。当打开一个渲染进程时，就为 V8 初始化了一个运行时环境。</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0KyaSUZF2cTUWH3D4WbicFx1cK9KIY01lfynWrTBOHOrmrwId2BEzQow/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">运行时环境为 V8 提供了堆空间，栈空间、全局执行上下文、消息循环系统、宿主对象及宿主 API 等。V8 的核心是实现了 ECMAScript 标准，此外还提供了垃圾回收器等内容。</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0l3vr44a7UPQa3wPx9VQNicj3rHc3OOic5fRnlzQlOIUHEicjDP7zuFa9Q/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">#### 解析器</span><br><span class="line"></span><br><span class="line">**解析源码生成 AST 和作用域**</span><br><span class="line"></span><br><span class="line">基础环境准备好之后，接下来就可以向 V8 提交要执行的 JavaScript 代码了。首先 V8 会接收到要执行的 JavaScript 源代码，不过这对 V8 来说只是一堆字符串，V8 并不能直接理解这段字符串的含义，它需要结构化这段字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>function add(x, y) {<br> var z = x+y<br> return z<br>}</p><p>console.log(add(1, 2))</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">比如针对如上源代码，V8 首先通过解析器（parser）解析成如下的抽象语法树 AST</span><br><span class="line"></span><br><span class="line">#### 解释器</span><br><span class="line"></span><br><span class="line">##### 依据 AST 和作用域生成字节码</span><br><span class="line"></span><br><span class="line">生成了作用域和 AST 之后，V8 就可以依据它们来生成字节码了。AST 之后会被作为输入传到字节码生成器 (BytecodeGenerator)，这是 Ignition 解释器中的一部分，用于生成以函数为单位的字节码。</span><br><span class="line"></span><br><span class="line">##### 解释执行字节码</span><br><span class="line"></span><br><span class="line">和 CPU 执行二进制机器代码类似：使用内存中的一块区域来存放字节码；使通用寄存器用来存放一些中间数据；PC 寄存器用来指向下一条要执行的字节码；栈顶寄存器用来指向当前的栈顶的位置。![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS07CSKESKibqsV9xjAEIibJ1cvzOtyq85ia36ev9LTiaNh9gsDv7FkcAWXVA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">- StackCheck 字节码指令就是检查栈是否达到了溢出的上限。</span><br><span class="line"></span><br><span class="line">- Ldar 表示将寄存器中的值加载到累加器中。</span><br><span class="line">- Add 表示寄存器加载值并将其与累加器中的值相加，然后将结果再次放入累加器。</span><br><span class="line">- Star 表示 把累加器中的值保存到某个寄存器中。</span><br><span class="line">- Return 结束当前函数的执行，并将控制权传回给调用方。返回的值是累加器中的值。</span><br><span class="line"></span><br><span class="line">##### 即时编译</span><br><span class="line"></span><br><span class="line">在解释器 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），**比如一段代码被重复执行多次，这种就称为热点代码**，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。**这种字节码配合解释器和编译器的技术被称为即时编译（JIT）。**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0KkDH6QODtJRY2Wf3icPoYcyyhSEv9iaf1r1wTKRCpIkyW6ddFkXRFXBg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&quot; alt=&quot;图片&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">### **TypeScript编译**</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/45898674</span><br><span class="line"></span><br><span class="line">- 将`TypeScript`代码编译为 `TypeScript-AST`</span><br><span class="line">- 检查`AST`代码上**类型检查**</span><br><span class="line">- 类型检查后，编译为`JavaScript`代码</span><br><span class="line">- `JavaScript`代码转换为`JavaScript-AST`</span><br><span class="line">- 将`AST`代码转换为字节码</span><br><span class="line">- 运算时计算字节码</span><br><span class="line"></span><br><span class="line">![preview](https://pic1.zhimg.com/v2-4f4017f944fb4ef89084df4bcdc79d3c_r.jpg)</span><br><span class="line"></span><br><span class="line">#### **预处理器处理**</span><br><span class="line"></span><br><span class="line">预处理器（preprocessing）负责根据`待编译文件`计算参与编译的文件，生成`源文件`列表，构成`编译上下文` 和 `Program`</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://pic2.zhimg.com/80/v2-d130e0803514d7562191618337a74b2d_720w.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">**编译列表中的文件 = 待编译文件 + 依赖文件 + @types 文件**</span><br><span class="line"></span><br><span class="line">**待编译文件**:默认为项目目录下所有的 .ts、.tsx、.d.ts 为待编译文件(tsconfig.json)</span><br><span class="line"></span><br><span class="line">**依赖文件** :</span><br><span class="line"></span><br><span class="line">1. `&lt;reference path=... /&gt;` 标签引入的依赖声明文件</span><br><span class="line">2. `import` 表达式引入的文件</span><br><span class="line"></span><br><span class="line">&gt; 注意：</span><br><span class="line">&gt; 当解析 import 导入的的时候，会优先选择 .ts/.tsx文件而不是 .d.ts 文件，以确保处理的是最新的文件</span><br><span class="line"></span><br><span class="line">**@types**:</span><br><span class="line"></span><br><span class="line">所有可见的 `@types` 目录下的所有文件</span><br><span class="line"></span><br><span class="line">&gt; 如：`node_modules/@types`、`./node_modules/@types/`等等</span><br><span class="line"></span><br><span class="line">#### **语法分析器处理**</span><br><span class="line"></span><br><span class="line">语法分析器（parser）将`预处理器`得到的`源文件列表`中的文件解析生成包含抽象语法树（AST）Node 的 `SourceFile` 对象</span><br><span class="line"></span><br><span class="line">**`SourceFile`对象 = `源文件 AST` + `额外信息` (如文件名及文件信息等)**</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_41257129/article/details/100901729</span><br><span class="line"></span><br><span class="line">&gt; 类似：</span><br><span class="line">&gt;</span><br><span class="line">&gt; var myDiv = React.createElement(&#x27;div&#x27;, &#123; title: &#x27;this is a div&#x27;, id: &#x27;mydiv&#x27; &#125;, &#x27;这是一个div&#x27;, myH1)</span><br><span class="line"></span><br><span class="line">#### **联合器处理**</span><br><span class="line"></span><br><span class="line">联合器（Binder）遍历并处理`语法分析器`生成的 `AST`，并将 AST 中的声明结合放到一个 `Symbol` 中。</span><br><span class="line"></span><br><span class="line">然后通过 `createSourceFile` API 生成带有 `Symbol`的 `SourceFile`</span><br><span class="line"></span><br><span class="line">**`SourceFile对象` = `源文件 AST` + `Symbol` + `额外信息` (如文件名及文件信息等)**</span><br><span class="line"></span><br><span class="line">&gt; 此时的 Symobl 仅表示**单个文件**的声明信息</span><br><span class="line"></span><br><span class="line">#### **类型解析器与检查器处理**</span><br><span class="line"></span><br><span class="line">**4.1、生成 `Program`**</span><br><span class="line"></span><br><span class="line">通过调用 `createProgramAPI` 来创建 `Program`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Program = All SourceFile + CompilerOptions</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**4.2、生成 `TypeChecker` 进行处理**</span><br><span class="line"></span><br><span class="line">通过 `Program` 实例创建 `TypeChecker`</span><br><span class="line"></span><br><span class="line">&gt; TypeChecker是TypeScript类型系统的核心，它负责计算出不同文件里的Symbols之间的关系，将Type赋值给Symbol，并生成任何语义Diagnostic（比如：error）</span><br><span class="line"></span><br><span class="line">处理内容：</span><br><span class="line"></span><br><span class="line">1. `TypeChecker` **合并**不同的 `SourceFile` 里的 `Symbol` 到一个单独的视图，创建单一的`Symbol`表（囊括所有文件的全局Symbol视图 ）</span><br><span class="line"></span><br><span class="line">2. 类型检查</span><br><span class="line"></span><br><span class="line">   &gt; Symbol 合并到一张表后，TypeChecker就可以解决关于这个程序的任何问题了。 这些“问题”可以是：</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 1. 这个Node的Symbol是什么？</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 2. 这个Symbol的Type是什么？</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 3. 在AST的某个部分里有哪些Symbol是可见的？</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 4. 某个函数声明的Signature都有哪些？</span><br><span class="line">   &gt; 5. 针对某个文件应该报哪些错误？</span><br><span class="line"></span><br><span class="line">#### **生成器处理**</span><br><span class="line"></span><br><span class="line">通过 Program 创建一个生成器 **（Emitter）**</span><br><span class="line"></span><br><span class="line">Emitter 将给定的 SourceFile 生成编译后文件（`.js`，`.jsx`，`.d.ts`和`.js.map`）</span><br><span class="line"></span><br><span class="line">## 调试工具Network</span><br><span class="line"></span><br><span class="line">https://mp.weixin.qq.com/s/CfL-uVNcKPasfcBcrifROA</span><br><span class="line"></span><br><span class="line">Network面板记录了与服务器交互的具体细节。在这里我们可以看到发起的请求数量，传输体积以及解压缩后的体积，同时还可以知道哪些资源是命中了强缓存，哪些资源命中的协商缓存。</span><br><span class="line"></span><br><span class="line">Network面板可以让我们初步评估网站性能，对网站整体的体积，网络的影响带来一个整体的认知，同时提供一些辅助功能，如禁用缓存，block某些资源。</span><br><span class="line"></span><br><span class="line">### 资源接口解析</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HLN2IKtpicicGicicOVtKg9wVF4czfJvEIdeo09qdFM2poL7rdmxdriaHl6F5zQZXyNeze3lzic6Nia5Su2awfdjpREDw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&quot; alt=&quot;图片&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">查看某一个请求的瀑布流可以让我们清晰的看到一个资源从服务器到达我们的电脑所花的时间。</span><br><span class="line"></span><br><span class="line">- 资源调度</span><br><span class="line"></span><br><span class="line">  - 排队用了1.65ms</span><br><span class="line"></span><br><span class="line">- 开始连接</span><br><span class="line"></span><br><span class="line">  - DNS查询用了21.47ms</span><br><span class="line"></span><br><span class="line">  - initial connection(进行TCP握手的时间)用了56.25ms</span><br><span class="line"></span><br><span class="line">  - SSL握手的时间用了37.87ms</span><br><span class="line"></span><br><span class="line">- 请求/响应	</span><br><span class="line">  - 已发送请求	0.16ms</span><br><span class="line">  - 正在等待服务器响应TTFB：233.09ms</span><br><span class="line">  - 下载文档内容	花了17ms</span><br><span class="line"></span><br><span class="line">**名词解释：**</span><br><span class="line"></span><br><span class="line">- Queueing: 在请求队列中的时间。</span><br><span class="line">- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。</span><br><span class="line">- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。</span><br><span class="line">- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。</span><br><span class="line">- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。</span><br><span class="line">- SSL: 完成SSL握手所花费的时间。</span><br><span class="line">- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。</span><br><span class="line">- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。</span><br><span class="line">- Content Download: 接收响应数据所花费的时间。</span><br><span class="line"></span><br><span class="line">### 时长解析</span><br><span class="line"></span><br><span class="line">Chrome控制台network底部的**DOMContentLoaded和Load，Finish**</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/20200508160958440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTM5MjEz,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">打开chrome控制台network部分刷新页面，可以看到浏览器记录的网络资源加载时间，可以用于评估网页性能。</span><br><span class="line">DOMContentLoaded 和 Load</span><br><span class="line"></span><br><span class="line">- DOMContentLoaded：DOM树构建完成。 即HTML页面由上向下解析HTML结构到末尾封闭标签</span><br><span class="line"></span><br><span class="line">- Load：页面加载完毕。 DOM树构建完成后，继续加载html/css 中的图片资源等外部资源，加载完成后视为页面加载完毕。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DOMContentLoaded 会比 Load 时间小，两者时间差大致等于外部资源加载的时间。</span><br><span class="line"></span><br><span class="line">Finish</span><br><span class="line"></span><br><span class="line">Finish： 是页面上所有 http 请求发送到响应完成的时间， HTTP1.0/1.1 协议限定，单个域名的请求并发量是 6 个，即 Finish 是所有请求（不只是XHR请求，还包括DOC，img，js，css等资源的请求）在并发量为6的限制下完成的时间。</span><br><span class="line"></span><br><span class="line">Finish 的时间比 Load 大，意味着页面有相当部分的请求量，Finish 的时间比 Load 小，意味着页面请求量很少，如果页面是只有一个 html文档请求的静态页面，Finish时间基本就等于HTML文档请求的时间。</span><br><span class="line"></span><br><span class="line">页面发送请求和页面解析文档结构，分属两个不同的线程，所以 Finish 时间与DOMContentLoaded 和 Load 并无直接关系。</span><br><span class="line"></span><br><span class="line">### prefetch 和 prefetch解析</span><br><span class="line"></span><br><span class="line">`prefetch.html` 定义了一个 `rel` 为 `prefetch` 的链接</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Prefetch&lt;/title&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;script.js&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><code>main.js</code> 创建了一个按钮，并绑定了点击事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">button.innerHTML = <span class="string">&#x27;Add Script&#x27;</span>;</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  script.src = <span class="string">&quot;script.js&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(button);</span><br></pre></td></tr></table></figure><p><code>script.js</code> 只是简单的打印了一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script run&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="预取资源"><a href="#预取资源" class="headerlink" title="预取资源"></a>预取资源</h4><p><img src="https://chanvinxiao.com/blog/prefetch-and-preload-with-webpack/prefetch-init.png" alt="img"></p><ul><li><code>script.js</code> 被 fetch 下来，size 列的两个数字，275 B 表示下载的字节大小，0 B 表示解析的字节大小（即目前并没有解析）</li><li>控制台是空的，即脚本没有运行</li></ul><p>点击页面上的 <code>Add Script</code>，会在页面增加地址为 <code>script.js</code> 的 <code>&lt;script&gt;</code> 标签，此时网络选项卡会增加以下内容</p><p><img src="https://chanvinxiao.com/blog/prefetch-and-preload-with-webpack/prefetch-add.png" alt="img"></p><ul><li><p>下载字节量为 <code>(prefetch cache)</code> ，即直接从预取缓存获取资源，下面的解析后的字节不再为 0</p></li><li><p>控制台打印出脚本中的调试内容，即这时脚本才被解析并运</p></li></ul><h4 id="预加载资源"><a href="#预加载资源" class="headerlink" title="预加载资源"></a>预加载资源</h4><p>将 prefetch.html 的 link 标签的 prefetch 改为 <code>preload</code>，并增加资源类型 <code>as</code> 为 <code>script</code>，即得 preload.html</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;script.js&quot;</span> as=<span class="string">&quot;script&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p><img src="https://chanvinxiao.com/blog/prefetch-and-preload-with-webpack/preload.png" alt="img"></p><ul><li><code>script.js</code> 被优先下载， size 列的解压字节不再为 0，即 <code>preload</code> 除了把脚本下载了下来，还进行了解析</li><li>控制台目前仍为空，即脚本虽然被解析，但并没有运行。</li></ul><p>点击 <code>Add Script</code>，网络选项卡并没有增加任何记录，但是控制台输出了脚本的打印内容</p><ul><li>因为脚本已经解析完成，所以连从缓存获取都不需要了，直接运行即可</li><li>如果没有在 3 秒内点击 <code>Add Script</code>，控制台会进行警告，因为没有及时使用应该优先加载的资源</li></ul><blockquote><p>The resource <a target="_blank" rel="noopener" href="https://chanvinxiao.com/demo/html/script.js">https://chanvinxiao.com/demo/html/script.js</a> was preloaded using link preload but not used within a few seconds from the window’s load event. Please make sure it has an appropriate <code>as</code> value and it is preloaded intentionally.</p></blockquote><h1 id="网络与安全"><a href="#网络与安全" class="headerlink" title="网络与安全"></a>网络与安全</h1><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p><strong>统一资源定位符</strong>（Uniform Resource Locator，缩写：URL），是对资源（web上每一种可用的资源，如 HTML文档、图像、视频片段、程序）的引用和访问该资源的方法。俗称网址。</p><p>一个 URL 由以下不同的部分组成：</p><p>协议：通常是 https 或 http，一种告诉浏览器或者设备如何访问资源的方法，当然还有其他的协议，如 ftp 、mailto 或者 file。接下来是 :// 。主机名：表示 IP 地址的注册名称（域名） 或 IP 地址，用于识别连接到网络的设备的数字标识符。后面是可选的端口好，前面是冒号 ： 。路径：可以引用文件系统路径，通常作为一个代码段使用。参数：以问号开头的可选查询参数，其中多个参数用 &amp; 连接hash：用于为页面上的标题提供快速链接，如锚点链接。上面是 URL 组成部份的简介，为了更加直观，如下图所示：</p><p><img src="https://pics2.baidu.com/feed/2f738bd4b31c8701d84cbce25aa37c270608ff25.jpeg?token=333256e42fecae798358d70e88a5ea3b" alt="img"></p><h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p><strong>统一资源标志符</strong>(Uniform Resource Identifier， URI)，表示能把一个资源独一无二地标识出来。</p><p>URI通常由三部分组成：</p><p>①资源的命名机制；</p><p>②存放资源的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%B8%BB%E6%9C%BA%E5%90%8D&spm=1001.2101.3001.7020">主机名</a>；</p><p>③资源自身的名称。</p><p>注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件</p><p>其实URL和URI的差异就是一个子集的关系，如下图：</p> <img src="https://pics2.baidu.com/feed/55e736d12f2eb9385f6b11cbaabe673de4dd6fee.jpeg?token=adebc2b35a1876aa182b9d51b3dc228d" alt="img" style="zoom:33%"><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><p>HTTP三点注意事项：</p><ul><li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li><li>HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态协议，即：服务器不需要知道客户端是谁,只认请求（一次请求request,一次相应response）</li></ul><p><img src="https://img-blog.csdn.net/20140610210038140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2019022420515851.png" alt="img"></p><p>请求协议的格式如下：</p><ul><li>请求首行<ul><li>请求方式</li><li>请求路径</li><li>协议和版本，</li><li>例如：GET/index.html HTTP/1.1</li></ul></li><li>请求头信息<ul><li>键值对格式 =》请求头名称：请求头内容，</li><li>即，例如：Host:localhost</li></ul></li><li>空行；用来与请求体分隔开</li><li>请求体。GET没有请求体，只有POST有请求体。</li></ul><h3 id="HTTP请求响应报文"><a href="#HTTP请求响应报文" class="headerlink" title="HTTP请求响应报文"></a>HTTP请求响应报文</h3><p>HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文</p><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p> <img src="https://upload-images.jianshu.io/upload_images/12603307-27e3bf8fde18f443.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%"><p>Query Params：常用是<strong>get</strong>方式请求，query是指<strong>请求行</strong>中请求的参数，一般是指URL中？后面的参数</p><p>Body Params：常用是<strong>post</strong>方式请求，body是指<strong>请求体</strong>中的数据</p><h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)</p> <img src="https://upload-images.jianshu.io/upload_images/12603307-cf75b41f632499a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp" alt="img" style="zoom:67%"><h3 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h3><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了<code>Connection: Keep-Alive</code>，<code>keep-alive</code>的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生<strong>队头阻塞</strong>的问题。HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。connection keep-alive</p><table><thead><tr><th>协议头</th><th>说明</th><th>示例</th><th>状态</th></tr></thead><tbody><tr><td>Accept</td><td>可接受的响应内容类型（<code>Content-Types</code>）。</td><td><code>Accept: text/plain</code></td><td>固定</td></tr><tr><td>Accept-Charset</td><td>可接受的字符集</td><td><code>Accept-Charset: utf-8</code></td><td>固定</td></tr><tr><td>Accept-Encoding</td><td>可接受的响应内容的编码方式。</td><td><code>Accept-Encoding: gzip, deflate</code></td><td>固定</td></tr><tr><td>Accept-Language</td><td>可接受的响应内容语言列表。</td><td><code>Accept-Language: en-US</code></td><td>固定</td></tr><tr><td>Accept-Datetime</td><td>可接受的按照时间来表示的响应内容版本</td><td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td><td>临时</td></tr><tr><td>Authorization</td><td>用于表示HTTP协议中需要认证资源的认证信息</td><td>Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==</td><td>固定</td></tr><tr><td>Cache-Control</td><td>用来指定当前的请求/回复中的，是否使用缓存机制。</td><td><code>Cache-Control: no-cache</code> max-age：缓存无法返回缓存时间长于max-age规定秒的文档</td><td>固定</td></tr><tr><td>Connection</td><td>客户端（浏览器）想要优先使用的连接类型</td><td><code>Connection: keep-alive``Connection: Upgrade</code></td><td>固定</td></tr><tr><td>Cookie</td><td>由之前服务器通过<code>Set-Cookie</code>（见下文）设置的一个HTTP协议Cookie</td><td><code>Cookie: $Version=1; Skin=new;</code></td><td>固定：标准</td></tr><tr><td>Content-Length</td><td>以8进制表示的请求体的长度</td><td><code>Content-Length: 348</code></td><td>固定</td></tr><tr><td>Content-MD5</td><td>请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果</td><td>Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==</td><td>废弃</td></tr><tr><td>Content-Type</td><td>请求体的MIME类型 （用于POST和PUT请求中）</td><td>Content-Type: application/x-www-form-urlencoded</td><td>固定</td></tr><tr><td>Date</td><td>发送该消息的日期和时间（以<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来发送）</td><td>Date: Dec, 26 Dec 2015 17:30:00 GMT</td><td>固定</td></tr><tr><td>Expect</td><td>表示客户端要求服务器做出特定的行为</td><td><code>Expect: 100-continue</code></td><td>固定</td></tr><tr><td>From</td><td>发起此请求的用户的邮件地址</td><td><code>From: user@itbilu.com</code></td><td>固定</td></tr><tr><td>Host</td><td>表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。</td><td><code>Host: www.itbilu.com:80``Host: www.itbilu.com</code></td><td>固定</td></tr><tr><td>If-Match</td><td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。</td><td>If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td>固定</td></tr><tr><td>If-Modified-Since</td><td>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</td><td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td><td><strong>固定</strong></td></tr><tr><td><strong>If-None-Match</strong></td><td>If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</td><td>If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td>固定</td></tr><tr><td>If-Range</td><td>如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体</td><td>If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td><td>固定</td></tr><tr><td>If-Unmodified-Since</td><td>仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。</td><td>If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td><td>固定</td></tr><tr><td>Max-Forwards</td><td>限制该消息可被代理及网关转发的次数。</td><td><code>Max-Forwards: 10</code></td><td>固定</td></tr><tr><td>Origin</td><td>发起一个针对<a target="_blank" rel="noopener" href="http://itbilu.com/javascript/js/VkiXuUcC.html">跨域资源共享</a>的请求（该请求要求服务器在响应中加入一个<code>Access-Control-Allow-Origin</code>的消息头，表示访问控制所允许的来源）。</td><td><code>Origin: http://www.itbilu.com</code></td><td>固定: 标准</td></tr><tr><td>Pragma</td><td>与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。</td><td><code>Pragma: no-cache</code></td><td>固定</td></tr><tr><td>Proxy-Authorization</td><td>用于向代理进行认证的认证信息。</td><td>Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==</td><td>固定</td></tr><tr><td>Range</td><td>表示请求某个实体的一部分，字节偏移以0开始。</td><td><code>Range: bytes=500-999</code></td><td>固定</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。<code>Referer</code>其实是<code>Referrer</code>这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用<code>Referer</code>了。</td><td>Referer: <a target="_blank" rel="noopener" href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td><td>固定</td></tr><tr><td>TE</td><td>浏览器预期接受的传输时的编码方式：可使用回应协议头<code>Transfer-Encoding</code>中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。</td><td><code>TE: trailers,deflate</code></td><td>固定</td></tr><tr><td>User-Agent</td><td>浏览器的身份标识字符串</td><td><code>User-Agent: Mozilla/……</code></td><td>固定</td></tr><tr><td>Upgrade</td><td>要求服务器升级到一个高版本协议。</td><td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td>固定</td></tr><tr><td>Via</td><td>告诉服务器，这个请求是由哪些代理发出的。</td><td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td><td>固定</td></tr><tr><td>Warning</td><td>一个一般性的警告，表示在实体内容体中可能存在错误。</td><td>Warning: 199 Miscellaneous warning</td><td>固定</td></tr></tbody></table><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><table><thead><tr><th align="left">响应头</th><th align="left">说明</th><th align="left">示例</th><th align="left">状态</th></tr></thead><tbody><tr><td align="left">Access-Control-Allow-Origin</td><td align="left">指定哪些网站可以<code>跨域源资源共享</code></td><td align="left"><code>Access-Control-Allow-Origin: *</code></td><td align="left">临时</td></tr><tr><td align="left">Accept-Patch</td><td align="left">指定服务器所支持的文档补丁格式</td><td align="left">Accept-Patch: text/example;charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Accept-Ranges</td><td align="left">服务器所支持的内容范围</td><td align="left"><code>Accept-Ranges: bytes</code></td><td align="left">固定</td></tr><tr><td align="left">Age</td><td align="left">响应对象在代理缓存中存在的时间，以秒为单位</td><td align="left"><code>Age: 12</code></td><td align="left">固定</td></tr><tr><td align="left">Allow</td><td align="left">对于特定资源的有效动作;</td><td align="left"><code>Allow: GET, HEAD</code></td><td align="left">固定</td></tr><tr><td align="left">Cache-Control</td><td align="left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td><td align="left"><code>Cache-Control: max-age=3600</code></td><td align="left">固定</td></tr><tr><td align="left">Connection</td><td align="left">针对该连接所预期的选项</td><td align="left"><code>Connection: close</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Disposition</td><td align="left">对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td><td align="left">Content-Disposition: attachment; filename=”fname.ext”</td><td align="left">固定</td></tr><tr><td align="left">Content-Encoding</td><td align="left">响应资源所使用的编码类型。</td><td align="left"><code>Content-Encoding: gzip</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Language</td><td align="left">响就内容所使用的语言</td><td align="left"><code>Content-Language: zh-cn</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Length</td><td align="left">响应消息体的长度，用8进制字节表示</td><td align="left"><code>Content-Length: 348</code></td><td align="left">固定</td></tr><tr><td align="left">Content-Location</td><td align="left">所返回的数据的一个候选位置</td><td align="left"><code>Content-Location: /index.htm</code></td><td align="left">固定</td></tr><tr><td align="left">Content-MD5</td><td align="left">响应内容的二进制 MD5 散列值，以 Base64 方式编码</td><td align="left">Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td><td align="left">已淘汰</td></tr><tr><td align="left">Content-Range</td><td align="left">如果是响应部分消息，表示属于完整消息的哪个部分</td><td align="left">Content-Range: bytes 21010-47021/47022</td><td align="left">固定</td></tr><tr><td align="left">Content-Type</td><td align="left">当前内容的<code>MIME</code>类型</td><td align="left">Content-Type: text/html; charset=utf-8</td><td align="left">固定</td></tr><tr><td align="left">Date</td><td align="left">此条消息被发送时的日期和时间(以<a target="_blank" rel="noopener" href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td><td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td><td align="left">固定</td></tr><tr><td align="left">ETag</td><td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td><td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td><td align="left">固定</td></tr><tr><td align="left">Expires</td><td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td><td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td><td align="left">固定: 标准</td></tr><tr><td align="left">Last-Modified</td><td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td><td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Link</td><td align="left">用来表示与另一个资源之间的类型关系，此类型关系是在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td><td align="left"><code>Link:</code> ; rel=”alternate”</td><td align="left">固定</td></tr><tr><td align="left">Location</td><td align="left">用于在进行重定向，或在创建了某个新资源时使用。</td><td align="left">Location: <a target="_blank" rel="noopener" href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td><td align="left">固定</td></tr><tr><td align="left">P3P</td><td align="left">P3P策略相关设置</td><td align="left">P3P: CP=”This is not a P3P policy!</td><td align="left">固定</td></tr><tr><td align="left">Pragma</td><td align="left">与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td><td align="left"><code>Pragma: no-cache</code></td><td align="left">固定</td></tr><tr><td align="left">Proxy-Authenticate</td><td align="left">要求在访问代理时提供身份认证信息。</td><td align="left"><code>Proxy-Authenticate: Basic</code></td><td align="left">固定</td></tr><tr><td align="left">Public-Key-Pins</td><td align="left">用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td><td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td><td align="left">固定</td></tr><tr><td align="left">Refresh</td><td align="left">用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td><td align="left">Refresh: 5; url=<a target="_blank" rel="noopener" href="http://itbilu.com/">http://itbilu.com</a></td><td align="left"></td></tr><tr><td align="left">Retry-After</td><td align="left">如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td><td align="left">示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td><td align="left">固定</td></tr><tr><td align="left">Server</td><td align="left">服务器的名称</td><td align="left"><code>Server: nginx/1.6.3</code></td><td align="left">固定</td></tr><tr><td align="left">Set-Cookie</td><td align="left">设置<code>HTTP cookie</code></td><td align="left">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td><td align="left">固定标准</td></tr><tr><td align="left">Status</td><td align="left">通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td><td align="left"><code>Status: 200 OK</code></td><td align="left"></td></tr><tr><td align="left">Trailer</td><td align="left"><code>Trailer</code>用户说明传输中分块编码的编码信息</td><td align="left"><code>Trailer: Max-Forwards</code></td><td align="left">固定</td></tr><tr><td align="left">Transfer-Encoding</td><td align="left">用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td><td align="left">Transfer-Encoding: chunked</td><td align="left">固定</td></tr><tr><td align="left">Upgrade</td><td align="left">要求客户端升级到另一个高版本协议。</td><td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td><td align="left">固定</td></tr><tr><td align="left">Vary</td><td align="left">告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td><td align="left"><code>Vary: *</code></td><td align="left">固定</td></tr><tr><td align="left">Via</td><td align="left">告知代理服务器的客户端，当前响应是通过什么途径发送的。</td><td align="left">Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td><td align="left">固定</td></tr><tr><td align="left">Warning</td><td align="left">一般性警告，告知在实体内容体中可能存在错误。</td><td align="left">Warning: 199 Miscellaneous warning</td><td align="left">固定</td></tr><tr><td align="left">WWW-Authenticate</td><td align="left">表示在请求获取这个实体时应当使用的认证模式。</td><td align="left"><code>WWW-Authenticate: Basic</code></td><td align="left">固定</td></tr></tbody></table><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li><p>1XX：信息状态码</p><ul><li><code>100 Continue</code> 继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li></ul></li><li><p>2XX：成功状态码</p><table><thead><tr><th>200</th><th>OK</th><th>请求成功。一般用于GET与POST请求</th></tr></thead><tbody><tr><td>201</td><td>Created</td><td>已创建。成功请求并创建了新的资源</td></tr><tr><td>202</td><td>Accepted</td><td>已接受。已经接受请求，但未处理完成</td></tr><tr><td>203</td><td>Non-Authoritative Information</td><td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td>204</td><td>No Content</td><td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td>205</td><td>Reset Content</td><td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td>206</td><td>Partial Content</td><td>部分内容。服务器成功处理了部分GET请求</td></tr></tbody></table></li><li><p>3XX：重定向</p><table><thead><tr><th>300</th><th>Multiple Choices</th><th>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</th></tr></thead><tbody><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td>303</td><td>See Other</td><td>查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td>305</td><td>Use Proxy</td><td>使用代理。所请求的资源必须通过代理访问</td></tr><tr><td>306</td><td>Unused</td><td>已经被废弃的HTTP状态码</td></tr><tr><td>307</td><td>Temporary Redirect</td><td>临时重定向。与302类似。使用GET请求重定向</td></tr></tbody></table></li><li><p>4XX：客户端错误</p><table><thead><tr><th>400</th><th>Bad Request</th><th>客户端请求的语法错误，服务器无法理解</th></tr></thead><tbody><tr><td>401</td><td>Unauthorized</td><td>请求要求用户的身份认证</td></tr><tr><td>402</td><td>Payment Required</td><td>保留，将来使用</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr></tbody></table></li><li><p>5XX:服务器错误</p><table><thead><tr><th>500</th><th>Internal Server Error</th><th>服务器内部错误，无法完成请求</th></tr></thead><tbody><tr><td>501</td><td>Not Implemented</td><td>服务器不支持请求的功能，无法完成请求</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。服务器的问题，找网管</td></tr><tr><td>504</td><td>Gateway Time-out</td><td>充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td>505</td><td>HTTP Version not supported</td><td>服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table></li></ul><h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。</p><p>在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以<strong>并行传输</strong>而不被阻塞，这样就解决了HTTP1.1时复用会产生的<strong>队头阻塞</strong>的问题</p><blockquote><p>队头堵塞：</p><p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p></blockquote><h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// 请求1</span><br><span class="line">:authority: unpkg.zhimg.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /za-js-sdk@2.16.0/dist/zap.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36</span><br><span class="line"></span><br><span class="line">// 请求2</span><br><span class="line">:authority: zz.bdstatic.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /linksubmit/push.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36</span><br></pre></td></tr></table></figure><p>从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。</p><p>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。</p><p>下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Header1:foo</span><br><span class="line">Header2:bar</span><br><span class="line">Header3:bat</span><br></pre></td></tr></table></figure><p>当客户端发送请求时，它会根据首部值创建一张表：</p><p><img src="https://pic2.zhimg.com/80/v2-be170562d69da5c67cfc40aa591a722d_1440w.jpg" alt="img"></p><p>如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">62 63 64</span><br></pre></td></tr></table></figure><p>服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</p><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。</p><h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</p><p>例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。</p><h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:33%"></p><p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p><h3 id="不同HTTP的协议"><a href="#不同HTTP的协议" class="headerlink" title="不同HTTP的协议"></a>不同HTTP的协议</h3><p><strong>HTTP和HTTPS协议的区别</strong></p><ul><li>HTTS协议需要CA证书，费用较高；而HTTP协议不需要；</li><li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li><li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li><li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li></ul><p><strong>HTTP 1.0和 HTTP 1.1 有以下区别</strong></p><ul><li>连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li><li>资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li>缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li>http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li><li>http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。</li></ul><p><strong>HTTP 1.1 和 HTTP 2.0 的区别</strong></p><ul><li><p>二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</p></li><li><p>多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</p></li><li><p>数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p></li><li><p>头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p></li><li><p>服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</p></li><li><p>它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；</p></li><li><p>网络管理（SMTP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；</p></li><li><p>域名系统（DNS），主机的域名到 IP 地址的映射</p><p><strong>域名解析的顺序：</strong></p><p>浏览器缓存；</p><p>找本机的hosts文件；</p><p>路由缓存；</p><p>找DNS服务器（本地域名、顶级域名、根域名）-&gt;迭代解析、递归查询。</p><p>顶级域（com，cn，net，gov，org）、二级域（baidu,taobao,qq,alibaba）、三级域（www）(12-2-0852)。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSQYoX1g3iboXfSY2oPtU9libeqiaFnebwhZCt93cStJibZJ4tLCP2ZWjKVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p></li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651556794&amp;idx=1&amp;sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651556794&amp;idx=1&amp;sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8</a></p><p><a target="_blank" rel="noopener" href="https://louiszhai.github.io/2017/04/07/http-cache/">https://louiszhai.github.io/2017/04/07/http-cache/</a></p><p>缓存通过复用之前的获取过的资源，可以显著提高网站和应用程序的性能，合理的缓存不仅可以节省巨大的流量也会让用户二次进入时身心愉悦，如果一个资源完全走了本地缓存，那么就可以节省下整个与服务器交互的时间，如果整个网站的内容都被缓存在本地，那即使离线也可以继续访问(很酷，但还没有完全很酷)。HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。整体流程如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7567844-72f2b2c531f65689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/886/format/webp" alt="img"></p><p><img src="https://upload-images.jianshu.io/upload_images/7567844-3fa31eccdfc2f4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp" alt="img"></p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a><strong>强缓存</strong></h3><p><strong>本地缓存阶段(也称强缓存)</strong></p><p>先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，不会发起任何网络请求；</p><ul><li><p><code>Expires</code>（该字段是 <code>http1.0</code> 时的规范，值为一个绝对时间的 <code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间）</p></li><li><p><code>Cache-Control:max-age</code>（该字段是 <code>http1.1</code>的规范，强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class="line">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: only-if-cached</span><br></pre></td></tr></table></figure></li></ul><p>如 果max-age和Expires同时出现，则max-age有更高的优先级。</p><p>常用的有<code>max-age</code>，<code>no-cache</code>和<code>no-store</code>。<code>max-age</code> 是资源从响应开始计时的最大新鲜时间，一般响应中还会出现<code>age</code>标明这个资源当前的新鲜程度。<code>no-cache</code> 会让浏览器缓存这个文件到本地但是不用，Network中<code>disable-cache</code>勾中的话就会在请求时带上这个haader，会在下一次新鲜度验证通过后使用这个缓存。<code>no-store</code> 会完全放弃缓存这个文件。服务器响应时的<code>Cache-Control</code>略有不同，其中有两个需要注意下:</p><ol><li>public, public 表明这个请求可以被任何对象缓存，代理/CDN等中间商。</li><li>private，private 表明这个请求只能被终端缓存，不允许代理或者CDN等中间商缓存。</li></ol><p><code>Expires</code>是一个具体的日期，到了那个日期就会让这个缓存失活，优先级较低，存在<code>max-age</code>的情况下会被忽略，和本地时间绑定，修改本地时间可以绕过。另外，如果你的服务器的返回内容中不存在<code>Expires</code>，<code>Cache-Control: max-age</code>，或 <code>Cache-Control:s-maxage</code>但是存在<code>Last-Modified</code>时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的<code>Date_value - Last-Modified_value</code>值的10%作为缓存时间，之后浏览器仍然会按强缓存来对待这个资源一段时间，如果你不想要缓存的话务必确保有<code>no-cache</code>或<code>no-store</code>在响应头中。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h3><p><strong>协商缓存阶段(也称弱缓存)</strong></p><p>如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</p><ul><li><code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li><li><code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li><li><code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li><li><code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li></ul><p>协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。服务器响应中会携带<code>ETag</code>和<code>Last-Modified</code>，<code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成<code>Last-Modified</code>被修改，所以在HTTP / 1.1 出现了<code>ETag</code>。<code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的。<code>If-None-Match</code>的header会将上次返回的<code>ETag</code>发送给服务器，询问该资源的<code>ETag</code>是否有更新，有变动就会发送新的资源回来<code>ETag</code>(<code>If-None-Match</code>)的优先级高于<code>Last-Modified</code>(<code>If-Modified-Since</code>)，优先使用<code>ETag</code>进行确认。协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。</p><blockquote><h4 id="有Last-Modified为什么还要有ETag"><a href="#有Last-Modified为什么还要有ETag" class="headerlink" title="有Last-Modified为什么还要有ETag"></a>有Last-Modified为什么还要有ETag</h4><p>HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题：</p><ul><li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度</li><li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存</li><li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li></ul></blockquote><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>在HTTP1.1规范中，新增了一个HTTP头信息：ETag。浏览器<strong>第一次</strong>请求一个资源的时候，服务端给予返回，并且返回了<strong>ETag</strong>: “50b1c1d4f775c61:df3” 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将<strong>If-None-Match</strong>: W/“50b1c1d4f775c61:df3” 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。通过Etag来利用浏览器的缓存，降低我们服务器的带宽压力。</p><p><strong>第一次请求，服务器返回Etag。强缓存，expires和Cache-Control，判断是否过期，过期，请求服务器，服务端拿到该ETAG，对比资源是否发生变化，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</strong></p><h3 id="缓存的流程"><a href="#缓存的流程" class="headerlink" title="缓存的流程"></a>缓存的流程</h3><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p><ul><li>先根据这个资源的一些 <code>http header</code> 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li><li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li><li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li><li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li><li>当 <code>ctrl+f5</code> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li><li>当 <code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li></ul><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax表示Asynchronous JavaScript and XML(异步JavaScript和XML)，使我们可以请求特定URL获取数据并显示新的内容而不必重新刷新页面</p><h3 id="原生Ajax机制"><a href="#原生Ajax机制" class="headerlink" title="原生Ajax机制"></a>原生Ajax机制</h3><p><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascript</code>来操作<code>DOM</code>更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据。</p><h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><p><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</p><p><strong>1) 创建XMLHttpRequest</strong></p><p>var xhr = new XMLHttpRequest()；标准浏览器</p><p>var xhr = new ActiveXObject(‘Microsoft.XMLHTTP’)；IE老版本</p><p><strong>2) 准备发送xhr.open(1，2，3)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">参数1，请求方式，get获取数据，post提交数据</span><br><span class="line">参数2，请求地址url</span><br><span class="line">参数3，同步异步标志位，true是异步</span><br></pre></td></tr></table></figure><ul><li><p>get请求，url要加参数，这样php才能接受到参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;/01.php?username&#x27;+username+&#x27;&amp;password&#x27;+password</span><br></pre></td></tr></table></figure><p><code>encodeURI（）</code>用来对中文参数进行编码，防止中文乱码</p></li><li><p>post请求，url只需要地址,不需要参数,参数在send中传递</p></li></ul><p> <strong>3) 执行发送动作</strong></p><ul><li>get请求 xhr.send(null)；</li></ul><ul><li><p>post请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;content-Type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)<span class="comment">//必须要请求头信息</span></span><br><span class="line"><span class="keyword">var</span> param=<span class="string">&#x27;username&#x27;</span>+username+<span class="string">&#x27;password&#x27;</span>+password;</span><br><span class="line">xhr.send(param);这里不需要<span class="built_in">encodeURI</span>编码</span><br><span class="line"></span><br><span class="line">​	在Form元素的语法中，EncType表明提交数据的格式</span><br><span class="line">​	用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。</span><br><span class="line">- application/x-www-form-urlencoded ： 窗体数据被编码为名称/值对。这是标准的编码格式。（默认）</span><br><span class="line">- multipart/form-data ： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。(type=file使用)</span><br><span class="line">- text/plain ： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><p> <strong>4）指定回调函数 浏览器调用</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 1. 创建连接 **/</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">/** 2. 连接服务器 **/</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">/** 3. 发送请求 **/</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">/** 4. 接受请求 **/</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;<span class="comment">//是否接收到数据</span></span><br><span class="line">		<span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;<span class="comment">//数据是否正常</span></span><br><span class="line">			success(xhr.responseText);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="comment">/** false **/</span></span><br><span class="line">			fail &amp;&amp; fail(xhr.status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p><strong>XMLHttpRequest</strong></p><p> XMLHttpRequest(XHR) 对象用于与服务器交互。通过 XMLHttpRequest 可以在<strong>不刷新页面的情况下请求特定 URL</strong>，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。</p><p> <code>XMLHttpRequest</code> 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a> 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。</p><p> <strong>1. 属性</strong></p><ul><li><strong>XMLHttpRequest.responseType</strong> 表示服务器返回数据的类型，这个属性是可写的，在 open 之后，send 之前，告诉服务器返回指定类型的数据。如果 responseType 设为空字符串，就等同于默认值 text 表示服务器返回文本数据；</li><li><strong>XMLHttpRequest.onreadystatechange</strong>当 <code>readyState</code> 属性发生变化时，调用的 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventHandler"><code>EventHandler</code></a>。</li><li><strong>readyState</strong> HTTP 请求的状态，当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。</li><li><strong>status</strong>由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。</li><li><strong>response</strong> 该属性只读表示服务器返回的数据体，可能是任意的数据类型，比如字符串，对象，二进制对象等，具体类型由responseType 属性决定。如果本次请求没有成功或者数据不完整，该属性等于 null</li></ul><p> <strong>2. 方法</strong></p><table><thead><tr><th>abort()</th><th>取消当前响应，关闭连接并且结束任何未决的网络活动</th></tr></thead><tbody><tr><td>getAllResponseHeaders()</td><td>把 HTTP 响应头部作为未解析的字符串返回</td></tr><tr><td>getResponseHeader()</td><td>返回指定的 HTTP 响应头部的值</td></tr><tr><td>open()</td><td>初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求</td></tr><tr><td>send()</td><td>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体</td></tr><tr><td>setRequestHeader()</td><td>向一个打开但未发送的请求设置或添加一个 HTTP 请求头</td></tr></tbody></table><h2 id="content-Type"><a href="#content-Type" class="headerlink" title="content-Type"></a>content-Type</h2><p>接口发送参数、接收响应数据，都需要双方约定好使用什么格式的数据，只有双方按照约定好的格式去解析数据才能正确的收发数据。而 Content-Type 就是用来告诉你数据的格式</p><ul><li><code>application/json</code>：JSON数据格式，现在非常流行的格式</li><li> <code>application/x-www-form-urlencoded</code>：很常见的一种数据格式，post请求中通常默认是这个</li><li> <code>multipart/form-data</code>：上传文件时我们需要用到这个格式</li><li> <code>application/xml</code>：XML数据格式</li><li> <code>text/html</code>：HTML格式</li><li> <code>text/plain</code>：纯文本格式</li><li> <code>image/png</code>：png图片格式</li></ul><h3 id="get请求常用数据类型"><a href="#get请求常用数据类型" class="headerlink" title="get请求常用数据类型"></a>get请求常用数据类型</h3><p>要么是拼接在URl 后面, 要么就是 QueryString的方式传递,Content-Type 的值就不是那么重要了。</p><h4 id="url-param"><a href="#url-param" class="headerlink" title="url param"></a>url param</h4><p>Restful 的规范允许把参数写在 url 中，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://c1998.cn/api/person/1111</span><br></pre></td></tr></table></figure><p>这里的111就是路径中的参数 (url params)</p><h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>通过 url 中 ？后面的用 &amp; 分隔的字符串传递数据。比如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">data</span> = &#123;</span><br><span class="line">	name:<span class="string">&#x27;coder&#x27;</span>,</span><br><span class="line">	age:<span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">const</span> getExceptionHandling  = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.axioseRquest(&#123;</span><br><span class="line">        url: <span class="string">&#x27;http://c1998.cn/api/person&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        params: <span class="keyword">data</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际请求的路径是: <a target="_blank" rel="noopener" href="http://c1998.cn/api/person?name=coder&amp;age=111">http://c1998.cn/api/person?name=coder&amp;age=111</a><br>通过URL传递数据的方式就这两种, 后面的3种是通过 body传递数据的方式</p><h3 id="post请求常用数据类型"><a href="#post请求常用数据类型" class="headerlink" title="post请求常用数据类型"></a>post请求常用数据类型</h3><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><p>http 请求报文<br><img src="https://img-blog.csdnimg.cn/47f2e5ccfe6f439986ad7ec20bd68118.png#pic_center" alt="在这里插入图片描述"></p><p>qs.stringify()作用是将对象或者数组序列化成URL的格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">对象序列化</span><br><span class="line">let obj = &#123;</span><br><span class="line">methods: &#x27;queryStu&#x27;</span><br><span class="line">id: 1,</span><br><span class="line">name: &#x27;zdy&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">// methods=queryStu&amp;id=1&amp;name=zdy    这就是我们的传到服务器的url</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">数组序列化</span><br><span class="line">let arr = [2,3]</span><br><span class="line">qs.stringify(&#123;a:arr&#125;)</span><br><span class="line">// &#x27;arr[0]=2&amp;arr[1]=3&#x27;</span><br><span class="line"></span><br><span class="line">这种格式可以进行转为序列化，但是url中会带有数组的下标a[0]、a[1]，这并不是我们一般的处理办法。常用方法如下：</span><br><span class="line">// 常用并推荐使用</span><br><span class="line">let arr = [2,3]</span><br><span class="line">qs.stringify(&#123;a:arr&#125;,&#123;indices:false&#125;);</span><br><span class="line">// &#x27;arr=2&amp;arr=3&#x27; 注意这个格式，一般我们常用的格式</span><br></pre></td></tr></table></figure><p>qs.parse()则就是反过来啦，将我们通过qs.stringify()序列化的对象或者数组转回去</p><h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><p> 一般用于上传文件、二进制数据、非 ASCII 字符的内容</p><p>通过 new FormData将文件转成二进制数据</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> formData = new FormData();</span><br><span class="line">  formData.append(<span class="string">&#x27;controlId&#x27;</span>, <span class="keyword">this</span>.node.itemId);</span><br><span class="line">  formData.append(<span class="string">&#x27;file&#x27;</span>, option.file);</span><br><span class="line">  formData.append(<span class="string">&#x27;roleId&#x27;</span>, <span class="keyword">this</span>.$refs.role.currentValue);</span><br><span class="line">  </span><br><span class="line">export <span class="keyword">const</span> getExceptionHandling  = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.axioseRquest(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://c1998.cn/api/person&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="keyword">data</span>: formData</span><br><span class="line">    headers: &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span> &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200119105200249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/20200119105635306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p><p>请求体首先随机生成了一个boundary字段，这个boundary用来分割不同的字段。</p><p>一个请求的参数，会以boundary开始，然后是附加信息(参数名称，文件路径等)，再空一行，最后是参数的内容</p><p>请求体最后再以boundary结束。</p><h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p><img src="https://img-blog.csdnimg.cn/7e17447496834543b155e816fc17f66f.png#pic_center" alt="在这里插入图片描述"></p><p>现在绝大部分的请求都会以json形式进行传输</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对</p><p>x-www-form-urlencoded：只能上传键值对，并且键值对都是用&amp;间隔分开的。(用Qs库转换)</p><p>application/json: 以序列化的 JSON 字符串形式传输</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><a target="_blank" rel="noopener" href="https://javascript.ruanyifeng.com/bom/cors.html">https://javascript.ruanyifeng.com/bom/cors.html</a></p><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/cors">https://wangdoc.com/javascript/bom/cors</a></p><h3 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h3><p><img src="https://img2022.cnblogs.com/blog/420532/202206/420532-20220622090900141-1679123227.png" alt="img"></p><p>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</p><p>举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p><h3 id="跨域请求分类"><a href="#跨域请求分类" class="headerlink" title="跨域请求分类"></a>跨域请求分类</h3><p>浏览器将跨域请求分为两大类: 简单请求和非简单请求.</p><p>同时满足以下条件的请求都为简单请求:</p><ul><li>请求方式为下列之一:<ul><li>GET</li><li>POST</li><li>HEAD</li></ul></li><li>人为设置以下集合外的请求头:<ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul></li></ul><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p><p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。<strong>浏览器</strong>发现回应的头信息没有包含<strong>Access-Control-Allow-Origin</strong>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p><p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p><p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p><p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p><p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p><p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p><p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p><p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p><h5 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h5><p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等）。如果需要包含 Cookie 信息，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure><p>另一方面，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p><p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p><p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。<strong>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中</strong>，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了<strong>防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力</strong>，给服务器一个提前拒绝的机会，这样可以防止服务器大量收到<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p><p>下面是一段浏览器的 JavaScript 脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &#x27;http://api.alice.com/cors&#x27;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;PUT&#x27;, url, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;X-Custom-Header&#x27;, &#x27;value&#x27;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p><p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p><p><strong>（1）<code>Access-Control-Request-Method</code></strong></p><p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p><p><strong>（2）<code>Access-Control-Request-Headers</code></strong></p><p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p><h5 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h5><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS http://api.bob.com HTTP/1.1</span><br><span class="line">Status: 200</span><br><span class="line">Access-Control-Allow-Origin: https://notyourdomain.com</span><br><span class="line">Access-Control-Allow-Method: POST</span><br></pre></td></tr></table></figure><p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p><p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure><p>服务器回应的其他 CORS 相关字段如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure><p><strong>（1）<code>Access-Control-Allow-Methods</code></strong></p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p><p><strong>（2）<code>Access-Control-Allow-Headers</code></strong></p><p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p><p><strong>（3）<code>Access-Control-Allow-Credentials</code></strong></p><p>该字段与简单请求时的含义相同。</p><p><strong>（4）<code>Access-Control-Max-Age</code></strong></p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），<strong>在此期间，不用发出另一条预检请求</strong>。</p><h5 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h5><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p><p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><p><img src="https://img2022.cnblogs.com/blog/420532/202206/420532-20220622090743322-561262700.png" alt="img"></p><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><strong>jsonp的原理</strong>：利用script标签可以跨域的原理实现。</p><p>html中通过动态创建一个script标签，通过它的src属性发送跨域请求，从服务器端响应的<strong>数据格式是一个函数的调用</strong>，函数名要一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">script.src=<span class="string">&#x27;http::/1.html/1.php?callback=hello&amp;username=123&#x27;</span>;</span><br><span class="line"></span><br><span class="line">head.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>限制：</p><ul><li>只能发起GET请求</li></ul><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而<strong>克服了AJAX只能同源使用的限制</strong>。</p><p><strong>CORS 需要浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p><p><strong>服务器端对于CORS的支持</strong>，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p><p>node后端代码支持跨域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(&quot;Access-Control-Allow-Origin&quot;, ctx.headers.origin);</span><br><span class="line">  ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);</span><br><span class="line">  ctx.set(&quot;Access-Control-Request-Method&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">  ctx.set(</span><br><span class="line">    &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">    &quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span><br><span class="line">  );</span><br><span class="line">  if (ctx.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">    ctx.status = 204;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而 且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain</p><h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有 的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是 持久存在一个窗口载入过的所有页面中的</p><p>使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容 到几乎所有浏览器，这真是极好的一种跨域方法。</p><h4 id="Nginx-代理服务器配置跨域"><a href="#Nginx-代理服务器配置跨域" class="headerlink" title="Nginx 代理服务器配置跨域"></a><strong>Nginx 代理服务器配置跨域</strong></h4><p>使用 Nginx 代理服务器之后，请求不会直接到达我们的 Node.js 服务器端，请求会先经过 Nginx 在设置一些跨域等信息之后再由 Nginx 转发到我们的 Node.js 服务端，所以这个时候我们的 Nginx 服务器去监听的 3011 端口，我们把 Node.js 服务的端口修改为 30011，简单配置如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen          3011;</span><br><span class="line">  server_name     localhost;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;http://127.0.0.1:3010&#x27;;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;PUT,DELETE&#x27;;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Test-CORS, Content-Type&#x27;;</span><br><span class="line">      add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">      add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line">      return 204;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;http://127.0.0.1:3010&#x27;;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://127.0.0.1:30011;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：需要在nginx进行额外配置，语义不清晰</p><h3 id="跨域操作cookie"><a href="#跨域操作cookie" class="headerlink" title="跨域操作cookie"></a>跨域操作cookie</h3><p>需要满足3个条件：</p><p>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。<br>浏览器发起ajax需要指定withCredentials 为true<br>响应头中的Access-Control-Allow-Origin一定不能为*，必须是特定的域名</p><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/WqJTHnHMsqvqAWjjJqyfsw">https://mp.weixin.qq.com/s/WqJTHnHMsqvqAWjjJqyfsw</a></p><h3 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。</p><p>攻击者往Web页面里插入恶意 html标签或者javascript代码。比 如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表 单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p><h5 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h5><p>会经常发生在内容驱动、用户保存数据的社区网站上，比如具备论坛发帖、商品评论、用户私信等功能的网站，危害比较大，可以说是永久型的</p><p>攻击者事先将恶意脚本代码提交到目标网站服务端数据库内（通过用户提交时夹杂脚本代码）<br>当用户打开该目标网站时，服务端将恶意代码取出拼接HTML返回给浏览器<br>用户浏览器接收到响应后立即执行，而恶意的脚本代码也被自动执行，从而冒充用户，窃取用户数据发送到攻击者网站，或者调用接口执行其他操作<br><img src="img/%E5%89%8D%E7%AB%AF/%E6%80%BB%E7%BB%93/c0d86005b67147b2aa7f09cea37df60c.png" alt="c0d86005b67147b2aa7f09cea37df60c"></p><h5 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h5><p>反射型XSS漏洞常见于具有通过URL传递参数的功能网站，如网站搜索、跳转等，需要引导用户主动打开URL，和存储型XSS攻击的区别是反射型存储在URL中，存储型存储在数据库中</p><p>攻击者通过混杂入恶意脚本构造恶意的URL<br>用户点击打开含有恶意脚本的URL，网站服务端将恶意代码从URL中取出，拼接在HTML返回给浏览器<br>用户接收到后，浏览器执行恶意代码，同上，窃取用户数据或者调取接口执行操作<br><img src="img/前端/总结/0657ed61def749e7a74e13a898d0c18d.png" style="zoom:50%"></p><h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>DOM型XSS攻击主要是前端浏览器直接取出恶意代码，而前两者是由后端先取出再拼接返回。</p><p>攻击者利用恶意脚本构造恶意URL<br>用户直接点开恶意的URL，浏览器响应后直接解析执行，前端JS取出URL并执行<br>浏览器执行恶意代码，同上，窃取用户数据或者调取接口执行操作<br>比如是诱导用户点击后往img标签src属性里插入恶意脚本等</p><p>以上三种XSS攻击主要都是要攻击者构造恶意的脚本执行攻击，存储型和反射型主要是后端安全问题，DOM型主要是前端安全问题</p><h5 id="XSS防范方法"><a href="#XSS防范方法" class="headerlink" title="XSS防范方法"></a>XSS防范方法</h5><p> 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容 写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过 一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价 值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单</p><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>Cross Site Request Forgery，跨站请求伪造，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</p><p>eg:David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗</p><p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0ng0DPsEaWQULZjqQ8Sw6KICkbQpPuo0GrtWLqYpw5aehchurtbqo0ibfvkls6mNWxHiaSOoMQIeHmoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p><ul><li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li><li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li><li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li></ul><p>如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。</p><p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p><ul><li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li><li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li></ul><h4 id="XSS与CSRF区别"><a href="#XSS与CSRF区别" class="headerlink" title="XSS与CSRF区别"></a><strong>XSS与CSRF区别</strong></h4><ul><li><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。</li><li><code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤<ul><li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li><li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li></ul></li></ul><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指<code>攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的</code>，主要用于身份认证过程，破坏认证的正确性。<br>重放攻击可以由<code>发起者</code>，也可以由<code>拦截并重发该数据的敌方</code>进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。<br>重放攻击在任何网络通信过程中都可能发生，是计算机世界黑客<code>常用的攻击方式之一</code></p><p>重放攻击的基本原理就是把以前<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%AA%83%E5%90%AC/1624599?fromModule=lemma_inlink">窃听</a>到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86/752748?fromModule=lemma_inlink">加密</a>过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81/65553?fromModule=lemma_inlink">密码</a>，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。再比如，假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款。</p><p><strong>防御方案</strong><br>(1)加随机数。该方法优点是认证双方不需要时间同步，双方记住使用过的随机数，如发现报文中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。<br>(2)加时间戳。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易<br>(3)加流水号。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。但是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。</p><h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a><code>sql</code>注入</h3><p>原理：就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p><ul><li>总的来说有以下几点<ul><li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li><li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li><li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li><li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li></ul></li></ul><h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><p>文本加粗标签<strong></strong><b></b> &gt; 工作里尽量使用strong</p><p>文本倾斜标签<em></em> &gt;<i></i> &gt; 工作里尽量使用em</p><p>删除线标签<del></del> &gt;<s></s> &gt; 工作里尽量使用del</p><p>下划线标签<ins></ins> &gt;<u></u> 工作里尽量使用ins</p><p> <sup>上标</sup> <sub>下标</sub></p><p>超链接a:属性target,’_self’在自身页面打开，’_blank’打开一个新页面</p><base target="_blank"> 让所有的超链接都在新窗口打开<p>锚链接：</p><p id="sd"></p> <a href="#sd">回到顶部</a><p></p><p>关键字：<mate name="keyword" content=""></mate></p><p>网页描述:<mate name="description" content=""></mate></p><p>网页重定向：<mate http-equiv="refresh" content="5;http://www.baidu.com"></mate></p><p>设置icon图标：<link rel="icon" href="xxx.ico"></p><p>img:<code>title</code>当鼠标滑动到元素上的时候显示,<code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>    <table><br>        <caption>23</caption><br>        <thead><br>            <th>1</th><br>            <th>2</th><br>            <th></th><br>        </thead><br>        <tbody><br>            <tr><br>                <td>1</td><br>                <td>1</td><br>                <td>1</td><br>            </tr><br>        </tbody><br>    </table></p><p>cellspacing：表示各单元格之间的空隙</p><p>cellpadding：表示单元格内容与单元格边界之间的距离</p><p>边框合并</p><p>colspan=”2” 合并同一行上的单元格</p><p>rowspan=”2” 合并同一列上的单元格</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">table    &#123; display: table &#125;</span><br><span class="line">tr       &#123; display: table-row &#125;</span><br><span class="line">thead    &#123; display: table-header-group &#125;</span><br><span class="line">tbody    &#123; display: table-row-group &#125;</span><br><span class="line">tfoot    &#123; display: table-footer-group &#125;</span><br><span class="line">col      &#123; display: table-column &#125;</span><br><span class="line">colgroup &#123; display: table-column-group &#125;</span><br><span class="line">td, th   &#123; display: table-cell &#125;</span><br><span class="line">caption  &#123; display: table-caption &#125;</span><br><span class="line">HTML Table是指使用原生的&lt;table&gt;标签，而CSS Table是指用CSS属性模仿HTML 表格的模型。</span><br><span class="line">display:table最常见的例子了。对于动态高度的元素，有了它，就可以实现真正的垂直（居中）对齐。</span><br></pre></td></tr></table></figure><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><fieldset></fieldset> 对表单信息分组<legend>分组</legend> 表单信息分组名称<optgroup label=""></optgroup> 对下拉列表select进行分组。Label=”” 分组名称。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  &lt;fieldset&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;legend&gt;信息分组名称&lt;/legend&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;select name=&quot;&quot; id=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;optgroup label=&quot;1&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;/optgroup&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/fieldset&gt;</span><br></pre></td></tr></table></figure><p><strong>表单元素属性</strong></p><ul><li>value 用于大部分表单元素的内容获取(option除外)</li><li>type 可以获取input标签的类型(输入框或复选框等)</li><li>disabled 禁用属性</li><li>checked 复选框选中属性</li><li>selected 下拉菜单选中属性</li></ul><h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a><strong>iframe</strong></h3><h4 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h4><ul><li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li><li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li><li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li><li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li></ul><p>实际应用中，iframe可以当作一个子模块，像vue单一应用那样，选择菜单栏的选项，就切换页面相应的子模块。而使用原生的话，选择菜单栏的选项，就<strong>请求</strong>相应的iframe模块。</p><blockquote><p>如何知道是iframe模块？</p><p>右键点击，出现重新加载框架，点击重新加载框架，就局部加载该iframe模块</p></blockquote><h4 id="iframe-父页面与子页面之间-postMessage-通信"><a href="#iframe-父页面与子页面之间-postMessage-通信" class="headerlink" title="iframe 父页面与子页面之间 postMessage() 通信"></a>iframe 父页面与子页面之间 <code>postMessage()</code> 通信</h4><p><a target="_blank" rel="noopener" href="https://drylint.com/HTML/iframe%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%B8%8E%E7%88%B6%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1.html#postmessage-%E6%96%B9%E6%B3%95">https://drylint.com/HTML/iframe%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%B8%8E%E7%88%B6%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1.html#postmessage-%E6%96%B9%E6%B3%95</a></p><h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>textarea文本域在页面中是可以拖动的，即时你给了固定的宽度和高度，但这在我们页面布局中，使我们不需要的，因为可拖拽很多时候会影响我们页面的布局和整体的美观度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">textarea &#123;</span><br><span class="line">    width:700px;</span><br><span class="line">    height:300px;</span><br><span class="line">    border:1px solid #bcbcbc;</span><br><span class="line">    resize:none;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>resize：</p><p>　　1.both(默认值)–在xy方向上均可以拖拽；</p><p>　　2.vertical–在垂直方向上</p><p>　　3.horizontal–在水平方向上</p><p>　　4.none–不可以拖拽</p><p>　　5.inherit（继承）–textarea的父集一般是div元素，所以设置为继承的话，也是不可以拖拽的</p><ul><li>-</li></ul><h2 id="html5标签"><a href="#html5标签" class="headerlink" title="html5标签"></a>html5标签</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p><ul><li>新增选择器 <code>document.querySelector</code>、<code>document.querySelectorAll</code></li><li>拖拽释放(<code>Drag and drop</code>) API</li><li>媒体播放的 <code>video</code> 和 <code>audio</code></li><li>本地存储 <code>localStorage</code> 和 <code>sessionStorage</code></li><li>离线应用 <code>manifest</code></li><li>桌面通知 <code>Notifications</code></li><li>语意化标签 <code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li><li>增强表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li><li>地理位置 <code>Geolocation</code></li><li>多任务 <code>webworker</code></li><li>全双工通信协议 <code>websocket</code></li><li>历史管理 <code>history</code></li><li>跨域资源共享(CORS) <code>Access-Control-Allow-Origin</code></li><li>页面可见性改变事件 <code>visibilitychange</code></li><li>跨窗口通信 <code>PostMessage</code></li><li><code>Form Data</code> 对象</li><li>绘画 <code>canvas</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;input_list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;input_list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;laoma&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--点击展示详细信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>HTML 5<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This slide deck teaches you everything you need to know about HTML 5.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--小窗口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--进度条--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span>&gt;</span>working...<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">low</span>=<span class="string">&quot;40&quot;</span> <span class="attr">high</span>=<span class="string">&quot;90&quot;</span> <span class="attr">optimum</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;91&quot;</span>&gt;</span>A+<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;toy.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- file text password radio checkbox button image submit reset select button --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some@email.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">min</span>=<span class="string">&quot;2010-08-14&quot;</span> <span class="attr">max</span>=<span class="string">&quot;2011-08-14&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2010-08-14&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;50&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">results</span>=<span class="string">&quot;10&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;(555) 555-5555&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;^\(?\d&#123;3&#125;\)?[-\s]\d&#123;3&#125;[-\s]\d&#123;4&#125;.*?$&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;e.g. #bbbbbb&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> <span class="attr">min</span>=<span class="string">&quot;-5&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p><strong>标签语义化</strong>：尽可能少的使用无语义的标签div和span；</p><ul><li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li><li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li><li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li><li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li><li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li><li>非装饰性图片必须加<code>alt</code></li><li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li></ul><h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><ul><li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li><li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行</li><li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li><li>DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现</li></ul><h3 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a>严格模式与混杂模式</h3><p><strong>严格模式的限制</strong></p><ul><li>变量必须声明后再使用</li><li>函数的参数不能有同名属性，否则报错</li><li>不能使用with语句</li><li>不能对只读属性赋值，否则报错</li><li>不能使用前缀0表示八进制数，否则报错</li><li>不能删除不可删除的属性，否则报错</li><li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li><li><code>eval</code>不会在它的外层作用域引入变量</li><li><code>eval</code>和<code>arguments</code>不能被重新赋值</li><li><code>arguments</code>不会自动反映函数参数的变化</li><li>不能使用<code>arguments.callee</code></li><li>不能使用<code>arguments.caller</code></li><li>禁止<code>this</code>指向全局对象</li><li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li><li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li></ul><h3 id="Charset编码"><a href="#Charset编码" class="headerlink" title="Charset编码"></a><strong>Charset编码</strong></h3><p>Ascll Ansi Unicode Gbk Gb2312 Big5 Utf-8 通用字符集</p><h3 id="src-与-href-的区别"><a href="#src-与-href-的区别" class="headerlink" title="src 与 href 的区别"></a>src 与 href 的区别</h3><p>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。</p><p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在</p><p>位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片</p><p>和 frame 等元素。</p><script src="”js.js”"></script><p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行</p><p>完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将</p><p>js 脚本放在底部而不是头部。</p><p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）</p><p>或当前文档（链接）之间的链接，如果我们在文档中添加</p><link href="common.css" rel="stylesheet"><p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。</p><p>这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p><h3 id="XML和JSON的区别"><a href="#XML和JSON的区别" class="headerlink" title="XML和JSON的区别"></a>XML和JSON的区别</h3><ul><li>数据体积方面<ul><li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li></ul></li><li>数据交互方面<ul><li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li></ul></li><li>数据描述方面<ul><li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li></ul></li><li>传输速度方面<ul><li><code>JSON</code>的速度要远远快于<code>XML</code></li></ul></li></ul><h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="class命名规范"><a href="#class命名规范" class="headerlink" title="class命名规范"></a>class命名规范</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yyzyou/p/7920023.html">https://www.cnblogs.com/yyzyou/p/7920023.html</a></p><h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>头：header</p><p>页面主体：main</p><p>内容：content/container</p><p>侧栏：sidebar</p><p>栏目：column</p><p>页面外围控制整体布局宽度：wrapper</p><p>方向：left right center top bottom</p><p>内部： in</p><p>尾：footer</p><p>版权：copyright</p><h3 id="菜单和导航"><a href="#菜单和导航" class="headerlink" title="菜单和导航"></a>菜单和导航</h3><p>导航：nav</p><p>　　主导航：mainbav</p><p>　　子导航：subnav</p><p>　　顶导航：topnav</p><p>　　边导航：sidebar</p><p>　　左导航：leftsidebar</p><p>　　右导航：rightsidebar</p><p>菜单：menu</p><p>　　子菜单：submenu</p><p>​ 下拉菜单:dropmenv</p><p>标签页：tab</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><table><thead><tr><th>文章列表：list</th><th align="center">提示信息：msg</th><th>小技巧：tips</th></tr></thead><tbody><tr><td>栏目标题：title</td><td align="center">字体：font</td><td>注释：note</td></tr><tr><td>文本：text</td><td align="center">摘要: summary</td><td></td></tr><tr><td></td><td align="center"></td><td></td></tr></tbody></table><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><table><thead><tr><th>加入：joinus</th><th>指南：guild</th><th>服务：service</th></tr></thead><tbody><tr><td>注册：regsiter</td><td>投票：vote</td><td>滚动：scroll</td></tr><tr><td>下载：download</td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><table><thead><tr><th>当前的: current</th><th></th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><table><thead><tr><th align="center">登录条：loginbar</th><th align="center">广告：banner</th><th align="center">功能区：shop</th></tr></thead><tbody><tr><td align="center">按钮：btn</td><td align="center">图标: icon</td><td align="center">线：line</td></tr><tr><td align="center">热点：hot</td><td align="center">新闻：news</td><td align="center">合作伙伴：partner</td></tr><tr><td align="center">友情链接：friendlink</td><td align="center">版权：copyright</td><td align="center">标签:label</td></tr><tr><td align="center">图片：pic</td><td align="center">首页：homepage</td><td align="center">模态：modal</td></tr><tr><td align="center">名片：card</td><td align="center">通知：notification</td><td align="center">平台：platform</td></tr><tr><td align="center">优惠券：coupon</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Jwhahaha/article/details/102483938">https://blog.csdn.net/Jwhahaha/article/details/102483938</a></p><h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：</p><ul><li>每个块级元素都是独自占一行。</li><li>元素的高度、宽度、行高和边距都是可以设置的。　　</li><li>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,<strong>高度由内容撑开</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">h1~h6:标题标签，用于标记网页中的大标题，依次从大到小</span><br><span class="line">p：用于标记网页中的段落性文字，默认占满横向区域</span><br><span class="line">div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽</span><br><span class="line">section：区段，是用来定义文档的某个区域，章节</span><br><span class="line">nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。</span><br><span class="line">header：标签定义文档的页眉</span><br><span class="line">footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等</span><br><span class="line">pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。</span><br><span class="line">address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行</span><br><span class="line">audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。</span><br><span class="line">/ 表格标签 /</span><br><span class="line">table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸</span><br><span class="line">thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tbody：表主体，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tr：表示一行</span><br><span class="line">th：表头中的第一个单元格</span><br><span class="line">td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列</span><br><span class="line">/ 有序列表，无序列表 /</span><br><span class="line">ul：无序列表</span><br><span class="line">ol：有序列表</span><br><span class="line">li：列表项</span><br><span class="line">dl：定义列表，用于描述类表中的项目（dt（dd））</span><br></pre></td></tr></table></figure><h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素 inline"></a><strong>行内元素 inline</strong></h3><p>行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点：</p><ul><li><p>每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。</p></li><li><p>行内元素的高度、宽度、行高不可设置。</p></li><li><p>元素的宽度就是它包含的文字或图片的宽度，不可改变。</p></li><li><p><strong>行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以</strong></p></li></ul><p>常见行内元素有以下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化</span><br><span class="line"></span><br><span class="line">a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件</span><br><span class="line">有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址</span><br><span class="line">strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容</span><br><span class="line"></span><br><span class="line">b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调</span><br><span class="line">s：删除线，仅仅是删除的效果</span><br><span class="line">del：具有删除语义，delete删除</span><br><span class="line">em：强调文本，斜体展示</span><br><span class="line">sup：上标</span><br><span class="line">sub：下标</span><br></pre></td></tr></table></figure><h3 id="行内块级元素-inline-block"><a href="#行内块级元素-inline-block" class="headerlink" title="行内块级元素 inline-block"></a><strong>行内块级元素 inline-block</strong></h3><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：</p><ul><li>和其他行内或行内块级元素元素放置在同一行上；</li><li>元素的高度、宽度、行高以及顶和底边距都可设置。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示</span><br><span class="line">button：按钮</span><br><span class="line">input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。</span><br><span class="line"></span><br><span class="line">单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值</span><br><span class="line">type=&quot;checkbox&quot;复选框</span><br><span class="line"></span><br><span class="line">label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态</span><br><span class="line">select:下拉列表</span><br><span class="line">option:下拉选项</span><br></pre></td></tr></table></figure><h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://i0.hdslb.com/bfs/article/8893357747d83ffb476629f3bd8e5bd25e202cdd.jpg@942w_423h_progressive.webp" alt="img"></p><ol><li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p></li><li><p>作为style属性写在元素内的样式 优先级1000</p></li><li><p>id选择器 优先级100</p></li><li><p>类选择器和<strong>伪类和属性</strong> 优先级10</p></li><li><p>标签选择器和<strong>伪元素</strong> 优先级1</p></li><li><p>通配符选择器 优先级0</p></li><li><p>浏览器自定义或继承 没有优先级</p><p><strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p></li><li><p>当权值相等时，后定义的样式表要优于先定义的样式表。</p></li><li><p>交集/后代选择器的优先级 所有优先级 加起来 运算 然后比较</p></li><li><p>并集的话 就是各算各的。</p></li></ol><h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><ul><li><p>相邻兄弟选择器 A + B，选择紧接在A后的B元素(A和B中间不能有元素)，且二者有相同的父元素</p></li><li><p>普通兄弟选择器 A ~ B，选择紧接在A后的<strong>所有B元素</strong>(A和B中间可以有元素)，且二者有相同的父元素</p></li><li><p>子选择器 A &gt; B</p></li><li><p>后代选择器 A B</p></li><li><p>交集 A.B{}</p></li><li><p>并集 A, B｛｝</p></li></ul><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> </span><br><span class="line"><span class="comment">/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span></span><br></pre></td></tr></table></figure><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>用来表示定位元素的某种状态所显示的样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a:link&#123;属性:值;&#125;       链接默认状态	 </span><br><span class="line">a:visited&#123;属性:值;&#125;     链接访问之后的状态 </span><br><span class="line">a:hover&#123;属性:值;&#125;      鼠标放到链接上显示的状态  	a:active&#123;属性:值;&#125;      链接激活的状态</span><br><span class="line">a:focus&#123;属性:值；&#125;     获取焦点</span><br></pre></td></tr></table></figure><ul><li><code>p:first-of-type</code> 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code> 元素。</li><li><code>p:last-of-type</code> 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素。</li><li><code>p:only-of-type</code> 选择属于其父元素唯一的 <code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:only-child</code> 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:nth-child(2)</code> 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li><li><code>p:nth-of-type(n)</code> 选择E的父元素下的第n个E元素</li><li><code>:after</code> 在元素之前添加内容,也可以用来做清除浮动。</li><li><code>:before</code> 在元素之后添加内容。</li><li><code>:enabled</code> 已启用的表单元素。</li><li><code>:disabled</code> 已禁用的表单元素。</li><li><code>:checked</code> 单选框或复选框被选中。</li><li><code>:empty</code> 选中没有任何子节点的E元素；</li></ul><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p> 用于创建一些<strong>不在文档树中的元素</strong>，并为其添加样式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">伪元素特性</span><br><span class="line">减少 dom 节点数,但不利于不利于 SEO</span><br><span class="line">它不存在于文档中，所以 js 无法操作它</span><br><span class="line">它属于主元素本身，因此当伪元素被点击的时候触发的是主元素的 click 事件</span><br></pre></td></tr></table></figure><ul><li>E::selection 可改变选中文本的样式</li></ul><ul><li>E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholderE:after、E:before</li></ul><ul><li><p><code>::before</code>创建一个伪元素，该元素是所选元素的第一个子元素</p><p><code>::after</code>创建一个伪元素，该元素是所选元素的最后一个子元素</p><ul><li><p>块级元素才能有:before, :after，譬如 img 就不能设置</p></li><li><p>伪类元素的display是默认值inline</p></li><li><p>```<br><a target="_blank" rel="noopener" href="http://www.cnblogs.com/starof">starof</a><br>attr() 通过attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。<br>a::after{</p><pre><code>content:  attr(href) ;
</code></pre><p>}<br>a::before{<br> content: url(“<a target="_blank" rel="noopener" href="https://www.baidu.com/img/baidu_jgylogo3.gif&quot;">https://www.baidu.com/img/baidu_jgylogo3.gif&quot;</a>);<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 清除浮动</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.cf:before,<br>.cf:after {</p><pre><code>content: &quot; &quot;;
display: table; 
</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 文字</span><br><span class="line"></span><br><span class="line">### 基础</span><br><span class="line"></span><br><span class="line">- **font-family**</span><br><span class="line"></span><br><span class="line">- font-variant 设置字母字体 </span><br><span class="line"></span><br><span class="line">  - **normal :** 正常的字体 	</span><br><span class="line"></span><br><span class="line">  - **small-caps :** 设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小</span><br><span class="line"></span><br><span class="line">- text-transform </span><br><span class="line"></span><br><span class="line">  - none</span><br><span class="line"></span><br><span class="line">  - **capitalize :** 　将每个单词的第一个字母转换成大写，其余无转换发生</span><br><span class="line"></span><br><span class="line">  - **uppercase :**  转换成大写</span><br><span class="line"></span><br><span class="line">  - **lowercase :** 　转换成小写</span><br><span class="line"></span><br><span class="line">- text-decoration下划线</span><br><span class="line"></span><br><span class="line">  -  none  |   underline   |     line-through</span><br><span class="line"></span><br><span class="line">- **direction**文本方向</span><br><span class="line">  ltr 	默认。文本方向从左到右。</span><br><span class="line">  rtl 	文本方向从右到左。</span><br><span class="line">  inherit 	规定应该从父元素继承 direction 属性的值。</span><br><span class="line"></span><br><span class="line">- **text-size-adjust**：文本溢出算法，根据设备尺寸而自动调整文字大小</span><br><span class="line"></span><br><span class="line">  auto：启用浏览器的文本溢出算法</span><br><span class="line"></span><br><span class="line">  none：禁用浏览器的文本溢出算法。</span><br><span class="line"></span><br><span class="line">  percentage：启用浏览器的文本溢出算法，并使用用一个百分数来确定文本放大程度。</span><br><span class="line"></span><br><span class="line">### 间距</span><br><span class="line"></span><br><span class="line">- **text-indent :** 规定文本块中首行文本的缩进。</span><br><span class="line"></span><br><span class="line">  | *length* | 定义固定的缩进。默认值：0。                 |</span><br><span class="line">  | -------- | ------------------------------------------- |</span><br><span class="line">  | *%*      | 定义基于父元素宽度的百分比的缩进。          |</span><br><span class="line">  | inherit  | 规定应该从父元素继承 text-indent 属性的值。 |</span><br><span class="line"></span><br><span class="line">- **letter-spacing :**增加或减少字符间的空白（字符间距）</span><br><span class="line"></span><br><span class="line">  | normal   | 默认。规定字符间没有额外的空间。               |</span><br><span class="line">  | -------- | ---------------------------------------------- |</span><br><span class="line">  | *length* | 定义字符间的固定空间（允许使用负值）。         |</span><br><span class="line">  | inherit  | 规定应该从父元素继承 letter-spacing 属性的值。 |</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">### **vertical-align **</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_42667613/article/details/123429515</span><br><span class="line"></span><br><span class="line">设置一个元素的垂直对齐方式。该属性**定义行内元素(`inline`、`inline-block`、`inline-table`、`table-cell`)的基线相对于该元素所在行的基线的对齐方式**。</span><br><span class="line"></span><br><span class="line">&gt;   vertical-align不可继承，必须对**子元素**单独设置。</span><br><span class="line"></span><br><span class="line">1. baseline：**默认值**，元素的基线与父元素基线对齐。</span><br><span class="line">2. top：把元素的顶端与父元素顶线对齐；</span><br><span class="line">3. **middle：把此元素放置在父元素的中部。**</span><br><span class="line">4. bottom：把元素的顶端与父元素底线对齐![属性值图解](https://img-blog.csdnimg.cn/8f73007c2be64c84a2e2f7e2a14c1b1d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3Mzk0Mw==,size_16,color_FFFFFF,t_70#pic_center)</span><br><span class="line"></span><br><span class="line">### line-height</span><br><span class="line"></span><br><span class="line">**行高是指文本行基线间的垂直距离** </span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/a2013126370/article/details/82786681</span><br><span class="line"></span><br><span class="line">*length :* 百分比数字 | 由浮点数字和单位标识符组成的长度值，允许为负值。其百分比取值是基于字体的高度尺寸。1em=字体的大小</span><br><span class="line"></span><br><span class="line">下图中两条红线之间的距离就是行高，上行的底线和下一行顶线之间的距离就是行距，而同一行顶线和底线之间的距离是font-size的大小，行距的一半是半行距。</span><br><span class="line"></span><br><span class="line">![img](https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">**line-height=font-size+行间距**</span><br><span class="line"></span><br><span class="line">当font-size等于line-height时，行距 = line-height - font-size = 0；而当font-size大于line-height时，则会出现行距为负值，则两行重叠，如下图：</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdn.net/20180920113755884?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 如果一个标签没有定义 `height` 属性，那么其最终表现的高度是由 `line-height` 决定的</span><br><span class="line"></span><br><span class="line">- 一个容器没有设置高度，那么撑开容器高度的是 `line-height` 而不是容器内的文字内容</span><br><span class="line"></span><br><span class="line">- 把 `line-height` 值设置为 `height` 一样大小的值可以实现单行文字的垂直居中</span><br><span class="line"></span><br><span class="line">### 换行</span><br><span class="line"></span><br><span class="line">#### white-space文本换行</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_37210523/article/details/103145240</span><br><span class="line"></span><br><span class="line">![img](https://img-blog.csdnimg.cn/2019111916525132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">  ```css</span><br><span class="line">  white-space: normal;  /*连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 */</span><br><span class="line">  white-space: nowrap;  /* 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。*/</span><br><span class="line">  white-space: pre;  /* 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。*/</span><br><span class="line">  white-space: pre-wrap; /* 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时才会换行。*/</span><br><span class="line">  white-space: pre-line;  /* 连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。*/</span><br><span class="line">   </span><br><span class="line">  white-space: break-spaces;</span><br><span class="line">  /**</span><br><span class="line">      与 pre-wrap的行为相同，除了：</span><br><span class="line">      任何保留的空白序列总是占用空间，包括在行尾。</span><br><span class="line">      每个保留的空格字符后都存在换行机会，包括空格字符之间。</span><br><span class="line">      这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。</span><br><span class="line">  */</span><br><span class="line">  white-space: inherit;</span><br><span class="line">  white-space: initial;</span><br><span class="line">  white-space: unset;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="word-break单词换行"><a href="#word-break单词换行" class="headerlink" title="word-break单词换行"></a><strong>word-break单词换行</strong></h4><p> <strong><code>word-break</code> 指定了怎样在单词内断行</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">word-break</span>：指定了怎样在单词内断行</span><br><span class="line"><span class="attribute">normal</span>	只在允许的断字点换行（浏览器保持默认处理）。</span><br><span class="line">keep-all中文自动换行了，而英文使用默认换行方式 ---&gt;break-all</span><br><span class="line">break-word 允许正常的不能被分割的长单词强制分割换行</span><br><span class="line">//因为<span class="attribute">word-break</span>的break-word未列入标准，才会一般使用<span class="attribute">overflow-wrap</span>的break-word值</span><br><span class="line"><span class="attribute">overflow-wrap</span>(==<span class="attribute">word-wrap</span>) 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。</span><br><span class="line">break-all表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。</span><br></pre></td></tr></table></figure><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul><li>white-space控制空白字符的显示，同时还能控制是否自动换行。它有五个值：normal | nowrap | pre | pre-wrap | pre-line</li><li>word-break，控制单词如何被拆分换行。它有三个值：normal | break-all | keep-all</li><li>word-wrap（overflow-wrap）控制长度超过一行的单词是否被拆分换行，是word-break的补充，它有两个值：normal | break-word</li></ul><h3 id="文本缩略"><a href="#文本缩略" class="headerlink" title="文本缩略"></a>文本缩略</h3><p><strong>text-overflow :</strong> <strong>clip</strong> | <strong>ellipsis</strong></p><p><strong>clip :</strong> 　不显示省略标记（…），而是简单的裁切<br><strong>ellipsis :</strong> 　当对象内文本溢出时显示省略标记（…）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">section:nth-of-type(4) p &#123;</span><br><span class="line">    width: 40%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p><strong>clip :</strong> <strong>auto</strong> | <strong>rect (</strong> <em>number number number number</em> **)**依据上-右-下-左的顺序剪切图像。必须将<a href="c_position.html">position</a>的值设为absolute，此属性方可使用。</p><p>clip-path 裁切一个圆角 inset(<top><right><bottom><left> round<top-radius><right-radius><bottom-radius><left-radius>)</left-radius></bottom-radius></right-radius></top-radius></left></bottom></right></top></p><h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/pr-object-fit.html">https://www.runoob.com/cssref/pr-object-fit.html</a></p><p>object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。</p><p>object-fit 一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">fill</td><td align="left">默认，不保证保持原有的比例，内容拉伸填充整个内容容器。</td></tr><tr><td align="left">contain</td><td align="left">保持原有尺寸比例。内容被缩放。</td></tr><tr><td align="left">cover</td><td align="left">保持原有尺寸比例。但部分内容可能被剪切。</td></tr><tr><td align="left">none</td><td align="left">保留原有元素内容的长度和宽度，也就是说内容不会被重置。</td></tr><tr><td align="left">scale-down</td><td align="left">保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。</td></tr><tr><td align="left">initial</td><td align="left">设置为默认值，<a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-initial.html">关于 <em>initial</em></a></td></tr><tr><td align="left">inherit</td><td align="left">从该元素的父元素继承属性。 <a target="_blank" rel="noopener" href="https://www.runoob.com/cssref/css-inherit.html">关于 <em>inherit</em></a></td></tr></tbody></table><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4d1dbb041bb2">https://www.jianshu.com/p/4d1dbb041bb2</a></p><p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使容器里面的元素不会在布局上影响到外面的元素。</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a><strong>触发条件</strong></h4><ul><li>body 根元素</li><li>浮动元素：float 除 none 以外的值</li><li>绝对定位元素：position (absolute、fixed)</li><li>display 为 inline-block、table-cells、flex</li><li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li></ul><h4 id="BFC场景和应用"><a href="#BFC场景和应用" class="headerlink" title="BFC场景和应用"></a><strong>BFC场景和应用</strong></h4><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img" style="zoom:33%"><p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p><p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p><p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img" style="zoom:33%"><p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p><blockquote><p>float为left/right是子元素本身触发了BFC，使普通布局流变成了浮动流布局；父级元素因为浮动从而高度塌陷，所以需要overflow来触发父级元素的BFC来重新布局回到普通布局。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img" style="zoom:33%"><p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p><p>先来看一个文字环绕效果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span></span><br><span class="line">    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure> <img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img" style="zoom:33%"><p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p> <img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img" style="zoom:33%"><p>这个方法可以用来实现<strong>两列自适应布局</strong>，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p><p><strong>开发中的应用</strong></p><ul><li>阻止<code>margin</code>重叠</li><li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 <code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li><li>自适应两栏布局</li><li>可以阻止元素被浮动元素覆盖</li></ul><h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36595013/article/details/81810219">https://blog.csdn.net/qq_36595013/article/details/81810219</a></p><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote><p>设置元素浮动后，对应的元素会脱离文档流，该元素的 <code>display</code> 值自动变成 <code>block</code></p></blockquote><p>假如某个div元素A是浮动的，如果A元素<strong>上一个元素也是浮动的</strong>，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素<strong>上一个元素是标准流中的元素</strong>，那么A的顶部和上一个元素的底部对齐。</p> <img src="https://img-blog.csdn.net/20180818160910520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%"><p>假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。</p> <img src="https://img-blog.csdn.net/20180818161114199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%"><p>把div2和div3都加上左浮动,由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。</p><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p><strong>清除浮动:清除浮动不是不用浮动，清除浮动产生的不利影响。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear :none| left |right  | both</span><br><span class="line">none :允许两边都可以有浮动对象</span><br><span class="line">both :不允许有浮动对象</span><br><span class="line">left :不允许左边有浮动对象</span><br></pre></td></tr></table></figure><p>场景：CSS浮动塌陷，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。</p><p>解决：</p><ul><li><p>父元素使用overflow:hidden来清除浮动，最好加上zoom:1;</p></li><li><p>父级div定义height</p></li><li><p>在父元素后面使用伪类：after和zoom</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.box:after&#123;</span><br><span class="line">- display:block;</span><br><span class="line">- content:&quot;&quot;;</span><br><span class="line">- height:0;</span><br><span class="line">- clear:both;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure></li><li><p>结尾处加空div标签clear:both</p></li><li><p>对父元素设置display:table；使父元素形成BFC（块格式化上下文）</p></li></ul><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul><li>float 可以用来让文字环绕图片而已。</li><li>如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</li></ul><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul><li><p><strong>position:absolute</strong></p><ul><li>会让元素以display:inline-block的方式显示,可以设置长宽，默认宽度并不占满父元素。</li><li><strong>Z-index 仅能在定位元素上奏效（例如 position:absolute;）！</strong></li><li>脱离文档流</li></ul></li><li><p><strong>position:relative</strong></p><ul><li><p>相对定位，相对于原来该元素在普通流中的位置重新定位，依旧在普通流中占据位置，没有脱离普通流，只是视觉上发生变化</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5627750-ec360e4418779b3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/535/format/webp" alt="img"></p></li></ul></li></ul><ul><li><p><strong>Position:fixed</strong> 通常相对于浏览器窗口或 frame 进行定位。</p><ul><li>固定定位之后，不占据原来的位置（脱标）</li><li>元素使用固定定位之后，会转化为行内块</li></ul></li><li><p>static：默认值。没有定位，元素出现在正常的流中</p></li></ul><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><ul><li>display: flex; 会浮动</li></ul><ul><li><p>flex-direction: column;决定主轴的方向(即子元素的排列方向)</p><p>调整主轴方向（默认为水平方向）包括row、column、row-reverse、column-reverse</p></li><li><p>justify-content（水平方向）定义了子元素在主轴上的对齐方式</p><p>主轴方向对齐，可以调整元素在主轴方向上的对齐方式，包括flex-start、flex-end、center、space-around(多与空间放两边)、space-between(多与空间放中间)几种方式</p></li><li><p>align-items（垂直方向）定义子元素在侧轴上如何对齐</p><p>调整侧轴方向对齐方式，包括flex-start、flex-end、center、baseline、stretch</p></li><li><p>flex-wrap 控制是否换行，包括wrap、nowrap （不换行）</p></li><li><p>align-content 定义了多根轴线的对齐方式, 如果子元素只有一根轴线,该属性不起作用<br>可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch</p></li><li><p>align-self 侧轴上单个项目对齐方式<br>单独对某一个子元素设置 flex-start、flex-end、center、baseline、stretch</p></li></ul><p><strong>flex 控制子元素伸缩比例</strong></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41635167/article/details/104190865">https://blog.csdn.net/qq_41635167/article/details/104190865</a></p><p><a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2019/12/css-flex-deep/">https://www.zhangxinxu.com/wordpress/2019/12/css-flex-deep/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">flex:1	</span><br><span class="line">	flex-grow: 1;</span><br><span class="line">  flex-shrink: 1;</span><br><span class="line">  flex-basis: 0%;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在Flex布局中，一个Flex子项的宽度是由元素自身尺寸，<code>flex-basis</code>设置的基础尺寸，以及外部填充（<code>flex-grow</code>）或收缩（<code>flex-shrink</code>）规则3者共同决定的。</p><p>举例：分家产</p><ul><li><p>flex-basis:用于设置子盒子宽度。在Flex布局中，<strong>flex-basis优先级是比width高的</strong>。<code>flex-basis</code>的默认值是<code>auto</code>，表示自动，也就是完全根据子列表项自身尺寸渲染。</p><p>自身尺寸渲染优先级如下：min-width &gt; || max-width &gt; width &gt; Content Size</p><blockquote><p><code>flex-basis</code>就是分配固定的家产数量。</p></blockquote></li><li><p>flex-grow(用在子盒子上)属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><blockquote><p><code>flex-grow</code>就是家产剩余家产仍有富余的时候该如何分配。</p></blockquote></li><li><p>flex-shrink(flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值)属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><blockquote><p><code>flex-shrink</code>就是家产剩余家产不足的时候该如何分配。</p></blockquote></li></ul><p><strong>flex参数</strong></p><ul><li><p><strong>1个值</strong></p><p>如果flex的属性值只有一个值，则：</p><ul><li>如果是数值，例如<code>flex: 1</code>，则这个<code>1</code>表示<code>flex-grow</code>，<del>此时<code>flex-shrink</code>和<code>flex-basis</code>都使用默认值，分别是<code>1</code>和<code>auto</code></del>。<strong>更正为：</strong>此时<code>flex-shrink</code>和<code>flex-basis</code>的值分别是<code>1</code>和<code>0%</code>，注意，这里的<code>flex-basis</code>的值是<code>0%</code>，而不是默认值<code>auto</code>。</li><li>如果是长度值，例如<code>flex: 100px</code>，则这个<code>100px</code>显然指<code>flex-basis</code>，因为3个缩写CSS属性中只有<code>flex-basis</code>的属性值是长度值。<del>此时<code>flex-grow</code>和<code>flex-shrink</code>都使用默认值，分别是<code>0</code>和<code>1</code>。</del><strong>更正为：</strong>此时<code>flex-grow</code>和<code>flex-shrink</code>都是<code>1</code>，注意，这里的<code>flex-grow</code>的值是<code>1</code>，而不是默认值<code>0</code>。</li></ul></li><li><p><strong>2个值</strong></p><p>如果flex的属性值有两个值，则第1个值一定指<code>flex-grow</code>，第2个值根据值的类型不同表示不同的CSS属性，具体规则如下：</p><ul><li>如果第2个值是数值，例如<code>flex: 1 2</code>，则这个<code>2</code>表示<code>flex-shrink</code>，<del>此时<code>flex-basis</code>使用默认值<code>auto</code>。</del><strong>更正为：</strong>此时<code>flex-basis</code>计算值是<code>0%</code>，并非默认值<code>auto</code>。</li><li>如果第2个值是长度值，例如<code>flex: 1 100px</code>，则这个<code>100px</code>指<code>flex-basis</code>，此时<code>flex-shrink</code>使用默认值<code>0</code>。</li></ul></li><li><p><strong>3个值</strong></p><p>如果<code>flex</code>的属性值有3个值，则这长度值表示<code>flex-basis</code>，其余2个数值分别表示<code>flex-grow</code>和<code>flex-shrink</code>。下面两行CSS语句的语法都是合法的，且含义也是一样的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面两行CSS语句含义是一样的 */</span></span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">50%</span>；</span><br><span class="line">flex: <span class="number">50%</span> <span class="number">1</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul><p>order <strong>定义子元素的排列顺序, 数值越小 排列越靠前 默认为0</strong></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="元素的水平居中"><a href="#元素的水平居中" class="headerlink" title="元素的水平居中"></a>元素的水平居中</h4><ul><li><p>元素为行内元素，设置父元素<code>text-align:center</code></p></li><li><p>如果子元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</p></li><li><p>绝对定位和移动: <code>absolute + transform</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.parent_box&#123;</span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .child_box&#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate( -50%,0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为center</p></li><li><p>```<br>display:block;<br>margin:auto;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 元素的垂直居中</span><br><span class="line"></span><br><span class="line">- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`</span><br><span class="line"></span><br><span class="line">- 使用`flex`布局，设置为`align-item：center`</span><br><span class="line"></span><br><span class="line">- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`</span><br><span class="line"></span><br><span class="line">- 绝对定位和移动: `absolute + transform`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>.parent_box{</p><pre><code>        width: 400px;
        height: 200px;
        position: relative;
    &#125;
    .child_box&#123;
        width: 200px;
        height: 100px;
        position: absolute;
        left: 0;
        top: 50%;
        transform: translate( 0，-50%);
    &#125;
</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值</span><br><span class="line"></span><br><span class="line">- 文本垂直居中设置`line-height`为`height`值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 垂直水平居中</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">/** 1 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  .box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: -50px 0 0 -50px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 2 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  .box &#123;</span><br><span class="line"></span><br><span class="line">        margin: 0 !important;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 3 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  .box &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 4 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  .box &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>如何垂直居中一个<code>&lt;img&gt;</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#container     /**&lt;img&gt;的容器设置如下**/</span><br><span class="line">&#123;</span><br><span class="line">    display:table-cell;</span><br><span class="line">    text-align:center;</span><br><span class="line">    vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="设备尺寸"><a href="#设备尺寸" class="headerlink" title="设备尺寸"></a>设备尺寸</h4><p>设备尺寸指的是设备对角线的长度，单位是英寸</p> <img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2548297ffb3741178f62c1dbc1a75388~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img" style="zoom:33%"><h4 id="像素px"><a href="#像素px" class="headerlink" title="像素px"></a>像素px</h4><p>是组成图片的色彩和亮度的最小图像单元，是显示屏的画面上能表现出来的最小单位。像素分为：<strong>css像素和物理像素</strong>。</p><p>**物理像素/设备像素(device pixel, dp)**： 由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位pt。 pt 在 css 单位中属于真正的绝对单位，1pt = 1/72(inch), inch及英寸，而1英寸等于2.54厘米。所以设备像素的特点就是大小固定，不可变。比如 iPhone 5 的分辨率为 640 x 1136px.</p><p>**CSS像素(css pixel, px)**： 由于不同的物理设备的物理像素的大小是不一样的，所以<code>css</code>认为浏览器应该对<code>css</code>中的像素进行调节，使得浏览器中 1css像素的大小在不同物理设备上看上去大小总是差不多 ，目的是为了保证阅读体验一致。为了达到这一点浏览器可以直接按照设备的物理像素大小进行换算。比如 iPhone 5 的 CSS 像素数为 320 x 568px.</p><p><strong>CSS像素 =设备独立像素 = 逻辑像素</strong></p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a><strong>分辨率</strong></h4><p>是指桌面设定的分辨率，而不是显示器的分辨率 。分辨率指的是宽度上和高度上最多能显示的物理像素点个数。指的是屏幕的像素尺寸。<code>750X1334</code>指的是横向有<code>750</code>个像素，纵向有<code>1334</code>个像素。<code>屏幕尺寸</code>指的是设备对角线的长度。</p><h4 id="像素比-DPR"><a href="#像素比-DPR" class="headerlink" title="像素比(DPR)"></a><strong>像素比(DPR)</strong></h4><p>在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio(设备像素比)属性，它的官方的定义为：设备物理像素和设备独立像素的比例。</p><p><strong>devicePixelRatio = 物理像素 / 独立像素</strong>。css中的<strong>px就可以看做是设备的独立像素</strong>，所以通过devicePixelRatio，我们可以知道该设备上<strong>一个css像素代表多少个物理像素</strong>。</p><p>在普通屏，1个css像素对应1个物理像素；2倍屏中，一个css像素对应4个物理像素；三倍屏中则是9个。如<code>iPhone6</code>的<code>dpr</code>为<code>2</code>，物理像素<code>750</code>（x轴）,则它的逻辑像素为<code>375</code>。</p><p>除了设备，还有一个因素也会引起DPR的变化，那就是<strong>用户缩放</strong>。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p><h4 id="1px"><a href="#1px" class="headerlink" title="1px"></a>1px</h4><p>对于前端来说，在高清屏出现之前，前端代码的 <code>1px</code> 即等于手机物理像素点的 <code>1px</code>。但有了 dpr 的概念之后，由于前端代码中的使用的是 CSS 像素，手机会根据 dpr 换算成实际的物理像素大小来渲染页面。比如 iPhone6 的设备像素比 <code>dpr = 2</code> ，相当于一个 CSS 像素等于两个物理像素，即 <code>1px</code> 由 2个物理像素点组成。</p><p>那么问题来了，以 iPhone6 为例，其 <code>dpr = 2</code>、屏幕尺寸(CSS 像素) 为 <code>375x667</code>，一般设计稿提供 2 倍图尺寸为 <code>750x1334</code> 。那么设计稿中的 <code>1px</code>，对应屏幕尺寸其实应该写成 <code>0.5px</code>。再由 dpr 计算公式可知，<code>0.5 * 2 = 1px</code> 物理像素。</p><p>此时你应该已经发现了，设计稿要实现 <code>1px</code> 细线、<code>1px</code> 边框，为什么前端实现总是偏粗的？那是因为如果你在代码中直接写成 <code>1px</code>，再通过 dpr 计算之后其实是 <code>2px</code> 物理像素，并不符合设计稿的要求</p><p>那么当 <code>dpr=2</code> 时，代码中直接写成 <code>0.5px</code> 就解决问题了吗？</p><h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liwusen/article/details/80834546">https://blog.csdn.net/liwusen/article/details/80834546</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zaoa/p/8630393.html">https://www.cnblogs.com/zaoa/p/8630393.html</a></p><h4 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h4><p><strong>视口针对移动设备，对PC没用</strong></p><p>(1) 布局视口（layout viewport）<br> 为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的 viewport 设为 980px 或其他值，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况</p> <img src="https://www.runoob.com/wp-content/uploads/2018/07/1532326331-2895-201407.png" alt="img" style="zoom:80%"><p>(2) 视觉视口（visual viewport）<br>视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。</p> <img src="https://www.runoob.com/wp-content/uploads/2018/07/1532326332-9414-201407.png" alt="img" style="zoom:50%"><p>(3) 理想视口（ideal viewport）</p><p>理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。 <strong>理想视口的值其实就是屏幕分辨率的值</strong></p><p><strong>应用</strong></p><p><strong>移动设备默认的viewport是layout viewport</strong>，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;
</code></pre><p>该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。让viewport的宽度等于设备的宽度，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p><table><thead><tr><th>width</th><th>设置<em><strong>layout viewport</strong></em> 的宽度，为一个正整数，或字符串”width-device”</th></tr></thead><tbody><tr><td>initial-scale</td><td>设置页面的初始缩放值，为一个数字，可以带小数</td></tr><tr><td>minimum-scale</td><td>允许用户的最小缩放值，为一个数字，可以带小数</td></tr><tr><td>maximum-scale</td><td>允许用户的最大缩放值，为一个数字，可以带小数</td></tr><tr><td>height</td><td>设置<em><strong>layout viewport</strong></em> 的高度，这个属性对我们并不重要，很少使用</td></tr><tr><td>user-scalable</td><td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td></tr></tbody></table><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>相对于根元素html的font-size值的大小，此单位若要用于屏幕自适应，可与vw配合使用设置根元素的字体大小。375px的网页的设计稿。此时，1vw=3.75px；4vw=15px；8vw=30px；</p><h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比%"></a>百分比%</h4><ol><li>子元素<strong>width</strong>或<strong>height</strong>的百分比是<strong>父元素width或height的百分比</strong></li><li><strong>top</strong>、<strong>bottom</strong>的百分比是相对于(默认定位)<strong>父元素的height</strong></li><li><strong>left</strong>、<strong>right</strong>的百分比是相对于(默认定位)<strong>父元素的width</strong></li><li><strong>padding</strong>、<strong>margin</strong>不论是垂直方向或者是水平方向，都相对于直接<strong>父元素的width</strong></li><li><strong>border-radius</strong>、<strong>translate</strong>、<strong>background-size</strong>的百分比，则是相对于<strong>自身的width</strong></li></ol><p><strong>两个缺点：</strong></p><p>（1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。<br>（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</p><h3 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenyoumei/p/10510321.html">https://www.cnblogs.com/chenyoumei/p/10510321.html</a></p><ul><li><p>查看设计图，确定页面布局，组件的复用等</p></li><li><p>尽可能的添加多的div来包含元素，并设置对应的classname</p></li><li><p>外层盒子使用flex进行布局，不设置绝对宽高px(使用rem或者%布局)，高度由里面的内容撑开（<strong>撑不开就用margin、padding</strong>）</p><p><code>box-sizing:border-box以及margin：auto</code></p></li><li><p><strong>Tips</strong></p><ul><li><p>float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</p></li><li><p>图片的自适应，<code>img &#123; width: auto; max-width: 100%; &#125;</code></p></li></ul></li></ul><h4 id="yd-ui移动端"><a href="#yd-ui移动端" class="headerlink" title="yd ui移动端"></a><strong>yd ui移动端</strong></h4><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b00cd3506782">https://www.jianshu.com/p/b00cd3506782</a></p><blockquote><p> <del>自适应不是指你缩放<strong>页面大小</strong>(ctrl+鼠标滚动条)，是指你浏览器大小变化自适应</del>。</p><p> 一般不加自适应，缩放页面，会发现<code>$(document).width()</code>会根据缩放变大变小，但是<strong>元素宽高不会变</strong>，相应元素就会<strong>感觉</strong>变大变小。加入自适应（<strong>自适应会根据页面大小来改变px，元素宽高会变</strong>），缩放页面，相应元素<strong>感觉</strong>不会改变。</p></blockquote><p> <strong>缩放页面大小有三种情况：</strong></p><pre><code>1. 改变浏览器宽高
2. ctrl+鼠标滚动条，改变页面大小
3. window中显示设置中的缩放与布局
</code></pre><blockquote><p>像素比就是第二种和第三种情况</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">(function (doc, win) &#123;</span><br><span class="line">  const docEl = doc<span class="selector-class">.documentElement</span>;</span><br><span class="line">  // 获取当前显示设备的物理像素分辨率与CSS像素分辨率之比;</span><br><span class="line">  <span class="selector-tag">var</span> dpr = window<span class="selector-class">.devicePixelRatio</span> || <span class="number">1</span>;</span><br><span class="line">  //orientationchange：在用户水平或者垂直翻转设备（即方向发生变化）时触发的事件</span><br><span class="line">  const resizeEvt = &#x27;orientationchange&#x27; in window ? &#x27;orientationchange&#x27; : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line">  const recalc = function () &#123;</span><br><span class="line">    <span class="selector-tag">var</span> clientWidth = docEl<span class="selector-class">.clientWidth</span>;</span><br><span class="line">    if (!clientWidth) return;</span><br><span class="line">    if (clientWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">      docEl<span class="selector-class">.style</span><span class="selector-class">.fontSize</span> = &#x27;<span class="number">100px</span>&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //<span class="selector-tag">html</span>宽度=clientWidth</span><br><span class="line">      //设计图的宽度=<span class="number">750</span>（通过设计图自行配置）</span><br><span class="line">      //在<span class="number">750</span>的设计图下，我们为了便于开发将根元素的字体大小设置成<span class="number">100px</span></span><br><span class="line">      docEl<span class="selector-class">.style</span><span class="selector-class">.fontSize</span> = <span class="number">100</span> * (clientWidth / <span class="number">750</span>) + &#x27;px&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">	// 检测是否支持<span class="number">0.5px</span></span><br><span class="line">  if (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="selector-tag">var</span> fakeBody = document<span class="selector-class">.createElement</span>(&quot;<span class="selector-tag">body</span>&quot;);</span><br><span class="line">    <span class="selector-tag">var</span> testElement = document<span class="selector-class">.createElement</span>(&quot;<span class="selector-tag">div</span>&quot;);</span><br><span class="line">    testElement<span class="selector-class">.style</span><span class="selector-class">.border</span> = &quot;.<span class="number">5px</span> solid transparent&quot;;</span><br><span class="line">    fakeBody<span class="selector-class">.appendChild</span>(testElement);</span><br><span class="line">    docEl<span class="selector-class">.appendChild</span>(fakeBody);</span><br><span class="line">    if (testElement<span class="selector-class">.offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl<span class="selector-class">.classList</span><span class="selector-class">.add</span>(&quot;hairlines&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    docEl<span class="selector-class">.removeChild</span>(fakeBody);</span><br><span class="line">  &#125;</span><br><span class="line">	win<span class="selector-class">.addEventListener</span>(&quot;pageshow&quot;, function(e) &#123;</span><br><span class="line">		if (e<span class="selector-class">.persisted</span>) &#123; // 浏览器后退的时候重新计算</span><br><span class="line">			clearTimeout(tid);</span><br><span class="line">			tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, false)</span><br><span class="line"></span><br><span class="line">  if (!doc<span class="selector-class">.addEventListener</span>) return;</span><br><span class="line">  win<span class="selector-class">.addEventListener</span>(resizeEvt, recalc, false);</span><br><span class="line">  doc<span class="selector-class">.addEventListener</span>(&#x27;DOMContentLoaded&#x27;, recalc, false);//判断DOM是否加载完毕</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure><h4 id="flexible-js"><a href="#flexible-js" class="headerlink" title="flexible.js"></a>flexible.js</h4><p><a target="_blank" rel="noopener" href="https://github.com/amfe/lib-flexible/blob/2.0/index.js">https://github.com/amfe/lib-flexible/blob/2.0/index.js</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是一个立即执行函数，执行时传入的参数是window和document</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">flexible</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回文档的root元素</span></span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement; </span><br><span class="line">  <span class="comment">// 获取设备的dpr，即当前设置下物理像素与虚拟像素的比值</span></span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置默认字体大小，默认的字体大小继承自body</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setBodyFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">      <span class="comment">// 调整body标签的fontSize，fontSize = (12 * dpr) + &#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">document</span>.body.style.fontSize = <span class="number">12</span> * dpr + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set 1rem = viewWidth / 24</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置root元素的fontSize = 其clientWidth / 24 + &#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">24</span>;</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setRemUnit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当页面展示或重新设置大小的时候，触发重新</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, setRemUnit);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测0.5px的支持，支持则root元素的class中有hairlines</span></span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fakeBody = <span class="built_in">document</span>.createElement(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> testElement = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    testElement.style.border = <span class="string">&#x27;.5px solid transparent&#x27;</span>;</span><br><span class="line">    fakeBody.appendChild(testElement);</span><br><span class="line">    docEl.appendChild(fakeBody);</span><br><span class="line">    <span class="keyword">if</span> (testElement.offsetHeight === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl.classList.add(<span class="string">&#x27;hairlines&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><ul><li><p>清除默认样式 Normalize.css</p></li><li><p>浏览器前缀，webpack:autoprefixer</p><table><thead><tr><th>内核</th><th>主要代表的浏览器</th><th>前缀</th></tr></thead><tbody><tr><td>Trident</td><td>IE浏览器</td><td>-ms</td></tr><tr><td>Gecko</td><td>Firefox</td><td>-moz</td></tr><tr><td>Presto</td><td>Opera</td><td>-o</td></tr><tr><td>Webkit</td><td>Chrome和Safari</td><td>-webkit</td></tr></tbody></table></li><li><p>h5中如何处理移动端滑动卡顿的问题</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  // <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">  <span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>遮罩层隐藏之后，底部div无法触发点击事件：给遮罩层pointer-events</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line">阻止用户的点击动作产生任何效果</span><br><span class="line">阻止缺省鼠标指针的显示</span><br><span class="line">阻止CSS里的hover和active状态的变化触发事件</span><br><span class="line">阻止JavaScript点击动作触发的事件</span><br></pre></td></tr></table></figure></li><li><p>移动端开发1px像素线条变粗移动端window对象里有个 <strong>devicePixelRatios</strong> 属性，叫做 <strong>设备像数比</strong> ，也就是设备的物理像素与逻辑像素的比值。 我们以iphone6为例子：它的物理像素是750，逻辑像素是375，所以他的 dpr 为 2，那么在css里写1px映射到物理像素就是2pt了</p><ul><li><p>伪类+transform实现</p></li><li><p>媒体查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.border &#123; border: 1px solid #999 &#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">  .border &#123; border: 0.5px solid #999 &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 3) &#123;</span><br><span class="line">  .border &#123; border: 0.333333px solid #999 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用viewport + js + 使用rem实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><ul><li>name=”viewport” content=”width=device-width: 本页面的 「viewport」 的宽度为设备宽度。</li><li>initial-scale=1.0: 初始缩放值为 1,</li><li>maximum-scale=1.0: 最大的缩放值为 1。</li><li>user-scalable=no: 禁止用户进行页面缩放。</li></ul><p>那么通过设置viewport的initial-scale，就可以轻松实现：</p><ul><li>当dpr = 1 时，initial-scale = 1</li><li>当dpr = 2 时，initial-scale = 0.5</li><li>当dpr = 3 时，initial-scale = 0.33333333333</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      let viewport = document.querySelector(&quot;meta[name=viewport]&quot;);</span><br><span class="line">      //下面是根据设备像素设置viewport</span><br><span class="line">      if (window.devicePixelRatio == 1) &#123;</span><br><span class="line">        viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (window.devicePixelRatio == 2) &#123;</span><br><span class="line">        viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (window.devicePixelRatio == 3) &#123;</span><br><span class="line">        viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      let docEl = document.documentElement;</span><br><span class="line">      let fontsize = 32* (docEl.clientWidth / 750) + &#x27;px&#x27;;</span><br><span class="line">      docEl.style.fontSize = fontsize;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h2><p>Scrollbar滚动条设置，cursor鼠标指针，zoom图像放大倍数</p><h3 id="连写属性"><a href="#连写属性" class="headerlink" title="连写属性"></a>连写属性</h3><ul><li><p>font：font-style font-weight font-size/line-height font-family;</p><p>文本属性连写文字大小和字体为必写项。</p></li><li><p>border：color style(solid实线dotted 点线dashed 虚线) width</p><p>没有顺序要求，线型为必写项。</p></li><li><p>Padding: 20px; 上右下左内边距都是20px</p><p>Padding: 20px 30px; 上下20px 左右30px</p><p>Padding: 20px 30px 40px; 上内边距为20px 左右内边距为30px 下内边距为40</p><p>Padding: 20px 30px 40px 50px; 上20px 右30px 下40px 左 50px</p></li></ul><h3 id="calc属性"><a href="#calc属性" class="headerlink" title="calc属性"></a>calc属性</h3><p>Calc用户动态计算长度值，任何长度值都可以使用calc()函数计算，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p><h2 id="总结与案例"><a href="#总结与案例" class="headerlink" title="总结与案例"></a>总结与案例</h2><h3 id="隐藏和透明度"><a href="#隐藏和透明度" class="headerlink" title="隐藏和透明度"></a>隐藏和透明度</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</span><br><span class="line">visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</span><br><span class="line">overflow:hidden 这个只隐藏元素溢出的部分，但是占据空间且不可交互</span><br><span class="line">opacity:0 本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互</span><br><span class="line">z-index:-9999: 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</span><br><span class="line">transform: scale(0,0) 平面变换，将元素缩放为0，但是依然占据空间，但不可交互</span><br></pre></td></tr></table></figure><p>透明度<br>background-color: rgba(0, 0, 0, 0.3);<br>opacity: 0.3;<br>transparent是颜色的一种，这种颜色叫透明色。</p><p><strong>rgba()和 opacity 的透明效果有什么不同</strong></p><p>rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的</p><p>所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明 效果！）</p><h3 id="设置placeholder样式"><a href="#设置placeholder样式" class="headerlink" title="设置placeholder样式"></a>设置placeholder样式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">placeholder（如果是在手机客户端webview 只使用－webkit内核方式即可。）</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,</span><br><span class="line">textarea::-webkit-input-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>:-moz-placeholder,</span><br><span class="line">textarea:-moz-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>::-moz-placeholder,</span><br><span class="line">textarea::-moz-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>:-ms-input-placeholder,</span><br><span class="line">textarea:-ms-input-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h3><ol><li>@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS，rel连接属性等；</li><li>加载页面时，link引入的CSS被同时加载，@import引入的CSS将在页面加载完毕后加载；</li><li>link标签作为HTML元素，不存在兼容性问题，而@import是CSS2.1才有的语法，故老版本浏览器（IE5之前）不能识别；</li><li>可以通过JS操作DOM，来插入link标签改变样式；由于DOM方法是基于文档的，无法使用@import方式插入样式；</li><li><code>link</code>引入的样式权重大于<code>@import</code>引入的样式。</li></ol><p>建议使用link的方式引入CSS</p><h3 id="display：table和本身的table有什么区别"><a href="#display：table和本身的table有什么区别" class="headerlink" title="display：table和本身的table有什么区别"></a>display：table和本身的table有什么区别</h3><p>Display:table和本身table是相对应的，区别在于，display：table的css声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，使我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。</p><p>之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用table边写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁</p><h3 id="如何实现小于12px的字体效果"><a href="#如何实现小于12px的字体效果" class="headerlink" title="如何实现小于12px的字体效果"></a>如何实现小于12px的字体效果</h3><blockquote><p><code>transform:scale()</code>这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个<code>display:inline-block</code>;</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transform: scale(0.7);</span><br></pre></td></tr></table></figure><h3 id="自定义浏览器滚动条样式"><a href="#自定义浏览器滚动条样式" class="headerlink" title="自定义浏览器滚动条样式"></a>自定义浏览器滚动条样式</h3><p><a target="_blank" rel="noopener" href="https://daotin.netlify.app/sxemmx.html">https://daotin.netlify.app/sxemmx.html</a></p><h3 id="如何设置input输入框的宽度随文字的输入长度而改变？"><a href="#如何设置input输入框的宽度随文字的输入长度而改变？" class="headerlink" title="如何设置input输入框的宽度随文字的输入长度而改变？"></a>如何设置input输入框的宽度随文字的输入长度而改变？</h3><p><a target="_blank" rel="noopener" href="https://daotin.netlify.app/winm4g.html#%E6%96%B9%E6%B3%95">https://daotin.netlify.app/winm4g.html#%E6%96%B9%E6%B3%95</a></p><h3 id="position定位的"><a href="#position定位的" class="headerlink" title="position定位的"></a>position定位的</h3><p>absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出</p><h3 id="盒子中根据内容撑开，但盒子高度比行内元素高度高"><a href="#盒子中根据内容撑开，但盒子高度比行内元素高度高" class="headerlink" title="盒子中根据内容撑开，但盒子高度比行内元素高度高"></a>盒子中根据内容撑开，但盒子高度比行内元素高度高</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;thumb&quot; style=&quot;width: 500px;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;imgs/1.jpg&quot; style=&quot;width: 100%;height: auto&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>原因：基线问题，img是行内块元素，一种类似text的元素，在结束的时候，会在末尾加上一个空白符，在块元素里默认有3px或者4px空白（基线对齐所导致）</p><p><img src="img/css/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%92%91%E5%BC%80.png" alt="行内元素撑开"></p><h1 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><a target="_blank" rel="noopener" href="https://www.imooc.com/article/68238">https://www.imooc.com/article/68238</a></p> <img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg" style="zoom:50%"><p><strong>标准盒子模型</strong></p><p>标准盒模型又称W3C标准盒模型，其中标准盒模型的 width 等于 content 的宽度，标准盒模型的 height 等于 content 的高度。<br><code>标准盒大小计算公式：width(content) + padding + border + margin</code></p><p><strong>怪异盒模型/IE盒子模型</strong></p><p>怪异盒模型又称IE盒子模型，其中怪异盒子模型的 width 等于 content + padding + border 的宽度，怪异盒子模型的 height 等于 content + padding + border 的高度。<br><code>怪异盒大小的计算公式：width(content + padding + border) + margin</code></p><p><strong>box-sizing 常用的属性有哪些？分别有什么作用</strong></p><ul><li><code>box-sizing: content-box;</code> 默认的标准(W3C)盒模型元素效果</li><li><code>box-sizing: border-box;</code> 触发怪异(IE)盒模型元素的效果</li><li><code>box-sizing: inherit;</code> 继承父元素 <code>box-sizing</code> 属性的值</li></ul><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>文本阴影：text-shadow</p><p>color length lenth opacity [ inset(阴影向内) ]</p><p>颜色 水平偏移量 垂直偏移量 模糊度 （缩展量）</p><p>边框阴影 ：border-shadow</p><p>box-shadow：[inset(阴影向内)] 水平偏移量 垂直偏移量 模糊度 （缩展量） 颜色</p><h2 id="边框圆角box-radius"><a href="#边框圆角box-radius" class="headerlink" title="边框圆角box-radius"></a>边框圆角box-radius</h2><p> 四个属性值，分别表示左上角、右上角、右下角、左下角的圆角大小（<strong>顺时针方向</strong>）</p><p> 三个属性值，第一个值表示左上角，第二个值表示右上角和左下角（对角），第三个值表示右下角。</p><p> 两个属性值，第一个值表示左上角和右下角，第二个值表示右上角和左下角</p><p> 斜杠二组值：第一组值表示水平半径，第二组值表示垂直半径，每组值也可以同时设置1到4个值，规则与上面相同。 border-radius:100px/40px;</p><p><strong>outline :</strong> <a href="c_outlinecolor.html"><strong>outline-color</strong></a> ||<a href="c_outlinestyle.html"><strong>outline-style</strong></a> || <a href="c_outlinewidth.html"><strong>outline-width</strong></a></p><p>设置或检索对象外的线条轮廓。outline画在<a href="c_border.html">border</a>外面，并且不一定是矩形</p><h2 id="边框图像"><a href="#边框图像" class="headerlink" title="边框图像"></a>边框图像</h2><p>border-image-source: url(images/border.png);<br>border-image-slice: 27;上、右、下、左侧边缘裁剪27像素，图像被分割为九个区域：四个角、四条边以及一个中间区域。<br>border-image-width: 10px;指定图像边界的宽度：<br>border-image-repeat: round/stretch/repeat;</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>background:color url repeat position attachment</strong></p><p>设置背景颜色会填充content,padding。</p><p>连写的时候没有顺序要求，url为必写项</p><ul><li><p><strong>background-position:left top</strong></p></li><li><p><strong>background-attachment :</strong> <strong>scroll</strong> | <strong>fixed</strong></p><p><strong>scroll :</strong> 　背景图像是随对象内容滚动<br><strong>fixed :</strong> 　背景图像固定</p></li><li><p><strong>background-clip</strong>：padding-box/content-box/border-box; 修改背景颜色区域/规定背景的绘制区域。</p></li><li><p><strong>background-origin:</strong> border-box;修改背景图片所在区域</p></li><li><p>**background-position:**center center;图片水平垂直居中</p></li></ul><p>background-size<br>cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。<br>contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。</p><h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>background-image：linear-gradient();radial-gradient()<br>repeating-linear-gradient repeating-radial-gradient</p><h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><h2 id="css3媒体查询"><a href="#css3媒体查询" class="headerlink" title="css3媒体查询"></a>css3媒体查询</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@media screen and (max-width:600px) &#123;   </span><br><span class="line">body &#123;      background-color: blue;   &#125;&#125;</span><br><span class="line">@media screen and (min-width:900px) &#123;  </span><br><span class="line">body &#123;      background-color: red;   &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a target="_blank" rel="noopener" href="http://www.animate.net.cn/1853.html">http://www.animate.net.cn/1853.html</a></p><h3 id="过渡transition"><a href="#过渡transition" class="headerlink" title="过渡transition"></a>过渡transition</h3><p>第一种叫过渡（transition）动画，就是从初始状态过渡到结束状态这个过程中所产生的动画。所谓的状态就是指大小、位置、颜色、变形（transform）等等这些属性。css过渡只能定义首和尾两个状态，所以是最简单的一种动画。</p><p><strong>参数</strong></p><ul><li>property – 什么属性将用动画表现，例如, opacity。</li><li>duration – 过渡的时间</li><li>transition-delay – 设置过渡延时</li><li>timing-function – 过渡的速度<ul><li>匀速linear 逐渐降速ease 加速ease-in 降速ease-out 先加速后减速ease-in-out</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">transform 和 transition 属性实现简单旋转效果的例子：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;transition: transform 3s ease-in&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">onclick</span>=<span class="string">&quot;this.style.transform=&#x27;rotate(360deg)&#x27;&quot;</span>&gt;</span></span><br><span class="line">点击这个方块，能让它旋转起来。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p>第二种叫做关键帧（keyframes）动画。不同于第一种的过渡动画只能定义首尾两个状态，关键帧动画可以定义多个状态，或者用关键帧来说的话，过渡动画只能定义第一帧和最后一帧这两个关键帧，而关键帧动画则可以定义任意多的关键帧，因而能实现更复杂的动画效果。</p><p>关键帧动画的定义方式也比较特殊，它使用了一个关键字 @keyframes 来定义动画。具体格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称&#123;</span><br><span class="line">   时间点 &#123;元素状态&#125;</span><br><span class="line">   时间点 &#123;元素状态&#125;</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><ul><li>animation-name:动画名称</li><li>animation-duration: 动画完成一个周期所花费的秒，默认为0</li><li>animation-timing-function: 动画的速度，默认ease</li><li>animation-delay：动画延时，默认为0</li><li>animation-iteration-count: 动画播放次数，默认为1，infinite无限次</li><li>animation-direction：动画是否再下一个周期逆向播放</li><li>animation-play-state：动画是否正在运行或暂停，默认是running，paused</li><li>animation-fill-mode：动画时间之外的状态</li></ul><p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5821d8e8b8bb59a5387d17dd3100ad21.png" alt="QQ截图20131102123530"></p><p> 这段代码定义了一个名为demo,且有5个关键帧的动画。0% ，10% 等这些表示的是时间点，是相对于整个动画的持续时间来说的，时间点之后的花括号里则是元素的状态属性集合，描述了这个元素在这个时间点的状态，动画发生时，就是从第一个状态到第二个状态进行过渡，然后从第二个状态到第三个状态进行过渡，直到最后一个状态。一般来说，0%和100%这两个关键帧是必须要定义的。</p><p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/6e21739e7cb9ee141063b0bceb541fa2.png" alt="QQ截图20131102123530"></p><p>注意，为了达到最佳的浏览器兼容效果，在实际书写代码的时候，还必须加上各大浏览器的私有前缀</p><p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5e08c5fe40dbf1178ed6283aba8f5843.png" alt="QQ截图20131102123530"></p><h3 id="转化transform"><a href="#转化transform" class="headerlink" title="转化transform"></a>转化transform</h3><p>CSS**<code>transform</code>**属性允许你旋转，缩放，倾斜或平移给定元素。</p><p>示例：<a target="_blank" rel="noopener" href="https://www.vps5.com/example?pid=2959">https://www.vps5.com/example?pid=2959</a></p><ul><li><p>transform: rotate(360deg);旋转</p></li><li><p>transform: skew(45deg);倾斜</p></li><li><p>transform: scale(1.5);盒子扩大1.5倍</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何实现小于12px的字体效果</span><br><span class="line">transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;</span><br><span class="line"></span><br><span class="line">transform: scale(0.7);</span><br></pre></td></tr></table></figure></li><li><p>transform: translate(400px) 向左移动400px translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%</p></li></ul><h3 id="3D"><a href="#3D" class="headerlink" title="3D"></a><strong>3D</strong></h3><p><strong>3D 转换方法</strong></p><table><thead><tr><th align="left">函数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td><td align="left">定义 3D 转换，使用 16 个值的 4x4 矩阵。</td></tr><tr><td align="left">translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td align="left">定义 3D 转化。</td></tr><tr><td align="left">translateX(<em>x</em>)</td><td align="left">定义 3D 转化，仅使用用于 X 轴的值。</td></tr><tr><td align="left">scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td><td align="left">定义 3D 缩放转换。</td></tr><tr><td align="left">scaleX(<em>x</em>)</td><td align="left">定义 3D 缩放转换，通过给定一个 X 轴的值。</td></tr><tr><td align="left">rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td><td align="left">定义 3D 旋转。</td></tr><tr><td align="left">rotateX(<em>angle</em>)</td><td align="left">定义沿 X 轴的 3D 旋转。</td></tr></tbody></table><p><strong>3D 转换属性</strong></p><ul><li><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_transform.asp">transform</a>：向元素应用 2D 或 3D 转换</p></li><li><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_transform-origin.asp">transform-origin</a>：变形的原点，允许你改变被转换元素的位置。默认情况，变形的原点在元素的中心点，或者是元素X轴和Y轴的50%处。</p><p>示例：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html">https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_transform-style.asp">transform-style</a>：规定<strong>被嵌套元素</strong>如何在 3D 空间中显示。</p><p>设置transform-style的值为flat，则该元素的所有<strong>子元素</strong>都将被平展到该元素的2D平面中呈现</p><p>设置transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中</p><p>示例：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style">https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_perspective.asp">perspective</a>：定义 3D 元素的景深，当为元素定义 perspective 属性时，其<strong>子元素</strong>会获得透视效果，而不是元素本身（透视效果是写在父亲身上，而不是元素本身）。</p><p>用来设置用户和元素3D空间Z平面之间的距离。值越小，用户与3D空间Z平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与3D空间Z平面距离越远，视觉效果就很小。</p><p>示例：<a target="_blank" rel="noopener" href="https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1">https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1</a></p></li><li><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_perspective-origin.asp">perspective-origin</a>：perspective属性的源点角度</p></li><li><p><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/cssref/pr_backface-visibility.asp">backface-visibility</a>：定义元素在不面对屏幕时是否可见。</p></li></ul><h1 id="预编译器"><a href="#预编译器" class="headerlink" title="预编译器"></a>预编译器</h1><h2 id="less、scss-sass区别"><a href="#less、scss-sass区别" class="headerlink" title="less、scss/sass区别"></a>less、scss/sass区别</h2><h3 id="less、scss-sass"><a href="#less、scss-sass" class="headerlink" title="less、scss/sass"></a>less、scss/sass</h3><p>scss/sass是动态样式语言，比css多出很多功能（如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等），更方便阅读和维护。</p><p>less也是动态样式语言，一样也比css多处很多功能（如变量，继承，运算， 函数）， Less 既可以在客户端上运行，也可在服务端运行 ( Node.js)。</p><p>scss和sass的关系<br>Sass是缩排语法，对于习惯css的web开发者来说很不直观，还是有点学习成本，也不能将css代码加入到sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，<strong>只是用{}取代了原来的缩进</strong>，更容易阅读。</p><h3 id="Sass-Scss与Less区别"><a href="#Sass-Scss与Less区别" class="headerlink" title="Sass/Scss与Less区别"></a>Sass/Scss与Less区别</h3><h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p>sass的安装需要Ruby环境，是在服务端处理的，而less是需要引入less.js来处理less代码输出css到浏览器，也可以在开发环节使用less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。在一般前端项目里面使用 yarn add less yarn add less-loader添加到对应的项目里面。</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>1、less、scss的变量符不一样</p><p>less是@、scss是$、css变量是两根连词线（- -）</p><p>2、变量作用域不一样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/** Less-作用域*/</span><br><span class="line">@color: #00c; /* 蓝色 */</span><br><span class="line">#header &#123;</span><br><span class="line">  @color: #c00; /* red */</span><br><span class="line">  border: 1px solid @color; /* 红色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  border: 1px solid @color; /* 蓝色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Less-作用域编译后*/</span><br><span class="line">#header&#123;border:1px solid #cc0000;&#125;</span><br><span class="line">#footer&#123;border:1px solid #0000cc;&#125;</span><br><span class="line"></span><br><span class="line">/**scss-作用域*/</span><br><span class="line">$color: #00c; /* 蓝色 */</span><br><span class="line"></span><br><span class="line">#header &#123;</span><br><span class="line"></span><br><span class="line">  $color: #c00; /* red */</span><br><span class="line">  border: 1px solid $color; /* 红色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  border: 1px solid $color; /* 蓝色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Sass-作用域编译后*/</span><br><span class="line"></span><br><span class="line">#header&#123;border:1px solid #c00&#125;</span><br><span class="line">#footer&#123;border:1px solid #c00&#125;</span><br><span class="line"></span><br><span class="line">/** 我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>less没有输出设置<br>scss提供四种输出选项：nested, compact, compressed 和 expanded。<br>有四种选择，默认为nested</p><p>nested：嵌套缩进的css代码<br>expanded：展开的多行css代码<br>compact：简洁格式的css代码<br>compressed：压缩后的css代码</p><h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>less不支持条件语句<br>scss语句支持if{}else{}、for{}循环语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** if else */</span><br><span class="line">@if lightness($color) &gt; 30% &#123;</span><br><span class="line">	/**	do....*/</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">	/**	do....*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**	循环*/</span><br><span class="line">@for $i from 1 to 10 &#123;</span><br><span class="line">  	.border-#&#123;$i&#125; &#123;</span><br><span class="line">    	border: #&#123;$i&#125;px solid red;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="引入外部css"><a href="#引入外部css" class="headerlink" title="引入外部css"></a>引入外部css</h4><p><code>scss</code>引用的外部文件命名必须以_开头, 如下例所示:其中<code>_test1.scss</code>、<code>_test2.scss</code>、<code>_test3.scss</code>文件分别设置的h1 h2 h3。文件名如果以下划线<code>_</code>开头的话，<code>sass</code>会认为该文件是一个引用文件，不会将其编译为css文件.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 源代码：</span><br><span class="line">@import &quot;_test1.scss&quot;;</span><br><span class="line">@import &quot;_test2.scss&quot;;</span><br><span class="line">@import &quot;_test3.scss&quot;;</span><br><span class="line"></span><br><span class="line">// 编译后：</span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 17px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h2 &#123;</span><br><span class="line">  font-size: 17px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h3 &#123;</span><br><span class="line">  font-size: 17px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>less</code>引用外部文件和<code>css</code>中的<code>@import</code>没什么差异。</p><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>sass/scss或是less，都可以看作为一种基于css之上的高级语言，其目的是使得css开发更灵活和更强大，sass的功能比less强大,基本可以说是一种真正的编程语言了，less则相对清晰明了,易于上手,对编译环境要求比较宽松，在实际开发中更倾向于选择less。但如果认真深入scss之后还是建议切换到scss，因为更加强大，更好用。</p><h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a><strong>scss</strong></h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li><p>数字，1, 2, 13, 10px</p></li><li><p>字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz</p></li><li><p>颜色，blue, #04a3f9, rgba(255,0,0,0.5)</p></li><li><p>布尔型，true, false</p><p>$a: true;$b: false; 只有自身是false和null才会返回false，其他一切都将返回true</p></li><li><p>空值，null</p><p>$value: null; 由于它代表空，所以不能够使用它与任何类型进行算数运算</p></li><li><p>数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif</p></li><li><p>maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)</p></li></ul><h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$blue : #1875e7;　</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">  color : $blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果变量需要镶嵌在字符串之中，就必须需要写在**#{}插值表达式**之中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$side : left;</span><br><span class="line"></span><br><span class="line">.rounded &#123;</span><br><span class="line">  border-#&#123;$side&#125;-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Sass变量的作用域只能在当前层级上有效果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$fontColor: #EEEEEE;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  $myColor: green;   // 只在 body 里头有用，局部作用域</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用!global关键词来设置变量为全局变量。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 此时body和a内自涂颜色都为green。</span><br><span class="line">$fontColor: #EEEEEE;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  $myColor: green !global;</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的全局变量我们一般定义在同一个文件，如：globals.scss，然后我们使用 @include来引入该文件。</p><h3 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a><strong>计算功能</strong></h3><p>SASS允许在代码中使用算式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    margin: (14px/2);</span><br><span class="line">    top: 50px + 100px;</span><br><span class="line">    right: $var * 10%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div h1 &#123;</span><br><span class="line">　　　　color : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　div &#123;</span><br><span class="line">　　　　hi &#123;</span><br><span class="line">　　　　　　color:red;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>属性也可以嵌套，比如border-color属性，可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　p &#123;</span><br><span class="line">　　　　border: &#123;</span><br><span class="line">　　　　　　color: red;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p>在嵌套的代码块内，可以<strong>使用&amp;引用父元素</strong>。比如a:hover伪类，可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　a &#123;</span><br><span class="line">　　　　&amp;:hover &#123; color: #ffb3ff; &#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong></p><p>SASS共有两种注释风格。</p><ul><li>标准的CSS注释 /* comment */ ，会保留到编译后的文件。</li></ul><ul><li>单行注释 // comment，只保留在SASS源文件中，编译后被省略。</li></ul><ul><li><p>在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/*!</span><br><span class="line">　　　　重要注释！</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li></ul><h3 id="条件语句-1"><a href="#条件语句-1" class="headerlink" title="条件语句"></a><strong>条件语句</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@if可以用来判断：</span><br><span class="line">p &#123;</span><br><span class="line">    @if 1 + 1 == 2 &#123; border: 1px solid; &#125;</span><br><span class="line">    @if 5 &lt; 3 &#123; border: 2px dotted; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配套的还有@else命令：</span><br><span class="line">@if lightness($color) &gt; 30% &#123;</span><br><span class="line">    　　　　background-color: #000;</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a><strong>代码的重用</strong></h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h4><p>SASS允许一个选择器，继承另一个选择器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.class1 &#123;</span><br><span class="line">	border: 1px solid #ddd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>class2要继承class1，就要使用@extend命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.class2 &#123;</span><br><span class="line">    @extend .class1;</span><br><span class="line">    font-size:120%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a><strong>Mixin</strong></h4><p>Mixin有点像C语言的宏（macro），是可以重用的代码块。</p><p>使用@mixin命令，定义一个代码块。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用@include命令，调用这个mixin。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">　　@include left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mixin的强大之处，在于可以指定参数和缺省值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin left($value: 10px) &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-right: $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用的时候，根据需要加入参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	@include left(20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="使用-each-循环"><a href="#使用-each-循环" class="headerlink" title="使用@each 循环"></a>使用@each 循环</h4><p>1.循环一个 list: 类名为 icon-10px 、icon-12px、icon-14px 写他们的字体大小写法就可以如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/988e776c0c83446cb62ad369a18fac21~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>2.循环一个 map：类名为 icon-primary、icon-success、icon-secondary 等，但是他们的值又都是变量，写法如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89edd2eb57d94eb485b93c74a711de46~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h4 id="map-get"><a href="#map-get" class="headerlink" title="map-get"></a>map-get</h4><p>map-get(map,key) 函数的作用是根据 key 参数，返回 key 在 map 中对应的 value 值。如果 key 不存在 map 中，将返回 null 值。此函数包括两个参数：</p><p>map：定义好的 map。</p><p>key：需要遍历的 key。</p><p>假设要获取 facebook 键值对应的值 #3b5998，我们就可以使用 map-get() 函数来实现：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c01074ab404f0f81fa65e945d03d70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>使用&amp;嵌套覆盖原有样式</p><p>当一个元素的样式在另一个容器中有其他指定的样式时，可以使用嵌套选择器让他们保持在同一个地方。<code>.no-opacity &amp;</code>相当于<code>.no-opacity .foo</code>。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/105bd1160dbd4a8287154408cd243d41~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><p>map-merge</p><p>合并两个 map 形成一个新的 map 类型，即将 <em>map2</em> 添加到 <em>map1</em>的尾部</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$font-sizes</span>: (<span class="string">&quot;small&quot;</span>: <span class="number">12px</span>, <span class="string">&quot;normal&quot;</span>: <span class="number">18px</span>, <span class="string">&quot;large&quot;</span>: <span class="number">24px</span>)</span><br><span class="line"><span class="variable">$font-sizes2</span>: (<span class="string">&quot;x-large&quot;</span>: <span class="number">30px</span>, <span class="string">&quot;xx-large&quot;</span>: <span class="number">36px</span>)</span><br><span class="line">map-merge(<span class="variable">$font-sizes</span>, <span class="variable">$font-sizes2</span>)</span><br><span class="line">结果: <span class="string">&quot;small&quot;</span>: <span class="number">12px</span>, <span class="string">&quot;normal&quot;</span>: <span class="number">18px</span>, <span class="string">&quot;large&quot;</span>: <span class="number">24px</span>,<span class="string">&quot;x-large&quot;</span>: <span class="number">30px</span>, <span class="string">&quot;xx-large&quot;</span>: <span class="number">36px</span></span><br></pre></td></tr></table></figure><p>@content</p><p><code>@content</code> 用在 <code>mixin</code> 里面的，当定义一个 <code>mixin</code> 后，并且设置了 <code>@content</code>； <code>@include</code> 的时候可以传入相应的内容到 <code>mixin</code> 里面</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7369e9cb63e4343a56474f9a1568ede~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p><h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量的命名规则和规范：由字母、数字、下划线、$符号组成，不能以数字开头</span><br><span class="line">驼峰命名法。首字母小写，后面单词的首字母需要大写</span><br></pre></td></tr></table></figure><h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a><strong>堆栈</strong></h3><p><strong>栈：</strong></p><ul><li>存储基础数据类型</li><li>栈会开辟一个内存</li><li>按值访问</li><li>存储的值大小固定</li><li>由系统自动分配内存空间</li><li>空间小，运行效率高</li><li>先进后出，后进先出</li></ul><p><strong>堆:</strong></p><ul><li>存储引用数据类型</li><li>堆共用同一个内存</li><li>按引用访问</li><li>存储的值大小不定，可动态调整</li><li>主要用来存放对象</li><li>空间大，但是运行效率相对较低</li><li>无序存储，可根据引用直接获取</li></ul><p><strong>区别</strong></p><ul><li>栈由系统自动分配，而堆是人为申请开辟</li><li>栈由系统自动分配，速度较快，而堆一般速度比较慢</li><li>栈是连续的空间，而堆是不连续的空间</li></ul><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a><strong>对象序列化</strong></h3><p>百度：序列化(Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程</p><p>前端：对象序列化是指将对象的状态转换为字符串</p><p><code>var obj = &#123;x:1, y:2&#125;;</code></p><p>当这句代码运行时，对象obj的内容会存储在一块内存中，而obj本身存储的只是这块内存的地址的映射而已。简单的说，对象obj就是我们的程序在电脑通电时在内存中维护的一种东西，如果我们程序停止了或者电脑断电了，对象obj将不复存在。那么如何把对象obj的内容保存在磁盘上呢（也就是说在没电时继续保留着）？这时就需要把对象obj序列化，也就是说把obj的内容转换成一个字符串的形式，然后再保存在磁盘上。另外，我们又怎么通过HTTP协议把对象obj的内容发送到客户端呢？没错，还是需要先把对象obj序列化，然后客户端根据接收到的字符串再反序列化（也就是将字符串还原为对象）解析出相应的对象。这也正是”百度百科—序列化“中描述的两个作用——存储、传输。</p> <img src="https://pic4.zhimg.com/80/v2-9400de90d5635c8fd8252239244e36e3_720w.jpg" alt="img" style="zoom:50%"><p><img src="https://pic3.zhimg.com/80/v2-75ede02a69c207a5dd8a534ef02e132a_720w.jpg" alt="img"></p><p>可以看到，exampleStr和exampleObj2中并没有 y:undefined 的内容。这说明：JSON的语法是JavaScript语法的子集，它并不能表示JavaScript中的所有值，对于JSON语法不支持的属性，序列化后会将其省略。</p><p>其详细规则如下：</p><p>①对于JavaScript中的五种原始类型，JSON语法支持数字、字符串、布尔值、null四种，不支持undefined；</p><p>②NaN、Infinity和-Infinity序列化的结果是null；</p><p>③JSON语法不支持函数；</p><p>④除了RegExp、Error对象，JSON语法支持其他所有对象；</p><p>⑤日期对象序列化的结果是ISO格式的字符串，但JSON.parse()依然保留它们字符串形态，并不会将其还原为日期对象；</p><p>⑥JSON.stringify()只能序列化对象的可枚举的自有属性；</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>局部变量无法共享和长久的保存，而全局变量可能造成变量污染，当我们希望有一种机制既可以长久的保存变量又不会造成全局污染。闭包就是指有权访问另一个函数<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>中的变量的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outterFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = outterFn()</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure><p>需求：实现变量a 自增</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Add()());<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(Add()());<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(Add()());<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure><p>因为没有将闭包函数作为对象引用出去，所以执行之后，会被销毁</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = Add();<span class="comment">//将函数a赋值给全局变量c时，a会执行一次</span></span><br><span class="line"><span class="built_in">console</span>.log(cc());</span><br><span class="line"><span class="built_in">console</span>.log(cc());</span><br><span class="line"><span class="built_in">console</span>.log(cc());</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将函数Add赋值给全局变量c时，Add会执行一次，并返回闭包函数，此时<strong>全局变量c的值为闭包函数的引用</strong>，此时函数Add虽然已执行完，但因为内部包含<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">闭包函数</a>，所以函数 Add 的执行期上下文会继续保留在内存中，不会被JS的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">垃圾回收机制</a>回收</p><h4 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h4><p>闭包的优点</p><ol><li>可以减少全局变量的定义，避免全局变量的污染</li><li>能够读取函数内部的变量</li><li>在内存中维护一个变量，可以用做缓存</li></ol><p>闭包的缺点</p><ul><li><p>造成内存泄露</p><p>闭包会使函数中的变量一直保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。</p><p>解决方法——使用完变量后，手动将它赋值为null；</p></li><li><p>闭包可能在父函数外部，改变父函数内部变量的值。</p></li><li><p>造成性能损失。由于闭包涉及跨作用域的访问，所以会导致性能损失。</p></li></ul><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><h5 id="模拟两人对话"><a href="#模拟两人对话" class="headerlink" title="模拟两人对话"></a>模拟两人对话</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function person(name) &#123;</span><br><span class="line">    function say(content) &#123;</span><br><span class="line">        console.log(name + &#x27;:&#x27; + content)</span><br><span class="line">    &#125;</span><br><span class="line">    return say</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = person(&quot;张三&quot;)//</span><br><span class="line">b = person(&quot;李四&quot;)</span><br><span class="line">a(&quot;在干啥？&quot;)</span><br><span class="line">b(&quot;没干啥。&quot;)</span><br><span class="line">a(&quot;出去玩吗？&quot;)</span><br><span class="line">b(&quot;去哪啊？&quot;)</span><br><span class="line"></span><br><span class="line">张三:在干啥？</span><br><span class="line">李四:没干啥。</span><br><span class="line">张三:出去玩吗？</span><br><span class="line">李四:去哪啊？</span><br></pre></td></tr></table></figure><h5 id="使setTimeout支持传参"><a href="#使setTimeout支持传参" class="headerlink" title="使setTimeout支持传参"></a>使setTimeout支持传参</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function func(param)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        alert(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = func(1);</span><br><span class="line">setTimeout(f1,1000);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="封装私有变量"><a href="#封装私有变量" class="headerlink" title="封装私有变量"></a>封装私有变量</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//用闭包定义能访问私有函数和私有变量的公有函数。</span><br><span class="line">var counter = (function () &#123;</span><br><span class="line">    var privateCounter = 0; //私有变量</span><br><span class="line">    function change(val) &#123;</span><br><span class="line">        privateCounter += val;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        increment: function () &#123;</span><br><span class="line">            change(1);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement: function () &#123;</span><br><span class="line">            change(-1);</span><br><span class="line">        &#125;,</span><br><span class="line">        value: function () &#123;</span><br><span class="line">            return privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(counter.value());//0</span><br><span class="line">counter.increment();</span><br><span class="line">console.log(counter.value());//1</span><br><span class="line">counter.increment();</span><br><span class="line">console.log(counter.value());//2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019250357">https://segmentfault.com/a/1190000019250357</a></p><h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p><strong>（1）对象是单个实物的抽象。</strong></p><p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p><p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p><p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p><p>JavaScript 语言使用构造函数（constructor）作为对象的模板。<strong>所谓”构造函数”，就是专门用来生成实例对象的函数</strong>。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>将一个事物所有的状态（属性），行为（方法）封装成一个对象</p><h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>封装的对象生成不同的单个对象</p><h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><h4 id="简单方式创建"><a href="#简单方式创建" class="headerlink" title="简单方式创建"></a>简单方式创建</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//为对象添加方法，属性</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&quot;TOM&quot;</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;TOM&quot;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式创建对象简单，但也存在一些问题：创建出来的对象无法实现对象的重复利用，并且没有一种固定的约束，操作起来可能会出现这样或者那样意想不到的问题。如下面这种情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">c[a]=a;</span><br><span class="line">c[b]=b;</span><br><span class="line"><span class="built_in">console</span>.log(c[a],a);<span class="comment">//&#123;&#125; &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c[a]===a); <span class="comment">//输出什么 false</span></span><br></pre></td></tr></table></figure><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createPerson = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象就是工厂模式的模子</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 依次添加我们需要的属性与方法</span></span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个实例</span></span><br><span class="line"><span class="keyword">var</span> perTom = createPerson(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> PerJake = createPerson(<span class="string">&#x27;Jake&#x27;</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure><p>缺点：1.无法识别对象类型； 2.每个对象都有自己的 <strong>sayName</strong> 函数，函数不能共享，造成内存浪费</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> per1 = createPerson(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = createPerson(<span class="string">&quot;李四&quot;</span>, <span class="number">40</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per1 <span class="keyword">instanceof</span> createPerson);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(per2 <span class="keyword">instanceof</span> createPerson);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(per1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(per2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>构造函数模式和工厂模式存在一下不同之处</strong>：</p><ul><li>没有显示的创建对象（new Object() 或者 var a = {}）</li><li>直接将属性和方法赋给this对象</li><li>没有return语句</li><li>函数共享</li></ul><h5 id="new-命令的机制"><a href="#new-命令的机制" class="headerlink" title="new 命令的机制"></a><strong>new 命令的机制</strong></h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将构造函数以参数形式传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将实例的原型指向构造函数的原型</span></span><br><span class="line">    res.__proto__ = func.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>,);</span><br><span class="line">  <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向实例对象res</span></span><br><span class="line">  <span class="keyword">const</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象(即在构造函数中明确写了return this;)</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> ret === <span class="string">&quot;function&quot;</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></span><br><span class="line"><span class="keyword">const</span> person1 = New(Person, <span class="string">&#x27;tom&#x27;</span>, <span class="number">20</span>);<span class="comment">//等同于New Person</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());</span><br><span class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给构造函数内部的<code>this</code>关键字。</li><li>开始执行构造函数内部的代码。</li></ol><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%"><blockquote><p>①所有<code>引用类型</code>都有一个<code>__proto__(隐式原型)</code>属性，属性值是一个普通的对象<br>②所有<code>函数</code>都有一个<code>prototype(原型)</code>属性，属性值是一个普通的对象<br>③所有<code>引用类型的__proto__</code>属性<code>指向构造函数的prototype</code></p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Array</span>.prototype;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>所有对象都有自己的原型对象（prototype）。原型对象的所有属性和方法，都能被实例对象共享。当我们访问对象的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p><blockquote><p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>__proto__</code>隐式原型上查找，即它的构造函数的<code>prototype</code>，如果还没有找到就会再在构造函数的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p></blockquote><p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p> <img src="https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%"> <img src="https://img-blog.csdn.net/20180620155400807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:67%"><p><code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure><h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><p>当一个实例对象被创建时，这个构造函数 将会把它的属性prototype赋给实例对象的内部属性__proto__。<strong>proto是指向构造函数原型对象的指针。</strong></p><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>判断是否是数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>判断某个对象是否是某个构造函数的实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> a()</span><br><span class="line"><span class="comment">//判断实例的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> a) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a>继承</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42926373/article/details/83149347">https://blog.csdn.net/qq_42926373/article/details/83149347</a></p><p>首先创建一个构造函数，并为其设置私有属性和公有属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个人类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><p>重点圈起来：将父类实例赋值给子类原型对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br></pre></td></tr></table></figure><h5 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h5><p>重点圈起来：执行父构造，将This指向本身，拉取父私有属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数指向</span></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure><h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>重点圈起来：构造继承与原型继承组合。注意注释区域，切勿在继承时使用此方法重写或添加方法，否则将会修改整个原型，导致崩塌。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="comment">// 构造函数指向</span></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。</p><h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure><p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p><p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 5</span><br><span class="line">    [[writable]]: true</span><br><span class="line">    [[enumerable]]: true</span><br><span class="line">    [[configurable]]: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: function () &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;&#125;;</span><br><span class="line">var obj = &#123; f: f &#125;;</span><br><span class="line"></span><br><span class="line">// 单独执行</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">// obj 环境执行</span><br><span class="line">obj.f()</span><br></pre></td></tr></table></figure><p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p><p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 单独执行</span><br><span class="line">f() // 1</span><br><span class="line"></span><br><span class="line">// obj 环境执行</span><br><span class="line">obj.f() // 2</span><br></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p><h4 id="类型指向"><a href="#类型指向" class="headerlink" title="类型指向"></a>类型指向</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_65450343/article/details/123109326">https://blog.csdn.net/m0_65450343/article/details/123109326</a></p><h5 id="全局作用域中的this"><a href="#全局作用域中的this" class="headerlink" title="全局作用域中的this"></a>全局作用域中的this</h5><p> 在严格模式下，在全局作用域中，this指向window对象</p><h5 id="全局作用域中函数中的this"><a href="#全局作用域中函数中的this" class="headerlink" title="全局作用域中函数中的this"></a>全局作用域中函数中的this</h5><ul><li>在非严格模式下: this的指向依旧是window对象</li><li>在严格模式下:this的指向是undefined</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"> </span><br><span class="line">console.log(&quot;严格模式&quot;);</span><br><span class="line">console.log(&#x27;在全局作用域中函数中的this&#x27;);</span><br><span class="line">function f1()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象方法中的this"><a href="#对象方法中的this" class="headerlink" title="对象方法中的this"></a>对象方法中的this</h5><p>在严格模式下，<strong>对象的函数中的this指向调用函数的对象实例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(&quot;在对象的函数中的this&quot;);</span><br><span class="line">var o = new Object();</span><br><span class="line">o.a = &#x27;o.a&#x27;;</span><br><span class="line">o.f5 = function()&#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o.f5());</span><br></pre></td></tr></table></figure><p><strong>特殊情况</strong></p><ul><li>```js<br>const obj = {<br> name() {<pre><code>console.log(this) //obj
function fn() &#123;
  console.log(this) //window
&#125;
fn()
</code></pre> }<br>}<br>obj.name()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如何让函数fn也能使用当前obj这个对象了</span><br><span class="line"></span><br><span class="line">1. 将this赋值给that</span><br><span class="line"></span><br><span class="line">2. 使用箭头函数</span><br><span class="line"></span><br></pre></td></tr></table></figure> const obj = {<pre><code> name() &#123;
   console.log(this) //obj
   const fn = () =&gt; &#123;
     console.log(this) //window
   &#125;
   fn()
 &#125;
</code></pre> }<br> obj.name()<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 将对象中方法赋值给变量</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  const a = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: &#123;</span><br><span class="line">      a: 12,</span><br><span class="line">      fn: function () &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const j = a.b.fn</span><br><span class="line">  a.b.fn()//12</span><br><span class="line">  j()//window</span><br></pre></td></tr></table></figure></li></ul><h5 id="构造函数的this"><a href="#构造函数的this" class="headerlink" title="构造函数的this"></a><strong>构造函数的this</strong></h5><p>this指向构造函数的实例对象</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function constru() &#123;</span><br><span class="line">  this.a = &#x27;constru.a&#x27;;</span><br><span class="line">  this.b = &#x27;constru.b.old&#x27;;</span><br><span class="line">  this.c = &#x27;constru.c&#x27;;</span><br><span class="line">  this.f2 = function () &#123;</span><br><span class="line">    console.log(this);<span class="comment">//&#123; a: &#x27;constru.a&#x27;, b: &#x27;o2.b&#x27;, c: &#x27;constru.c&#x27;, f2: [λ] &#125;</span></span><br><span class="line">    return this.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const o2 = new constru();</span><br><span class="line">o2.b = &#x27;o2.b&#x27;;</span><br><span class="line">console.log(o2.f2());<span class="comment">//o2.b </span></span><br></pre></td></tr></table></figure><h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h5><p><strong>超时调用（<code>setTimeout</code>回调）的代码都是在全局作用域环境中执行的</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn()</span><br></pre></td></tr></table></figure><p>如果定时器中放<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">箭头函数</a> ，则会将this指向所在的对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//obj</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn()</span><br></pre></td></tr></table></figure><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数体内的<code>this</code>对象，就是定义<strong>该函数时所在的作用域指向的对象</strong>，而不是使用时所在的作用域指向的对象。<strong>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//call绑定并执行了一次</span></span><br><span class="line"><span class="keyword">const</span> f = foo.call(&#123; <span class="attr">id</span>: <span class="number">111</span> &#125;);        <span class="comment">// 设置foo的id为1</span></span><br><span class="line"></span><br><span class="line">f.call(&#123; <span class="attr">id</span>: <span class="number">2</span> &#125;)()();     <span class="comment">// id: 111</span></span><br><span class="line">f().call(&#123; <span class="attr">id</span>: <span class="number">3</span> &#125;)()      <span class="comment">// id: 111</span></span><br><span class="line">f()().call(&#123; <span class="attr">id</span>: <span class="number">4</span> &#125;)      <span class="comment">// id: 111</span></span><br><span class="line"><span class="comment">//上面代码之中，只有一个this，就是函数foo的this。所以t1、t2、t3都输出同样的结果。</span></span><br></pre></td></tr></table></figure><p>因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。所以箭头函数的this指向是创建它所在的对象，不会改变。</p><h5 id="React中this指向"><a href="#React中this指向" class="headerlink" title="React中this指向"></a>React中this指向</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_58207509/article/details/121185142">https://blog.csdn.net/weixin_58207509/article/details/121185142</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">&#x27;8888&#x27;</span>) <span class="comment">// 这里的this是？</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">&#x27;render里的this&#x27;</span>) <span class="comment">// 这里的this是？</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我&lt;/button+&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span>, document.getElementById(&#x27;root&#x27;))</span></span><br></pre></td></tr></table></figure> <img src="https://img-blog.csdnimg.cn/5b50b6fb880042a2beca398c77872cd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5o2n6bKc6Iqx55qE5ZSQ6ICB6bit,size_19,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%"><p>render方法中的this指向当前react组件。</p><p>事件处理程序中的this指向的是undefined</p><p><strong>分析原因</strong></p><ul><li><p>class的内部，开启了局部严格模式use strict，所以this不会指向window而是undefined</p></li><li><p>onClick={this.fn}中，this.fn的调用并不是通过类的实例调用的，所以值是undefined</p></li></ul><ul><li>render函数是被组件实例调用的，因此render函数中的this指向当前组件</li></ul><h4 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>他们的作用都是<strong>改变函数内部的this</strong>。这三个函数都是Function原型中的方法（所有的函数都是Function的</p><p>实例），也就是说<strong>只有函数才可以直接调用这些方法</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDate</span>(<span class="params">month, day</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">year</span>: <span class="number">2022</span> &#125;</span><br><span class="line">getDate.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">8</span>)    <span class="comment">//undefined-3-8</span></span><br><span class="line">getDate.call(obj, <span class="number">3</span>, <span class="number">8</span>)     <span class="comment">//2022-3-8</span></span><br><span class="line">getDate.apply(obj, [<span class="number">6</span>, <span class="number">8</span>])  <span class="comment">//2022-6-8</span></span><br><span class="line">getDate.bind(obj)           <span class="comment">//bind 只是修改this指向，并不会调用</span></span><br><span class="line"><span class="keyword">const</span> getDateNew = getDate.bind(obj)</span><br><span class="line">getDateNew(<span class="number">1</span>, <span class="number">1</span>)					<span class="comment">//2022-1-1</span></span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h5><p>参数：三个函数的第一个参数都是需要绑定的 this。</p><ul><li><p>call： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。</p><p>foo.call(this, arg1,arg2, … ,argn );</p></li><li><p>bind： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。</p><p>foo.bind(this, arg1,arg2, … ,argn)</p></li><li><p>apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。</p><p>foo.apply(this, [ arg1,arg2, … ,argn ] );</p></li></ul><p><strong>call/apply 修改完this指向后，会立即调用原函数，但是 bind 只是修改this指向，并不会调用，调用后返回已经绑定好this的函数。</strong></p><h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h5><ul><li>处理伪数组 (最常用)</li><li>继承</li><li>取数组最大最小值</li><li>合并数组</li></ul><h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在函数原型上增加call1方法</span><br><span class="line">Function.prototype.call1 = function(context, ...rest) &#123;</span><br><span class="line">let newContext = context || window</span><br><span class="line">  newContext.fn = this  // 将调用call函数的对象添加到context的属性中</span><br><span class="line">  </span><br><span class="line">  let result = newContext.fn(...rest)  //  // 执行该属性</span><br><span class="line"></span><br><span class="line">  delete newContext.fn  // 删除该属性</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//在函数原型上增加apply1方法</span><br><span class="line">Function.prototype.apply = function(thisArg, args) &#123;</span><br><span class="line">    if (typeof this !== &#x27;function&#x27;) &#123; </span><br><span class="line">        throw new TypeError(&#x27;Error&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    thisArg = thisArg || window</span><br><span class="line">    thisArg.fn = this</span><br><span class="line">    let result</span><br><span class="line">    if(args) &#123;</span><br><span class="line">        result = thisArg.fn(...args)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = thisArg.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    delete thisArg.fn</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind = function(thisArg) &#123;</span><br><span class="line">    if(typeof this !== &#x27;function&#x27;)&#123;</span><br><span class="line">        throw new TypeError(this + &#x27;must be a function&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 存储函数本身</span><br><span class="line">    const _this  = this;</span><br><span class="line">    // 去除thisArg的其他参数 转成数组</span><br><span class="line">    const args = [...arguments].slice(1)</span><br><span class="line">    // 返回一个函数</span><br><span class="line">    const bound = function() &#123;</span><br><span class="line">        // 可能返回了一个构造函数，我们可以 new F()，所以需要判断</span><br><span class="line">        if (this instanceof bound) &#123;</span><br><span class="line">            return new _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        // apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果</span><br><span class="line">        return _this.apply(thisArg, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">    return bound</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶组件即<code>高阶函数</code>。React遵循函数式开发，而高阶组件这个概念其实是React社区繁衍出来的概念。</p><p>在这里我们要谨记这一句话，<strong>组件 = 函数</strong>。</p><blockquote><p>高阶函数：一个函数，接受一个或多个函数作为参数并返回一个函数 。</p><p>高阶组件：一个函数，接受一个或多个组件作为参数并返回一个组件 。</p></blockquote><h4 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a><strong>实际应用场景</strong></h4><h5 id="vue-防抖按钮"><a href="#vue-防抖按钮" class="headerlink" title="vue:防抖按钮"></a>vue:防抖按钮</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// NewButton.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Button &#125; from &#x27;element-ui&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Button&#x27;,</span><br><span class="line">  components: &#123; &#x27;el-button&#x27;: Button &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      timer: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click() &#123;</span><br><span class="line">      // 实现防抖</span><br><span class="line">      const that = this</span><br><span class="line">      clearTimeout(that.timer)</span><br><span class="line">      that.timer = setTimeout(function() &#123;</span><br><span class="line">        that.$emit(&#x27;click&#x27;)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">      ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render(createElement) &#123;</span><br><span class="line">    return createElement(</span><br><span class="line">      &#x27;el-button&#x27;,</span><br><span class="line">      &#123;</span><br><span class="line">        on: &#123; click: this.click &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x27;按钮&#x27;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用新组件的时候</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">NewButton</span> @<span class="attr">click</span>=<span class="string">&quot;click&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> NewButton <span class="keyword">from</span> <span class="string">&quot;./Button&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123; NewButton &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(<span class="string">&#x27;一秒的防抖效果&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h5 id="react-权限按钮"><a href="#react-权限按钮" class="headerlink" title="react:权限按钮"></a>react:权限按钮</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; useAccess &#125; from &#x27;../../../hooks/useAccess&#x27;;</span><br><span class="line">import &#123; message &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 权限高阶组件，使用示例：</span><br><span class="line"> * </span><br><span class="line"> * import WithAccess from &#x27;@components/WithAccess&#x27;;</span><br><span class="line"> * </span><br><span class="line"> * const WithAccessBtn = WithAccess(你的组件, 可选&#x27;button&#x27; | &#x27;menu&#x27; 默认为button);</span><br><span class="line"> * </span><br><span class="line"> * &lt;WithAccessBtn permission=&#x27;permission&#x27; /&gt;</span><br><span class="line"> * </span><br><span class="line"> * @param Comp 组件</span><br><span class="line"> * @param type 鉴权类型 按钮：button，菜单：menu</span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">const WithAccess = (Comp, type = &#x27;button&#x27;) =&gt; &#123;</span><br><span class="line">  const Access = props =&gt; &#123;</span><br><span class="line">    const &#123; getPermission &#125; = useAccess();</span><br><span class="line">    const &#123; permission, name, icon, onClick &#125; = props;</span><br><span class="line">    //showVisible是否展示, available是否有权限</span><br><span class="line">    const &#123; showVisible, available &#125; = getPermission(permission, type) || &#123;&#125;;</span><br><span class="line">    let initProps = props</span><br><span class="line">    console.log(props);</span><br><span class="line">    const config = () =&gt; &#123;</span><br><span class="line">      if (available === 0) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          onClick: () =&gt; &#123;</span><br><span class="line">            message.info(&#x27;按钮没有权限&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return showVisible ? &lt;Comp &#123;...initProps&#125; &#123;...config()&#125;&gt;&#123;name&#125;&lt;/Comp&gt; : null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Access;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default WithAccess;</span><br></pre></td></tr></table></figure><p>使用高阶组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import usePermissionModel from &quot;../../hox/access&quot;;</span><br><span class="line">import WithAccess from &#x27;./components&#x27;</span><br><span class="line">import &#123; Button, message &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; LaptopOutlined &#125; from &quot;@ant-design/icons&quot;;</span><br><span class="line"></span><br><span class="line">const WithAccessBtnYes = WithAccess(Button)</span><br><span class="line">const WithAccessBtnNo = WithAccess(Button)</span><br><span class="line">export default function AHooks(props) &#123;</span><br><span class="line">  const &#123; menus, set &#125; = usePermissionModel();</span><br><span class="line">  console.log(menus, set)</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;WithAccessBtnYes permission=&#x27;account:authorization:yes&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnYes&gt;</span><br><span class="line">    &lt;WithAccessBtnNo permission=&#x27;account:authorization:no&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnNo&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="位置获取"><a href="#位置获取" class="headerlink" title="位置获取"></a>位置获取</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><img src="https://img-blog.csdnimg.cn/20210203195542730.png" alt="在这里插入图片描述"></p><ul><li>视口/浏览器窗口可视区域：<strong>不包括浏览器的 UI，菜单栏等</strong>——即指你正在浏览的文档的那一部分。视口大小是可变的<code>document.documentElement.clientWidth</code></li></ul><h4 id="获取鼠标当前位置（事件对象）"><a href="#获取鼠标当前位置（事件对象）" class="headerlink" title="获取鼠标当前位置（事件对象）"></a>获取鼠标当前位置（事件对象）</h4><ul><li><p>offsetX、offsetY： 鼠标的当前位置 相对于 目标节点的内填充边顶部、内填充边左部的位置。<strong>内填充边意思是不包含border，但包含padding</strong>，类似于padding-box。</p></li><li><p>clientX、clientY： 鼠标当前位置 相对于 <strong>视口</strong>顶部、浏览器可视区域左部 的位置；</p></li><li><p>pageY、pageX： 鼠标当前位置 相对于 <strong>页面/文档</strong>顶部、<strong>页面/文档</strong>左部的位置；</p></li><li><p>screenY、screenX：鼠标当前位置 相对于 <strong>屏幕</strong>顶部、屏幕左部的位置；</p></li></ul><p><img src="https://yqfile.alicdn.com/img_0dd0fbe280de6112d9c8bb8b0ab8acab.jpeg" alt="img_0dd0fbe280de6112d9c8bb8b0ab8acab.jpe"></p><h4 id="获取元素当前位置"><a href="#获取元素当前位置" class="headerlink" title="获取元素当前位置"></a>获取元素当前位置</h4><ul><li><p>Element.getBoundingClientRect() 获取元素相对于<strong>视口</strong>的位置</p><p>width、height：元素自身的宽高</p><p>top、bottom、left、right：分别是该元素的元素框（盒模型）上下左右位置距视口的距离。</p></li></ul> <img src="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect/element-box-diagram.png" alt="DOMRect object that is the smallest rectangle containing the entire element." style="zoom:33%"><ul><li><p>clientHeight：内容+padding（上下）</p><p>clientWidth：内容+padding（左右）</p></li><li><p>offsetTop：从边框border（不包含）距离父元素的高度距离</p><p>offsetLeft：从边框border（不包含）距离父元素的宽度距离</p><p>offsetHeight：内容+padding+border</p><p>offsetWidth： 内容+padding+border</p></li><li><p>scrolleft/top：读取或设置<strong>元素滚动条</strong>到<strong>元素</strong>左边的距离。</p></li><li><p>scrollWidth/height 总的宽/高（显示+隐藏的）</p></li></ul><h4 id="获取浏览器宽高"><a href="#获取浏览器宽高" class="headerlink" title="获取浏览器宽高"></a>获取浏览器宽高</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.outerWidth/Height获取浏览器显示区域，包括所有界面元素（如工具栏）</span><br><span class="line"><span class="built_in">window</span>.innerWidth/Height获取浏览器显示区域，不包括工具栏等的高度</span><br></pre></td></tr></table></figure><p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1711/window-scroll-1.png" alt="视口宽高、位置与滚动高度"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JQ</span><br><span class="line">获取页面的文档高度(包括滚动出去的宽高)   </span><br><span class="line">$(<span class="built_in">document</span>).height();   </span><br><span class="line">获取页面的文档宽度 ：</span><br><span class="line">$(<span class="built_in">document</span>).width(); </span><br><span class="line">JQ</span><br><span class="line">获取浏览器显示区域（可视区域）的高度 ：   </span><br><span class="line">$(<span class="built_in">window</span>).height()=<span class="built_in">window</span>.innerHeight;   </span><br><span class="line">获取浏览器显示区域（可视区域）的宽度 ：</span><br><span class="line">$(<span class="built_in">window</span>).width()=<span class="built_in">window</span>.innerWidth</span><br><span class="line">获取滚动条到顶部的垂直高度 (即网页被卷上去的高度)  </span><br><span class="line">$(<span class="built_in">document</span>).scrollTop();   </span><br><span class="line">获取滚动条到左边的垂直宽度 ：</span><br><span class="line">$(<span class="built_in">document</span>).scrollLeft(); </span><br></pre></td></tr></table></figure><h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p><code>window.scrollTo(options)</code>方法,<code>options</code>是一个对象，有三个属性：<br><code>top</code>，<code>left</code> ，<code>behavior</code> 类型String,表示滚动行为,支持参数 <code>smooth</code>(平滑滚动),<code>instant</code>(瞬间滚动),默认值auto（等同于<code>instant</code>）</p><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>mouseup事件在释放按下的鼠标键时触发。</p><p>mousedown事件在按下鼠标键时触发。</p><p>mousemove事件当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次代码。</p><p>mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。</p><p>两者的区别是，mouseover事件会冒泡，mouseenter事件不会。子节点的mouseover事件会冒泡到父节点，进而触发父节点的mouseover事件。mouseenter事件就没有这种效果，所以进入子节点时，不会触发父节点的监听</p><p>mouseout事件和mouseleave事件，都是鼠标离开一个节点时触发。</p><p>两者的区别是，mouseout事件会冒泡，mouseleave事件不会。子节点的mouseout事件会冒泡到父节点，进而触发父节点的mouseout事件。mouseleave事件就没有这种效果，所以离开子节点时，不会触发父节点的监听函数。</p><h4 id="拖拉事件"><a href="#拖拉事件" class="headerlink" title="拖拉事件"></a>拖拉事件</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u012060033/article/details/89787009">https://blog.csdn.net/u012060033/article/details/89787009</a></p><p>拖拉指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p><p>拖拉的对象有好几种，包括Element节点、图片、链接、选中的文字等等。在HTML网页中，除了Element节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让Element节点可拖拉，可以将该节点的draggable属性设为true。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div draggable=&quot;true&quot;&gt;</span><br><span class="line">  此区域可拖拉</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>draggable属性可用于任何Element节点，但是图片（img元素）和链接（a元素）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为false，防止拖拉。</p><p>注意，一旦某个Element节点的draggable属性设为true，就无法再用鼠标选中该节点内部的文字或子节点了。</p><p>当Element节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件：</p><ul><li>drag事件：拖拉过程中，在被拖拉的节点上持续触发。</li><li>dragstart事件：拖拉开始时在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li><li>dragend事件：拖拉结束时（释放鼠标键或按下escape键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragStart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。</li><li>dragenter事件：拖拉进入当前节点时，在当前节点上触发，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li><li>dragover事件：拖拉到当前节点上方时，在当前节点上持续触发，该事件的target属性是当前节点。该事件与dragenter事件基本类似，默认会重置当前的拖拉事件的效果（DataTransfer对象的dropEffect属性）为none，即不允许放下被拖拉的节点，所以如果允许在当前节点drop数据，通常会使用preventDefault方法，取消重置拖拉效果为none。</li><li>dragleave事件：拖拉离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。在视觉上显示拖拉离开当前节点，就在这个事件的监听函数中设置。</li><li>drop事件：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下Escape键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li></ul><p>关于拖拉事件，有以下几点注意事项。</p><ul><li><p>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</p></li><li><p>将文件从操作系统拖拉进浏览器，不会触发dragStart和dragend事件。</p></li><li><p>dragenter和dragover事件的监听函数，用来指定可以放下（drop）拖拉的数据。由于网页的大部分区域不适合作为drop的目标节点，所以这两个事件的默认设置为当前节点不允许drop。如果想要在目标节点上drop拖拉的数据，首先必须阻止这两个事件的默认行为，或者取消这两个事件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;div ondragover=&quot;return false&quot;&gt;</span><br><span class="line">&lt;div ondragover=&quot;event.preventDefault()&quot;&gt;</span><br></pre></td></tr></table></figure><p> 上面代码中，如果不取消拖拉事件或者阻止默认行为，就不可能在div节点上drop被拖拉的节点。</p></li></ul><h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><ul><li><p>js获取css属性值</p><ul><li>jquery方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//jquery方法</span><br><span class="line">const jq_width = $(&#x27;.box&#x27;).css(&#x27;width&#x27;);</span><br><span class="line">const jq_lineHeight = $(&#x27;.box&#x27;).css(&#x27;line-height&#x27;);</span><br><span class="line">console.log(jq_width,jq_lineHeight);//200px 150px</span><br></pre></td></tr></table></figure><ul><li>然后我们再用js原生方法去获取</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生style.css方法</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> js_width = box.style.width;</span><br><span class="line"><span class="keyword">const</span> js_lineHeight = box.style.lineHeight;</span><br><span class="line"><span class="built_in">console</span>.log(js_width,js_lineHeight);<span class="comment">//   50px</span></span><br><span class="line"><span class="comment">//在这里我们会发现style.css方法只能获取到写在标签上的属性 style = &quot;line-height:150px&quot; 不能获取写在&lt;style&gt;``&lt;/style&gt;中的css属性</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>window.getComputedStyle</code>这个方法获取所有经过浏览器计算过的样式</li></ul></li><li><p>elementNode.getAttribute(name)：方法通过名称获取属性的值。</p><p>elementNode.setAttribute(name, value)：方法创建或改变某个新属性。</p><p>elementNode.removeAttribute(name)：方法通过名称删除属性的值。</p></li></ul><h3 id="节点元素获取"><a href="#节点元素获取" class="headerlink" title="节点元素获取"></a>节点元素获取</h3><blockquote><p>getElementsBy方法都是伪数组arguments</p></blockquote><blockquote><p>判断当前的子节点是否是元素节点 if (node.nodeType === 1)</p></blockquote><p>parentNode 父元素 childNodes 所有子节点 children 所有的子元素</p><p>lastChild 获取最后一个子节点 lastElementChild 获取最后一个子元素</p><p>nextSibling 下一个兄弟节点 nextElementSibling 下一个兄弟元素</p><p>previousSibling 上一个兄弟节点 previousElementSibling 上一个兄弟元素</p><h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><h3 id="事件流阶段"><a href="#事件流阶段" class="headerlink" title="事件流阶段"></a>事件流阶段</h3><blockquote><p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p></blockquote><ul><li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li><li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li><li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li><li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li><li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li></ul><p>监听事件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.addEventListener(&#x27;click&#x27;, fn, false);//false(默认)是事件冒泡，true是事件捕获</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e.stopPropagation();阻止事件冒泡  e.preventDefault()阻止事件默认行为。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在jQuery中使用return false时，相当于同时使用event.preventDefault和event.stopPropagation，它会阻止冒泡也会阻止默认行为。 但是使用原生js写时，return false只会阻止默认行为。</span><br></pre></td></tr></table></figure><h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p><p>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p><p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。可以大量节省内存占用，减少事件注册</p><h3 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h3><ul><li><code>target</code>是事件触发的真实元素</li><li><code>currentTarget</code>是事件绑定的元素</li><li>事件处理函数中的<code>this</code>指向是中为<code>currentTarget</code>。</li><li><code>currentTarget</code>和<code>target</code>，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）<ul><li>当事件是子元素触发时，<code>currentTarget</code>为绑定事件的元素，<code>target</code>为子元素<ul><li>若绑定父元素，点击子元素冒泡触发事件，e.target指向子元素</li></ul></li><li>当事件是元素自身触发时，<code>currentTarget</code>和<code>target</code>为同一个元素。</li></ul></li></ul><p>e.type点击对象的事件类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;a&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">  &#125;); </span><br></pre></td></tr></table></figure><h3 id="加载事件"><a href="#加载事件" class="headerlink" title="加载事件"></a>加载事件</h3><ul><li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。(譬如如果有async加载的脚本就不一定完成)</li><li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。</li></ul><p>顺序是：<code>DOMContentLoaded -&gt; load</code></p><p>页面加载完成有两种事件:</p><ul><li><p>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</p></li><li><p>onload，指示页面包含图片等文件在内的所有元素都加载完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当页面加载完成执行</span></span><br><span class="line">  <span class="comment">// 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>onunload</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当用户退出页面时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="addEventListener自定义事件"><a href="#addEventListener自定义事件" class="headerlink" title="addEventListener自定义事件"></a>addEventListener自定义事件</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>在js事件中，我们首先想到的是click、dblclick、mouseover、mouseout、mouseenter、mouseleave、mousedown、mouseup、mousemove、wheel、contextmenu（点击鼠标右键时）这些常用的事件，在给第三方提供sdk使用时，这些预定义的事件有时无法满足我们的需求。</p><p>由于第三方sdk运行环境未知，而且可能会导致事件冲突的问题，这时候就需要我们自定义事件避免问题的发生。</p><h4 id="自定义事件构造器"><a href="#自定义事件构造器" class="headerlink" title="自定义事件构造器"></a>自定义事件构造器</h4><ul><li><p>new Event(type[, options]);</p><ul><li><p><strong>type</strong> —— 事件类型，</p><p>自定义事件名称，可以是像这样 <code>&quot;click&quot;</code> 的字符串，或者我们自己的像这样 <code>&quot;my-event&quot;</code> 的参数。</p></li><li><p><strong>options</strong> —— 具有两个可选属性的对象：</p><ul><li><code>bubbles: true/false</code> —— 如果为 <code>true</code>，那么事件会冒泡。</li><li><code>cancelable: true/false</code> —— 如果为 <code>true</code>，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。</li></ul><p>默认情况下，以上两者都为 false：<code>&#123;bubbles: false, cancelable: false&#125;</code>。</p></li></ul></li><li><p>new CustomEvent</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;elem&quot;</span>&gt;Hello <span class="keyword">for</span> John!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">// 事件附带给处理程序的其他详细信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  elem.addEventListener(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    alert(event.detail.name);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  elem.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;hello&quot;</span>, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">detail</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;));</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>从技术上讲，<a target="_blank" rel="noopener" href="https://dom.spec.whatwg.org/#customevent">CustomEvent</a> 和 <code>Event</code> 一样。除了一点不同。</p><p>在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 <code>detail</code>。</p></blockquote><h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h4><p>事件对象被创建后，我们应该使用 elem.dispatchEvent(event) 调用在元素上“运行”它。</p><p>然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。如果事件是用 bubbles 标志创建的，那么它会冒泡。</p><p>在下面这个示例中，click 事件是用 JavaScript 初始化创建的。处理程序工作方式和点击按钮的方式相同：</p><p><button id="elem" onclick='alert("Click!")'>Autoclick</button></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let event = new Event(&quot;click&quot;);</span><br><span class="line">  elem.dispatchEvent(event);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>event.isTrusted</strong></p><p>有一种方法可以区分“真实”用户事件和通过脚本生成的事件。</p><p>对于来自真实用户操作的事件，<code>event.isTrusted</code> 属性为 <code>true</code>，对于脚本生成的事件，<code>event.isTrusted</code> 属性为 <code>false</code></p></blockquote><h4 id="冒泡示例"><a href="#冒泡示例" class="headerlink" title="冒泡示例"></a>冒泡示例</h4><p>我们可以创建一个名为 “hello” 的冒泡事件，并在 document 上捕获它。</p><p>我们需要做的就是将 bubbles 设置为 true：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;elem&quot;</span>&gt;Hello <span class="keyword">from</span> the script!&lt;/h1&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 在 document 上捕获...</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	alert(<span class="string">&quot;Hello from &quot;</span> + event.target.tagName); <span class="comment">// Hello from H1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// ...在 elem 上 dispatch！</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> event = <span class="keyword">new</span> Event(<span class="string">&quot;hello&quot;</span>, &#123;<span class="attr">bubbles</span>: <span class="literal">true</span>&#125;); <span class="comment">// (2)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">elem.dispatchEvent(event);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 在 document 上的处理程序将被激活，并显示消息。</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p>navigator.userAgent用来<strong>区分设备和浏览器</strong></p><p>userAgent 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。</p><ul><li><p>打印</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">document</span>.write(<span class="string">&quot;用户代理: &quot;</span> + navigator.userAgent);&lt;/script&gt;</span><br><span class="line">输出结果:</span><br><span class="line">用户代理: Mozilla/<span class="number">5.0</span> (Linux; Android) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">88.0</span><span class="number">.4324</span><span class="number">.109</span> Safari/<span class="number">537.36</span> CrKey/<span class="number">1.54</span><span class="number">.248666</span></span><br></pre></td></tr></table></figure></li><li><p>属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">navigator.appVersion 浏览器的版本号 </span><br><span class="line"></span><br><span class="line">navigator.appName 浏览器的名称 </span><br><span class="line"></span><br><span class="line">navigator.language 浏览器使用的语言 </span><br><span class="line"></span><br><span class="line">navigator.platform 浏览器使用的平台 </span><br><span class="line"></span><br><span class="line">navigator.userAgent 浏览器的user-agent信息</span><br></pre></td></tr></table></figure></li><li><p>判断终端和环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line"><span class="keyword">let</span> isAndroid = ua.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> isIOS = !!ua.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>)</span><br><span class="line"><span class="comment">//环境</span></span><br><span class="line">ua.match(<span class="regexp">/weibo/i</span>) == <span class="string">&quot;weibo&quot;</span></span><br><span class="line">ua.indexOf(<span class="string">&#x27;qq/&#x27;</span>)!= -<span class="number">1</span></span><br><span class="line">ua.match(<span class="regexp">/MicroMessenger/i</span>)==<span class="string">&quot;micromessenger&quot;</span>   <span class="comment">//微信</span></span><br></pre></td></tr></table></figure></li><li><p>判断pc和手机端</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IsPC = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> userAgentInfo = navigator.userAgent;</span><br><span class="line">  <span class="keyword">var</span> Agents = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>);  </span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; Agents.length; v++) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (userAgentInfo.indexOf(Agents[v]) &gt; <span class="number">0</span>) &#123; flag = <span class="literal">false</span>; <span class="keyword">break</span>; &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>isIPhoneX</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isIPhoneX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line">   <span class="keyword">var</span> isIOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br><span class="line">   <span class="keyword">if</span> (isIOS) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="built_in">window</span>.screen.height == <span class="number">812</span> &amp;&amp; <span class="built_in">window</span>.screen.width == <span class="number">375</span>) || (<span class="built_in">window</span>.screen.width === <span class="number">414</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">896</span>)) &#123;<span class="comment">//有底部小黑条</span></span><br><span class="line">       <span class="comment">//是iphoneX(375*812) iphoneXR(414*896) iphoneXS max(414*896)  iphone11(414*896) iphone pro max(414*896)</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有底部小黑条</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li></ul><p><strong>在web应用程序中使用文件</strong></p><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images">https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images</a></p><p><code>Content-Type:multipart/form-data</code> ： 需要在表单中进行文件上传时，就需要使用该格</p><h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><h3 id="Error对象"><a href="#Error对象" class="headerlink" title="Error对象"></a>Error对象</h3><h4 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h4><h5 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h5><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 变量名错误</span><br><span class="line">var 1a;</span><br><span class="line">// Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line"></span><br><span class="line">// 缺少括号</span><br><span class="line">console.log &#x27;hello&#x27;);</span><br><span class="line">// Uncaught SyntaxError: Unexpected string</span><br></pre></td></tr></table></figure><h5 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h5><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p><h5 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h5><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。</p><h5 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h5><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new 123</span><br><span class="line">// Uncaught TypeError: number is not a func</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></pre></td></tr></table></figure><p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p><h5 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h5><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p><h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;出错了，变量超出有效范围！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;出错了，变量类型无效！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">err1.message <span class="comment">// &quot;出错了！&quot;</span></span><br><span class="line">err2.message <span class="comment">// &quot;出错了，变量超出有效范围！&quot;</span></span><br><span class="line">err3.message <span class="comment">// &quot;出错了，变量类型无效！&quot;</span></span><br></pre></td></tr></table></figure><h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p><p><code>throw</code>也可以抛出自定义错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function UserError(message) &#123;</span><br><span class="line">  this.message = message || &#x27;默认信息&#x27;;</span><br><span class="line">  this.name = &#x27;UserError&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">throw new UserError(&#x27;出错了！&#x27;);</span><br><span class="line">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p><p><code>throw</code><strong>可以抛出任何类型的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 抛出一个字符串</span><br><span class="line">throw &#x27;Error！&#x27;;</span><br><span class="line">// Uncaught Error！</span><br><span class="line"></span><br><span class="line">// 抛出一个数值</span><br><span class="line">throw 42;</span><br><span class="line">// Uncaught 42</span><br><span class="line"></span><br><span class="line">// 抛出一个布尔值</span><br><span class="line">throw true;</span><br><span class="line">// Uncaught true</span><br></pre></td></tr></table></figure><h4 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h4><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">&quot;: &quot;</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。</p><h4 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h4><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><h3 id="FormData表单对象"><a href="#FormData表单对象" class="headerlink" title="FormData表单对象"></a>FormData表单对象</h3><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/form">https://wangdoc.com/javascript/bom/form</a></p><h4 id="表单FormData对象"><a href="#表单FormData对象" class="headerlink" title="表单FormData对象"></a>表单FormData对象</h4><p>每一个控件都会生成一个键值对，所有的键值对都会提交到服务器。提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p><p>点击<code>submit</code>控件，就可以提交表单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>表单里面的<code>&lt;button&gt;</code>元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formElement.submit();</span><br></pre></td></tr></table></figure><p><strong>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程</strong></p><p>FormData 首先是一个构造函数，用来生成实例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var formdata = new FormData(form);</span><br><span class="line"></span><br><span class="line">// 获取某个控件的值</span><br><span class="line">formData.get(&#x27;username&#x27;) // &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 设置某个控件的值</span><br><span class="line">formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line">formData.get(&#x27;username&#x27;) // &quot;张三&quot;</span><br></pre></td></tr></table></figure><h4 id="FormData-实例方法"><a href="#FormData-实例方法" class="headerlink" title="FormData 实例方法"></a>FormData 实例方法</h4><p>创建表单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;advForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>广告名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;advName&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>广告类别：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;advType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>轮播图<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>轮播图底部广告<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>热门回收广告<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>优品精选广告<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过表单元素作为参数，实现对formData的初始化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得表单按钮元素</span></span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line"><span class="comment">//为按钮添加点击事件</span></span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//根据ID获得页面当中的form表单元素</span></span><br><span class="line">    <span class="keyword">var</span> form=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#advForm&quot;</span>);</span><br><span class="line">    <span class="comment">//将获得的表单元素作为参数，对formData进行初始化</span></span><br><span class="line">    <span class="keyword">var</span> formdata=<span class="keyword">new</span> FormData(form);</span><br><span class="line">    <span class="comment">//通过get方法获得name为advName元素的value值</span></span><br><span class="line">    <span class="built_in">console</span>.log(formdata.get(<span class="string">&quot;advName&quot;</span>));<span class="comment">//xixi</span></span><br><span class="line">    <span class="comment">//通过get方法获得name为advType元素的value值</span></span><br><span class="line">    <span class="built_in">console</span>.log(formdata.get(<span class="string">&quot;advType&quot;</span>));<span class="comment">//1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> formdata=<span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">&quot;advForm&quot;</span>));</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;post&quot;</span>,<span class="string">&quot;http://127.0.0.1/adv&quot;</span>);</span><br><span class="line">    xhr.send(formdata);</span><br><span class="line">    xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li><li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li><li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li><li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li><li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li><li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li><li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li><li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li><li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li></ul><h4 id="自动校验"><a href="#自动校验" class="headerlink" title="自动校验"></a>自动校验</h4><p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 必填 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须符合正则表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">pattern</span>=<span class="string">&quot;banana|cherry&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 字符串长度必须为6个字符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">minlength</span>=<span class="string">&quot;6&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数值必须在1到10之间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须填入 Email 地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须填入 URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p><h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/arraybuffer">https://wangdoc.com/javascript/bom/arraybuffer</a></p><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/file">https://wangdoc.com/javascript/bom/file</a></p><h4 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h4><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a></p><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/97768916">https://zhuanlan.zhihu.com/p/97768916</a></p><p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410d77d17b~tplv-t2oaga2asx-watermark.awebp" alt="plain-type-blob"></p><p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），type 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 File 接口基于 Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p><p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410c51dbed~tplv-t2oaga2asx-watermark.awebp" alt="blob-structure"></p><p>Blob 构造函数的语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var aBlob = new Blob(blobParts, options);</span><br></pre></td></tr></table></figure><p>blobParts数组：</p><ul><li><p>arraybuffer</p><p>response 是一个包含二进制数据的 JavaScript ArrayBuffer。</p></li><li><p>ArrayBufferView</p></li><li><p>blob</p><p>response 是一个包含二进制数据的 Blob 对象 。</p></li><li><p>document</p><p>response 是一个 HTML Document 或 XML XMLDocument，这取决于接收到的数据的 MIME 类型。DOMStrings 会被编码为 UTF-8。</p></li></ul><p>options：一个可选的对象，包含以下两个属性：</p><ul><li>type —— 默认值为 <code>&quot;&quot;</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li><li>endings —— 默认值为 <code>&quot;transparent&quot;</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。 它是以下两个值中的一个： <code>&quot;native&quot;</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>&quot;transparent&quot;</code>，代表会保持 blob 中保存的结束符不变。</li></ul><h5 id="file对象"><a href="#file对象" class="headerlink" title="file对象"></a>file对象</h5><p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">https://developer.mozilla.org/zh-CN/docs/Web/API/File</a></p><p>File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象</p><p><strong>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中</strong></p><h4 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h4><ul><li><p>Clipboard.JS：Selection 与 execCommand API</p><p>运行<code>ClipboardJS.isSupported()</code>来检查是否支持<code>clipboard.js</code></p><p>点击按钮两次才执行</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6906635620752293902#heading-0">https://juejin.cn/post/6906635620752293902#heading-0</a></p></li><li><p>图像写入剪切板</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6909237803050074126#heading-0">https://juejin.cn/post/6909237803050074126#heading-0</a></p></li><li><p>base64,file和Blob的转换</p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903862873112583">https://juejin.cn/post/6844903862873112583</a></p></li><li><p>阮一峰：剪贴板操作 Clipboard API 教程</p><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html">http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html</a></p></li></ul><h5 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大家好，我是阿宝哥&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">data-clipboard-action</span>=<span class="string">&quot;copy&quot;</span> <span class="attr">data-clipboard-target</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;success&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了 <code>input</code> 元素之外，复制的目标还可以是 <code>div</code> 或 <code>textarea</code> 元素。在以上示例中，我们复制的目标是通过 <strong><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_data_attributes">data-* 属性</a></strong> 来指定。此外，我们也可以在实例化 clipboard 对象时，设置复制的目标：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-target.html</span></span><br><span class="line"><span class="keyword">let</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>如果需要设置复制的文本，我们也可以在实例化 clipboard 对象时，设置复制的文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-text.html</span></span><br><span class="line"><span class="keyword">let</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;大家好，我是阿宝哥&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="图像-1"><a href="#图像-1" class="headerlink" title="图像"></a>图像</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将base64转换为blob对象</span></span><br><span class="line"><span class="comment">//https://juejin.cn/post/6844903862873112583</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> bstr = atob(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">var</span> n = bstr.length;</span><br><span class="line">  <span class="keyword">var</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转换成file对象</span></span><br><span class="line">  <span class="comment">//return new File([u8arr], filename, &#123; type: mime &#125;);</span></span><br><span class="line">  <span class="comment">//转换成成blob对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123; <span class="attr">type</span>: mime &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imageBlob = dataURLtoFile(src);</span><br><span class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> ClipboardItem(&#123;</span><br><span class="line">    [imageBlob.type]: imageBlob,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//检测浏览器是否支持clipboard-write</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">askWritePermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; state &#125; = <span class="keyword">await</span> navigator.permissions.query(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;clipboard-write&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> state === <span class="string">&quot;granted&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (askWritePermission()) &#123;</span><br><span class="line">    navigator.clipboard.write([item]);</span><br><span class="line">    alert(<span class="string">&quot;成功复制到剪切板&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;不支持复制&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>Chrome 浏览器规定，navigator.clipboard只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</strong></p><h2 id="WEB存储"><a href="#WEB存储" class="headerlink" title="WEB存储"></a>WEB存储</h2><h3 id="cookie对象"><a href="#cookie对象" class="headerlink" title="cookie对象"></a>cookie对象</h3><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg">https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg</a></p><p><a target="_blank" rel="noopener" href="https://wangdoc.com/javascript/bom/cookie">https://wangdoc.com/javascript/bom/cookie</a></p><p>Cookie 是服务器保存在浏览器的一小段文本信息，一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过 4KB。超过限制以后，Cookie 将被忽略，不会被设置。浏览器每次向服务器发出请求，就会自动附上这段信息。</p><p>用户可以设置浏览器不接受Cookie，也可以设置不向服务器发送 Cookie。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.navigator.cookieEnabled // true</span><br></pre></td></tr></table></figure><p><code>document.cookie</code>属性返回当前网页的 Cookie。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie // &quot;id=foo;key=bar&quot;</span><br></pre></td></tr></table></figure><p>Cookie 的目的就是区分用户，以及放置状态信息，它的使用场景主要如下。</p><ul><li>对话（session）管理：保存登录状态、购物车等需要记录的信息。</li><li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li><li>追踪用户：记录和分析用户行为。</li></ul><p>每个 Cookie 都有以下几方面的元数据。</p><ul><li>Cookie 的名字</li><li>Cookie 的值（真正的数据写在这里面）</li><li>到期时间（超过这个时间会失效）</li><li>所属域名（默认为当前域名）</li><li>生效的路径（默认为当前网址）</li></ul><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>用户访问网址<code>www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为<code>www.example.com</code>，生效路径为根路径<code>/</code>。</p><p>如果 Cookie 的生效路径设为<code>/forums</code>，那么这个 Cookie 只有在访问<code>www.example.com/forums</code>及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p><p>Cookie 是按照域名区分的，<code>foo.com</code>只能读取自己放置的 Cookie，无法读取其他网站（比如<code>bar.com</code>）放置的 Cookie。一般情况下，一级域名也不能读取二级域名留下的 Cookie，比如<code>mydomain.com</code>不能读取<code>subdomain.mydomain.com</code>设置的 Cookie。但是有一个例外，设置 Cookie 的时候（不管是一级域名设置的，还是二级域名设置的），明确将<code>domain</code>属性设为一级域名，则这个域名下面的各级域名可以共享这个 Cookie。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name=value; domain=mydomain.com</span><br></pre></td></tr></table></figure><p>上面示例中，设置 Cookie 时，<code>domain</code>属性设为<code>mydomain.com</code>，那么各级的子域名和一级域名都可以读取这个 Cookie。</p><p>注意，区分 Cookie 时不考虑协议和端口。也就是说，<code>http://example.com</code>设置的 Cookie，可以被<code>https://example.com</code>或<code>http://example.com:8080</code>读取。</p><h4 id="cookie读写"><a href="#cookie读写" class="headerlink" title="cookie读写"></a>cookie读写</h4><h5 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h5><ul><li>在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li><li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口</li></ul><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly </span><br></pre></td></tr></table></figure><h5 id="HTTP-头对-cookie-的读写"><a href="#HTTP-头对-cookie-的读写" class="headerlink" title="HTTP 头对 cookie 的读写"></a><strong>HTTP 头对 cookie 的读写</strong></h5><p>HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly </span><br></pre></td></tr></table></figure><p>那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>height=180; domain=me.jimu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>weight=80; domain=me.jimu.com </span><br></pre></td></tr></table></figure><h5 id="前端对-cookie-的读写"><a href="#前端对-cookie-的读写" class="headerlink" title="前端对 cookie 的读写"></a><strong>前端对 cookie 的读写</strong></h5><p>前端可以自己创建 cookie，如果服务端创建的 cookie 没加<code>HttpOnly</code>，那恭喜你也可以修改他给的 cookie。</p><p>调用<code>document.cookie</code>可以创建、修改 cookie，和 HTTP 一样，一次<code>document.cookie</code>能且只能操作一个 cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct</span></span><br></pre></td></tr></table></figure><p>调用<code>document.cookie</code>也可以读到 cookie，也和 HTTP 一样，能读到所有的非<code>HttpOnly</code>cookie。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="comment">// username=jimu; height=180; weight=80 </span></span><br></pre></td></tr></table></figure><h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><ul><li><p>localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 localStorage.sitename = &quot;菜鸟教程&quot;; </span></span><br><span class="line"><span class="comment">// 查找 document.getElementById(&quot;result&quot;).innerHTML =localStorage.sitename;</span></span><br><span class="line"><span class="comment">//移除 localStorage 中的 &quot;sitename&quot; :</span></span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;sitename&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">不管是 <span class="built_in">localStorage</span>，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以<span class="built_in">localStorage</span>为例）：</span><br><span class="line"></span><br><span class="line">- 保存数据：<span class="built_in">localStorage</span>.setItem(key,value);</span><br><span class="line">- 读取数据：<span class="built_in">localStorage</span>.getItem(key);</span><br><span class="line">- 删除单个数据：<span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">- 删除所有数据：<span class="built_in">localStorage</span>.clear();</span><br><span class="line">- 得到某个索引的key：<span class="built_in">localStorage</span>.key(index);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="cookie和storage区别"><a href="#cookie和storage区别" class="headerlink" title="cookie和storage区别"></a>cookie和storage区别</h3><ul><li><p>生命周期：</p><p>Cookie：可设置失效时间，否则默认为关闭浏览器后失效</p><p>Localstorage:除非被手动清除，否则永久保存</p><p>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</p></li><li><p>存放数据：</p><p>Cookie：4k左右</p><p>Localstorage和sessionstorage：可以保存5M的信息</p></li><li><p>http请求：</p><p>cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递</p><p>其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信</p></li><li><p>易用性：</p><p>Cookie：需要程序员自己封装，原生的cookie接口不友好</p><p>其他两个：即可采用原生接口，亦可再次封装</p></li><li><p>应用场景</p><p>每次http请求都会携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用（识别用户登陆来说，cookie还是比storage好用），此外cookie还需要指定作用域，<strong>不可以跨域调用</strong></p><p>Cookie 不是一种理想的客户端存储机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端存储建议使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p></li></ul><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>设置属性（setAttribute）,属性名为’data-‘开头的，可以使用dataset来获取值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAttribute(&#x27;data-age&#x27;, value);      dataset[&#x27;age&#x27;]</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">属性length,返回类的数量</span><br><span class="line">classList.item(index)返回元素中索引值对应的类名。索引值从 <span class="number">0</span> 开始。</span><br><span class="line">classList.remove/add/toggle(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">classList.contains(<span class="string">&#x27;active&#x27;</span>)判断当前ClassList中有没有active</span><br><span class="line">classList.toggle(<span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;&#x27;</span>);toggle函数的第二个参数<span class="literal">true</span>为添加 <span class="literal">false</span>删除</span><br></pre></td></tr></table></figure><h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul><li><p>$([selector,[context]])</p><p>$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个 context 中查找。</p><h5 id="jQuery-代码"><a href="#jQuery-代码" class="headerlink" title="jQuery 代码:"></a>jQuery 代码:</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;input:radio&quot;</span>, <span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。</span></span><br></pre></td></tr></table></figure></li><li><p>```js<br>//DOM文档载入完成后执行的函数<br>$(function(){<br> // 文档就绪<br>});</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ## this</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">当你用的是jquery时，就用$(this)，如果是JS，就用this</span><br><span class="line">jquery对象$(this)[0]等同于JS里的元素this</span><br><span class="line">console.log($(this)[0]==this) //true</span><br><span class="line"></span><br><span class="line">JS里的元素只要包上$()就是jquery对象了，而jquery的对象只要加上[0]或者.get(0)，就是js元素了</span><br><span class="line">$(this).get(0)与$(this)[0]等价。</span><br><span class="line">console.log($(this)[0]==$(this).get(0)) //true</span><br></pre></td></tr></table></figure></li><li><p>each(callback),每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;img&quot;).each(function(i)&#123;</span><br><span class="line">   this.src = &quot;test&quot; + i + &quot;.jpg&quot;;</span><br><span class="line"> &#125;);</span><br><span class="line">//this是js的this</span><br></pre></td></tr></table></figure><ul><li><p>size()/length当前匹配的元素个数</p></li><li><p>get(index)取得其中一个匹配的元素</p><h5 id="HTML-代码"><a href="#HTML-代码" class="headerlink" title="HTML 代码:"></a>HTML 代码:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;test1.jpg&quot;/&gt; &lt;img src=&quot;test2.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure><h5 id="jQuery-代码-1"><a href="#jQuery-代码-1" class="headerlink" title="jQuery 代码:"></a>jQuery 代码:</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;img&quot;).get(0);</span><br></pre></td></tr></table></figure></li><li><p>index(一个DOM选择器/ jQuery 选择器)</p><p>搜索匹配的元素，并返回相应元素的索引值，从0开始计数。</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span>&gt;</span>baz<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">$(&#x27;li&#x27;).index(document.getElementById(&#x27;bar&#x27;)); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置</span><br><span class="line">$(&#x27;#bar&#x27;).index(&#x27;li&#x27;); //1，传递一个选择器，返回#bar在所有li中的索引位置</span><br><span class="line">$(&#x27;#bar&#x27;).index(); //1，不传递参数，返回这个元素在同辈中的索引位置。</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul><li><p>attr(name|key,value)返回或设置被选元素的属性值。removeAttr</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(&#123; <span class="attr">src</span>: <span class="string">&quot;test.jpg&quot;</span>, <span class="attr">alt</span>: <span class="string">&quot;Test Image&quot;</span> &#125;);<span class="comment">//为所有图像设置src和alt属性。</span></span><br><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;test.jpg&quot;</span>);<span class="comment">//为所有图像设置src属性。</span></span><br></pre></td></tr></table></figure></li><li><p>removeAttr(name)从每一个匹配的元素中删除一个属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;img&quot;</span>).removeAttr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line"><span class="comment">//将文档中图像的src属性删除</span></span><br></pre></td></tr></table></figure></li><li><p>addClass(class|fn)为每个匹配的元素添加指定的类名。removeClass</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul li:last&#x27;</span>).addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index,<span class="keyword">class</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;item-&#x27;</span> + $(<span class="built_in">this</span>).index();</span><br><span class="line">&#125;);<span class="comment">//给li加上不同的class</span></span><br></pre></td></tr></table></figure></li><li><p>toggleClass(class|fn)如果存在（不存在）就删除（添加）一个类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="built_in">this</span>).toggleClass(<span class="string">&quot;highlight&quot;</span>, count++ % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">&#125;);<span class="comment">//每点击三下加上一次 &#x27;highlight&#x27; 类</span></span><br></pre></td></tr></table></figure></li><li><p>html()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回p元素的内容。取得第一个匹配元素的html内容。</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).html();</span><br><span class="line"><span class="comment">//设置所有 p 元素的内容</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).html(<span class="string">&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>text()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回p元素的文本内容。</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).text();</span><br><span class="line"><span class="comment">//设置所有 p 元素的文本内容</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).text(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>val()</p></li></ul><h2 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h2><ul><li><p>css</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得第一个段落的color样式属性的值。</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;color&quot;</span>);</span><br><span class="line"><span class="comment">//将所有段落的字体颜色设为红色并且背景为蓝色。</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(&#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#ff0011&quot;</span>, <span class="string">&quot;background&quot;</span>: <span class="string">&quot;blue&quot;</span> &#125;);</span><br><span class="line"><span class="comment">//将所有段落字体设为红色</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>height()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取第一段的高</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).height();</span><br><span class="line"><span class="comment">//把所有段落的高设为 20:</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).height(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//以 10 像素的幅度增加 p 元素的高度</span></span><br><span class="line"> $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;p&quot;</span>).height(<span class="function"><span class="keyword">function</span>(<span class="params">n,c</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//n,c索引位置和元素旧的高度值</span></span><br><span class="line">    <span class="keyword">return</span> c+<span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li></ul><h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><ul><li><p>prev + next匹配所有紧接在 prev 元素后的 next 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匹配所有跟在 label 后面的 input 元素</span></span><br><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Newsletter:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span></span><br><span class="line">    </span><br><span class="line">$(<span class="string">&quot;label + input&quot;</span>)</span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span>, <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span> ]</span><br></pre></td></tr></table></figure></li><li><p>prev ~ siblings匹配 prev 元素之后的所有 siblings 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Newsletter:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;form ~ input&quot;</span>)</span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span> ]</span><br></pre></td></tr></table></figure></li></ul><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul><li><p>:first获取第一个元素–&gt;last</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&#x27;li:first&#x27;</span>);</span><br></pre></td></tr></table></figure></li><li><p>:not去除所有与给定选择器匹配的元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找所有未选中的 input 元素</span></span><br><span class="line">&lt;input name=<span class="string">&quot;apple&quot;</span> /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;flower&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span></span><br><span class="line">$(<span class="string">&quot;input:not(:checked)&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>:even()匹配所有索引值为偶数的元素，从 0 开始计数–&gt;:odd()</p></li><li><p>:eq()匹配一个给定索引值的元素,从 0 开始计数</p></li><li><p>:gt()匹配所有大于给定索引值的元素,从 0 开始计数–&gt;:It()</p></li></ul><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><h3 id="表单-1"><a href="#表单-1" class="headerlink" title="表单"></a>表单</h3><h2 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h2><h3 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a>内部插入</h3><ul><li><p>append()向每个匹配的元素内部追加内容。</p></li><li><p>appendTo()把所有匹配的元素追加到另一个指定的元素元素集合中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;I would like to say: &lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).appendTo(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I would like to say: <span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I would like to say: <span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p>prepend()向每个匹配的元素内部前置内容。–&gt;prependTo()</p></li></ul><h3 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a>外部插入</h3><ul><li>after()在每个匹配的元素之后插入内容。–&gt;before</li><li>insertAfter–&gt;insertBefore</li></ul><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素。</li></ul><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li>empty()删除匹配的元素集合中所有的子节点。</li><li>remove()从DOM中删除所有匹配的元素。</li></ul><h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><p>is(expr|obj|ele|fn)根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</p><p>map(fn)将一组元素转换成其他数组（不论是否是元素数组）用这个函数来建立一个列表，不论是值、属性还是CSS样式，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).append( $(&quot;input&quot;).map(function()&#123;</span><br><span class="line">  return $(this).val();</span><br><span class="line">&#125;).get().join(&quot;, &quot;) );get()jQuery转DOM对象</span><br><span class="line"></span><br><span class="line">$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array:待转换数组。将原数组中每个元素加 4 转换为一个新数组。</span><br><span class="line">$.map( [0,1,2], function(n)&#123;</span><br><span class="line">  return n + 4;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>children(expr),取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。expr用以过滤子元素的表达式</p><p>find(expr|obj|ele),搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。与$(“p span”)相同。</p><p>next(expr),取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。</p><p>nextAll(expr),查找当前元素之后所有的同辈元素。</p><p>prev(expr)取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。</p><p>siblings(expr)取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。</p><h2 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.one(type,[data],fn)  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。在每个对象上，这个事件处理函数只会被执行一次。 其他规则与bind()函数相同(bind()的事件函数只能针对已经存在的元素进行事件的设置)。</span><br><span class="line"></span><br><span class="line">**type:**添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。</span><br><span class="line">**data:**作为event.data属性值传递给事件对象的额外数据对象</span><br><span class="line">**fn:**每当事件触发时执行的函数。</span><br><span class="line"></span><br><span class="line">2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 </span><br><span class="line">3.on(events,[selector],[data],fn)  在选择元素上绑定一个或多个事件的事件处理函数。</span><br><span class="line">事件委托即事件冒泡</span><br><span class="line">// 在body元素上绑定click事件处理函数handler，如果这个click事件是由其后代的P元素触发的，就执行handlerp</span><br><span class="line">$(document.body).on(&quot;click&quot;, &quot;p&quot;, handler);</span><br><span class="line">e.stopPaptration();//为了不让点击p 使得他们的父级的事件也触发了，就阻止冒泡</span><br></pre></td></tr></table></figure><p>trigger(type,[data])在每一个匹配的元素上触发某类事件。</p><p>hover([over,]out)</p><p>over:鼠标移到元素上要触发的函数</p><p>out:鼠标移出元素要触发的函数</p><p>toggle([speed],[easing],[fn])用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;td&quot;).toggle(</span><br><span class="line">  function () &#123;</span><br><span class="line">    $(this).addClass(&quot;selected&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    $(this).removeClass(&quot;selected&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">);//对表格的切换一个类</span><br><span class="line">$(&#x27;td).toggle();//对表格切换显示/隐藏</span><br></pre></td></tr></table></figure><p>change([data],fn)当元素的值发生改变时，会发生 change 事件。</p><p>unload([[data],fn])在当用户离开页面时，会发生 unload 事件。</p><p>会发出 unload 事件：</p><ul><li>点击某个离开页面的链接</li><li>在地址栏中键入了新的 URL</li><li>使用前进或后退按钮</li><li>关闭浏览器</li><li>重新加载页面</li></ul><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h2><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><table><thead><tr><th>^</th><th>表示匹配行首的文本(以谁开始)</th></tr></thead><tbody><tr><td>$</td><td>表示匹配行尾的文本(以谁结束)</td></tr><tr><td><strong>\b</strong></td><td>当前位置的左右两侧，只能有一侧是字母数字或下划线</td></tr></tbody></table><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h4><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\D</td><td>匹配任意非数字的字符</td></tr><tr><td>\w</td><td>匹配字母或数字或下划线</td></tr><tr><td>\W</td><td>匹配任意不是字母，数字，下划线</td></tr><tr><td>\s</td><td>匹配任意的空白符（包括空格、制表符、换页符）</td></tr><tr><td>\S</td><td>匹配任意不是空白符的字符</td></tr><tr><td>.</td><td>匹配除换行符以外的任意单个字符</td></tr></tbody></table><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table><thead><tr><th>限定符</th><th>说明</th><th></th></tr></thead><tbody><tr><td>*</td><td>表达式尽可能的多匹配，最少可以不匹配，相当于 <strong>{0, }</strong></td><td></td></tr><tr><td>+</td><td>表达式尽可能的多匹配，至少匹配1次，相当于 <strong>{1, }</strong></td><td>“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}</td></tr><tr><td>?</td><td>表达式尽可能匹配1次，也可以不匹配，相当于 <strong>{0, 1}</strong></td><td>“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。</td></tr><tr><td>{n}</td><td>表达式固定重复n次</td><td>“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</td></tr><tr><td>{n,}</td><td>表达式尽可能的多匹配，至少重复n次</td><td>“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”</td></tr><tr><td>{n,m}</td><td>表达式尽可能重复m次，至少重复n次</td><td>“o{1,3}”匹配“fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td></tr><tr><td><strong>{n, m}?</strong></td><td>表达式尽量只匹配n次，最多重复m次。</td><td></td></tr><tr><td><strong>{m, n}+</strong></td><td>表达式尽可能重复n次，至少重复m次。</td><td></td></tr></tbody></table><ul><li><p>贪婪模式:在限定符之后的表达式能够匹配成功的情况下，不定次数的限定符总是<strong>尽可能的多匹配</strong>。如果之后的表达式匹配失败，限定符可适当“让出”能够匹配的字符，以使整个表达式匹配成功。这种模式就叫“贪婪模式”。</p><ul><li>限定符之后添加加号(+),总是尽可能多的匹配</li></ul></li><li><p>非贪婪匹配模式:正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有<code>g</code>，开启下一组匹配)</p><ul><li>限定符之后添加问号(?),总是尽可能少的匹配</li></ul></li><li><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 前瞻/先行断言：</span><br><span class="line">exp1(?=exp2) 查找exp2前面的exp1</span><br><span class="line">// 后顾：</span><br><span class="line">(?&lt;=exp2)exp1 查找exp2后面的exp1</span><br><span class="line">// 负前瞻：</span><br><span class="line">exp1(?!exp2) 查找后面不是exp2的exp1</span><br><span class="line">// 负后顾：</span><br><span class="line">(?&lt;!exp2)exp1 查找前面不是exp2的exp1</span><br></pre></td></tr></table></figure></li></ul><h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul><li><p>转义符</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td>\r, \n</td><td>代表回车和换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>代表 “&quot; 本身</td></tr></tbody></table></li><li><p><strong>有特殊用处的标点符号，在前面加 “\” 后，就代表该符号本身</strong></p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td>^</td><td>匹配 ^ 符号本身</td></tr><tr><td>\ $</td><td>匹配 $ 符号本身</td></tr><tr><td>\ .</td><td>匹配小数点（.）本身</td></tr></tbody></table></li><li><p>方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。**[^] 匹配除中括号以内的内容**</p><table><thead><tr><th>表达式</th><th>可匹配</th></tr></thead><tbody><tr><td><strong>[ab5@]</strong></td><td>匹配 “a” 或 “b” 或 “5” 或 “@”</td></tr><tr><td><strong>[^abc]</strong></td><td>匹配 “a”,”b”,”c” 之外的任意一个字符</td></tr><tr><td><strong>[f-k]</strong></td><td>匹配 “f”~”k” 之间的任意一个字母</td></tr><tr><td><strong>[^A-F0-3]</strong></td><td>匹配 “A”<del>“F”,”0”</del>“3” 之外的任意一个字符</td></tr></tbody></table></li><li><p>| 选择左右两边的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱。</p><p>eg：gr(a|e)y匹配gray和grey</p></li><li><p>() 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</p></li></ul><h2 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h2><h3 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h3><p>方式1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;gi&#x27;</span>);</span><br></pre></td></tr></table></figure><p>方式2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/i</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/gi</span>;</span><br></pre></td></tr></table></figure><p><strong>参数</strong></p><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写</td></tr><tr><td>g</td><td>全局匹配</td></tr><tr><td>gi</td><td>全局匹配+忽略大小写</td></tr></tbody></table><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2015-10-10&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(dateStr));</span><br></pre></td></tr></table></figure><h3 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 提取工资</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;张三：1000，李四：5000，王五：8000。&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取email地址</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分组提取  </span></span><br><span class="line"><span class="comment">// 3. 提取日期中的年部分  2015-5-10</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2016-1-5&#x27;</span>;</span><br><span class="line"><span class="comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(dateStr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提取邮件中的每一部分</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 替换所有空白</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;   123AD  asadf   asadfasf  adf &quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换所有,|，</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc,efg,123，abc,123，a&quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/,|，/g</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[正则表达式]文本框输入内容控制</span><br><span class="line"> 整数或者小数：^[0-9]+.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line"> 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line"> 只能输入n位的数字：&quot;^d&#123;n&#125;$&quot;。</span><br><span class="line"> 只能输入至少n位的数字：&quot;^d&#123;n,&#125;$&quot;。</span><br><span class="line"> 只能输入m~n位的数字：。&quot;^d&#123;m,n&#125;$&quot;</span><br><span class="line"> 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line"> 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line"> 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 只能输入非零的正整数：&quot;^+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 只能输入非零的负整数：&quot;^-[1-9][]0-9&quot;*$。</span><br><span class="line"> 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^w+$&quot;。</span><br><span class="line"> 验证是否含有^%&amp;&#x27;,;=?$&quot;等字符：&quot;[^%&amp;&#x27;,;=?$x22]+&quot;。</span><br><span class="line"> 只能输入汉字：&quot;^[u4e00-u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 验证Email地址：&quot;^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$&quot;。</span><br><span class="line"> 验证InternetURL：&quot;^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 验证电话号码：&quot;^((d&#123;3,4&#125;-)|d&#123;3.4&#125;-)?d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 验证身份证号（15位或18位数字）：&quot;^d&#123;15&#125;|d&#123;18&#125;$&quot;。</span><br><span class="line"> 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 匹配中文字符的正则表达式： [u4e00-u9fa5]</span><br><span class="line"> 匹配双字节字符(包括汉字在内)：[^x00-xff]</span><br><span class="line"> 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> String.prototype.len=function()&#123;return this.replace(/[^x00-xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 匹配空行的正则表达式：n[s| ]*r</span><br><span class="line"> 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;/(.*)&gt;|&lt;(.*)/&gt;</span><br><span class="line"> 匹配首尾空格的正则表达式：(^s*)|(s*$)</span><br><span class="line"> 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*</span><br><span class="line"> 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="限制el-input只能输入两位小数"><a href="#限制el-input只能输入两位小数" class="headerlink" title="限制el-input只能输入两位小数"></a>限制el-input只能输入两位小数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this.ruleForm[name] = (&#x27;&#x27; + value) // 第一步：转成字符串</span><br><span class="line"></span><br><span class="line">    .replace(/[^\d^\.]+/g, &#x27;&#x27;) // 第二步：把不是数字，不是小数点的过滤掉</span><br><span class="line"></span><br><span class="line">    .replace(/^0+(\d)/, &#x27;$1&#x27;) // 第三步：第一位0开头，0后面为数字，则过滤掉，取后面的数字.$1是与正则表达式中的第 1 个子表达式相匹配的文本</span><br><span class="line"></span><br><span class="line">   .replace(/^\./, &#x27;0.&#x27;) // 第四步：如果输入的第一位为小数点，则替换成 0. 实现自动补全</span><br><span class="line"></span><br><span class="line">   .match(/^\d*(\.?\d&#123;0,2&#125;)/g)[0] || &#x27;&#x27; // 第五步：最终匹配得到结果 以数字开头，只有一个小数点，	而且小数点后面只能有0到2位小数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>利用正则表达式获取括号里面的内容 或者 包括括号与内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//1.获取括号的内容，包换括号</span><br><span class="line">var str=&quot;123&#123;456&#125;hhh[789]zzz[yyy]bbb(90ba)kkk&quot;;</span><br><span class="line">var regex1 = /\((.+?)\)/g;   // () 小括号</span><br><span class="line">var regex2 = /\[(.+?)\]/g;   // [] 中括号</span><br><span class="line">var regex3 = /\&#123;(.+?)\&#125;/g;  // &#123;&#125; 花括号，大括号</span><br><span class="line"> </span><br><span class="line">// 输出是一个数组</span><br><span class="line">console.log(str.match(regex1)); //[&#x27;(90ba)&#x27;]</span><br><span class="line">console.log(str.match(regex2));//[&#x27;[789]&#x27;, &#x27;[yyy]&#x27;]</span><br><span class="line">console.log(str.match(regex3));//[&#x27;&#123;456&#125;&#x27;]</span><br><span class="line"></span><br><span class="line">2.获取括号的内容，不包含括号 </span><br><span class="line">var str2=&quot;123&#123;456&#125;hhh[789]zzz[yyy]bbb(90ba)kkk&quot;;</span><br><span class="line">var regex11 = /(?&lt;=\()(.+?)(?=\))/g;   // () 小括号</span><br><span class="line">var regex22 = /(?&lt;=\[)(.+?)(?=\])/g;   // [] 中括号</span><br><span class="line">var regex33 = /(?&lt;=\&#123;)(.+?)(?=\&#125;)/g;  // &#123;&#125; 花括号，大括号</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 输出是一个数组</span><br><span class="line">console.log(str2.match(regex11)); //[&#x27;90ba&#x27;]</span><br><span class="line">console.log(str2.match(regex22));//[&#x27;789&#x27;, &#x27;yyy&#x27;]</span><br><span class="line">console.log(str2.match(regex33));//[&#x27;456&#x27;]</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://tomorrowlm.github.io">LMTomorrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://tomorrowlm.github.io/2020/09/25/02-%E6%80%BB%E7%BB%93/">https://tomorrowlm.github.io/2020/09/25/02-%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tomorrowlm.github.io" target="_blank">TomorrowLM-Web</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/">浏览器</a><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a><a class="post-meta__tags" href="/tags/html/">html</a><a class="post-meta__tags" href="/tags/css/">css</a><a class="post-meta__tags" href="/tags/scss/">scss</a><a class="post-meta__tags" href="/tags/es5/">es5</a><a class="post-meta__tags" href="/tags/jq/">jq</a><a class="post-meta__tags" href="/tags/%E6%AD%A3%E5%88%99/">正则</a></div><div class="post_share"><div class="social-share" data-image="/img/cover_1.gif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/25/04-ES6%E5%92%8CTS/" title="ES6，TS和设计模式"><img class="cover" src="/img/cover_1.gif" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ES6，TS和设计模式</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/25/09-%E5%9B%BE%E5%BD%A2%E6%9E%84%E5%BB%BA/" title="图形构建"><img class="cover" src="/img/cover_1.gif" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">图形构建</div></div></a></div></nav><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">LMTomorrow</div><div class="author-info__description">热爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">44</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TomorrowLM"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E7%AB%AF"><span class="toc-number">1.</span> <span class="toc-text">后端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF"><span class="toc-number">2.</span> <span class="toc-text">前端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86"><span class="toc-number">2.1.</span> <span class="toc-text">常识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%94%AF"><span class="toc-number">2.2.</span> <span class="toc-text">分支</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%8F%91"><span class="toc-number">2.3.</span> <span class="toc-text">开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tip"><span class="toc-number">2.4.</span> <span class="toc-text">tip</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95"><span class="toc-number"></span> <span class="toc-text">面试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E5%9C%A8%E5%85%AC%E5%8F%B8%E5%81%9A%E5%95%A5"><span class="toc-number">1.</span> <span class="toc-text">你在公司做啥</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#data"><span class="toc-number">1.1.</span> <span class="toc-text">data</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cisdi"><span class="toc-number">1.2.</span> <span class="toc-text">cisdi</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF"><span class="toc-number">2.</span> <span class="toc-text">技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%88%9D%E4%B8%AD%E9%AB%98%E8%AF%84%E7%BA%A7"><span class="toc-number">3.</span> <span class="toc-text">前端初中高评级</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript"><span class="toc-number">3.1.</span> <span class="toc-text">javascript</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">3.2.</span> <span class="toc-text">工程化工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React%EF%BC%88ng-vue%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">React（ng&#x2F;vue）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#react%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7%EF%BC%88ng-vue%E5%90%8C%E7%90%86%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">react生态工具（ng&#x2F;vue同理）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8DWeb%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF"><span class="toc-number">3.5.</span> <span class="toc-text">各种Web前端技术</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-number">1.</span> <span class="toc-text">浏览器渲染机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">浏览器是多进程的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8C%85%E5%90%AB%E7%9A%84%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">浏览器包含的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">1.1.3.</span> <span class="toc-text">浏览器多进程的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85%E6%A0%B8-%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">浏览器内核(渲染进程)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GUI%E6%B8%B2%E6%9F%93%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">GUI渲染线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JS%E5%BC%95%E6%93%8E%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">JS引擎线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%A7%A6%E5%8F%91%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">事件触发线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E8%A7%A6%E5%8F%91%E5%99%A8%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">定时触发器线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5http%E8%AF%B7%E6%B1%82%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">异步http请求线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">渲染流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%BB%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">浏览器主进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">浏览器渲染进程</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88%E6%9C%AC"><span class="toc-number">1.3.2.0.1.</span> <span class="toc-text">基础版本</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%89%88"><span class="toc-number">1.3.2.0.2.</span> <span class="toc-text">详细版</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">1.3.3.</span> <span class="toc-text">名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%9B%BE%E5%B1%82%E5%92%8C%E5%A4%8D%E5%90%88%E5%9B%BE%E5%B1%82"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">普通图层和复合图层</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%8F%96%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.4.</span> <span class="toc-text">预取资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%84%E5%8A%A0%E8%BD%BD%E8%B5%84%E6%BA%90"><span class="toc-number">1.3.5.</span> <span class="toc-text">预加载资源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8"><span class="toc-number"></span> <span class="toc-text">网络与安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#URI%E5%92%8CURL"><span class="toc-number">1.</span> <span class="toc-text">URI和URL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#URL"><span class="toc-number">1.0.1.</span> <span class="toc-text">URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URI"><span class="toc-number">1.0.2.</span> <span class="toc-text">URI</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">2.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E8%AF%B7%E6%B1%82%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">2.1.</span> <span class="toc-text">HTTP请求响应报文</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87"><span class="toc-number">2.1.1.</span> <span class="toc-text">请求报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87"><span class="toc-number">2.1.2.</span> <span class="toc-text">响应报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E5%92%8C%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">2.2.</span> <span class="toc-text">请求头和响应头</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%A4%B4"><span class="toc-number">2.2.1.</span> <span class="toc-text">请求头</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#keep-alive"><span class="toc-number">2.2.2.</span> <span class="toc-text">keep-alive</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">2.2.3.</span> <span class="toc-text">响应头</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">状态码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP2"><span class="toc-number">2.4.</span> <span class="toc-text">HTTP2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">多路复用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9"><span class="toc-number">2.4.2.</span> <span class="toc-text">首部压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.4.3.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">2.4.4.</span> <span class="toc-text">流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8%E9%80%81"><span class="toc-number">2.4.5.</span> <span class="toc-text">服务器推送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.5.</span> <span class="toc-text">HTTPS协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8CHTTP%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.6.</span> <span class="toc-text">不同HTTP的协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">3.</span> <span class="toc-text">缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%BC%93%E5%AD%98"><span class="toc-number">3.1.</span> <span class="toc-text">强缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">3.2.</span> <span class="toc-text">协商缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89Last-Modified%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89ETag"><span class="toc-number">3.2.1.</span> <span class="toc-text">有Last-Modified为什么还要有ETag</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ETag"><span class="toc-number">3.3.</span> <span class="toc-text">ETag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">缓存的流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">4.</span> <span class="toc-text">Ajax</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FAjax%E6%9C%BA%E5%88%B6"><span class="toc-number">4.1.</span> <span class="toc-text">原生Ajax机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">ajax过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest"><span class="toc-number">4.3.</span> <span class="toc-text">XMLHttpRequest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#content-Type"><span class="toc-number">5.</span> <span class="toc-text">content-Type</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#get%E8%AF%B7%E6%B1%82%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">get请求常用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#url-param"><span class="toc-number">5.1.1.</span> <span class="toc-text">url param</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#query"><span class="toc-number">5.1.2.</span> <span class="toc-text">query</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#post%E8%AF%B7%E6%B1%82%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">post请求常用数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#application-x-www-form-urlencoded"><span class="toc-number">5.2.1.</span> <span class="toc-text">application&#x2F;x-www-form-urlencoded</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#multipart-form-data"><span class="toc-number">5.2.2.</span> <span class="toc-text">multipart&#x2F;form-data</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#json"><span class="toc-number">5.2.3.</span> <span class="toc-text">json</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">6.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">6.1.</span> <span class="toc-text">同源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">跨域请求分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.1.</span> <span class="toc-text">简单请求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">基本流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#withCredentials-%E5%B1%9E%E6%80%A7"><span class="toc-number">6.2.1.2.</span> <span class="toc-text">withCredentials 属性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.2.</span> <span class="toc-text">非简单请求</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">预检请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%E7%9A%84%E5%9B%9E%E5%BA%94"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">预检请求的回应</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%AD%A3%E5%B8%B8%E8%AF%B7%E6%B1%82%E5%92%8C%E5%9B%9E%E5%BA%94"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">浏览器的正常请求和回应</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.3.</span> <span class="toc-text">跨域解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-number">6.3.1.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">6.3.2.</span> <span class="toc-text">CORS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#document-domain"><span class="toc-number">6.3.3.</span> <span class="toc-text">document.domain</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-name"><span class="toc-number">6.3.4.</span> <span class="toc-text">window.name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Nginx-%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F"><span class="toc-number">6.3.5.</span> <span class="toc-text">Nginx 代理服务器配置跨域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E6%93%8D%E4%BD%9Ccookie"><span class="toc-number">6.4.</span> <span class="toc-text">跨域操作cookie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">7.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS%E5%92%8CCSRF"><span class="toc-number">7.1.</span> <span class="toc-text">XSS和CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS"><span class="toc-number">7.1.1.</span> <span class="toc-text">XSS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8BXSS%E6%94%BB%E5%87%BB"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">存储型XSS攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8BXSS%E6%94%BB%E5%87%BB"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">反射型XSS攻击</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DOM%E5%9E%8BXSS"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">DOM型XSS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#XSS%E9%98%B2%E8%8C%83%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.1.4.</span> <span class="toc-text">XSS防范方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF"><span class="toc-number">7.1.2.</span> <span class="toc-text">CSRF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XSS%E4%B8%8ECSRF%E5%8C%BA%E5%88%AB"><span class="toc-number">7.1.3.</span> <span class="toc-text">XSS与CSRF区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB"><span class="toc-number">7.2.</span> <span class="toc-text">重放攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E6%B3%A8%E5%85%A5"><span class="toc-number">7.3.</span> <span class="toc-text">sql注入</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#html"><span class="toc-number"></span> <span class="toc-text">html</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#html%E6%A0%87%E7%AD%BE"><span class="toc-number">1.</span> <span class="toc-text">html标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC"><span class="toc-number">1.1.</span> <span class="toc-text">表格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95"><span class="toc-number">1.2.</span> <span class="toc-text">表单</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe"><span class="toc-number">1.3.</span> <span class="toc-text">iframe</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iframe%E6%9C%89%E9%82%A3%E4%BA%9B%E7%BC%BA%E7%82%B9%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">iframe有那些缺点？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iframe-%E7%88%B6%E9%A1%B5%E9%9D%A2%E4%B8%8E%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%B9%8B%E9%97%B4-postMessage-%E9%80%9A%E4%BF%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">iframe 父页面与子页面之间 postMessage() 通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#textarea"><span class="toc-number">1.4.</span> <span class="toc-text">textarea</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#html5%E6%A0%87%E7%AD%BE"><span class="toc-number">2.</span> <span class="toc-text">html5标签</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE"><span class="toc-number">2.1.</span> <span class="toc-text">标签</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SEO"><span class="toc-number">3.1.</span> <span class="toc-text">SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Doctype%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">Doctype作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%B7%B7%E6%9D%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">严格模式与混杂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Charset%E7%BC%96%E7%A0%81"><span class="toc-number">3.4.</span> <span class="toc-text">Charset编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src-%E4%B8%8E-href-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.</span> <span class="toc-text">src 与 href 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">XML和JSON的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#css"><span class="toc-number"></span> <span class="toc-text">css</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#class%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">1.</span> <span class="toc-text">class命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">整体结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8F%9C%E5%8D%95%E5%92%8C%E5%AF%BC%E8%88%AA"><span class="toc-number">1.2.</span> <span class="toc-text">菜单和导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#title"><span class="toc-number">1.3.</span> <span class="toc-text">title</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E8%AF%8D"><span class="toc-number">1.4.</span> <span class="toc-text">动词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E5%AE%B9%E8%AF%8D"><span class="toc-number">1.5.</span> <span class="toc-text">形容词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD"><span class="toc-number">1.6.</span> <span class="toc-text">功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E5%85%83%E7%B4%A0"><span class="toc-number">2.</span> <span class="toc-text">行内元素和块元素</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0"><span class="toc-number">2.1.</span> <span class="toc-text">块级元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0-inline"><span class="toc-number">2.2.</span> <span class="toc-text">行内元素 inline</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E5%86%85%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0-inline-block"><span class="toc-number">2.3.</span> <span class="toc-text">行内块级元素 inline-block</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7-1"><span class="toc-number">3.1.</span> <span class="toc-text">优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">组合选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">属性选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.4.</span> <span class="toc-text">伪类选择器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">伪元素选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#word-break%E5%8D%95%E8%AF%8D%E6%8D%A2%E8%A1%8C"><span class="toc-number">3.5.1.</span> <span class="toc-text">word-break单词换行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.5.2.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BC%A9%E7%95%A5"><span class="toc-number">3.6.</span> <span class="toc-text">文本缩略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F"><span class="toc-number">4.</span> <span class="toc-text">图像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA"><span class="toc-number">4.1.</span> <span class="toc-text">裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#object-fit"><span class="toc-number">4.2.</span> <span class="toc-text">object-fit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80"><span class="toc-number">5.</span> <span class="toc-text">布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC"><span class="toc-number">5.1.</span> <span class="toc-text">BFC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.1.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BFC%E5%9C%BA%E6%99%AF%E5%92%8C%E5%BA%94%E7%94%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">BFC场景和应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#float"><span class="toc-number">5.2.</span> <span class="toc-text">float</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">5.2.2.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8"><span class="toc-number">5.2.3.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#position"><span class="toc-number">5.3.</span> <span class="toc-text">position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flex"><span class="toc-number">5.4.</span> <span class="toc-text">flex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">5.5.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">5.5.1.</span> <span class="toc-text">元素的水平居中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F"><span class="toc-number">6.</span> <span class="toc-text">响应式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%93%E5%B1%95"><span class="toc-number">6.1.</span> <span class="toc-text">拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E5%B0%BA%E5%AF%B8"><span class="toc-number">6.1.1.</span> <span class="toc-text">设备尺寸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0px"><span class="toc-number">6.1.2.</span> <span class="toc-text">像素px</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">6.1.3.</span> <span class="toc-text">分辨率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E6%AF%94-DPR"><span class="toc-number">6.1.4.</span> <span class="toc-text">像素比(DPR)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1px"><span class="toc-number">6.1.5.</span> <span class="toc-text">1px</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D"><span class="toc-number">6.2.</span> <span class="toc-text">单位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%86%E5%8F%A3"><span class="toc-number">6.2.1.</span> <span class="toc-text">视口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rem"><span class="toc-number">6.2.2.</span> <span class="toc-text">rem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%88%86%E6%AF%94"><span class="toc-number">6.2.3.</span> <span class="toc-text">百分比%</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94"><span class="toc-number">6.3.</span> <span class="toc-text">自适应</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#yd-ui%E7%A7%BB%E5%8A%A8%E7%AB%AF"><span class="toc-number">6.3.1.</span> <span class="toc-text">yd ui移动端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flexible-js"><span class="toc-number">6.3.2.</span> <span class="toc-text">flexible.js</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF"><span class="toc-number">6.4.</span> <span class="toc-text">移动端</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css%E5%B1%9E%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">css属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E5%86%99%E5%B1%9E%E6%80%A7"><span class="toc-number">7.1.</span> <span class="toc-text">连写属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#calc%E5%B1%9E%E6%80%A7"><span class="toc-number">7.2.</span> <span class="toc-text">calc属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%A1%88%E4%BE%8B"><span class="toc-number">8.</span> <span class="toc-text">总结与案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%92%8C%E9%80%8F%E6%98%8E%E5%BA%A6"><span class="toc-number">8.1.</span> <span class="toc-text">隐藏和透明度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AEplaceholder%E6%A0%B7%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">设置placeholder样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#link%E4%B8%8E-import%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.3.</span> <span class="toc-text">link与@import的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#display%EF%BC%9Atable%E5%92%8C%E6%9C%AC%E8%BA%AB%E7%9A%84table%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">8.4.</span> <span class="toc-text">display：table和本身的table有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B0%8F%E4%BA%8E12px%E7%9A%84%E5%AD%97%E4%BD%93%E6%95%88%E6%9E%9C"><span class="toc-number">8.5.</span> <span class="toc-text">如何实现小于12px的字体效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%8F%E8%A7%88%E5%99%A8%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%A0%B7%E5%BC%8F"><span class="toc-number">8.6.</span> <span class="toc-text">自定义浏览器滚动条样式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AEinput%E8%BE%93%E5%85%A5%E6%A1%86%E7%9A%84%E5%AE%BD%E5%BA%A6%E9%9A%8F%E6%96%87%E5%AD%97%E7%9A%84%E8%BE%93%E5%85%A5%E9%95%BF%E5%BA%A6%E8%80%8C%E6%94%B9%E5%8F%98%EF%BC%9F"><span class="toc-number">8.7.</span> <span class="toc-text">如何设置input输入框的宽度随文字的输入长度而改变？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#position%E5%AE%9A%E4%BD%8D%E7%9A%84"><span class="toc-number">8.8.</span> <span class="toc-text">position定位的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%92%E5%AD%90%E4%B8%AD%E6%A0%B9%E6%8D%AE%E5%86%85%E5%AE%B9%E6%92%91%E5%BC%80%EF%BC%8C%E4%BD%86%E7%9B%92%E5%AD%90%E9%AB%98%E5%BA%A6%E6%AF%94%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6%E9%AB%98"><span class="toc-number">8.9.</span> <span class="toc-text">盒子中根据内容撑开，但盒子高度比行内元素高度高</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#css3"><span class="toc-number"></span> <span class="toc-text">css3</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">盒模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B4%E5%BD%B1"><span class="toc-number">2.</span> <span class="toc-text">阴影</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E6%A1%86%E5%9C%86%E8%A7%92box-radius"><span class="toc-number">3.</span> <span class="toc-text">边框圆角box-radius</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%B9%E6%A1%86%E5%9B%BE%E5%83%8F"><span class="toc-number">4.</span> <span class="toc-text">边框图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">5.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%90%E5%8F%98"><span class="toc-number">6.</span> <span class="toc-text">渐变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80"><span class="toc-number">7.</span> <span class="toc-text">多列布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css3%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.</span> <span class="toc-text">css3媒体查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E7%94%BB"><span class="toc-number">9.</span> <span class="toc-text">动画</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%B8%A1transition"><span class="toc-number">9.1.</span> <span class="toc-text">过渡transition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B8%A7%E5%8A%A8%E7%94%BB"><span class="toc-number">9.2.</span> <span class="toc-text">关键帧动画</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E5%8C%96transform"><span class="toc-number">9.3.</span> <span class="toc-text">转化transform</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3D"><span class="toc-number">9.4.</span> <span class="toc-text">3D</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91%E5%99%A8"><span class="toc-number"></span> <span class="toc-text">预编译器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#less%E3%80%81scss-sass%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">less、scss&#x2F;sass区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#less%E3%80%81scss-sass"><span class="toc-number">1.1.</span> <span class="toc-text">less、scss&#x2F;sass</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sass-Scss%E4%B8%8ELess%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.</span> <span class="toc-text">Sass&#x2F;Scss与Less区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83"><span class="toc-number">1.2.1.</span> <span class="toc-text">编译环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.3.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.2.4.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%A4%96%E9%83%A8css"><span class="toc-number">1.2.5.</span> <span class="toc-text">引入外部css</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scss"><span class="toc-number">2.</span> <span class="toc-text">scss</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-number">2.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.3.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%8A%9F%E8%83%BD"><span class="toc-number">2.4.</span> <span class="toc-text">计算功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97"><span class="toc-number">2.5.</span> <span class="toc-text">嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5-1"><span class="toc-number">2.6.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">代码的重用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Mixin"><span class="toc-number">2.7.2.</span> <span class="toc-text">Mixin</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.8.</span> <span class="toc-text">循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-each-%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.8.1.</span> <span class="toc-text">使用@each 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-get"><span class="toc-number">2.8.2.</span> <span class="toc-text">map-get</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#js"><span class="toc-number"></span> <span class="toc-text">js</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%AF%86-1"><span class="toc-number">1.</span> <span class="toc-text">常识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">1.1.</span> <span class="toc-text">命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%A0%88"><span class="toc-number">1.2.</span> <span class="toc-text">堆栈</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">2.</span> <span class="toc-text">概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.1.</span> <span class="toc-text">对象序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">2.2.</span> <span class="toc-text">闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.2.1.</span> <span class="toc-text">闭包的优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E4%B8%A4%E4%BA%BA%E5%AF%B9%E8%AF%9D"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">模拟两人对话</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BFsetTimeout%E6%94%AF%E6%8C%81%E4%BC%A0%E5%8F%82"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">使setTimeout支持传参</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">封装私有变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.3.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">特征</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">封装</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-1"><span class="toc-number">2.3.2.3.</span> <span class="toc-text">继承</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%B9%E5%BC%8F%E5%88%9B%E5%BB%BA"><span class="toc-number">2.3.3.</span> <span class="toc-text">简单方式创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.4.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.5.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#new-%E5%91%BD%E4%BB%A4%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">new 命令的机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#proto"><span class="toc-number">2.3.5.3.</span> <span class="toc-text">proto</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">2.3.5.4.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#instanceof"><span class="toc-number">2.3.5.5.</span> <span class="toc-text">instanceof</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-2"><span class="toc-number">2.3.6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.6.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.6.2.</span> <span class="toc-text">构造继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.6.3.</span> <span class="toc-text">组合继承</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E5%90%91"><span class="toc-number">2.4.</span> <span class="toc-text">this指向</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B4%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">实质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8C%87%E5%90%91"><span class="toc-number">2.4.2.</span> <span class="toc-text">类型指向</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E7%9A%84this"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">全局作用域中的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84this"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">全局作用域中函数中的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84this"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">对象方法中的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84this"><span class="toc-number">2.4.2.4.</span> <span class="toc-text">构造函数的this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#setTimeout"><span class="toc-number">2.4.2.5.</span> <span class="toc-text">setTimeout</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.2.6.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#React%E4%B8%ADthis%E6%8C%87%E5%90%91"><span class="toc-number">2.4.2.7.</span> <span class="toc-text">React中this指向</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#call%E3%80%81apply%E3%80%81bind"><span class="toc-number">2.4.3.</span> <span class="toc-text">call、apply、bind</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E7%A0%81"><span class="toc-number">2.4.3.4.</span> <span class="toc-text">源码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.5.1.</span> <span class="toc-text">实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#vue-%E9%98%B2%E6%8A%96%E6%8C%89%E9%92%AE"><span class="toc-number">2.5.1.1.</span> <span class="toc-text">vue:防抖按钮</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#react-%E6%9D%83%E9%99%90%E6%8C%89%E9%92%AE"><span class="toc-number">2.5.1.2.</span> <span class="toc-text">react:权限按钮</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DOM%E6%93%8D%E4%BD%9C"><span class="toc-number">3.</span> <span class="toc-text">DOM操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E7%BD%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">3.1.</span> <span class="toc-text">位置获取</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">3.1.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%EF%BC%88%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">3.1.2.</span> <span class="toc-text">获取鼠标当前位置（事件对象）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.1.3.</span> <span class="toc-text">获取元素当前位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%BD%E9%AB%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">获取浏览器宽高</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8"><span class="toc-number">3.1.5.</span> <span class="toc-text">滚动</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">鼠标事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.2.2.</span> <span class="toc-text">拖拉事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E8%8E%B7%E5%8F%96"><span class="toc-number">3.3.</span> <span class="toc-text">属性获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96"><span class="toc-number">3.4.</span> <span class="toc-text">节点元素获取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">4.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E6%B5%81%E9%98%B6%E6%AE%B5"><span class="toc-number">4.1.</span> <span class="toc-text">事件流阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98"><span class="toc-number">4.2.</span> <span class="toc-text">事件委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1event"><span class="toc-number">4.3.</span> <span class="toc-text">事件对象event</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.4.</span> <span class="toc-text">加载事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addEventListener%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">addEventListener自定义事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-2"><span class="toc-number">4.5.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.5.2.</span> <span class="toc-text">自定义事件构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dispatchEvent"><span class="toc-number">4.5.3.</span> <span class="toc-text">dispatchEvent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.5.4.</span> <span class="toc-text">冒泡示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">浏览器对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#window%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">window对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#navigator"><span class="toc-number">5.2.</span> <span class="toc-text">navigator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.</span> <span class="toc-text">History对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Error%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.</span> <span class="toc-text">Error对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E9%94%99%E8%AF%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">原生错误类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SyntaxError-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">SyntaxError 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReferenceError-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">ReferenceError 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#RangeError-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">RangeError 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#TypeError-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.1.4.</span> <span class="toc-text">TypeError 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#URIError-%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.4.1.5.</span> <span class="toc-text">URIError 对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">5.4.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%94%99%E8%AF%AF"><span class="toc-number">5.4.2.</span> <span class="toc-text">自定义错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#throw-%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.4.3.</span> <span class="toc-text">throw 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try%E2%80%A6catch-%E7%BB%93%E6%9E%84"><span class="toc-number">5.4.4.</span> <span class="toc-text">try…catch 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finally-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.4.5.</span> <span class="toc-text">finally 代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FormData%E8%A1%A8%E5%8D%95%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.</span> <span class="toc-text">FormData表单对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95FormData%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.5.1.</span> <span class="toc-text">表单FormData对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FormData-%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">5.5.2.</span> <span class="toc-text">FormData 实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%A0%A1%E9%AA%8C"><span class="toc-number">5.5.3.</span> <span class="toc-text">自动校验</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.6.</span> <span class="toc-text">File对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#blob%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.6.1.</span> <span class="toc-text">blob对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#file%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">file对象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%AA%E5%88%87%E6%9D%BF"><span class="toc-number">5.6.2.</span> <span class="toc-text">剪切板</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E5%AD%97"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">文字</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F-1"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">图像</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WEB%E5%AD%98%E5%82%A8"><span class="toc-number">6.</span> <span class="toc-text">WEB存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">cookie对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-number">6.1.1.</span> <span class="toc-text">域名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie%E8%AF%BB%E5%86%99"><span class="toc-number">6.1.2.</span> <span class="toc-text">cookie读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">读写流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTTP-%E5%A4%B4%E5%AF%B9-cookie-%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">HTTP 头对 cookie 的读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%AF%B9-cookie-%E7%9A%84%E8%AF%BB%E5%86%99"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">前端对 cookie 的读写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Location%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.2.</span> <span class="toc-text">Location对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E5%92%8Cstorage%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">cookie和storage区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tips"><span class="toc-number">7.</span> <span class="toc-text">Tips</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#jquery"><span class="toc-number"></span> <span class="toc-text">jquery</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">核心</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#jQuery-%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">jQuery 代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HTML-%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">HTML 代码:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#jQuery-%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">jQuery 代码:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#css-1"><span class="toc-number">3.</span> <span class="toc-text">css</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%99%A8-1"><span class="toc-number">4.</span> <span class="toc-text">选择器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E7%BA%A7"><span class="toc-number">4.1.</span> <span class="toc-text">层级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC"><span class="toc-number">4.2.</span> <span class="toc-text">基本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">4.3.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-1"><span class="toc-number">4.4.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%85%83%E7%B4%A0"><span class="toc-number">4.5.</span> <span class="toc-text">子元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95-1"><span class="toc-number">4.6.</span> <span class="toc-text">表单</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E5%A4%84%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">文档处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">5.1.</span> <span class="toc-text">内部插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8F%92%E5%85%A5"><span class="toc-number">5.2.</span> <span class="toc-text">外部插入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4"><span class="toc-number">5.4.</span> <span class="toc-text">删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%9B%E9%80%89"><span class="toc-number">6.</span> <span class="toc-text">筛选</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6-2"><span class="toc-number">7.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number"></span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E7%BB%84%E6%88%90"><span class="toc-number">1.</span> <span class="toc-text">正则表达式的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C"><span class="toc-number">1.1.</span> <span class="toc-text">边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6"><span class="toc-number">1.2.</span> <span class="toc-text">元字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%85%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.2.1.</span> <span class="toc-text">常用元字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">1.2.2.</span> <span class="toc-text">限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.2.3.</span> <span class="toc-text">其它</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript-%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">JavaScript 中使用正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%AD%A3%E5%88%99%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">创建正则对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D"><span class="toc-number">2.2.</span> <span class="toc-text">正则匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E6%8F%90%E5%8F%96"><span class="toc-number">2.3.</span> <span class="toc-text">正则提取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E6%9B%BF%E6%8D%A2"><span class="toc-number">2.4.</span> <span class="toc-text">正则替换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B-2"><span class="toc-number">3.</span> <span class="toc-text">案例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6el-input%E5%8F%AA%E8%83%BD%E8%BE%93%E5%85%A5%E4%B8%A4%E4%BD%8D%E5%B0%8F%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">限制el-input只能输入两位小数</span></a></li></ol></li></ol></li></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="计算机"><img src="/img/cover_1.gif" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="计算机"></a><div class="content"><a class="title" href="/2023/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="计算机">计算机</a><time datetime="2023-05-30T03:39:50.217Z" title="发表于 2023-05-30 11:39:50">2023-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/01-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/" title="项目构建"><img src="/img/cover_1.gif" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="项目构建"></a><div class="content"><a class="title" href="/2023/05/30/01-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/" title="项目构建">项目构建</a><time datetime="2023-05-30T03:39:46.242Z" title="发表于 2023-05-30 11:39:46">2023-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/00-%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81/" title="前端原理和源码"><img src="/img/cover_1.gif" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="前端原理和源码"></a><div class="content"><a class="title" href="/2023/05/30/00-%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81/" title="前端原理和源码">前端原理和源码</a><time datetime="2023-05-30T03:39:46.239Z" title="发表于 2023-05-30 11:39:46">2023-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/25/08-app/" title="app"><img src="/img/cover_1.gif" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="app"></a><div class="content"><a class="title" href="/2020/09/25/08-app/" title="app">app</a><time datetime="2020-09-24T16:00:00.000Z" title="发表于 2020-09-25 00:00:00">2020-09-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2020/09/25/03-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="代码片段"><img src="/img/cover_1.gif" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="代码片段"></a><div class="content"><a class="title" href="/2020/09/25/03-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/" title="代码片段">代码片段</a><time datetime="2020-09-24T16:00:00.000Z" title="发表于 2020-09-25 00:00:00">2020-09-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url(/img/cover_1.gif)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By LMTomorrow</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">因为热爱，所以专注</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '6bfdb22315df9b919429',
      clientSecret: '80fa5ba42986f3960283146c3faf03bc34beb4ab',
      repo: 'TomorrowLM.github.io',
      owner: 'TomorrowLM',
      admin: ['TomorrowLM'],
      id: 'cc69618e2f561a1fab2839820286f5f7',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><div class="aplayer no-destroy" data-id="4929980436" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listfolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><canvas id="universe"></canvas><script defer="defer" src="/js/custom/universe.js"></script><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>if(document.getElementById("recent-posts")&&"/"==location.pathname){var parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/cover_1.gif" alt="/img/cover_1.gif"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-05-30</span><a class="blog-slider__title" href="2023/05/30/01-项目构建/">项目构建</a><div class="blog-slider__text">webpack,优化,项目构建,规范,业务,npm,git</div><a class="blog-slider__button" href="2023/05/30/01-项目构建/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/cover_1.gif" alt="/img/cover_1.gif"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-05-30</span><a class="blog-slider__title" href="2023/05/30/00-原理和源码/">前端原理和源码</a><div class="blog-slider__text">vue,webpack,响应式,路由,响应式,diff</div><a class="blog-slider__button" href="2023/05/30/00-原理和源码/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/cover_1.gif" alt="/img/cover_1.gif"/></div><div class="blog-slider__content"><span class="blog-slider__code">2020-09-25</span><a class="blog-slider__title" href="2020/09/25/02-总结/">总结</a><div class="blog-slider__text">关于一些实战常用的html,css,es5的总结！经验</div><a class="blog-slider__button" href="2020/09/25/02-总结/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/cover_1.gif" alt="/img/cover_1.gif"/></div><div class="blog-slider__content"><span class="blog-slider__code">2020-09-25</span><a class="blog-slider__title" href="2020/09/25/04-ES6和TS/">ES6，TS和设计模式</a><div class="blog-slider__text">ES6,TS,设计模式</div><a class="blog-slider__button" href="2020/09/25/04-ES6和TS/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/cover_1.gif" alt="/img/cover_1.gif"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-05-30</span><a class="blog-slider__title" href="2023/05/30/计算机/">计算机</a><div class="blog-slider__text">计算机,计算机网络,安全,通信,软考,linux,windows</div><a class="blog-slider__button" href="2023/05/30/计算机/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';console.log("已挂载swiper"),parent.insertAdjacentHTML("afterbegin",child)}</script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script><style></style><script data-pjax>function electric_clock_injector_config(){var e=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载electric_clock"),e.insertAdjacentHTML("afterbegin","undefined")}document.getElementsByClassName("sticky_layout")[0]&&(location.pathname,1)&&electric_clock_injector_config()</script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script data-pjax>function butterfly_clock_anzhiyu_injector_config(){var e=document.getElementsByClassName("sticky_layout")[0];console.log("已挂载butterfly_clock_anzhiyu"),e&&e.insertAdjacentHTML("afterbegin",'<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>')}for(var elist="null".split(","),cpage=location.pathname,epage="all",qweather_key="b16a1fa0e63c46a4b8f28abfb06ae3fe",gaud_map_key="20e4a5b832b5f4649f41ffc0a68c8c16# 高得地图web服务key",baidu_ak_key="undefined",flag=0,clock_rectangle="112.982279,28.19409",clock_default_rectangle_enable="false",i=0;i<elist.length;i++)cpage.includes(elist[i])&&flag++;"all"===epage&&0==flag?butterfly_clock_anzhiyu_injector_config():epage===cpage&&butterfly_clock_anzhiyu_injector_config()</script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script></body></html>