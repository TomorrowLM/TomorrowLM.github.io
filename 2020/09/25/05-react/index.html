<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>react技术栈 | TomorrowLM-Web</title><meta name="author" content="LMTomorrow,120329698@qq.com"><meta name="copyright" content="LMTomorrow"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="react学习"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://tomorrowlm.github.io/2020/09/25/05-react/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'react技术栈',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-30 11:33:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom/custom.css"><link rel="stylesheet" href="/css/custom/universe.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiperstyle.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw anzhiyu-icon-music"></i><span> 音乐馆</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/header.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="TomorrowLM-Web"><span class="site-name">TomorrowLM-Web</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 其他</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw anzhiyu-icon-music"></i><span> 音乐馆</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">react技术栈</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-24T16:00:00.000Z" title="发表于 2020-09-25 00:00:00">2020-09-25</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-30T03:33:56.751Z" title="更新于 2023-05-30 11:33:56">2023-05-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/react%E6%8A%80%E6%9C%AF%E6%A0%88/">react技术栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>111分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="react技术栈"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h1><ol>
<li>虚拟DOM<br>之前操作dom的⽅式是通过document.getElementById()的⽅式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进⾏操作<br>⽽reactjs定义了⼀套变量形式的dom模型，⼀切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的⾼，和主流MVC框架有本质的区别，并不和dom打交道</li>
<li>组件系统<br>react最核⼼的思想是将⻚⾯中任何⼀个区域或者元素都可以看做⼀个组件 component<br>那么什么是组件呢？<br>组件指的就是同时包含了html、css、js、image元素的聚合体<br>使⽤react开发的核⼼就是将⻚⾯拆分成若⼲个组件，并且react⼀个组件中同时耦合了css、js、<br>image，这种模式整个颠覆了过去的传统的⽅式</li>
<li>单向数据流<br>其实reactjs的核⼼内容就是数据绑定，所谓数据绑定指的是只要将⼀些服务端的数据和前端⻚⾯绑定<br>好，开发者只关注实现业务就⾏了</li>
<li>JSX 语法<br>在vue中，我们使⽤render函数来构建组件的dom结构性能较⾼，因为省去了查找和编译模板的过程，<br>但是在render中利⽤createElement创建结构的时候代码可读性较低，较为复杂，此时可以利⽤jsx语法<br>来在render中创建dom，解决这个问题，但是前提是需要使⽤⼯具来编译jsx</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>全局定义将组件App放置在<code>id=&#39;App&#39;</code>的容器里</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDom from &#x27;react-dom&#x27;</span><br><span class="line">import App from &#x27;./app.jsx&#x27;</span><br><span class="line">// ReactDOM.render(&#x27;要渲染的虚拟DOM元素&#x27;, &#x27;要渲染到页面上的哪个位置中&#x27;)</span><br><span class="line">// 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 &quot;#app&quot; 这样的字符串，而是需要传递一个 原生的 DOM 对象</span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App/&gt;,</span><br><span class="line">    document.getElementById(&#x27;App&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="APP-jsx"><a href="#APP-jsx" class="headerlink" title="APP.jsx"></a>APP.jsx</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素</span><br><span class="line">// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数</span><br><span class="line">// 参数1： 是个字符串类型的参数，表示要创建的元素类型</span><br><span class="line">// 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性</span><br><span class="line">// 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点</span><br><span class="line"> var myDiv = React.createElement(&#x27;div&#x27;, &#123; title: &#x27;this is a div&#x27;, id: &#x27;mydiv&#x27; &#125;, &#x27;这是一个div&#x27;, myH1)</span><br><span class="line">//&lt;div title=&quot;this is a div&quot; id=&quot;mydiv&quot;&gt;这是一个div&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">// 由于，React官方，发现，如果直接让用户手写 JS 代码创建元素，用户会疯掉的，然后，用户就开始寻找新的前端框架了，于是，React 官方，就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构；</span><br><span class="line">// 问题： JSX（符合 XML 规范的 JS 语法）的原理是什么？</span><br><span class="line">// JSX内部在运行的时候，也是先把 类似于HTML 这样的标签代码，转换为了 React.createElement 的形式；（JSX是一个对程序员友好的语法糖）</span><br><span class="line">//在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> // 在React中，构造函数，就是一个最基本的组件</span><br><span class="line">// 如果想要把组件放到页面中，可以把 构造函数的名称，当作 组件的名称，以 HTML标签形式引入页面中即可</span><br><span class="line">// 注意：React在解析所有的标签的时候，是以标签的首字母来区分的，如果标签的首字母是小写，那么就按照 普通的 HTML 标签来解析，如果 首字母是大写，则按照 组件的形式去解析渲染</span><br><span class="line">// 结论：组件的首字母必须是大写</span><br><span class="line">export default function Hello(props) &#123;</span><br><span class="line">  // 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；</span><br><span class="line">  // 通过 props 得到的任何数据都是只读的，不能从新赋值</span><br><span class="line">  return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是在Hello组件中定义的元素 --- &#123;props.name&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><p><a target="_blank" rel="noopener" href="https://react.docschina.org/docs/react-component.html">https://react.docschina.org/docs/react-component.html</a></p>
<p><a target="_blank" rel="noopener" href="https://m.html.cn/qa/react/14367.html">https://m.html.cn/qa/react/14367.html</a></p>
<p>从出生到成长，最后到死亡，这个过程的时间可以理解为生命周期。React的生命周期同理也是这么一个过程。<br>React的生命周期分为三个阶段：挂载期（也叫实例化期）、更新期（也叫存在期）、卸载期（也叫销毁期）。在每个周期中React都提供了一些钩子函数。<br>生命周期的描述如下：<br>挂载期：一个组件实例初次北创建的过程。<br>更新期：组件在创建后再次渲染的过程。<br>卸载期：组件在使用完后被销毁的过程。</p>
<h2 id="组件初始化阶段"><a href="#组件初始化阶段" class="headerlink" title="组件初始化阶段"></a>组件初始化阶段</h2><p><strong>组件实例创建阶段的生命周期函数，在组件的一辈子中，只执行一次</strong>；</p>
<ul>
<li><p>constructor(props)</p>
<p>仅用于以下两种情况：</p>
<ul>
<li>通过给 <code>this.state</code> 赋值对象来初始化<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html">内部 state</a>。</li>
<li>为<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/handling-events.html">事件处理函数</a>绑定实例</li>
</ul>
<p>在为 React.Component 子类实现构造函数时，通过 super(props)调用父类React Component的构造函数，⽤来将⽗组件传来的 props 绑定到这个类中。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p>
</li>
<li><p>componentWillMount<strong>（17后已经过时</strong>）: 组件将要被挂载，此时还没有开始渲染虚拟DOM，无法获取到页面上的任何元素，因为虚拟DOM和页面都还没有开始渲染呢。</p>
<ul>
<li><p>进⾏ajax请求，作者一开始也喜欢在React的willMount函数中进行异步获取数据（认为这可以减少白屏的时间），后来发现其实应该在didMount中进行。</p>
</li>
<li><p>可以修改state</p>
</li>
</ul>
</li>
<li><p>render： <code>render()</code> 方法是 class 组件中唯一必须实现的方法。 第一次开始渲染，创建虚拟dom，当render执行完，内存中就有了完整的虚拟DOM了。但是，页面上尚未真正显示DOM元素</p>
</li>
<li><p>componentDidMount:  <code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。</p>
<ul>
<li>网络请求获取数据</li>
<li>对DOM进行操作</li>
<li>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅  </li>
</ul>
</li>
</ul>
<h2 id="组件更新阶段"><a href="#组件更新阶段" class="headerlink" title="组件更新阶段"></a><strong>组件更新阶段</strong></h2><p>更新根据组件的state和props的改变，有选择性的触发0次或多次；</p>
<ul>
<li><p>componentWillReceiveProps（<strong>17后已经过时）</strong>:<br>组件将要接收新属性props，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；<br>如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentWillReceiveProps</span>(<span class="params">nextProps</span>)&#123;    </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">pmsg</span> + <span class="string">&#x27; ---- &#x27;</span> + nextProps.<span class="property">pmsg</span></span><br><span class="line">);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的。 首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure></li>
<li><p>componentWillUpdate（<strong>17已经过时</strong>）: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的，页面上的 DOM 元素 也是旧的</p>
</li>
<li><p>render: 根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！<strong>此时页面还是旧的</strong></p>
</li>
<li><p>componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步</p>
</li>
</ul>
<h2 id="组件销毁阶段"><a href="#组件销毁阶段" class="headerlink" title="组件销毁阶段"></a>组件销毁阶段</h2><p><strong>也有一个显著的特点，一辈子只执行一次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb3cd2923f04e4c8dc58243522ff666~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/13/172acf9ceebe696c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200528113856923"></p>
<p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p>
<ul>
<li>constructor()</li>
<li>static getDerivedStateFromProps()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()</li>
</ul>
<p>错误处理<br>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p>
<ul>
<li>static getDerivedStateFromError()</li>
<li>componentDidCatch()</li>
</ul>
<h3 id="废弃的生命周期"><a href="#废弃的生命周期" class="headerlink" title="废弃的生命周期"></a>废弃的生命周期</h3><p><strong>被废弃的三个函数都是在render之前</strong></p>
<h4 id="为什么废弃"><a href="#为什么废弃" class="headerlink" title="为什么废弃"></a>为什么废弃</h4><p>由于<code>React</code>未来会推出新的渲染方式–异步渲染，一种生命周期可被打断的渲染方式<strong>（因为fiber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次）</strong>，具体是在<code>render()</code>生成虚拟 <code>dom</code> 阶段可以打断重来， 这就会导致在dom挂载之前或是被更新之前的所有任务都会重复操作，所以<code>componentWillMount()</code>、·<code>componentWillReceiveProps()</code> <code>componentWIllUpdate()</code>方法可能会执行多次。（<strong>函数内部逻辑多次调用</strong>）</p>
<h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><strong>componentWillMount</strong></h4><p><strong>新版本中官方推荐将初始化的操作放在<code>constructor()</code>中， 将请求异步数据、订阅事件源、监听事件的操作放在<code>componentDidMount()</code></strong></p>
<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><strong>componentWillReceiveProps</strong></h4><p>在老版本的<code>React</code>中，如果组件自身的state与其props密切相关的话，我们就会用到<code>componentWillReceiveProps(nextProps)</code>。常见的业务场景比如，tabs的激活状态，一般我们会在组件自身内通过state维持，但是当我们从其他页面返回时，想要保持离开之前时的tabs状态，这时我们可以通过props来传递，（<strong>破坏了数据源的单一性</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//previous </span><br><span class="line">componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">   if(nextProps.activeIndex !== this.state.activeIndex) &#123;</span><br><span class="line">     this.setState(&#123;activeIndex: nextProps.activeIndex&#125;)</span><br><span class="line">     this.fetchData() //因异步中断，可能会重复操作</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/** next </span><br><span class="line">*将更新state与触发逻辑的操作分成两部分来执行，state更新部分在getDerivedStateFromProps中完成， 逻辑部分操作</span><br><span class="line">*在componentDidUpdate()中完成</span><br><span class="line">*/</span><br><span class="line">static getDerivedStateFromProps(nextProps, prevState) &#123; //此方法不能获取组件实例</span><br><span class="line">   if(nextProps.activeIndex !== prevState.activeIndex) &#123;</span><br><span class="line">     return &#123;activeIndex: nextProps.activeIndex&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  this.fetchData() //可以确保只执行一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该生命周期函数按照上面图谱中应该是在props属性改变之后调用，但其实只要父组件重新渲染，无论子组件的props有没有更新，子组件都会调用<code>componentWillReceiveProps</code> <strong>注意这里可能会造成死循环，即当子组件在该方法中调用了父组件通过props传递过来的函数时， 恰巧该函数中有能让父组件重新渲染的逻辑，就会造成死循环</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">          			&#123;/* 迫使父组件更新, 子组件就会调用componentWillReceiveProps */&#125;</span><br><span class="line">                &lt;div onClick=&#123;() =&gt; this.forceUpdate()&#125;&gt; re-render &lt;/div&gt; </span><br><span class="line">                &lt;Child parentFun=&#123;() =&gt; this.setState(&#123;&#125;)&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">    componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">      &#123;/*  子组件调用了父组件通过props传递过来的函数，该函数会使父组件重新渲染，造成死循环 */&#125;</span><br><span class="line">        nextProps.parentFun()</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt; child component &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><strong>componentWillUpdate</strong></h4><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><p><strong>使用getDerivedStateFromProps代替了旧的componentWillReceiveProps及componentWillMount</strong></p>
<p>getDerivedStateFromProps是一个静态方法，在挂载和更新阶段时调用，可以返回一个对象来更新状态或者返回null不更新。</p>
<p>优点</p>
<ol>
<li><p>getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码</p>
</li>
<li><p>开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况</p>
</li>
</ol>
<h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>getSnapshotBeforeUpdate代替了旧的componentWillUpdate。</p>
<p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    // 我们是否在 list 中添加新的 items ？</span><br><span class="line">    // 捕获滚动​​位置以便我们稍后调整滚动位置。</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span><br><span class="line">    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span><br><span class="line">    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span><br><span class="line">    if (snapshot !== null) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromError(error)</span><br></pre></td></tr></table></figure>

<p>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;    // 更新 state 使下一次渲染可以显降级 UI    return &#123; hasError: true &#125;;  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;      // 你可以渲染任何自定义的降级  UI      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    &#125;</span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate"></a>forceUpdate</h3><p>默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 <code>render()</code> 方法依赖于其他数据，则可以调用 <code>forceUpdate()</code> 强制让组件重新渲染。</p>
<p>调用 <code>forceUpdate()</code> 将致使组件调用 <code>render()</code> 方法，此操作会跳过该组件的 <code>shouldComponentUpdate()</code>。但其<strong>子组件</strong>会触发正常的生命周期方法，包括 <code>shouldComponentUpdate()</code> 方法。如果标记发生变化，React 仍将只更新 DOM。</p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.<span class="property">isLoggedIn</span>;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.<span class="property">isLoggedIn</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	&#123;isLoggedIn?<span class="language-xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>:<span class="language-xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="comment">// Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoggedIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h3><p>key为每个元素加上唯一的标识，这样在执行diff的时候会加快位置的确定</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.<span class="property">numbers</span>;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.<span class="title function_">map</span>(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;number&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> <strong>在 JSX 中嵌入 map()</strong></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">NumberList</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.<span class="property">numbers</span>;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;numbers.map((number) =&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                  <span class="attr">value</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。</p>
<p><strong>如果使用数组索引，那么在对dom进行添加或删除，会出问题</strong>：</p>
<img src="/img/react/arr-delete-start.png" style="zoom: 50%;">

<img src="/img/react/arr-delete-end.png" style="zoom:50%;">

<p>页面渲染好了之后，3 个 input 输入框依次输入随机内容，当我们用 index 作为 key 的时候，点击删除第一项按钮会发现，左侧文字正确改变，input 输入框最后一项没了，这不是我们希望的样子。 因为当我们使用 index 作为 key 时，此时 key 为 0、1、2，删掉第一项后 key 变为 0、1，此时 react 在执行 diff 算法过程中，任务 key=0 存在，只需要更新子节点的值，所以左侧的 name 成功改变，而 input 的值非受控，不会更新。同时在对比计算中少了 key=2 这项，删除了最后一项。</p>
<h3 id="添加样式的方式"><a href="#添加样式的方式" class="headerlink" title="添加样式的方式"></a>添加样式的方式</h3><p><strong>第一种：行内样式</strong></p>
<p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号</span></span><br><span class="line"> &lt;p style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;14px&#x27;</span>&#125;&#125;&gt;<span class="title class_">Hello</span> world&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态添加样式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;<span class="attr">display</span>: (index===<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">currentIndex</span>) ? <span class="string">&quot;block&quot;</span> : <span class="string">&quot;none&quot;</span>&#125;&#125;&gt;此标签是否隐藏&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;index===<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">currentIndex</span>?<span class="string">&quot;active&quot;</span>:<span class="literal">null</span>&#125;&gt;此标签是否选中&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第二种：内嵌样式</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;&#123;<span class="string">`.operafor4&#123;margin-top:42px !important&#125;`</span>&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第三种：css modules</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html">https://www.ruanyifeng.com/blog/2016/06/css_modules.html</a></p>
<p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。例如：父组件和子组件使用相同的class，父组件的class会覆盖子组件的样式</p>
<p>产生局部作用域的唯一方法，就是使用一个独一无二的<code>class</code>的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。</p>
<p>css Modules 添加多个className</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> className=&#123;`$&#123;styles<span class="selector-class">.sAll</span>&#125; $&#123;styles<span class="selector-class">.s1</span>&#125;`&#125;&gt;aaaaaa&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局规则。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:<span class="built_in">global</span>(.title) &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四种：样式组件（styled-components）</strong></p>
<p>styled-components是针对React写的一套css-in-js框架，简单来讲就是在js中写css。<br>styled-components是一个第三方包，要安装。<strong>Material框架</strong>中的样式也是如此</p>
<h2 id="表单和受控组件"><a href="#表单和受控组件" class="headerlink" title="表单和受控组件"></a>表单和受控组件</h2><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a target="_blank" rel="noopener" href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a>来更新。</p>
<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“<strong>受控组件</strong>”。</p>
<figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NameForm</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">value</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleChange</span> = <span class="variable language_">this</span>.<span class="property">handleChange</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>&#125;);  &#125;</span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;提交的名字: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">value</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          名字:</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&#123;this.state.value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.handleChange&#125;</span> /&gt;</span>        </span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>
<p><strong>对于受控组件来说，输入的值始终由 React 的 state 驱动</strong></p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Welcome</span>(<span class="params">props</span>) &#123;  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="language-xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;<span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  element,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p>无论是函数组件还是 class 组件，都拥有 <code>defaultProps</code> 属性。可以通过配置特定的 <code>defaultProps</code> 属性来定义 <code>props</code> 的默认值</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 props 的默认值：</span></span><br><span class="line"><span class="title class_">Greeting</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Stranger&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染出 &quot;Hello, Stranger&quot;：</span></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="PropTypes类型检查"><a href="#PropTypes类型检查" class="headerlink" title="PropTypes类型检查"></a>PropTypes类型检查</h3><p>PropTypes 进行类型检查,可用于确保组件接收到的props数据类型是有效的</p>
<p>导入包</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>编写组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增类型检查</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">Greeting.propTypes = &#123;</span><br><span class="line"><span class="comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class="line">  <span class="comment">// 这些属性都是可选的。</span></span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.<span class="type">bool</span>,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class="line">  <span class="comment">// (或 Fragment) 也包含这些类型。</span></span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素。</span></span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素类型（即，MyComponent）。</span></span><br><span class="line">  optionalElementType: PropTypes.elementType,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class="line">  <span class="comment">// JS 的 instanceof 操作符。</span></span><br><span class="line">  optionalMessage: PropTypes.<span class="built_in">instanceOf</span>(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class="line">  <span class="comment">// 枚举类型。</span></span><br><span class="line">  optionalEnum: PropTypes.<span class="built_in">oneOf</span>([<span class="string">&#x27;News&#x27;</span>, <span class="string">&#x27;Photos&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class="line">  optionalUnion: PropTypes.<span class="built_in">oneOfType</span>([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.<span class="built_in">instanceOf</span>(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class="line">  optionalArrayOf: PropTypes.<span class="built_in">arrayOf</span>(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由某一类型的值组成</span></span><br><span class="line">  optionalObjectOf: PropTypes.<span class="built_in">objectOf</span>(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由特定的类型值组成</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.<span class="built_in">shape</span>(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// An object with warnings on extra properties</span></span><br><span class="line">  optionalObjectWithStrictShape: PropTypes.<span class="built_in">exact</span>(&#123;</span><br><span class="line">    name: PropTypes.string,</span><br><span class="line">    quantity: PropTypes.number</span><br><span class="line">  &#125;),   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class="line">  <span class="comment">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任意类型的数据</span></span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class="line">  customProp: <span class="built_in">function</span>(props, propName, componentName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!/matchme/.<span class="built_in">test</span>(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class="line">  <span class="comment">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class="line">  <span class="comment">// 第一个是数组或对象本身</span></span><br><span class="line">  <span class="comment">// 第二个是他们当前的键。</span></span><br><span class="line">  customArrayProp: PropTypes.<span class="built_in">arrayOf</span>(<span class="built_in">function</span>(propValue, key, componentName, location, propFullName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!/matchme/.<span class="built_in">test</span>(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a><strong>this.props.children</strong></h3><p>将一个组件写在另一个组件的内容中，然后在外层组件中通过 this.props.children来接收内容中的组件</p>
<p>如果当前组件没有子节点，它就是 undefined ;<br>如果有一个子节点，数据类型是 Object；<br>如果有多个子节点，数据类型就是 Array。</p>
<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6850418109636050958">https://juejin.cn/post/6850418109636050958</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6959885030063603743#heading-0">https://juejin.cn/post/6959885030063603743#heading-0</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    number:1</span><br><span class="line">&#125;;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;number:3&#125;)</span><br><span class="line">    console.log(this.state.number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/11/1733ca3cdf9d950d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>setState是一个异步方法，如果每次调用setState都会触发更新，那么性能消耗就大，异步操作是为了提高性能，将多个状态更新合并一起进行<strong>批量更新</strong>，减少re-render调用。 <strong>将 <code>setState()</code> 视为<em>请求</em>而不是立即更新组件的命令。</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( let i = 0; i &lt; 100; i++ ) &#123;</span><br><span class="line">    this.setState( &#123; num: this.state.num + 1 &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果setState是一个同步执行的机制，那么这个状态会被重新渲染100次，这对性能是一个相当大的消耗。</p>
<blockquote>
<p>React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新</p>
</blockquote>
<p><strong>回调函数</strong></p>
<p>setState提供了一个回调函数供开发者使用，在回调函数中，我们可以实时的获取到更新之后的数据。还是以刚才的例子做示范：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    number:1</span><br><span class="line">&#125;;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;number:3&#125;,()=&gt;&#123;</span><br><span class="line">        console.log(this.state.number)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/11/1733ca3cdfc5be38~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p><strong>总结：</strong></p>
<ul>
<li><p>setState本身并不是异步（不会立即更新state的结果），只是因为react的性能优化机制体现为异步。在react的生命周期函数或者作用域下为异步，在原生的环境下为同步。</p>
</li>
<li><p>React18之前，react 无法对 setTimeout 的代码前后加上事务逻辑（除非 react 重写 setTimeout）。</p>
<p>所以当遇到 <code>setTimeout/setInterval/Promise.then(fn)/fetch 回调/xhr 网络回调</code>时，react 都是无法控制的<strong>（可以使用手动批处理）</strong>。</p>
<ul>
<li>在setTimeout，Promise.then等异步事件中。setState和useState是同步执行的（立即更新state的结果）</li>
</ul>
</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>react的核心思想是虚拟DOM。react包含了生成虚拟DOM的函数react.createElement，及Component类。而react-dom包的核心功能就是把这些虚拟DOM渲染到文档中变成实际DOM。</p>
<h3 id="原生JS获取Dom"><a href="#原生JS获取Dom" class="headerlink" title="原生JS获取Dom"></a>原生JS获取Dom</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Component</span>&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="comment">//定义获取Dom的函数</span></span><br><span class="line">    <span class="title function_">handleGetDom</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> title = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#title&#x27;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(title);</span><br><span class="line">        title.<span class="property">style</span>.<span class="property">background</span> = <span class="string">&#x27;skyblue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>测试节点<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleGetDom&#125;</span>&gt;</span>点击操作Dom<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a><strong>Ref</strong></h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul>
<li>对Dom元素的焦点控制、内容选择、控制</li>
<li>对Dom元素的内容设置及媒体播放</li>
<li>对Dom元素的操作和对组件实例的操作</li>
<li>集成第三方 DOM 库</li>
</ul>
<h4 id="回调-Ref"><a href="#回调-Ref" class="headerlink" title="回调 Ref"></a>回调 Ref</h4><blockquote>
<p>支持在函数组件和类组件内部使用</p>
</blockquote>
<p>使用<strong>回调 refs</strong>需要将<strong>回调函数</strong>赋值给 React元素 的 ref 属性。这个函数接受 React 组件 或 HTML 元素作为参数，将其挂载到实例属性上</p>
<p>React 会在组件挂载时，调用 <code>ref</code> 回调函数并传入 DOM元素，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，React 会保证 Refs 一定是最新的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setTextInputRef</span> = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">inputRef</span> = ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setSonRef</span> = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">sonInfo</span> = ele;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">inputRef</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">inputRef</span>.<span class="title function_">focus</span>();<span class="comment">//获取input DOM</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sonInfo</span>.<span class="title function_">getSonInfo</span>()<span class="comment">//父组件执行子组件函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.setTextInputRef&#125;/</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.setSonRef&#125;/</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyInput</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">info</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">getSonInfo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, state.<span class="property">info</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;props.inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//函数组件</span><br><span class="line">let tooltipRefs: any = &#123;&#125;;</span><br><span class="line">const Emotion: FC&lt;OnlyProps&gt; = (props) =&gt; &#123;</span><br><span class="line">  const DraggableBox = (&#123; id, index &#125;) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Tooltip</span><br><span class="line">          ref=&#123;ref =&gt; tooltipRefs[key] = ref&#125;</span><br><span class="line">        &gt;</span><br><span class="line">      &lt;/div &gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><blockquote>
<p><strong>支持在类组件中使用</strong></p>
</blockquote>
<h5 id="Refs-API使用"><a href="#Refs-API使用" class="headerlink" title="Refs API使用"></a>Refs API使用</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyInput</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="comment">//分配给实例属性</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">inputRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//通过 this.inputRef.current 获取对该节点的引用</span></span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">inputRef</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">inputRef</span>.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//把 &lt;input&gt; ref 关联到构造函数中创建的 `inputRef` 上</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;/</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ref 的值根据节点的类型而有所不同：</strong></p>
<p>一、当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收<strong>底层 DOM 元素</strong>作为其 current 属性。</p>
<p>二、当 ref 属性用于自定义 class 组件时，ref 对象接收组件的 <strong>挂载实例</strong> 作为其 current 属性。</p>
<p>三、<strong>不能挂载到函数组件上，因为函数组件没有实例（instance）</strong></p>
<p>但是，你可以在函数式组件中使用ref属性，就像你引用DOM元素和类组件一样。</p>
<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p><strong>只能在函数组件中使用</strong></p>
<blockquote>
<p>区别：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/105276393">https://zhuanlan.zhihu.com/p/105276393</a></p>
<p>useRef 用法类似于React.createRef()，区别：</p>
<p><strong>createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。</strong><code>useRef</code> 返回的 ref 对象在组件的<strong>整个生命周期内保持不变</strong>。useRef 不仅仅是用来管理 DOM ref 的，它还相当于 this , 可以存放任何变量。useRef 可以很好的解决闭包带来的不方便性</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">UseRefHookExample</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> inputRef = <span class="title function_">useRef</span>(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">handleClick</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    inputRef.<span class="property">current</span>.<span class="title function_">focus</span>();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      使用 useRef() hook:</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        Click</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useImperativeHandle</span>(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<ul>
<li>通过useImperativeHandle可以<strong>只暴露特定的操作</strong><ul>
<li>通过useImperativeHandle的Hook, 将父组件传入的ref和useImperativeHandle第二个参数返回的对象绑定到了一起</li>
<li>所以在父组件中, 调用inputRef.current时, 实际上是返<strong>回的对象</strong></li>
</ul>
</li>
<li>useImperativeHandle使用简单总结:<ul>
<li>作用: 减少暴露给父组件获取的DOM元素属性, 只暴露给父组件需要用到的DOM方法</li>
<li>参数1: 父组件传递的ref属性</li>
<li>参数2: 返回一个对象, 以供给父组件中通过ref.current调用该对象中的方法</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useRef, forwardRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">JMInput</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>()</span><br><span class="line">  <span class="comment">// 作用: 减少父组件获取的DOM元素属性,只暴露给父组件需要用到的DOM方法</span></span><br><span class="line">  <span class="comment">// 参数1: 父组件传递的ref属性</span></span><br><span class="line">  <span class="comment">// 参数2: 返回一个对象,父组件通过ref.current调用对象中方法</span></span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">focus</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.<span class="property">current</span>.<span class="title function_">focus</span>()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">ImperativeHandleDemo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// useImperativeHandle 主要作用:用于减少父组件中通过forward+useRef获取子组件DOM元素暴露的属性过多</span></span><br><span class="line">  <span class="comment">// 为什么使用: 因为使用forward+useRef获取子函数式组件DOM时,获取到的dom属性暴露的太多了</span></span><br><span class="line">  <span class="comment">// 解决: 使用uesImperativeHandle解决,在子函数式组件中定义父组件需要进行DOM操作,减少获取DOM暴露的属性过多</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = <span class="title function_">useRef</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> inputRef.current.focus()&#125;&gt;聚焦<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">JMInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; forwardRef, useImperativeHandle, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TestRef</span> = <span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="title function_">open</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;open&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TestRef</span> = (<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ref &#125; = props;</span><br><span class="line">  <span class="title function_">useImperativeHandle</span>(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="title function_">open</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;open&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span> () &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = <span class="title function_">useRef</span>()</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.<span class="property">current</span>.<span class="title function_">open</span>()</span><br><span class="line">  &#125;,[])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>石小阳<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TestRef</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">TestRef</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure>

<h4 id="forwardRef-转发-传递"><a href="#forwardRef-转发-传递" class="headerlink" title="forwardRef 转发/传递"></a>forwardRef 转发/传递</h4><p>React.forwardRef是转发ref 获取组件内的DOM节点 ，</p>
<p>以下两种场景中特别有用：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">转发 refs 到 DOM 组件</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyInput</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Form</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = <span class="title class_">React</span>.<span class="title function_">useRef</span>(<span class="literal">null</span>);<span class="comment">//class组件用createRef</span></span><br><span class="line">    <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(inputRef.<span class="property">current</span>);<span class="comment">//input节点</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用 <code>React.useRef</code> 创建了一个 <code>React ref</code> 并将其赋值给 <code>ref</code> 变量。</li>
<li>指定 <code>ref</code> 为JSX属性，并向下传递 <code>&lt;MyInput ref=&#123;inputRef&#125;&gt;</code></li>
<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code> 作为其第二个参数。</li>
<li>向下转发该 <code>ref</code> 参数到 <code>&lt;button ref=&#123;ref&#125;&gt;</code>，将其指定为JSX属性</li>
<li>当 <code>ref</code> 挂载完成，<code>inputRef.current</code> 指向 <code>input</code> DOM节点</li>
</ol>
</li>
<li><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components">在高阶组件中转发 refs</a></p>
</li>
</ul>
<h3 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h3><p>当组件加载到页面上之后（mounted），你都可以通过 <code>react-dom</code> 提供的 <code>findDOMNode()</code> 方法拿到组件对应的 DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; findDOMNode &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside Component class</span></span><br><span class="line"><span class="title function_">componentDidMound</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>findDOMNode()</code> 不能用在无状态组件上。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li><p>react 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p>
</li>
<li><p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p>
</li>
<li><p>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Toggle</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.<span class="property">isToggleOn</span></span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 JavaScript 中，class 的方法默认不会<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>
<p><strong>绑定this：</strong></p>
<ul>
<li><p>在constructor中用bind绑定</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>回调中使用箭头函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&#x27;this is:&#x27;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 此语法确保 `handleClick` 内的 `this` 已被绑定。</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="组件渲染机制"><a href="#组件渲染机制" class="headerlink" title="组件渲染机制"></a>组件渲染机制</h3><p><code>Component</code>在 <code>state</code>改变,<code>props</code>改变,调用<code>this.setState(&#123;...&#125;)</code>，的时候都会进行渲染</p>
<ul>
<li><p>强制React组件重新渲染</p>
<p><strong>使用React的<code>forceUpdate</code>函数</strong></p>
<p>这是一个最明显的方式。在React类组件中，你可以通过调用这个方法，强制重渲染一个组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>();</span><br></pre></td></tr></table></figure>

<p><strong>在React hooks中强制更新组件</strong></p>
<p>在React hooks中，<code>forceUpdate</code>函数是无法使用的。你可以使用如下方式强制更新组件，并且不更改组件的state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, updateState] = <span class="title class_">React</span>.<span class="title function_">useState</span>();</span><br><span class="line"><span class="keyword">const</span> forceUpdate = <span class="title class_">React</span>.<span class="title function_">useCallback</span>(<span class="function">() =&gt;</span> <span class="title function_">updateState</span>(&#123;&#125;), []);</span><br></pre></td></tr></table></figure></li>
<li><p><code>shouldComponentUpdate</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>) &#123;    </span><br><span class="line">    <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">name</span> === nextState.<span class="property">name</span>) &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>    </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过memo来判断指定的参数变化更新组件</p>
</li>
<li><p><strong>componentWillReciveProps</strong></p>
</li>
</ul>
<h3 id="状态组件"><a href="#状态组件" class="headerlink" title="状态组件"></a>状态组件</h3><h4 id="状态组件对比"><a href="#状态组件对比" class="headerlink" title="状态组件对比"></a>状态组件对比</h4><p>使用 function 创建的组件，叫做【无状态组件】；使用 class 创建的组件，叫做【有状态组件】</p>
<ul>
<li>使用 function 构造函数创建的组件，内部没有 state 私有数据，只有一个props来接收外界传递过来的数据</li>
<li>使用 class创建的组件，内部，除了有 this.props 这个只读属性之外，还有一个 专门用于 存放自己私有数据的this.state 属性，这个 state 是可读可写的！</li>
</ul>
<p>有状态组件和无状态组件，最本质的区别：</p>
<ul>
<li><p>有无 state 属性；</p>
</li>
<li><p>class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数；</p>
</li>
</ul>
<p>问题来了：什么时候使用 有状态组件，什么时候使用无状态组件呢？？？</p>
<ol>
<li>如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件；</li>
<li>如果一个组件，只需要根据外界传递过来的 props，渲染固定的 页面结构就完事儿了，此时，非常适合使用 function 创建出来的 无状态组件；（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一丢丢）</li>
</ol>
<h4 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h4><p><strong>用class关键字创建出来的组件：“有状态组件”</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 class 创建的类，通过 extends 关键字，继承了 React.Component 之后，这个类，就是一个组件的模板了</span></span><br><span class="line"><span class="comment">// 如果想要引用这个组件，可以把 类的名称， 以标签形式，导入到 JSX 中使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">Hello2</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="comment">// 注意： 如果使用 extends 实现了继承，那么在 constructor 的第一行，一定要显示调用一下 super()</span></span><br><span class="line">    <span class="comment">//  super() 表示父类的构造函数</span></span><br><span class="line">    <span class="variable language_">super</span>(props)</span><br><span class="line">    <span class="comment">// 在 constructor 中，如果想要访问 props 属性，不能直接使用 this.props， 而是需要在 constructor 的构造器参数列表中，显示的定义 props 参数来接收，才能正常使用；</span></span><br><span class="line">    <span class="comment">// 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data()&#123; return &#123;&#125; &#125; 函数  </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;这是 Hello2 组件的私有msg数据&#x27;</span>,</span><br><span class="line">      <span class="attr">info</span>: <span class="string">&#x27;瓦塔西***&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存信息1： No `render` method found on the returned component instance: you may have forgotten to define `render`.</span></span><br><span class="line">  <span class="comment">// 通过分析以上报错，发现，提示我们说，在 class 实现的组件内部，必须定义一个 render 函数</span></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 报错信息2： Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.</span></span><br><span class="line">    <span class="comment">// 通过分析以上报错，发现，在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然在 React dev tools 中，并没有显示说 class 组件中的 props 是只读的，但是，经过测试得知，其实 只要是 组件的 props，都是只读的；</span></span><br><span class="line">    <span class="comment">// this.props.address = &#x27;123&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是 使用 class 类创建的组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>外界传递过来的数据是： &#123;this.props.address&#125; --- &#123;this.props.info&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h5</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      //React中，提供的事件绑定机制，使用的 都是驼峰命名</span></span><br><span class="line"><span class="language-xml">      //     在为 React 事件绑定 处理函数的时候，需要通过 this.函数名， 来把 函数的引用交给 事件 </span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改 msg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnChangeMsg&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeMsg = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意： 这里不是传统网页，所以 React 已经帮我们规定死了，在 方法中，默认this 指向 undefined，并不是指向方法的调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 this.state.msg = &#x27;123&#x27; 为 state 上的数据重新赋值，可以修改 state 中的数据值，但是，页面不会被更新；</span></span><br><span class="line">    <span class="comment">// 所以这种方式，React 不推荐，以后尽量少用；</span></span><br><span class="line">    <span class="comment">// 如果要为 this.state 上的数据重新赋值，那么，React 推荐使用 this.setState(&#123;配置对象&#125;) 来重新为 state 赋值</span></span><br><span class="line">    <span class="comment">// 注意： this.setState 方法，只会重新覆盖那些 显示定义的属性值，如果没有提供最全的属性，则没有提供的属性值，不会被覆盖；</span></span><br><span class="line">    <span class="comment">/* this.setState(&#123;</span></span><br><span class="line"><span class="comment">      msg: &#x27;123&#x27;</span></span><br><span class="line"><span class="comment">    &#125;) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.setState 方法，也支持传递一个 function，如果传递的是 function，则在 function 内部，必须return 一个 对象；</span></span><br><span class="line">    <span class="comment">// 在 function 的参数中，支持传递两个参数，其中，第一个参数是 prevState，表示为修改之前的 老的 state 数据</span></span><br><span class="line">    <span class="comment">// 第二个参数，是 外界传递给当前组件的 props 数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="keyword">function</span> (<span class="params">prevState, props</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// 由于 this.setState 是异步执行的，所以，如果想要立即拿到最新的修改结果，最保险的方式， 在回调函数中去操作最新的数据</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">msg</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数/无状态组件是一个纯函数，它可接受接受参数，并返回react元素。这些都是没有任何副作用的纯函数。这些组件没有状态或生命周期方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组件的首字母必须是大写</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Hello</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">// 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；</span></span><br><span class="line">  <span class="comment">// 通过 props 得到的任何数据都是只读的，不能从新赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是在Hello组件中定义的元素 --- &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><h4 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h4><h5 id="shouldComponentUpdate模拟"><a href="#shouldComponentUpdate模拟" class="headerlink" title="shouldComponentUpdate模拟"></a>shouldComponentUpdate模拟</h5><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/deng1456694385/article/details/88746797">https://blog.csdn.net/deng1456694385/article/details/88746797</a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> extent <span class="title class_">Component</span> &#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的组件会在<code>this.setState</code>调用后就会重新传染一次,但是我们可以看出<code>name</code>状态并没有没被我们用到,也没有改变,这种渲染就是无效渲染,所以为了优化我们通常会使用钩子函数<code>shouldComponentUpdate</code>来做一些逻辑判断,来确定是否要重新<code>render</code>一次</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> extent <span class="title class_">Component</span> &#123;    </span><br><span class="line">    state = &#123;        </span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;	</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>) &#123;    </span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">name</span> === nextState.<span class="property">name</span>) &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>    </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	render &lt;div&gt;haha&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以避免无效渲染,优化性能,但是如果这种判断逻辑多到一定程度,光判断逻辑就很复杂,而且每次都要判断也会影响性能,所以才有了 <code>PureComponent</code>，**<code>PureComponent</code>的区别在于相当于自己写了一个<code>shouldComponentUpdate</code>钩子函数处理, 对<code>props</code>和<code>state</code>进行浅比较,所谓浅比较就是之比较内部第一层的各个属性的值是否相同,像对象和数组这种数据类型,如果只改变内部的元素,就不会造成渲染**</p>
<h5 id="PureComponent的浅比较"><a href="#PureComponent的浅比较" class="headerlink" title="PureComponent的浅比较"></a><strong>PureComponent的浅比较</strong></h5><p>浅比较通过一个<code>shallowEqual</code>函数来完成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">is</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): boolean &#123;</span><br><span class="line">  <span class="comment">// 首先对基本数据类型的比较</span></span><br><span class="line">  <span class="comment">// !! 若是同引用便会返回 true</span></span><br><span class="line">  <span class="comment">//其中is函数是自己实现的一个Object.is的功能，排除了===两种不符合预期的情况：</span></span><br><span class="line">  <span class="comment">// +0 === -0  // true</span></span><br><span class="line">  <span class="comment">// NaN === NaN // false</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">is</span>(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object</span></span><br><span class="line">  <span class="comment">// 之后，就可以返回false了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">&#x27;object&#x27;</span> || objA === <span class="literal">null</span> || <span class="keyword">typeof</span> objB !== <span class="string">&#x27;object&#x27;</span> || objB === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 过滤掉基本数据类型之后，就是对对象的比较了</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="title class_">Object</span>.<span class="title function_">keys</span>(objB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先拿出key值，对key的长度进行对比</span></span><br><span class="line">  <span class="keyword">if</span> (keysA.<span class="property">length</span> !== keysB.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key相等的情况下，在去循环比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// key值相等的时候</span></span><br><span class="line">    <span class="comment">// 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值</span></span><br><span class="line">    <span class="comment">// 属性的顺序不影响结果也就是&#123;name:&#x27;daisy&#x27;, age:&#x27;24&#x27;&#125; 跟&#123;age:&#x27;24&#x27;，name:&#x27;daisy&#x27; &#125;是一样的</span></span><br><span class="line">    <span class="comment">// 最后，对对象的value进行一个基本数据类型的比较，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!hasOwnProperty.<span class="title function_">call</span>(objB, keysA[i]) || !<span class="title function_">is</span>(objA[keysA[i]], objB[keysA[i]])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Component-vs-PureComponent-总结"><a href="#Component-vs-PureComponent-总结" class="headerlink" title="Component vs PureComponent 总结"></a><strong>Component vs PureComponent 总结</strong></h5><p>PureComponent相较于Component区别就是,对props和state默认进行判断来确定是否渲染,从而减少无效渲染次数. 大部分情况下直接用PureComponent比较好可以提高性能,但是如果遇到需要频繁修改值重新渲染的组件,用Component比较好,因为PureComponent频繁的判断也会影响性能.</p>
<h4 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h4><p><strong>针对函数组件的</strong>,减少组件的不必要更新。 <code>React.memo</code> 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-state.html"><code>useState</code></a>，<a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a> 或 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TextCell</span> = <span class="title function_">memo</span>(<span class="keyword">function</span>(<span class="params">props:any</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我重新渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;props.click&#125;</span>&gt;</span>ffff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fatherComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> [number,setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      模块&#123;number&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TextCell</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setNumber(number =&gt; number + 1)&#125;&gt;加加加<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里如果没有用到memo 每次父组件重新setNumber,子组件都会重新渲染一次,加上了后<strong>只会在初始化的时候渲染(useMemo会在页面初始化的时候执行一次,并把执行的结果缓存一份)</strong>,减少了子组件渲染的次数</p>
<p>默认情况下其只会对复杂对象做<strong>浅层对比</strong>，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">areEqual</span>(<span class="params">prevProps, nextProps</span>) &#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">MyComponent</span>, areEqual);</span><br></pre></td></tr></table></figure>

<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>无论是函数组件还是类组件，return 的 React 元素的语法必须是由一个标签包裹起来的所有虚拟 DOM 内容</p>
<p>一种是使用一个 div 标签将其包裹起来，另外一种方式就是使用 React 提供的 <code>&lt;React.Fragment&gt;</code> 将其包裹起来。但是我们不期望，增加额外的<code>dom</code>节点，所以<code>react</code>提供<code>Fragment</code>碎片概念，能够让一个组件返回多个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      Some text.</span><br><span class="line">      &lt;h2&gt;A heading&lt;/h2&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h4><p>适用于父子组件通信</p>
<h5 id="父组件-gt-子组件"><a href="#父组件-gt-子组件" class="headerlink" title="父组件-&gt;子组件"></a>父组件-&gt;子组件</h5><p>父组件将需要传递的参数通过<code>key=&#123;xxx&#125;</code>方式传递至子组件，子组件通过<code>this.props.key</code>获取参数.</p>
<h5 id="子组件-gt-父组件"><a href="#子组件-gt-父组件" class="headerlink" title="子组件-&gt;父组件"></a>子组件-&gt;父组件</h5><p>利用 props callback 通信，父组件传递一个 callback 到子组件，当事件触发时将参数放置到 callback 带回给父组件.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import Son from &#x27;./son&#x27;</span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: &#x27;&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">  callback = (value) =&gt; &#123;</span><br><span class="line">    // 此处的value便是子组件带回</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      info: value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.info&#125;&lt;/p&gt;</span><br><span class="line">        &lt;Son callback=&#123;this.callback&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Father</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  callback: (string) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line">class Son extends React.Component&lt;IProps&gt; &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.handleChange = this.handleChange.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    // 在此处将参数带回</span><br><span class="line">    this.props.callback(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&#x27;text&#x27; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Son</span><br></pre></td></tr></table></figure>

<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/context.html">https://zh-hans.reactjs.org/docs/context.html</a></p>
<p>数据是通过 props 属性自上而下（由父及子）进行传递的 ，需要显式地通过组件树的逐层传递 props。Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//创建一个 Context 对象，并暴露Consumer和Provide</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Consumer</span>, <span class="title class_">Provider</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="literal">null</span>) </span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">Consumer</span>, <span class="title class_">Provider</span> &#125;</span><br><span class="line"><span class="comment">//Father</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Son</span> <span class="keyword">from</span> <span class="string">&#x27;./son&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Provider</span> value=&#123;<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">info</span>&#125;&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.info&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Provider</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Son</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">GrandSon</span> <span class="keyword">from</span> <span class="string">&#x27;./grandson&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Consumer</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line">&lt;<span class="title class_">Consumer</span>&gt;</span><br><span class="line">&#123;<span class="function">(<span class="params">info</span>) =&gt;</span> (</span><br><span class="line"><span class="comment">// 通过Consumer直接获取父组件的值</span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件的值:&#123;info&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">GrandSon</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">&lt;/<span class="title class_">Consumer</span>&gt;</span><br></pre></td></tr></table></figure>

<p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。从 Provider 到其内部 consumer 组件（包括 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/context.html#classcontexttype">.contextType</a> 和 <a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">useContext</a>）的传播不受制于  <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。 </p>
<h2 id="高阶函数与组件"><a href="#高阶函数与组件" class="headerlink" title="高阶函数与组件"></a>高阶函数与组件</h2><p>高阶组件即<code>高阶函数</code>，前面我们讲到，React遵循函数式开发，而高阶组件这个概念其实是React社区繁衍出来的概念。</p>
<p>在这里我们要谨记这一句话，<strong>组件 = 函数</strong>。</p>
<blockquote>
<p>高阶函数，通俗的讲，就是把函数当作参数，传入另外一个函数当中，再返回一个函数。</p>
</blockquote>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a><strong>实际应用场景</strong></h3><h4 id="权限按钮"><a href="#权限按钮" class="headerlink" title="权限按钮"></a>权限按钮</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; useAccess &#125; from &#x27;../../../hooks/useAccess&#x27;;</span><br><span class="line">import &#123; message &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 权限高阶组件，使用示例：</span><br><span class="line"> * </span><br><span class="line"> * import WithAccess from &#x27;@components/WithAccess&#x27;;</span><br><span class="line"> * </span><br><span class="line"> * const WithAccessBtn = WithAccess(你的组件, 可选&#x27;button&#x27; | &#x27;menu&#x27; 默认为button);</span><br><span class="line"> * </span><br><span class="line"> * &lt;WithAccessBtn permission=&#x27;permission&#x27; /&gt;</span><br><span class="line"> * </span><br><span class="line"> * @param Comp 组件</span><br><span class="line"> * @param type 鉴权类型 按钮：button，菜单：menu</span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">const WithAccess = (Comp, type = &#x27;button&#x27;) =&gt; &#123;</span><br><span class="line">  const Access = props =&gt; &#123;</span><br><span class="line">    const &#123; getPermission &#125; = useAccess();</span><br><span class="line">    const &#123; permission, name, icon, onClick &#125; = props;</span><br><span class="line">    //showVisible是否展示, available是否有权限</span><br><span class="line">    const &#123; showVisible, available &#125; = getPermission(permission, type) || &#123;&#125;;</span><br><span class="line">    let initProps = props</span><br><span class="line">    console.log(props);</span><br><span class="line">    const config = () =&gt; &#123;</span><br><span class="line">      if (available === 0) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          onClick: () =&gt; &#123;</span><br><span class="line">            message.info(&#x27;按钮没有权限&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return showVisible ? &lt;Comp &#123;...initProps&#125; &#123;...config()&#125;&gt;&#123;name&#125;&lt;/Comp&gt; : null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Access;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default WithAccess;</span><br></pre></td></tr></table></figure>

<p>使用高阶组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import usePermissionModel from &quot;../../hox/access&quot;;</span><br><span class="line">import WithAccess from &#x27;./components&#x27;</span><br><span class="line">import &#123; Button, message &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; LaptopOutlined &#125; from &quot;@ant-design/icons&quot;;</span><br><span class="line"></span><br><span class="line">const WithAccessBtnYes = WithAccess(Button)</span><br><span class="line">const WithAccessBtnNo = WithAccess(Button)</span><br><span class="line">export default function AHooks(props) &#123;</span><br><span class="line">  const &#123; menus, set &#125; = usePermissionModel();</span><br><span class="line">  console.log(menus, set)</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;WithAccessBtnYes permission=&#x27;account:authorization:yes&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnYes&gt;</span><br><span class="line">    &lt;WithAccessBtnNo permission=&#x27;account:authorization:no&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnNo&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hooks函数"><a href="#Hooks函数" class="headerlink" title="Hooks函数"></a>Hooks函数</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html">http://www.ruanyifeng.com/blog/2019/09/react-hooks.html</a></p>
<ul>
<li>纯函数组件<strong>没有状态</strong></li>
<li>纯函数组件<strong>没有生命周期</strong></li>
<li>纯函数组件没有<code>this</code></li>
</ul>
<p>这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，我们不得不用类组件或者redux，但我们知道类组件的也是有缺点的，比如，遇到简单的页面，你的代码会显得很重，并且每创建一个类组件，都要去继承一个React实例，至于Redux,更不用多说，很久之前Redux的作者就说过，“能用React解决的问题就不用Redux”,等等一系列的话。关于<strong>React类组件r</strong>edux的作者又有话说</p>
<blockquote>
<ul>
<li>大型组件很难拆分和重构，也很难测试。</li>
<li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li>
<li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li>
</ul>
</blockquote>
<p><strong>Hooks 优势</strong></p>
<ol>
<li>能优化类组件的三大问题</li>
<li>能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</li>
<li>能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
</ol>
<p><strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。</strong>而React Hooks 就是我们所说的“钩子”。</p>
<h2 id="useState-状态钩子"><a href="#useState-状态钩子" class="headerlink" title="useState():状态钩子"></a>useState():状态钩子</h2><p>用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//useState模拟1.0</span></span><br><span class="line"><span class="comment">//因为每次调用myUseState时会重置state的值。经过改进，必须将state写在函数的外面。</span></span><br><span class="line"><span class="keyword">let</span> _state;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myUseState</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  _state = _state===<span class="literal">undefined</span>? <span class="attr">initialValue</span>:_state;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setState</span> = (<span class="params">newValue</span>) =&gt; &#123;</span><br><span class="line">    _state = newValue; <span class="comment">//更新state值，</span></span><br><span class="line">    <span class="title function_">render</span>(); <span class="comment">//触发重新渲染</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 粗糙的渲染 */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用myUseState</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = <span class="title function_">myUseState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">classNam</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		 <span class="tag">&lt;<span class="name">p</span>&gt;</span>n:&#123;n&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		 <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setN(n+1)&#125;&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个组件用了两个useState怎么办？useState模拟2.0</span></span><br><span class="line"><span class="keyword">let</span> _state=[];</span><br><span class="line"><span class="keyword">let</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myUseState</span>(<span class="params">initialValue</span>) &#123;</span><br><span class="line">  int currentIndex=index;	<span class="comment">//引入中间变量currentIndex就是为了保存当前操作的下标index。</span></span><br><span class="line">  _state[currentIndex] = _state[currentIndex]===<span class="literal">undefined</span>? <span class="attr">initialValue</span>:_state[currentIndex];</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">setState</span> = (<span class="params">newValue</span>) =&gt; &#123;</span><br><span class="line">    _state[currentIndex] = newValue; </span><br><span class="line">    <span class="title function_">render</span>(); </span><br><span class="line">  &#125;;</span><br><span class="line">  index+=<span class="number">1</span>;<span class="comment">// 每次更新完state值后，index值+1</span></span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">render</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  index=<span class="number">0</span>;	<span class="comment">//重要的一步，必须在渲染前后将index值重置为0，不然index会一种增加1</span></span><br><span class="line">  <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用myUseState</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = <span class="title function_">myUseState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = <span class="title function_">myUseState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">classNam</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		 <span class="tag">&lt;<span class="name">p</span>&gt;</span>n:&#123;n&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		 <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setN(n+1)&#125;&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">		 <span class="tag">&lt;<span class="name">p</span>&gt;</span>m:&#123;m&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		 <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setM(m+1)&#125;&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="language-xml">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在正常的react的事件流里（如onClick等）</p>
<ul>
<li><p>setState和useState是<strong>异步执行</strong>的（不会立即更新state的结果，所以console数据没有更新）</p>
</li>
<li><p>多次执行setState和useState，只会调用一次重新渲染render</p>
</li>
<li><p>不同的是，setState会进行state的合并，而useState会进行state的覆盖</p>
</li>
</ul>
</li>
<li><p>在setTimeout，Promise.then等异步事件中</p>
<ul>
<li><p>setState和useState是<strong>同步执行</strong>的（立即更新state的结果，<strong>react17之后还是会批处理</strong>）</p>
</li>
<li><p>多次执行setState和useState，每一次的执行setState和useState，都会调用一次render</p>
</li>
</ul>
</li>
</ul>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a><strong>批处理</strong></h3><p>batch批量处理：在每次执行 useState 的时候，组件都要重新 render 一次，会造成无效渲染，浪费时间（因为最后一次渲染会覆盖掉前面所有的渲染效果）。 所以 react 会把一些可以一起更新的 useState/setState 放在一起，只渲染一次。</p>
<p>在React16版本及以前，React 会对所有React内部触发的事件监听函数中的更新（比如onClick函数）做批处理，如果是绕过react组件，如addEventListenr，或者异步调用如异步请求或者setTimeout等，不会进行批处理。在React17版本及之后，React会对所有的更新做批处理。</p>
<p><strong>unstable_batchedUpdates手动批处理</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick3</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 手动批处理</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">unstable_batchedUpdates</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setCount1</span>(count1 + <span class="number">1</span>);</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(count1);</span><br><span class="line">      <span class="title function_">setFlag</span>(<span class="function">(<span class="params">f</span>) =&gt;</span> !f);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">// React 只会在最后重新渲染一次（这是批处理！）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul>
<li><p>react中useState更新了组件，但是页面上的组件没有刷新</p>
<p>原因：useState更新的数据，是一个多层次的数据，<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=react">react</a>监听的时候，是浅层监听(默认开启 类 Object.is 的浅层比较，所以指向的地址不变)，所以不一定及时刷新页面</p>
<p>解决办法:深拷贝，把需要更新的数据深拷贝一份，再使用useState 存储，就能实现每次都及时更新页面</p>
</li>
</ul>
<h2 id="useContext-共享状态钩子"><a href="#useContext-共享状态钩子" class="headerlink" title="useContext():共享状态钩子"></a>useContext():共享状态钩子</h2><p>如果需要在层层组件之间共享状态，可以使用<code>useContext()</code>。</p>
<p>第一步就是使用 React Context API，在组件外部建立一个 Context。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">AppContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>组件封装代码如下。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line"><span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">&lt;<span class="title class_">AppContext</span>.<span class="property">Provider</span> value=&#123;&#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&#x27;superawesome&#x27;</span></span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">Messages</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">AppContext</span>.<span class="property">Provider</span>&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>AppContext.Provider</code>提供了一个 Context 对象，这个对象可以被子组件共享。</p>
<p>Navbar 组件的代码如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Navbar</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = <span class="title function_">useContext</span>(<span class="title class_">AppContext</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>AwesomeSite<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="useReducer-钩子"><a href="#useReducer-钩子" class="headerlink" title="useReducer()钩子"></a>useReducer()钩子</h2><p><strong>useReducer适用于引用类型，而useState适合值类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>useReducer 接收三个参数，<strong>第一个参数为一个 reducer 函数，第二个参数是reducer的初始值，第三个参数为可选参数，值为一个函数，可以用来惰性提供初始状态。</strong></p>
<p>reducer 接受两个参数一个是 state 另一个是 action ，用法原理和 redux 中的 reducer 一致</p>
</li>
<li><p>useReducer 返回一个数组，数组中包含一个 state 和 dispath，state 是返回状态中的值，而 dispatch 是一个可以发布事件来更新 state 的函数。</p>
</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>useReucer 也是 useState 的内部实现</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedState</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useReducer</span>(<span class="params">reducer, initialArg, init</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> initState = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> init === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        initState = <span class="title function_">init</span>(initialArg)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initState = initialArg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">action</span>) &#123;</span><br><span class="line">        memoizedState = <span class="title function_">reducer</span>(memoizedState, action)</span><br><span class="line">        <span class="comment">// React的渲染</span></span><br><span class="line">        <span class="comment">// render()</span></span><br><span class="line">    &#125;</span><br><span class="line">    memoizedState = memoizedState || initState</span><br><span class="line">    <span class="keyword">return</span> [memoizedState, dispatch]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useState</span>(<span class="params">initState</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">useReducer</span>(<span class="function">(<span class="params">oldState, newState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> newState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_">newState</span>(oldState)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newState</span><br><span class="line">    &#125;, initState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reducer</span>(<span class="params">state, action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Counter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = <span class="title function_">useReducer</span>(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p>纯函数只能进行数据计算，那些不涉及计算的操作（比如ajax 请求、访问原生dom 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志）应该写在哪里呢？</p>
<p>函数式编程将那些跟数据计算无关的操作，都称为 “<strong>副效应</strong>“ <strong>（side effect）</strong> 。</p>
<p><code>useEffect()</code>用来引入具有副作用的操作，最常见的就是向服务器请求数据。可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p>
<p><strong><code>useEffect()</code>的用法如下：</strong></p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()  =&gt;</span>  &#123;</span><br><span class="line">    <span class="comment">// Async Action</span></span><br><span class="line">    <span class="comment">//return 则是在页面被卸载时调用.返回一个函数来指定如何“清除”副作用</span></span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面用法中，<code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p>
<p><strong>它的常见用途有下面几种：</strong></p>
<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
<p><strong>tips</strong></p>
<ul>
<li><p><strong>它在第一次渲染之后<em>和</em>每次更新之后都会执行</strong></p>
</li>
<li><p>使用<code>useEffect()</code>时，有一点需要注意。如果有多个副效应，应该调用多个<code>useEffect()</code>，而不应该合并写在一起。</p>
</li>
<li><p>在useEffect中，不仅会请求后端的数据，还会通过调用setData来更新本地的状态，这样会触发view的更新。</p>
<p>但是，运行这个程序的时候，会出现无限循环的情况。useEffect在组件<strong>mount</strong>时执行，但也会在组件<strong>更新</strong>时执行。因为我们在每次请求数据之后都会设置本地的状态，所以组件会更新，因此useEffect会再次执行，因此出现了无限循环的情况。<strong>我们只想在组件mount时请求数据。</strong>我们可以传递一个空数组作为useEffect的第二个参数，这样就能避免在组件更新执行useEffect，只会在组件mount时执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(</span><br><span class="line">      <span class="string">&#x27;http://localhost/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ))&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure>

<p>升级加载loading </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Fragment</span>, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title function_">useState</span>(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = <span class="title function_">useState</span>(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = <span class="title function_">useState</span>(</span><br><span class="line">    <span class="string">&#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = <span class="title function_">useState</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fetchData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="title function_">setIsLoading</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> <span class="title function_">axios</span>(url);</span><br><span class="line"></span><br><span class="line">      <span class="title function_">setData</span>(result.<span class="property">data</span>);</span><br><span class="line">      <span class="title function_">setIsLoading</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">fetchData</span>();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;query&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> setQuery(event.target.value)&#125;</span></span><br><span class="line"><span class="language-xml">      /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="language-xml">          setUrl(`http://localhost/api/v1/search?query=$&#123;query&#125;`)</span></span><br><span class="line"><span class="language-xml">        &#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        Search</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      &#123;isLoading ? (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      ) : (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="useCallback和useMemo"><a href="#useCallback和useMemo" class="headerlink" title="useCallback和useMemo"></a>useCallback和useMemo</h2><p><a target="_blank" rel="noopener" href="https://www.xiaye0.com/?p=113">https://www.xiaye0.com/?p=113</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/014ee0ebe959">https://www.jianshu.com/p/014ee0ebe959</a></p>
<p><strong>useCallback和useMemo</strong>都会在组件第一次渲染的时候执行，之后会在其<strong>依赖的变量</strong>发生改变时再次执行；并且这两个hooks都返回<strong>缓存</strong>，<strong>useMemo返回缓存的变量，useCallback返回缓存的函数。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type <span class="title class_">DependencyList</span> = <span class="title class_">ReadonlyArray</span>&lt;any&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> useCallback&lt;T <span class="keyword">extends</span> (...<span class="attr">args</span>: any[]) =&gt; any&gt;(<span class="attr">callback</span>: T, <span class="attr">deps</span>: <span class="title class_">DependencyList</span>): T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> useMemo&lt;T&gt;(<span class="attr">factory</span>: <span class="function">() =&gt;</span> T, <span class="attr">deps</span>: <span class="title class_">DependencyList</span> | <span class="literal">undefined</span>): T;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>React 中当组件的 props 或 state 变化时，会重新渲染视图</strong></p>
</blockquote>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>父组件给子组件传递属性（<strong>函数</strong>），父组件重新渲染，会重新创建函数，对应函数地址改变，即传给子组件的属性发生了变化，导致子组件渲染。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">TextCell</span> = <span class="title function_">memo</span>(<span class="keyword">function</span>(<span class="params">props:any</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;我重新渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;props.click&#125;</span>&gt;</span>ffff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">fatherComponent</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> [number,setNumber] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="title function_">useCallback</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">33</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"> <span class="keyword">return</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      模块&#123;number&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">TextCell</span> <span class="attr">click</span>=<span class="string">&#123;handleClick&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setNumber(number =&gt; number + 1)&#125;&gt;加加加<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果不使用useCallback,哪怕子组件用memo包裹了 也还是会更新子组件,因为子组件的绑定的函数click在父组件更新的时候也会更新<strong>引用地址</strong>,导致子组件的更新,但是这个其实是没必要的更新,绑定的函数并不需要子组件更新,useCallback就是阻止这类没必要的更新而存在的</p>
<p>这里需要注意的是 如果是有参数需要传递,则需要这样写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">TextCell</span> click=&#123;<span class="title function_">useCallback</span>(<span class="function">()=&gt;</span><span class="title function_">handleClick</span>(‘传递的参数’),[])&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong></p>
<ul>
<li><p>防止死循环</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于记录 getData 调用次数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [val, setVal] = <span class="title function_">useState</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setVal</span>(<span class="string">&quot;new data &quot;</span> + count);</span><br><span class="line">      count++;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">val</span>=<span class="string">&#123;val&#125;</span> <span class="attr">getData</span>=<span class="string">&#123;getData&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Child</span>(<span class="params">&#123;val, getData&#125;</span>) &#123;</span><br><span class="line">  <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">getData</span>();</span><br><span class="line">  &#125;, [getData]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ol>
<li><code>App</code>渲染<code>Child</code>，将<code>val</code>和<code>getData</code>传进去</li>
<li><code>Child</code>使用<code>useEffect</code>获取数据。因为对<code>getData</code>有依赖，于是将其加入依赖列表</li>
<li><code>getData</code>执行时，调用<code>setVal</code>，导致<code>App</code>重新渲染</li>
<li><code>App</code>重新渲染时生成新的<code>getData</code>方法，传给<code>Child</code></li>
<li><code>Child</code>发现<code>getData</code>的引用变了，又会执行<code>getData</code></li>
<li>3 -&gt; 5 是一个死循环</li>
</ol>
</li>
</ul>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>useEventListener</p>
<p>如果你发现自己使用useEffect添加了许多事件监听，那你可能需要考虑将这些逻辑封装成一个通用的hook。</p>
<p>useWhyDidYouUpdate</p>
<p>这个hook让你更加容易观察到是哪一个prop的改变导致了一个组件的重新渲染。</p>
<p>useLockBodyScroll</p>
<p>有时候当一些特别的组件在你们的页面中展示时，你想要阻止用户滑动你的页面（想一想modal框或者移动端的全屏菜单）。</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由是一种向用户显示不同页面的能力。 这意味着用户可以通过输入 URL 或单击页面元素在 WEB 应用的不同部分之间切换</p>
<p>这里需要说明一下 React Router 库中几个不同的 npm 依赖包，每个包都有不同的用途</p>
<table>
<thead>
<tr>
<th>相关组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>react-router</td>
<td>实现了路由的核心功能，用作下面几个包的运行时依赖项(peer dependency)。</td>
</tr>
<tr>
<td>react-router-dom</td>
<td>基于 <code>react-router</code> 添加了浏览器运行环境的一些组件和功能。</td>
</tr>
<tr>
<td>react-router-native</td>
<td>适用于 <code>React Native</code></td>
</tr>
<tr>
<td>react-router-redux</td>
<td>React Router 和 Redux 的集成。</td>
</tr>
<tr>
<td>eact-router-config</td>
<td>提供可配置化的路由</td>
</tr>
</tbody></table>
<h2 id="React-Routers三类组件"><a href="#React-Routers三类组件" class="headerlink" title="React Routers三类组件"></a>React Routers三类组件</h2><h3 id="路由器Router"><a href="#路由器Router" class="headerlink" title="路由器Router"></a>路由器Router</h3><p><code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code>，两者之间的主要区别是它们存储URL和与Web服务器通信的方式。</p>
<h4 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h4><p><code>&lt;BrowserRouter&gt;</code>使用常规的URL路径。但它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面</p>
<p>BrowserRouter提供了如下属性</p>
<ul>
<li><code>basename (string)</code> 当前位置的基准 URL。当应用程序放置于服务器上子目录中时，可以设置，比如 <code>/public</code> 。</li>
<li><code>forceRefresh (boolean)</code>，在导航的过程中整个页面是否刷新</li>
<li><code>getUserConfirmation (func)</code>，当导航需要确认时执行的函数。默认是：window.confirm</li>
<li><code>keyLength (number)</code>  location.key 的长度。默认是 6</li>
<li><code>children (node)</code> 要渲染的子节点</li>
</ul>
<h4 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h4><p><code>&lt;HashRouter&gt;</code>将当前位置存储在<a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">URL</a><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">的<code>hash</code>一部分中</a>，因此URL看起来像<code>http://example.com/#/your/page</code>。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置(<strong>在任意的路由进行页面的刷新都不会是 404</strong>)。</p>
<p>HashRouter提供了如下属性</p>
<ul>
<li><code>basename: string</code>, 同 <code>&lt;BrowserRouter&gt;</code> 的 <code>basename</code>。</li>
<li><code>getUserConfirmation: function</code>, 同 <code>&lt;BrowserRouter&gt;</code> 的 <code>getUserConfirmation</code>。</li>
<li><code>hashType: string</code>, Hash 编码类型，可选值 <code>&#39;slash&#39;(默认) | &#39;noslash&#39; | &#39;hashbang&#39;</code> 。<ul>
<li><code>slash</code>, 创建像 <code>#/</code>, <code>#/user/1</code> 这样的 hash 地址，默认值。</li>
<li><code>noslash</code>, 创建像 <code>#</code>, <code>#user/1</code> 这样的 hash 地址</li>
<li><code>hashbang</code>, 创建像 <code>#!/</code>, <code>#!/user/1</code> 这样的 ajax crawlable(已被 Google 遗弃) 的 hash 地址</li>
</ul>
</li>
<li><code>children: node</code>, 同 <code>&lt;BrowserRouter&gt;</code> 的 <code>children: node</code>。</li>
</ul>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>HashRouter：使用 URL 的哈希值实现</p>
<p>原理：监听 window 的 <code>hashchange</code> 事件来实现的</p>
<p>BrowserRouter（推荐）：使用 H5 的 history.pushState() API 实现</p>
<p>原理：监听 window 的 <code>popstate</code> 事件来实现的</p>
<p>BrowserRouter组件都会创建一个 <code>history</code> 实例对象，它记录了当前的位置，还记录了堆栈中以前的位置。在当前位置发生变化时，页面会被重新渲染，于是你就有一种导航跳转的感觉。</p>
<p>那么如何改变当前的位置呢？也就是说如何做到<strong>导航跳转</strong>呢？这时候 <code>history</code> 的作用就来了，这个对象暴露了一些方法，比如 <code>history.push</code> 和 <code>history.replace</code> ，它们就可以拿来处理上面的问题。</p>
<p>当你点击一个 <code>&lt;Link&gt;</code> 组件时，<code>history.push</code> 就会被调用，而当你使用一个 <code>&lt;Redirect&gt;</code> 组件时，<code>history.replace</code> 就会被调用。其它的方法比如 <code>history.Back</code> 和 <code>history.Forward</code> 可以用来在历史堆栈中回溯或前进。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p><strong>basename: string</strong></p>
<p>原因是：ngix服务器上面要放不止一个网站 根目录下面已经有一个网站，这个网站需单独建一个文件夹。</p>
<p>作用：为所有位置添加一个基准URL<br>使用场景：假如你需要把页面部署到服务器的二级目录，你可以使用 <code>basename</code> 设置到此目录。</p>
</li>
</ul>
<h3 id="路线匹配器Route"><a href="#路线匹配器Route" class="headerlink" title="路线匹配器Route"></a>路线匹配器Route</h3><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/76ee90125e9f">https://www.jianshu.com/p/76ee90125e9f</a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">	<span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> onRemoveItem(item)&#125;&gt;Dismiss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleRemoveItem&#125;</span>&gt;</span>Dismiss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例。</p>
<p>当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。</p>
<p>因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。</p>
<h5 id="三种渲染方式"><a href="#三种渲染方式" class="headerlink" title="三种渲染方式"></a><strong>三种渲染方式</strong></h5><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ypSharing/p/15587340.html">https://www.cnblogs.com/ypSharing/p/15587340.html</a></p>
<p><strong>优先级是 children &gt; component &gt; render。</strong> </p>
<ul>
<li><p><code>&lt;Route component&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> exact path=<span class="string">&quot;/home&quot;</span> component=&#123;<span class="title class_">Home</span>&#125; /&gt;   <span class="comment">//推荐</span></span><br><span class="line">或</span><br><span class="line">&lt;<span class="title class_">Route</span> exact path=<span class="string">&quot;/home&quot;</span> component=&#123;<span class="function">()=&gt;</span><span class="language-xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>&#125; /&gt; <span class="comment">// 内联函数</span></span><br></pre></td></tr></table></figure>

<p>参数：对象<code>&lt;Route path=&#39;/home&#39; component=&#123;home&#125;/&gt;</code></p>
<ul>
<li>直接使用组件类–使用最多的方式</li>
<li>缺点：不能把父组件中的数据通过props传递给路由组件中</li>
</ul>
<p>参数：函数<code>&lt;Route path=&#39;/home&#39; component=&#123;()=&gt;&lt;home/&gt;&#125; /&gt;</code></p>
<ul>
<li><p>使用函数，可以写条件判断，根据条件来渲染不同的组件</p>
</li>
<li><p>可以通过props来完成父组件中的数据向路由渲染组件传递</p>
</li>
<li><p>缺点：每次匹配路由成功都会从新创建组件—效率低下，不建议使用</p>
<p>路由会使用<code>React.createElement</code>从指定的组件中创建一个新的React元素。这意味着，如果你向组件属性提供内置函数，则将在每个渲染中创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不是仅更新现有组件。使用内置函数进行内联渲染时，应使用<code>render</code>或<code>children</code>属性。</p>
</li>
</ul>
</li>
<li><p><code>&lt;Route render=&#123;(props)=&gt;&#123;return &lt;component/&gt;&#125;&#125;&gt;</code></p>
<ul>
<li><p>render方式渲染，使用函数方式</p>
</li>
<li><p>如果匹配相同，则不重新创建，效率高</p>
</li>
<li><p>建议如果组件对象方式渲染（函数方式）推荐使用render</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> render=&#123;(props)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state.count==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;Home1 count=&#123;<span class="keyword">this</span>.state.count&#125;/&gt;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        retutn &lt;Home2/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>&lt;Route children&gt;</code></p>
<ul>
<li><p>组件对象方式：必须匹配到path的路由规则才渲染和render与component一样<br><code>&lt;Route path=&quot;/about&quot; children=&#123;&lt;About /&gt;&#125; /&gt;</code></p>
</li>
<li><p>函数方式：不管是否和path匹配都渲染</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在匹配时，容器的class是light，&lt;Home /&gt;会被渲染</span></span><br><span class="line"><span class="comment">// 在不匹配时，容器的class是dark，&lt;About /&gt;会被渲染</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/home&#x27;</span> children=&#123;<span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;match</span> ? &#x27;<span class="attr">light</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">dark</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;match ? <span class="tag">&lt;<span class="name">Home</span>/&gt;</span>:<span class="tag">&lt;<span class="name">About</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">)&#125;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>一、它同 render 类似,是一个 function。不同的地方在于它会被传入一个 match 参数来告诉你这个 Route 的 path 和 location 匹配上没有。</p>
<p>二、第二个特殊的地方在于，即使 path 没有匹配上，我们也可以将它渲染出来。秘诀就在于前面一点提到的 match 参数。我们可以根据这个参数来决定在匹配的时候渲染什么，不匹配的时候又渲染什么。</p>
</li>
</ul>
</li>
</ul>
<h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a><strong>参数</strong></h5><ul>
<li><p><a id="exact">exact</a> 是否进行精确匹配，路由 <code>/a</code> 可以和 <code>/a/、/a</code> 匹配</p>
<blockquote>
<p>当exact为false时，根据路由匹配所有组件，例如/a/b/c 能匹配到/、/a、/a/b、/a/b/c 且匹配还是按顺序的</p>
<p>例如路由设置的前后顺序为:<br>1./ ；<br>2./a；<br>3./a/b ; <br>4./a/b/c<br>且前3个路径都没有设置 exact，这样前3个组件<strong>都会被渲染</strong>并且默认将2当作1的子页面，3当作2的子页面</p>
</blockquote>
</li>
<li><p><code>strict</code> 是否进行严格匹配，指明路径只匹配以斜线结尾的路径，路由<code>/a</code>可以和<code>/a</code>匹配，不能和<code>/a/</code>匹配，相比 <code>exact</code> 会更严格些</p>
</li>
<li><p><code>path (string)</code> 标识路由的路径,<code>path</code>属性可以使用通配符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>通配符的规则如下:</p>
<ul>
<li><p><strong>paramName</strong></p>
<p><code>:paramName</code>匹配URL的一个部分，直到遇到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。这个路径参数可以通过<code>this.props.params.paramName</code>取出。</p>
</li>
<li><p>()</p>
<p><code>()</code>表示URL的这个部分是可选的。</p>
</li>
<li><p>*</p>
<p><code>*</code>匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</p>
</li>
<li><p>**</p>
<p><code>**</code> 匹配任意字符，直到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。匹配方式是贪婪模式。</p>
</li>
</ul>
</li>
<li><p><code>component</code> 表示路径对应显示的组件</p>
</li>
<li><p><code>location (object)</code> 除了通过 path 传递路由路径，也可以通过传递 location 对象可以匹配</p>
</li>
<li><p><code>sensitive (boolean)</code> 匹配路径时，是否区分大小写</p>
</li>
</ul>
<h4 id="Swtich"><a href="#Swtich" class="headerlink" title="Swtich"></a>Swtich</h4><p><code>Swtich</code> 就近匹配路由，仅渲染一个路由，路由的默认行为是匹配了就直接渲染</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 假设你访问的URL为 /dog</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/dog&#x27;</span> component=&#123;<span class="title class_">Dog</span>&#125;&gt;&lt;<span class="regexp">/Route&gt; /</span>/ 虽然这里匹配了，但不会停止查找</span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/:dog&quot;</span> component=&#123;<span class="title class_">Husky</span>&#125;&gt;&lt;<span class="regexp">/Route&gt; /</span>/ 这个路由依然会被匹配，这样两个组件都会被渲染</span><br><span class="line">...</span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&#x27;/dog&#x27;</span> <span class="attr">component</span>=<span class="string">&#123;Dog&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span> <span class="comment">// Switch 匹配一个路由后就不会再去查找下一个路由，那么下面的路由就不会被匹配</span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/:dog&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Husky&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p><code>&lt;Link&gt;</code> 组件被用来在<strong>页面之间</strong>进行导航，它其实就是 HTML 中的 <code>&lt;a&gt;</code> 标签的上层封装，不过在其源码中使用 <code>event.preventDefault</code> 禁止了其默认行为，然后使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">history API</a> 自己实现了跳转。我们都知道，如果使用 <code>&lt;a&gt;</code> 标签去进行导航的话，整个页面都会被刷新，这是我们不希望看到的。所以我们使用 <code>&lt;Link&gt;</code> 组件来导航到一个目标 URL，可以在不刷新页面的情况下重新渲染页面。</p>
<p><strong>参数</strong></p>
<ul>
<li><p>to（string | object | function）</p>
<ul>
<li><p>为 string 时 就是一个明确的路径地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&quot;/courses?sort=name&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>为 object 时有如下属性（就是一个location对象）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link</span><br><span class="line">  to=&#123;&#123;</span><br><span class="line">  	pathname: &quot;/courses&quot;,</span><br><span class="line">    search: &quot;?sort=name&quot;,</span><br><span class="line">    hash: &quot;#the-hash&quot;,</span><br><span class="line">    state: &#123; fromDashboard: true &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>pathname：URL路径。</li>
<li>search：URl中查询字符串。</li>
<li>hash：URL的hash分段，例如#a-hash。</li>
<li>state：表示location中的状态</li>
</ul>
</li>
<li><p>为 function 时，就是一个函数接收当前 location 为参数，然后以字符串或对象的形式返回位置形式</p>
</li>
</ul>
</li>
<li><p><code>replace (boolean)</code>，当为 <code>true</code> 时，单击链接将替换历史堆栈中的当前记录，而不是添加一个新记录。</p>
</li>
</ul>
<h4 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h4><p><code>NavLink</code> 功能与 <code>Link</code> 类似不过参数更多，并且可以设置被选中时的样式或者类</p>
<ul>
<li><p><code>exact (boolean)</code> 是否进行精确匹配</p>
</li>
<li><p><code>strict (boolean)</code> 是否进行严格匹配</p>
</li>
<li><p><code>to（string | object）</code> 需要跳转到的路径(pathname)或地址（location）</p>
</li>
<li><p><code>activeClassName (string)</code> 是选中状态的类名，我们可以为其添加样式</p>
<p>当激活(<code>to</code> 属性与当前 URL 匹配)时，会将这个 class 选择器名添加到元素上，默认值为 <code>&#39;active&#39;</code></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span> to=<span class="string">&quot;/faq&quot;</span> activeClassName=<span class="string">&quot;selected&quot;</span>&gt;</span><br><span class="line">  <span class="title class_">FAQs</span></span><br><span class="line">&lt;/<span class="title class_">NavLink</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>activeStyle (Object)</code> 元素处于选中状态时，应用于元素的样式</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span></span><br><span class="line">  to=<span class="string">&quot;/faq&quot;</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    <span class="attr">fontWeight</span>: <span class="string">&quot;bold&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="title class_">FAQs</span></span><br><span class="line">&lt;/<span class="title class_">NavLink</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>isActive(function)</code> ，一个函数，用于添加额外的逻辑，以确定链接是否处于激活状态。如果您想做的不仅仅是验证链接的路径名是否与当前 URL 的路径名匹配，那么应该使用此方法来返回 <code>true</code> 或 <code>false</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">NavLink</span></span><br><span class="line">  to=<span class="string">&quot;/events/123&quot;</span></span><br><span class="line">  isActive=&#123;<span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line">    <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.<span class="property">params</span>.<span class="property">eventID</span>);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  <span class="title class_">Event</span> <span class="number">123</span></span><br><span class="line">&lt;/<span class="title class_">NavLink</span>&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h4><p><strong>重定向，新位置将覆盖历史堆栈中的当前位置</strong></p>
<p><code>from (string)</code> 需要重定向的路径，可以包括动态参数</p>
<p><code>push (boolean)</code> 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目</p>
<p><code>to (string | object)</code> 重定向到的路径</p>
<p><code>exact (boolean)</code> 是否要对 from 进行精确匹配</p>
<p><code>strict (boolean)</code> 是否要对 from 进行严格匹配</p>
<p><code>sensitive (boolean)</code> 匹配 from 时是否区分大小写</p>
<h3 id="IndexRoute和IndexRedirect"><a href="#IndexRoute和IndexRedirect" class="headerlink" title="IndexRoute和IndexRedirect"></a>IndexRoute和IndexRedirect</h3><h4 id="Index-Routes"><a href="#Index-Routes" class="headerlink" title="Index Routes"></a>Index Routes</h4><p>通常情况下，我们会建立如下情况的路由：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Router</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Accounts&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;statements&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Statements&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Router</span>&gt;</span><br></pre></td></tr></table></figure>

<p>当用户访问 <code>/</code> 时, App 组件被渲染，但组件内的子元素却没有， <code>App</code> 内部的 <code>this.props.children</code> 为 undefined 。 你可以简单地使用 <code>&#123;this.props.children ||&#125;</code> 来渲染一些默认的 UI 组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Router</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">IndexRoute</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Accounts&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;statements&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Statements&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Router</span>&gt;</span><br></pre></td></tr></table></figure>

<p>如此配置后，我们再次访问 <code>/</code> 路由，你会发现页面渲染了 Home 组件的内容。这就是 IndexRoute 的功能，指定一个路由的默认页。</p>
<h4 id="Index-Redirects"><a href="#Index-Redirects" class="headerlink" title="Index Redirects"></a>Index Redirects</h4><p>上面这种情况比较常见，还有一种非常常见的方式就是当我们尝试访问 <code>/</code> 这个路由时，我们想让其直接跳转到 ‘/Accounts’，直接免去了默认页 Home，这样来的更加直接。由此我们就需要 <code>IndexRedirect</code> 功能。考虑如下路由：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRedirect to=&quot;/accounts&quot;/&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>

<p>这样设计路由后，我们再次访问 <code>/</code> 时，系统默认会跳转到 <code>/accounts</code> 路由。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上就是 IndexRoute 和 IndexRedirect 的功能介绍，让我们来总结一下他们两个的区别。</p>
<ul>
<li>IndexRoute 一般情况下用于设计一个默认页且不改变 URL 地址，而 IndexRedirect 则是跳转默认地址且地址会发生改变。</li>
<li>IndexRoute 指定一个组件作为默认页，而 IndexRedirect 指定一个路由地址作为跳转地址。</li>
</ul>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="属性的隐式传递"><a href="#属性的隐式传递" class="headerlink" title="属性的隐式传递"></a><strong>属性的隐式传递</strong></h3><p>this.props.history/match/location</p>
<table>
<thead>
<tr>
<th>所属</th>
<th>属性</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>history</td>
<td>length</td>
<td>number</td>
<td>表示history堆栈的数量</td>
</tr>
<tr>
<td></td>
<td>action</td>
<td>string</td>
<td>表示当前的动作。比如pop、replace或push</td>
</tr>
<tr>
<td></td>
<td>location</td>
<td>object</td>
<td>表示当前的位置</td>
</tr>
<tr>
<td></td>
<td>push(path, [state])</td>
<td>function</td>
<td>在history堆栈顶加入一个新的条目</td>
</tr>
<tr>
<td></td>
<td>replace(path, [state])</td>
<td>function</td>
<td>替换在history堆栈中的当前条目</td>
</tr>
<tr>
<td></td>
<td>go(n)</td>
<td>function</td>
<td>将history堆栈中的指针向前移动</td>
</tr>
<tr>
<td></td>
<td>goBack()</td>
<td>function</td>
<td>等同于go(-1)</td>
</tr>
<tr>
<td></td>
<td>goForward()</td>
<td>function</td>
<td>等同于go(1)</td>
</tr>
<tr>
<td></td>
<td>block(promt)</td>
<td>function</td>
<td>阻止跳转</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>match</td>
<td>params</td>
<td>object</td>
<td>表示路径参数，通过解析URL中动态的部分获得的键值对</td>
</tr>
<tr>
<td></td>
<td>isExact</td>
<td>boolean</td>
<td>为true时，表示精确匹配</td>
</tr>
<tr>
<td></td>
<td>path</td>
<td>string</td>
<td>用来做匹配的路径格式</td>
</tr>
<tr>
<td></td>
<td>url</td>
<td>string</td>
<td>URL匹配的部分</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>location</td>
<td>pathname</td>
<td>string</td>
<td>URL路径</td>
</tr>
<tr>
<td></td>
<td>search</td>
<td>string</td>
<td>URl中查询字符串</td>
</tr>
<tr>
<td></td>
<td>hash</td>
<td>string</td>
<td>URL的hash分段</td>
</tr>
<tr>
<td></td>
<td>state</td>
<td>string</td>
<td>表示location中的状态</td>
</tr>
</tbody></table>
<h3 id="useHistory"><a href="#useHistory" class="headerlink" title="useHistory"></a>useHistory</h3><p>用以获取history对象，进行编程式的导航</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">  console.log(useHistory()); // 与 props.history 结果一致</span><br><span class="line">  console.log(props.history);</span><br><span class="line">  return &lt;div&gt;哈士奇&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&lt;Route path=&quot;/dog&quot; component=&#123;Dog&#125;&gt;&lt;/Route&gt; // 必须这么写，props 才能拿到相关值</span><br><span class="line">...</span><br><span class="line">&lt;Route path=&quot;/husky&quot;&gt;</span><br><span class="line">	&lt;Husky /&gt;</span><br><span class="line">&lt;/Route&gt; // 这样写的话 useHistory 可以正常取值，但是 props 不行</span><br></pre></td></tr></table></figure>

<h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h3><p>用以获取location对象，可以查看当前路由信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">  console.log(useLocation()); // 与 props.location 结果一致</span><br><span class="line">  console.log(props.location);</span><br><span class="line">  return &lt;div&gt;哈士奇&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h3><p>useParams和props.match.params可以获取路由参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=&quot;/blog/:eat&quot;&gt;</span><br><span class="line">    &lt;Husky /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">    console.log(useParams()) // 与 props.match.params 结果一致，但明显更简洁</span><br><span class="line">    console.log(props.match.params)</span><br><span class="line">    const &#123;eat&#125; = props.match.params;</span><br><span class="line">    return (</span><br><span class="line">    	&lt;div&gt;哈士奇 吃 &#123;eat&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRouteMatch"><a href="#useRouteMatch" class="headerlink" title="useRouteMatch"></a>useRouteMatch</h3><p><code>useRouteMatch</code>，接受一个<strong>path字符串</strong>作为参数。当参数的path与当前的路径相匹配时，useRouteMatch会返回match对象，否则返回null。</p>
<p><code>useRouteMatch</code>在对于一些，<strong>不是路由级别的组件</strong>。但是<strong>组件自身的显隐却和当前路径相关的组件时</strong>，非常有用。</p>
<p>比如，你在做一个后台管理系统时，网页的Header只会在登录页显示，登录完成后不需要显示，这种场景下就可以用到<code>useRouteMatch</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">const Home = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;Home&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">// Header组件只会在匹配`/detail/:id`时出现</span><br><span class="line">const Header = () =&gt; &#123;</span><br><span class="line">  // 只有当前路径匹配`/detail/:id`时，match不为null</span><br><span class="line">  const match = useRouteMatch(&#x27;/detail/:id&#x27;)</span><br><span class="line">  return (</span><br><span class="line">    match &amp;&amp; &lt;div&gt;Header&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">const Detail = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;Detail&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route exact path=&quot;/detail/:id&quot; component=&#123;Detail&#125;/&gt; </span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>可以通过嵌套 <code>route</code> 来实现路由嵌套，注意<a href="#exact">exact</a></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根路由</span></span><br><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;router&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Router&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br><span class="line"><span class="comment">//Router.jsx</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>router<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/router/second/1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/router/second/12&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="comment">//子路由的配置分散到各组件中</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/router/second/:id&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Second&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：如果在父路由中开启 exact 匹配，就会导致子组件加载不出来</p>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p><a target="_blank" rel="noopener" href="https://zh-hans.reactjs.org/docs/code-splitting.html">https://zh-hans.reactjs.org/docs/code-splitting.html</a></p>
<p><strong>Suspense和lazy</strong></p>
<p>如果我们项目有三个模块，用户管理（UserManage）、资产管理（AssetManage）、考勤管理（AttendanceManage）。当我们进入首页的时候由于没有进入任何一个模块，为了提高响应效率是不需要进行模块资源加载的，同时当我们进入用户管理的时候只需要加载用户管理路由对应的模块资源，进入其他模块亦然。这时候我们就需要对代码进行拆分，React.lazy可以结合Router来对模块进行懒加载。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Suspense</span>, lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载引入组件 在用到路由组件时才发送请求</span></span><br><span class="line"><span class="comment">// 通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/Home&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">UserManage</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/UserManage&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AssetManage</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/AssetManage&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AttendanceManage</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/AttendanceManage&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     &#123;/* 用Suspense包含所有需要注册的路由 fallback为响应未回来时显示的内容 */&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/userManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;UserManage&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/assetManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AssetManage&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/attendanceManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AttendanceManage&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>本质: 高阶组件</p>
<p>作用: 可以在非路由组件中注入路由对象</p>
<p>在没有路由指向(就是没有Route对象)的组件默认this.props当中没有路由所需要的参数，使用withRouter可以添加</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import BackHome from &#x27;./backhome&#x27;;</span><br><span class="line">export default class Test extends React.Component &#123;</span><br><span class="line"> render () &#123;</span><br><span class="line">  console.log(this.props)</span><br><span class="line">  return (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">    这是测试的内容</span><br><span class="line">	//返回首页的按钮不是通过route标签渲染的，所以该子组件的this.props中没有路由参数</span><br><span class="line">    &lt;BackHome&gt;返回首页&lt;/BackHome&gt; </span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">//导入withRoute</span><br><span class="line">import &#123;withRouter&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">class BackHome extends React.Component &#123;</span><br><span class="line"> goHome = () =&gt; &#123;</span><br><span class="line">  //必须在使用withRouter的情况下，该组件在this.props中才有路由参数和方法</span><br><span class="line">  //否则，会报错</span><br><span class="line">  this.props.history.push(&#123;</span><br><span class="line">   pathname: &#x27;/home&#x27;,</span><br><span class="line">   state: &#123;</span><br><span class="line">    name: &#x27;dx&#x27; //同样，可以通过state向home路由对应的组件传递参数</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> render () &#123;</span><br><span class="line">  return (</span><br><span class="line">   &lt;button onClick=&#123;this.goHome&#125;&gt;this.props.children&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//导出的时候，用withRouter标签将backHome组件以参数形式传出</span><br><span class="line">export default withRouter(BackHome)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="param动态路由传参"><a href="#param动态路由传参" class="headerlink" title="param动态路由传参"></a><strong>param动态路由传参</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/path/:name&#x27;</span> component=&#123;<span class="title class_">Path</span>&#125;/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">to</span>=<span class="string">&#123;</span> &#x27;/<span class="attr">user</span>/&#x27; + &#x27;<span class="attr">2</span>&#x27; &#125;&gt;</span>xxx<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(&#123;<span class="attr">pathname</span>:<span class="string">&quot;/path/&quot;</span> + name&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数用:this.props.match.params.name</span></span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、刷新页面参数不会丢失<br>缺点：<br>1、 当复杂数据对象或数组需要传参时，这样做比较麻烦，需要通过json字符串的方式进行处理</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义路由匹配</span></span><br><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&quot;/user/:data&quot;</span> component=&#123;<span class="title class_">Component</span>&#125; /&gt;;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> path = <span class="title class_">JSON</span>.<span class="title class_">Stringify</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递路由参数</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;path&#125;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由参数</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, name, age &#125; = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">match</span>.<span class="property">params</span>.<span class="property">data</span>;</span><br></pre></td></tr></table></figure>

<p>2、多个参数的传递，url 会又长又不美观<br>3、参数会出现在url上，不够安全 </p>
<h4 id="search传参"><a href="#search传参" class="headerlink" title="search传参"></a>search传参</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/web/departManange&#x27;</span> component=&#123;<span class="title class_">DepartManange</span>&#125;/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">to</span>=<span class="string">&quot;web/departManange?tenantId=12121212&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(&#123;<span class="attr">pathname</span>:<span class="string">&quot;/web/departManange?tenantId&quot;</span> + row.<span class="property">tenantId</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数用: this.props.location.search</span></span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、刷新页面参数不会丢失<br>3、可以传递多个参数<br>缺点：<br>1、当复杂数据对象或数组需要传参时，这样做比较麻烦，需要通过json字符串的方式进行处理<br>2、参数会出现在url上，不够安全 </p>
<h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a><strong>query传参</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Route</span> path=<span class="string">&#x27;/query&#x27;</span> component=&#123;<span class="title class_">Query</span>&#125;/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span> <span class="attr">path</span> <span class="attr">:</span> &#x27; /<span class="attr">query</span>&#x27; , <span class="attr">query</span> <span class="attr">:</span> &#123; <span class="attr">name</span> <span class="attr">:</span> &#x27;<span class="attr">sunny</span>&#x27; &#125;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">this.props.history.push(&#123;pathname:&quot;/query&quot;,query: &#123; name : &#x27;sunny&#x27; &#125;&#125;);</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">//读取参数用: this.props.location.query.name</span></span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、可以传递多个参数<br>3、传递对象数组等复杂参数方便<br>4、不会暴露给用户，比较安全<br>缺点：<br>1、如果手动刷新当前路由时，数据参数有可能会丢失 </p>
<h4 id="state传参"><a href="#state传参" class="headerlink" title="state传参"></a><strong>state传参</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">    pathname: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">&#x27;dx&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;&gt;关于&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line">this.props.location.state</span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、可以传递多个参数<br>3、传递对象数组等复杂参数方便<br>4、不会暴露给用户，比较安全<br>缺点：<br>1、如果手动刷新当前路由时，数据参数有可能会丢失 </p>
<p>在<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=react&spm=1001.2101.3001.7020">react</a>中，最外层包裹了BrowserRouter时，不会丢失,但如果使用的时HashRouter，刷新当前页面时，会丢失state中的数据 </p>
<h1 id="状态管理器"><a href="#状态管理器" class="headerlink" title="状态管理器"></a>状态管理器</h1><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux是将整个应用状态存储到一个地方，称为store。里面保存一棵状态树(state tree)。组件可以派发(dispatch)行为(action)给store,action发出命令后将state放入reucer加工函数中，返回新的state。其它组件可以通过订阅store中的状态(state)来刷新自己的视图</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f09a0b5196a2dd~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;">



<h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h3><h4 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h4><p><strong>整个应用的state被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个store 中。</strong></p>
<h4 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h4><p><strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></p>
<p>这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。<strong>action就是改变state的指令，有多少操作state的动作就会有多少action。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加todo任务的 action 是这样的：</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">ADD_TODO</span> = <span class="string">&#x27;ADD_TODO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//action创建函数，返回一个action对象 </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addTodo</span>(<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="variable constant_">ADD_TODO</span>,<span class="comment">//执行的动作</span></span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Build my first Redux app&#x27;</span>，</span><br><span class="line">  index：<span class="number">5</span>，<span class="comment">//用户完成任务的动作序列号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次dispatch 过程。</span></span><br><span class="line"><span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(text))</span><br><span class="line"><span class="comment">//或者创建一个被绑定的 action 创建函数来自动 dispatch：</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">boundAddTodo</span> = text =&gt; <span class="title function_">dispatch</span>(<span class="title function_">addTodo</span>(text))</span><br><span class="line"><span class="title function_">boundAddTodo</span>(text);</span><br><span class="line"><span class="comment">//store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的 connect() 帮助器来调用。</span></span><br></pre></td></tr></table></figure>

<h4 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h4><p><strong>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure>

<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a> 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。<strong>永远不要</strong>在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li>
</ul>
<p><strong>这是一个redux的经典案例</strong></p>
<ul>
<li><p>通过createStore创建store</p>
</li>
<li><p>actions 定义指令</p>
</li>
<li><p>调用store.dispatch()发出修改state的命令</p>
</li>
<li><p>定义reducer函数根据action的类型改变state</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="comment">//这里一个技巧是使用 ES6 参数默认值语法 来精简代码。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">reducer</span> = (<span class="params">state = &#123;count: <span class="number">0</span>&#125;, action</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREASE&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREASE&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.<span class="property">count</span> - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="attr">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="attr">increase</span>: <span class="function">() =&gt;</span> (&#123;<span class="attr">type</span>: <span class="string">&#x27;INCREASE&#x27;</span>&#125;),</span><br><span class="line">  <span class="attr">decrease</span>: <span class="function">() =&gt;</span> (&#123;<span class="attr">type</span>: <span class="string">&#x27;DECREASE&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 Redux store 来存放应用的状态。</span></span><br><span class="line"><span class="comment">// API 是 &#123; subscribe, dispatch, getState &#125;。</span></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">createStore</span>(counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动订阅更新，也可以事件绑定到视图层。</span></span><br><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变内部 state 惟一方法是 dispatch 一个 action。</span></span><br><span class="line"><span class="comment">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(actions.<span class="title function_">increase</span>()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(actions.<span class="title function_">increase</span>()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.<span class="title function_">dispatch</span>(actions.<span class="title function_">increase</span>()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="store构建"><a href="#store构建" class="headerlink" title="store构建"></a>store构建</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h4><p><a target="_blank" rel="noopener" href="https://imgchr.com/i/sgpjbR"><img src="https://z3.ax1x.com/2021/01/19/sgpjbR.png" alt="屏幕截图"></a></p>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><strong>存放描述行为的数据结构(本质上是 JavaScript 普通对象),一般来说你会通过 store.dispatch() 将 action 传到 store。</strong></p>
<p>我们约定，action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作。多数情况下，<code>type</code> 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	./actions/counter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INCREMENT</span> = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">DECREMENT</span> = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="variable constant_">INCREMENT</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>)=&gt;&#123;</span><br><span class="line">  &#123;<span class="attr">type</span>:<span class="variable constant_">DECREMENT</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当我们表示用户完成任务的动作序列号时，我们还需要再添加一个 action index 来，所以我们通过下标 <code>index</code> 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。</p>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><strong>Reducer</strong></h4><p><strong>Reducers</strong> 指定了应用状态的变化如何响应 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/basics/Actions.html">actions</a> 并发送到 store 的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	./reducers/counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">INCREMENT</span>, <span class="variable constant_">DECREMENT</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../actions/counter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">state = <span class="number">0</span>, action</span>)&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">          <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">          <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">          <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	./reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">	counter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p><strong>注意：Redux 应用只有一个单一的 store</strong></p>
<p>我们学会了使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。</p>
<p><strong>Store</strong> 就是把它们联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#getState"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#subscribe"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#subscribe"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/258017257">https://zhuanlan.zhihu.com/p/258017257</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">configureStore</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> logger = <span class="title function_">createLogger</span>(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middlewares = [thunk]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    middlewares.<span class="title function_">push</span>(logger)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> composeEnhancers =</span><br><span class="line">    <span class="keyword">typeof</span> <span class="variable language_">window</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="variable language_">window</span>.<span class="property">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span></span><br><span class="line">      ? <span class="variable language_">window</span>.<span class="title function_">__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span>(&#123;&#125;)</span><br><span class="line">      : compose</span><br><span class="line">  <span class="keyword">const</span> enhancer = <span class="title function_">composeEnhancers</span>(<span class="title function_">applyMiddleware</span>(...middlewares))</span><br><span class="line"><span class="comment">//createStore() 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">createStore</span>(reducers, enhancer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">configureStore</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="redux-异步请求"><a href="#redux-异步请求" class="headerlink" title="redux 异步请求"></a>redux 异步请求</h3><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/18616547-35a9f5f3f9956a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。<br>在实际的开发中，redux中管理的很多数据可能来自服务器，我们需要进行异步的请求，再将数据保存到redux中。就是说在异步的网络请求中通过dispatch action来更新state中的数据。这时候就需要用到Redux中间件**(指这个框架允许我们在某个流程的执行中间插入我们自定义的一段代码)**。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gaearon/redux-thunk">Thunk middleware</a> 并不是 Redux 处理异步 action 的唯一方式：</p>
<ul>
<li>你可以使用 <a target="_blank" rel="noopener" href="https://github.com/acdlite/redux-promise">redux-promise</a> 或者 <a target="_blank" rel="noopener" href="https://github.com/pburtchaell/redux-promise-middleware">redux-promise-middleware</a> 来 dispatch Promise 来替代函数。</li>
<li>你可以使用 <a target="_blank" rel="noopener" href="https://github.com/redux-observable/redux-observable">redux-observable</a> 来 dispatch Observable。</li>
<li>你可以使用 <a target="_blank" rel="noopener" href="https://github.com/yelouafi/redux-saga/">redux-saga</a> 中间件来创建更加复杂的异步 action。</li>
<li>你可以使用 <a target="_blank" rel="noopener" href="https://github.com/lelandrichardson/redux-pack">redux-pack</a> 中间件 dispatch 基于 Promise 的异步 Action。</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h4><p><code>&lt;Provider store&gt;</code> 使组件层级中的 <code>connect()</code> 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <code>&lt;Provider&gt;</code> 中才能使用 <code>connect()</code> 方法。</p>
<p>React-Redux 提供<code>Provider</code>组件，可以让容器组件拿到<code>state</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./components/App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">createStore</span>(todoApp);</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。</p>
<p><strong>它的原理是<code>React</code>组件的<a target="_blank" rel="noopener" href="https://facebook.github.io/react/docs/context.html"><code>context</code></a>属性</strong>，请看源码。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Provider</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">getChildContext</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">store</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">store</span></span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Provider</span>.<span class="property">childContextTypes</span> = &#123;</span><br><span class="line"><span class="attr">store</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>store</code>放在了上下文对象<code>context</code>上面。然后，子组件就可以从<code>context</code>拿到<code>store</code>，代码大致如下。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VisibleTodoList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">unsubscribe</span> = store.<span class="title function_">subscribe</span>(<span class="function">() =&gt;</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">forceUpdate</span>()</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">const</span> props = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"> <span class="keyword">const</span> &#123; store &#125; = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line"> <span class="keyword">const</span> state = store.<span class="title function_">getState</span>();</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">VisibleTodoList</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line"><span class="attr">store</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>React-Redux</code>自动生成的容器组件的代码，就类似上面这样，从而拿到<code>store</code>。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>React-Redux 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VisibleTodoList</span> = <span class="title function_">connect</span>()(<span class="title class_">TodoList</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>TodoList</code>是 UI 组件，<code>VisibleTodoList</code>就是由 React-Redux 通过<code>connect</code>方法自动生成的容器组件。</p>
<p>但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。</p>
<blockquote>
<p>（1）输入逻辑：外部的数据（即<code>state</code>对象）如何转换为 UI 组件的参数</p>
<p>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</p>
</blockquote>
<p>因此，<code>connect</code>方法的完整 API 如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">VisibleTodoList</span> = <span class="title function_">connect</span>(</span><br><span class="line">mapStateToProps,</span><br><span class="line">mapDispatchToProps</span><br><span class="line">)(<span class="title class_">TodoList</span>)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h5 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h5><p><code>mapStateToProps</code>是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）<code>state</code>对象到（UI 组件的）<code>props</code>对象的映射关系。也就是说， <strong>把state映射到props中去</strong> </p>
<p>作为函数，<code>mapStateToProps</code>执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state</span>) =&gt; &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">todos</span>: <span class="title function_">getVisibleTodos</span>(state.<span class="property">todos</span>, state.<span class="property">visibilityFilter</span>)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>mapStateToProps</code>是一个函数，它接受<code>state</code>作为参数，返回一个对象。这个对象有一个<code>todos</code>属性，代表 UI 组件的同名参数，后面的<code>getVisibleTodos</code>也是一个函数，可以从<code>state</code>算出 <code>todos</code> 的值。</p>
<p>下面就是<code>getVisibleTodos</code>的一个例子，用来算出<code>todos</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getVisibleTodos</span> = (<span class="params">todos, filter</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">switch</span> (filter) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;SHOW_ALL&#x27;</span>:</span><br><span class="line">   <span class="keyword">return</span> todos</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;SHOW_COMPLETED&#x27;</span>:</span><br><span class="line">   <span class="keyword">return</span> todos.<span class="title function_">filter</span>(<span class="function"><span class="params">t</span> =&gt;</span> t.<span class="property">completed</span>)</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;SHOW_ACTIVE&#x27;</span>:</span><br><span class="line">   <span class="keyword">return</span> todos.<span class="title function_">filter</span>(<span class="function"><span class="params">t</span> =&gt;</span> !t.<span class="property">completed</span>)</span><br><span class="line"> <span class="attr">default</span>:</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Unknown filter: &#x27;</span> + filter)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 容器组件的代码</span></span><br><span class="line"><span class="comment">//    &lt;FilterLink filter=&quot;SHOW_ALL&quot;&gt;</span></span><br><span class="line"><span class="comment">//      All</span></span><br><span class="line"><span class="comment">//    &lt;/FilterLink&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mapStateToProps</span> = (<span class="params">state, ownProps</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="attr">active</span>: ownProps.<span class="property">filter</span> === state.<span class="property">visibilityFilter</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</p>
<p><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
<h5 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h5><p><code>mapDispatchToProps</code>是<code>connect</code>函数的第二个参数，<strong>用来建立各种dispatch变成props，让你可以直接使用  UI 组件的参数到<code>store.dispatch</code>方法的映射</strong>。也就是说，<strong>把各种dispatch变成了props让你可以直接使用</strong> </p>
<p>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code>（容器组件的<code>props</code>对象）两个参数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">mapDispatchToProps</span> = (<span class="params"></span></span><br><span class="line"><span class="params">dispatch,</span></span><br><span class="line"><span class="params">ownProps</span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="title function_">dispatch</span>(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">     <span class="attr">filter</span>: ownProps.<span class="property">filter</span></span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从上面代码可以看到，<code>mapDispatchToProps</code>作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p>
<p>如果<code>mapDispatchToProps</code>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的<code>mapDispatchToProps</code>写成对象就是下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line"><span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line"> <span class="attr">filter</span>: filter</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="实例：计数器"><a href="#实例：计数器" class="headerlink" title="实例：计数器"></a>实例：计数器</h5><p>我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&quot;../../store/actions/counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="keyword">function</span> (<span class="params">props</span>) &#123;</span><br><span class="line"> <span class="comment">//生成props</span></span><br><span class="line"><span class="keyword">const</span> &#123; count, onincrement, ondecrement&#125; = props;</span><br><span class="line"><span class="comment">// console.log(props);</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">   <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">variant</span>=<span class="string">&quot;contained&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">color</span>=<span class="string">&quot;primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">onClick</span>=<span class="string">&#123;onincrement&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     &gt;</span></span></span><br><span class="line"><span class="language-xml">       increment</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">variant</span>=<span class="string">&quot;contained&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">color</span>=<span class="string">&quot;primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">onClick</span>=<span class="string">&#123;ondecrement&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">       <span class="attr">style</span>=<span class="string">&#123;&#123;marginLeft:</span>&#x27;<span class="attr">30px</span>&#x27;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="language-xml">     &gt;</span></span></span><br><span class="line"><span class="language-xml">       decrement</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">30px</span>&#x27;&#125;&#125;&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，这个 UI 组件有三个参数：count和 onincrement, ondecrement。前者需要从<code>state</code>计算得到，后者需要向外发出 Action。</p>
<p>接着，定义<code>count</code>到<code>state</code>的映射，以及<code>onincrement, ondecrement</code>到<code>dispatch</code>的映射。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">mapStateToProps</span>(<span class="params">state</span>) &#123;</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(state)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">count</span>: state.<span class="property">counter</span>.<span class="property">count</span>,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">mapDispatchToProps</span>(<span class="params">dispatch</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onincrement</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">increment</span>()),</span><br><span class="line">   <span class="attr">ondecrement</span>: <span class="function">() =&gt;</span> <span class="title function_">dispatch</span>(<span class="title function_">decrement</span>())</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，使用<code>connect</code>方法生成容器组件。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">connect</span>(mapStateToProps, mapDispatchToProps)(<span class="title class_">Home</span>);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，定义这个组件的 Reducer。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="variable constant_">INCREMENT</span>, <span class="variable constant_">DECREMENT</span>&#125; <span class="keyword">from</span> <span class="string">&quot;../actions/counter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params">state = &#123; count: <span class="number">0</span>&#125;, action</span>)&#123;</span><br><span class="line"><span class="keyword">const</span> count = state.<span class="property">count</span></span><br><span class="line"><span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="attr">INCREMENT</span>:</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="attr">count</span>:count + <span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">case</span> <span class="attr">DECREMENT</span>:</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="attr">count</span>:count - <span class="number">1</span>&#125;;</span><br><span class="line">     <span class="attr">default</span>:</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="attr">count</span>:count&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后，生成<code>store</code>对象，并使用<code>Provider</code>在根组件外面包一层。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> route <span class="keyword">from</span> <span class="string">&quot;../route/index.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Provider</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;../store&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Menu</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="keyword">const</span> classes = <span class="title function_">useStyles</span>();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h4><p><code>createStore(reducer, [preloadedState], enhancer)</code></p>
<p>创建一个 Redux <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html">store</a> 来以存放应用中所有的 state。<br>应用中应有且仅有一个 store。</p>
<p><strong>参数</strong></p>
<ol>
<li><code>reducer</code> <em>(Function)</em>: 接收两个参数，分别是当前的 state 树和要处理的 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/Glossary.html#action">action</a>，返回新的 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/Glossary.html#state">state 树</a>。</li>
<li>[<code>preloadedState</code>] <em>(any)</em>: 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers</code></a> 创建 <code>reducer</code>，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 <code>reducer</code> 可理解的内容。</li>
<li><code>enhancer</code> <em>(Function)</em>: Store enhancer 是一个组合 store creator 的<strong>高阶函数</strong>，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</li>
</ol>
<p><strong>返回值</strong></p>
<p>(<a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html"><em><code>Store</code></em></a>): 保存了应用所有 state 的对象。改变 state 的惟一方法是 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#dispatch">dispatch</a> action。你也可以 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/Store.html#subscribe">subscribe 监听</a> state 的变化，然后更新 UI。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">todos</span>(<span class="params">state = [], action</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.<span class="title function_">concat</span>([action.<span class="property">text</span>])</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">createStore</span>(todos, [<span class="string">&#x27;Use Redux&#x27;</span>])</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Read the docs&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(store.<span class="title function_">getState</span>())</span><br><span class="line"><span class="comment">// [ &#x27;Use Redux&#x27;, &#x27;Read the docs&#x27; ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应用中不要创建多个 store！相反，使用 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers</code></a> 来把多个 reducer 创建成一个根 reducer。</li>
<li>要使用多个 store 增强器的时候，你可能需要使用 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/api/compose.html">compose</a></li>
</ul>
<h4 id="Store-方法"><a href="#Store-方法" class="headerlink" title="Store 方法"></a>Store 方法</h4><p>Store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。</p>
<ul>
<li>getState()</li>
<li>dispatch(action)</li>
<li>subscribe(listener)</li>
<li>replaceReducer(nextReducer)</li>
</ul>
<h4 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h4><p>随着应用变得越来越复杂，可以考虑将 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/Glossary.html#reducer">reducer 函数</a> 拆分成多个单独的函数，拆分后的每个函数负责独立管理 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/Glossary.html#state">state</a> 的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#x27;redux&#x27;</span><br><span class="line">import counter from &#x27;./counter&#x27;</span><br><span class="line"></span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">	counter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>combineReducers把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。</p>
<p>合并后的 reducer 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。</p>
<h4 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h4><p><a target="_blank" rel="noopener" href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p>
<p><strong>applyMiddleware(…middlewares)</strong></p>
<p>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。</p>
<p>Middleware 最常见的使用场景是实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 <strong>dispatch 异步 actions</strong>。</p>
<p><strong>示例: 自定义 Logger Middleware</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logger</span>(<span class="params">&#123; getState &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;will dispatch&#x27;</span>, action)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 middleware 链中下一个 middleware 的 dispatch。</span></span><br><span class="line">    <span class="keyword">let</span> returnValue = <span class="title function_">next</span>(action)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state after dispatch&#x27;</span>, <span class="title function_">getState</span>())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般会是 action 本身，除非</span></span><br><span class="line">    <span class="comment">// 后面的 middleware 修改了它。</span></span><br><span class="line">    <span class="keyword">return</span> returnValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  todos,</span><br><span class="line">  [ <span class="string">&#x27;Use Redux&#x27;</span> ],</span><br><span class="line">  <span class="title function_">applyMiddleware</span>(logger)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store.<span class="title function_">dispatch</span>(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Understand the middleware&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// (将打印如下信息:)</span></span><br><span class="line"><span class="comment">// will dispatch: &#123; type: &#x27;ADD_TODO&#x27;, text: &#x27;Understand the middleware&#x27; &#125;</span></span><br><span class="line"><span class="comment">// state after dispatch: [ &#x27;Use Redux&#x27;, &#x27;Understand the middleware&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="compose-functions"><a href="#compose-functions" class="headerlink" title=" compose(...functions)"></a><code> compose(...functions)</code></h4><p>从右到左来组合多个函数。</p>
<p>这是函数式编程中的方法，为了方便，被放到了 Redux 里。<br>当需要把多个 <a target="_blank" rel="noopener" href="https://www.redux.org.cn/docs/Glossary.html#store-enhancer">store 增强器</a> 依次执行的时候，需要用到它。</p>
<p><strong>参数</strong></p>
<ol>
<li>(<em>arguments</em>): 需要合成的多个函数。预计每个函数都接收一个参数。它的返回值将作为一个参数提供给它左边的函数，以此类推。例外是最右边的参数可以接受多个参数，因为它将为由此产生的函数提供签名。（译者注：<code>compose(funcA, funcB, funcC)</code> 形象为 <code>compose(funcA(funcB(funcC())))</code>）</li>
</ol>
<p><strong>返回值</strong></p>
<p>(<em>Function</em>): 从右到左把接收到的函数合成后的最终函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">DevTools</span> <span class="keyword">from</span> <span class="string">&#x27;./containers/DevTools&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;../reducers/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(</span><br><span class="line">  reducer,</span><br><span class="line">  <span class="title function_">compose</span>(</span><br><span class="line">    <span class="title function_">applyMiddleware</span>(thunk),</span><br><span class="line">    <span class="title class_">DevTools</span>.<span class="title function_">instrument</span>()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a><strong>Mobx</strong></h2><p>作为了解的内容，在项⽬中使⽤redux的情况更多。</p>
<p>Mobx是⼀个功能强⼤，上⼿⾮常容易的状态管理⼯具。redux的作者也曾经向⼤家推荐过它，在不少情况下可以使⽤Mobx来替代掉redux。</p>
<h2 id="hox"><a href="#hox" class="headerlink" title="hox"></a>hox</h2><p><strong>定义 Model</strong>： 用 <code>createModel</code> 包装后，就变成了持久化，且全局共享的数据。 </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createModel &#125; <span class="keyword">from</span> <span class="string">&#x27;hox&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任意一个 custom Hook */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">useCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">decrement</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">increment</span> = (<span class="params"></span>) =&gt; <span class="title function_">setCount</span>(count + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    decrement,</span><br><span class="line">    increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createModel</span>(useCounter)</span><br></pre></td></tr></table></figure>

<p><strong>使用 Model</strong>：<code>createModel</code> 返回值是个 Hook，你可以按 React Hooks 的用法正常使用它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCounterModel &#125; <span class="keyword">from</span> <span class="string">&quot;../models/useCounterModel&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> counter = <span class="title function_">useCounterModel</span>();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;counter.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counter.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TS与React"><a href="#TS与React" class="headerlink" title="TS与React"></a>TS与React</h1><h2 id="jsx转ts"><a href="#jsx转ts" class="headerlink" title="jsx转ts"></a>jsx转ts</h2><p><a target="_blank" rel="noopener" href="https://blog.yangteng.me/articles/2021/migrate-react-project-to-typescript/">https://blog.yangteng.me/articles/2021/migrate-react-project-to-typescript/</a></p>
<h3 id="配置TS"><a href="#配置TS" class="headerlink" title="配置TS"></a>配置TS</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add typescript</span><br></pre></td></tr></table></figure>

<p>然后加入 TypeScript 的配置文件：将 tsconfig.json 放到项目的根目录下。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;target&quot;</span><span class="punctuation">:</span> <span class="string">&quot;es5&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lib&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;dom&quot;</span><span class="punctuation">,</span> <span class="string">&quot;dom.iterable&quot;</span><span class="punctuation">,</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">//有的项目webpack会设置一些module的别名alias，ts也得配一下防止找不到</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;paths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;./*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@api/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/api/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@assets/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/assets/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@common/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/common/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@enum/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/enum/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@context/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/context/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@components/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/components/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@models/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/models/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@hooks/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/hooks/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@pages/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/pages/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@store/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/store/*&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;@utils/*&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src/utils/*&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;module&quot;</span><span class="punctuation">:</span> <span class="string">&quot;esnext&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;include&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;src&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.15.8&quot;,</span><br><span class="line">    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.15.0&quot;,</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;^7.15.8&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;: &quot;^7.14.5&quot;,</span><br><span class="line">    &quot;@babel/preset-typescript&quot;: &quot;^7.15.0&quot;,</span><br><span class="line">    &quot;@types/react-redux&quot;: &quot;^7.1.23&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.2.2&quot;,</span><br><span class="line">    &quot;typescript&quot;: &quot;^4.6.3&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@types/node&quot;: &quot;^17.0.23&quot;,</span><br><span class="line">    &quot;@types/react&quot;: &quot;^17.0.43&quot;,</span><br><span class="line">    &quot;@types/react-dom&quot;: &quot;^17.0.14&quot;,</span><br><span class="line">    &quot;@types/react-router&quot;: &quot;^5.1.16&quot;,</span><br><span class="line">    &quot;@types/react-router-dom&quot;: &quot;^5.1.7&quot;,</span><br><span class="line">    &quot;less-loader&quot;: &quot;^10.2.0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置-babel-和-webpack"><a href="#配置-babel-和-webpack" class="headerlink" title="配置 babel 和 webpack"></a>配置 babel 和 webpack</h3><p>将 babel 的 TypeScript 预设加入项目依赖中，并添加到 babel 的配置文件里。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @babel/preset-typescript --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;presets&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// other presets</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&quot;@babel/typescript&quot;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line">  <span class="comment">// other settings</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p> 修改 webpack 的配置，将 TypeScript 文件加入 <code>resolve</code> 和<code>babel-loader</code> 的 match 规则中。 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// other settings</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|jsx|ts|tsx)$/</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="attr">use</span>: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引入类型定义的-package"><a href="#引入类型定义的-package" class="headerlink" title="引入类型定义的 package"></a>引入类型定义的 package</h3><p>上一步完成后，实际上已经可以在代码中使用 TypeScript 了。但这时候如果你去写一个 React 组件，就会发现类似 <code>Cannot find module &#39;react&#39;.</code> 的报错。这就需要将一些你用到的 library 的类型定义加进来了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add @types/react @types/react-dom @types/node <span class="comment">#@types/&lt;package-used-in-your-project&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h3><ul>
<li><p><strong>antd,css</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        loader: &#x27;less-loader&#x27;, // 编译 Less 为 CSS</span><br><span class="line">        options: &#123;</span><br><span class="line">          lessOptions: &#123;</span><br><span class="line">            javascriptEnabled: true,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="React-FC"><a href="#React-FC" class="headerlink" title="React.FC"></a>React.FC</h2><p><code>React.FC</code>是函数式组件，是在TypeScript使用的一个<strong>泛型</strong>。FC是FunctionComponent的缩写，<code>React.FC</code>可以写成<code>React.FunctionComponent</code>。这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 声明Props类型</span><br><span class="line"> */</span><br><span class="line">export interface MyComponentProps &#123;</span><br><span class="line">  className?: string;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyComponent: FC&lt;MyComponentProps&gt; = props =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;hello react&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h1><p><a target="_blank" rel="noopener" href="https://www.nextjs.cn/">https://www.nextjs.cn/</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>要从头开始使用 React 构建一个完整的 Web 应用程序，需要考虑许多重要的细节：</p>
<ul>
<li>必须使用打包程序（例如 webpack）打包代码，并使用 Babel 等编译器进行代码转换。</li>
<li>你需要针对生产环境进行优化，例如代码拆分。</li>
<li>你可能需要对一些页面进行预先渲染以提高页面性能和 SEO。你可能还希望使用服务器端渲染或客户端渲染。</li>
<li>你可能必须编写一些服务器端代码才能将 React 应用程序连接到数据存储。</li>
</ul>
<p><strong>Next.js：React 开发框架</strong></p>
<ul>
<li>直观的、 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/pages">基于页面</a> 的路由系统（并支持 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/routing/dynamic-routes">动态路由</a>）</li>
<li><a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/pages#pre-rendering">预渲染</a>。支持在页面级的 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/pages#static-generation-recommended">静态生成</a> (SSG) 和 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/pages#server-side-rendering">服务器端渲染</a> (SSR)</li>
<li>自动代码拆分，提升页面加载速度</li>
<li>具有经过优化的预取功能的 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/routing/introduction#linking-between-pages">客户端路由</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/built-in-css-support">内置 CSS</a> 和 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/built-in-css-support#sass-support">Sass 的支持</a>，并支持任何 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/built-in-css-support#css-in-js">CSS-in-JS</a> 库</li>
<li>开发环境支持 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/fast-refresh">快速刷新</a></li>
<li>利用 Serverless Functions 及 <a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/api-routes/introduction">API 路由</a> 构建 API 功能</li>
<li>完全可扩展</li>
</ul>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nextjs-blog</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开 <a target="_blank" rel="noopener" href="http://localhost:3000/">http://localhost:3000</a> 。</p>
<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><h3 id="客户端导航"><a href="#客户端导航" class="headerlink" title="客户端导航"></a>客户端导航</h3><p>在 Next.js 中，页面是从<a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/basic-features/pages"><code>pages</code>目录中</a>的文件导出的 React 组件。</p>
<p>页面与基于其<strong>文件名</strong>的路由相关联。例如，在开发中：</p>
<ul>
<li><code>pages/index.js</code>与<code>/</code>路由相关联。</li>
<li><code>pages/posts/first-post.js</code>与<code>/posts/first-post</code>路由相关联。</li>
</ul>
<p><strong>在页面之间导航</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Link from &#x27;next/link&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Read &lt;Link href=&quot;/posts/first-post&quot;&gt;&lt;a&gt;this page!&lt;/a&gt;&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>该<a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件支持在同一个 Next.js 应用程序中的两个页面之间进行<strong>客户端导航</strong>。</p>
<p>客户端导航意味着页面转换<em>使用 JavaScript 进行</em>，这比浏览器执行的默认导航更快。</p>
<p>该<a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件支持在同一个 Next.js 应用程序中的两个页面之间进行<strong>客户端导航</strong>。</p>
<p>客户端导航意味着页面转换<em>使用 JavaScript 进行</em>，这比浏览器执行的默认导航更快。</p>
<p>这是您可以验证的简单方法：</p>
<ul>
<li>使用浏览器的开发人员工具将<code>background</code>CSS 属性更改<code>&lt;html&gt;</code>为<code>yellow</code>。</li>
<li>单击链接可在两个页面之间来回切换。</li>
<li>您会看到黄色背景在页面转换之间持续存在。</li>
</ul>
<p>这表明浏览器<em>未</em>加载完整页面并且客户端导航正在工作。</p>
<img src="https://www.nextjs.cn/static/images/learn/navigate-between-pages/client-side.gif" alt="Links" style="zoom:50%;">

<p>如果您使用了<code>&lt;a href=&quot;…&quot;&gt;</code>代替<code>&lt;Link href=&quot;…&quot;&gt;</code>并执行了此操作，则链接点击时背景颜色将被清除，因为浏览器会完全刷新。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>Next.js 支持具有动态路由的 pages（页面）。例如，如果你创建了一个命名为 <code>pages/posts/[id].js</code> 的文件，那么就可以通过 <code>posts/1</code>、<code>posts/2</code> 等类似的路径进行访问。</p>
<ul>
<li><code>pages/blog/[slug].js</code> → <code>/blog/:slug</code> (<code>/blog/hello-world</code>)</li>
<li><code>pages/[username]/settings.js</code> → <code>/:username/settings</code> (<code>/foo/settings</code>)</li>
<li><code>pages/post/[...all].js</code> → <code>/post/*</code> (<code>/post/2020/id/title</code>)</li>
</ul>
<h3 id="代码拆分和预取"><a href="#代码拆分和预取" class="headerlink" title="代码拆分和预取"></a>代码拆分和预取</h3><p>Next.js 会自动进行代码拆分，因此每个页面只加载该页面所需的内容。这意味着在呈现主页时，最初不会提供其他页面的代码。</p>
<p>这可确保即使您添加数百个页面，主页也能快速加载。</p>
<p>仅加载您请求的页面的代码也意味着页面变得孤立。如果某个页面抛出错误，应用程序的其余部分仍然可以工作。</p>
<p>此外，在 Next.js 的生产版本中，每当<a target="_blank" rel="noopener" href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件出现在浏览器的视口中时，Next.js 都会在后台自动<strong>预取</strong>链接页面的代码。当您单击链接时，目标页面的代码已在后台加载，页面转换将近乎即时！</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p><code>&lt;Head&gt;</code>使用 代替小写字母<code>&lt;head&gt;</code>。<code>&lt;Head&gt;</code>是一个内置于 Next.js 的 React 组件。它允许您修改<code>&lt;head&gt;</code>页面的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import Head from &#x27;next/head&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charSet</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&#123;props.description&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">img统一放在public中，引用直接引用img，不需要添加图像路径</span><br><span class="line">src=&quot;/head.jpg&quot;</span><br></pre></td></tr></table></figure>

<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;`</span><br><span class="line">  …</span><br><span class="line">`&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>这是使用一个名为<a target="_blank" rel="noopener" href="https://github.com/vercel/styled-jsx">styled-jsx</a>的库。它是一个“CSS-in-JS”库——它允许你在 React 组件中编写 CSS，并且 CSS 样式将被<em>限定</em>（其他组件不会受到影响）。</p>
<p>Next.js 内置了对<a target="_blank" rel="noopener" href="https://github.com/vercel/styled-jsx">styled-jsx 的</a>支持，但您也可以使用其他流行的 CSS-in-JS 库。我用的是materialUI框架中的css-in-js</p>
<ul>
<li><p>全局样式</p>
<p>如果你希望<strong>每个页面</strong>都加载一些 CSS，添加pages/_app.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#x27;../styles/global.css&#x27;</span><br><span class="line">export default function App(&#123; Component, pageProps &#125;) &#123;</span><br><span class="line">  return &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个顶级styles目录并global.css在里面创建。将其导入pages/_app.js</p>
</li>
</ul>
<h2 id="内置API"><a href="#内置API" class="headerlink" title="内置API"></a>内置API</h2><p>某些页面需要获取外部数据以进行预渲染。有两种情况，在每种情况下，您都可以使用 Next.js 提供的特殊功能：</p>
<ol>
<li>您的页面 <strong>内容</strong> 取决于外部数据：使用 <code>getStaticProps</code>。</li>
<li>你的页面 <strong>paths（路径）</strong> 取决于外部数据：使用 <code>getStaticPaths</code> （通常还要同时使用 <code>getStaticProps</code>）。</li>
</ol>
<p><strong>getStaticProps</strong>函数在<strong>构建时</strong>被调用，并允许你在预渲染时将获取的数据作为 <code>props</code> 参数传递给页面。<strong>getStaticProps不会在页面组件中生效</strong></p>
<p>Next.js 允许你创建具有 <strong>动态路由</strong> 的页面。例如，你可以创建一个名为 <code>pages/posts/[id].js</code> 的文件用以展示以 <code>id</code> 标识的单篇博客文章。当你访问 <code>posts/1</code> 路径时将展示 <code>id: 1</code> 的博客文章。但是，在构建 <code>id</code> 所对应的内容时可能需要从外部获取数据。<strong>getStaticPaths</strong>函数在构建时被调用，并允许你指定要预渲染的路径。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此函数在构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getStaticPaths</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取博文列表</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">&#x27;https://.../posts&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.<span class="title function_">json</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 据博文列表生成所有需要预渲染的路径</span></span><br><span class="line">  <span class="keyword">const</span> paths = posts.<span class="title function_">map</span>(<span class="function">(<span class="params">post</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: post.<span class="property">id</span> &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ll pre-render only these paths at build time.</span></span><br><span class="line">  <span class="comment">// &#123; fallback: false &#125; means other routes should 404.</span></span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让页面使用服务端渲染，你需要导出 getServerSideProps 异步函数。这个函数将在<strong>每次请求</strong>时在服务端被调用。例如，假设你的页面需要用最新的数据预渲染（通过外部的 api 获取数据）。你应该写下 getServerSideProps 来获取数据传递给 Page。</p>
<p>getServerSideProps 和 getStaticProps 很像，但是区别的是，getServerSideProps 是每个请求都会调用而不是在构建时。</p>
<h2 id="mardown解析"><a href="#mardown解析" class="headerlink" title="mardown解析"></a>mardown解析</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a target="_blank" rel="noopener" href="https://dev.to/imranib/build-a-next-js-markdown-blog-5777">https://dev.to/imranib/build-a-next-js-markdown-blog-5777</a></p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-markdown">react-markdown</a>将帮助我们解析和渲染 Markdown 文件</p>
</li>
<li><p>代码格式化：<code>react-syntax-highlighter</code>包</p>
</li>
<li><p>gray-matter](<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/react-markdown">https://www.npmjs.com/package/react-markdown</a>) 将解析我们博客的<em>顶部内容</em>。（文件顶部的部分<code>---</code> ）</p>
<p>我们需要这样的元数据<code>title</code>，<code>data</code> 并<code>description</code>和<code>slug</code>。您可以在此处添加任何您喜欢的内容</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>slug</td>
<td>导航的参数</td>
</tr>
<tr>
<td>title</td>
<td>文章名称</td>
</tr>
<tr>
<td>data</td>
<td>最新时间</td>
</tr>
<tr>
<td>updated</td>
<td>文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>文章標籤</td>
</tr>
<tr>
<td>category</td>
<td>文章分類</td>
</tr>
<tr>
<td>description</td>
<td>文章描述</td>
</tr>
</tbody></table>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/raw-loader">raw-loader</a>将帮助我们导入我们的markdown文件。 </li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><a target="_blank" rel="noopener" href="https://dev.to/imranib/build-a-next-js-markdown-blog-5777">https://dev.to/imranib/build-a-next-js-markdown-blog-5777</a></p>
<p><a target="_blank" rel="noopener" href="https://thetombomb.com/posts/adding-code-snippets-to-static-markdown-in-Next%20js">https://thetombomb.com/posts/adding-code-snippets-to-static-markdown-in-Next%20js</a></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>material,classname报错，每次刷新，material失去效果。添加_app.js和__document.js文件</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://tomorrowlm.github.io">LMTomorrow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://tomorrowlm.github.io/2020/09/25/05-react/">https://tomorrowlm.github.io/2020/09/25/05-react/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://tomorrowlm.github.io" target="_blank">TomorrowLM-Web</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/react/">react</a><a class="post-meta__tags" href="/tags/redux/">redux</a><a class="post-meta__tags" href="/tags/router/">router</a><a class="post-meta__tags" href="/tags/hooks/">hooks</a><a class="post-meta__tags" href="/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/">生命周期</a><a class="post-meta__tags" href="/tags/next/">next</a></div><div class="post_share"><div class="social-share" data-image="/img/header.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/30/00-%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81/" title="前端原理和源码"><img class="cover" src="/img/header.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">前端原理和源码</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/25/06-vue/" title="vue"><img class="cover" src="/img/header.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">vue</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/25/06-vue/" title="vue"><img class="cover" src="/img/header.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">vue</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LMTomorrow</div><div class="author-info__description">热爱</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/TomorrowLM"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React%E7%9A%84%E7%89%B9%E7%82%B9%E5%92%8C%E4%BC%98%E5%8A%BF"><span class="toc-number">1.</span> <span class="toc-text">React的特点和优势</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">核心代码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#main-js"><span class="toc-number">2.1.</span> <span class="toc-text">main.js</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#APP-jsx"><span class="toc-number">2.2.</span> <span class="toc-text">APP.jsx</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.</span> <span class="toc-text">组件的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">组件初始化阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0%E9%98%B6%E6%AE%B5"><span class="toc-number">3.2.</span> <span class="toc-text">组件更新阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%94%80%E6%AF%81%E9%98%B6%E6%AE%B5"><span class="toc-number">3.3.</span> <span class="toc-text">组件销毁阶段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E"><span class="toc-number">3.4.</span> <span class="toc-text">新增</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%9F%E5%BC%83%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.4.1.</span> <span class="toc-text">废弃的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BA%9F%E5%BC%83"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">为什么废弃</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#componentWillMount"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">componentWillMount</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#componentWillReceiveProps"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">componentWillReceiveProps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#componentWillUpdate"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">componentWillUpdate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDerivedStateFromProps"><span class="toc-number">3.4.2.</span> <span class="toc-text">getDerivedStateFromProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getSnapshotBeforeUpdate"><span class="toc-number">3.4.3.</span> <span class="toc-text">getSnapshotBeforeUpdate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getDerivedStateFromError"><span class="toc-number">3.4.4.</span> <span class="toc-text">getDerivedStateFromError</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forceUpdate"><span class="toc-number">3.4.5.</span> <span class="toc-text">forceUpdate</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">4.</span> <span class="toc-text">核心概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jsx"><span class="toc-number">4.1.</span> <span class="toc-text">jsx</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93"><span class="toc-number">4.1.1.</span> <span class="toc-text">条件渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8-amp-Key"><span class="toc-number">4.1.2.</span> <span class="toc-text">列表 &amp; Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%A0%B7%E5%BC%8F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">4.1.3.</span> <span class="toc-text">添加样式的方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%92%8C%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-number">4.2.</span> <span class="toc-text">表单和受控组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#props"><span class="toc-number">4.3.</span> <span class="toc-text">props</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#defaultProps"><span class="toc-number">4.3.1.</span> <span class="toc-text">defaultProps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PropTypes%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-number">4.3.2.</span> <span class="toc-text">PropTypes类型检查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-props-children"><span class="toc-number">4.3.3.</span> <span class="toc-text">this.props.children</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#setState"><span class="toc-number">4.4.</span> <span class="toc-text">setState</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ref"><span class="toc-number">4.5.</span> <span class="toc-text">ref</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%94%9FJS%E8%8E%B7%E5%8F%96Dom"><span class="toc-number">4.5.1.</span> <span class="toc-text">原生JS获取Dom</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ref"><span class="toc-number">4.5.2.</span> <span class="toc-text">Ref</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83-Ref"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">回调 Ref</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createRef"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">createRef</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Refs-API%E4%BD%BF%E7%94%A8"><span class="toc-number">4.5.2.3.1.</span> <span class="toc-text">Refs API使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useRef"><span class="toc-number">4.5.2.4.</span> <span class="toc-text">useRef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#useImperativeHandle"><span class="toc-number">4.5.2.5.</span> <span class="toc-text">useImperativeHandle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forwardRef-%E8%BD%AC%E5%8F%91-%E4%BC%A0%E9%80%92"><span class="toc-number">4.5.2.6.</span> <span class="toc-text">forwardRef 转发&#x2F;传递</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findDOMNode"><span class="toc-number">4.5.3.</span> <span class="toc-text">findDOMNode()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">事件处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6"><span class="toc-number">4.7.1.</span> <span class="toc-text">组件渲染机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.2.</span> <span class="toc-text">状态组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%BB%84%E4%BB%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">4.7.2.1.</span> <span class="toc-text">状态组件对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.2.2.</span> <span class="toc-text">class组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.2.3.</span> <span class="toc-text">函数组件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.3.</span> <span class="toc-text">内置组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PureComponent"><span class="toc-number">4.7.3.1.</span> <span class="toc-text">PureComponent</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#shouldComponentUpdate%E6%A8%A1%E6%8B%9F"><span class="toc-number">4.7.3.1.1.</span> <span class="toc-text">shouldComponentUpdate模拟</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#PureComponent%E7%9A%84%E6%B5%85%E6%AF%94%E8%BE%83"><span class="toc-number">4.7.3.1.2.</span> <span class="toc-text">PureComponent的浅比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Component-vs-PureComponent-%E6%80%BB%E7%BB%93"><span class="toc-number">4.7.3.1.3.</span> <span class="toc-text">Component vs PureComponent 总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#memo"><span class="toc-number">4.7.3.2.</span> <span class="toc-text">memo</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fragment"><span class="toc-number">4.7.3.3.</span> <span class="toc-text">Fragment</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1"><span class="toc-number">4.7.4.</span> <span class="toc-text">组件通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#props-1"><span class="toc-number">4.7.4.1.</span> <span class="toc-text">props</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%88%B6%E7%BB%84%E4%BB%B6-gt-%E5%AD%90%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.4.1.1.</span> <span class="toc-text">父组件-&gt;子组件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%90%E7%BB%84%E4%BB%B6-gt-%E7%88%B6%E7%BB%84%E4%BB%B6"><span class="toc-number">4.7.4.1.2.</span> <span class="toc-text">子组件-&gt;父组件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Context"><span class="toc-number">4.7.4.2.</span> <span class="toc-text">Context</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E7%BB%84%E4%BB%B6"><span class="toc-number">4.8.</span> <span class="toc-text">高阶函数与组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">4.8.1.</span> <span class="toc-text">实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E6%8C%89%E9%92%AE"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">权限按钮</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Hooks%E5%87%BD%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">Hooks函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#useState-%E7%8A%B6%E6%80%81%E9%92%A9%E5%AD%90"><span class="toc-number">5.1.</span> <span class="toc-text">useState():状态钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86"><span class="toc-number">5.1.2.</span> <span class="toc-text">批处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tip"><span class="toc-number">5.1.3.</span> <span class="toc-text">Tip</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useContext-%E5%85%B1%E4%BA%AB%E7%8A%B6%E6%80%81%E9%92%A9%E5%AD%90"><span class="toc-number">5.2.</span> <span class="toc-text">useContext():共享状态钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useReducer-%E9%92%A9%E5%AD%90"><span class="toc-number">5.3.</span> <span class="toc-text">useReducer()钩子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">5.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B"><span class="toc-number">5.3.2.</span> <span class="toc-text">实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useEffect-%EF%BC%9A%E5%89%AF%E4%BD%9C%E7%94%A8%E9%92%A9%E5%AD%90"><span class="toc-number">5.4.</span> <span class="toc-text">useEffect()：副作用钩子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#useCallback%E5%92%8CuseMemo"><span class="toc-number">5.5.</span> <span class="toc-text">useCallback和useMemo</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#useCallback"><span class="toc-number">5.5.1.</span> <span class="toc-text">useCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useMemo"><span class="toc-number">5.5.2.</span> <span class="toc-text">useMemo</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95"><span class="toc-number">5.6.</span> <span class="toc-text">调试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1"><span class="toc-number">6.</span> <span class="toc-text">路由</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#React-Routers%E4%B8%89%E7%B1%BB%E7%BB%84%E4%BB%B6"><span class="toc-number">6.1.</span> <span class="toc-text">React Routers三类组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%99%A8Router"><span class="toc-number">6.1.1.</span> <span class="toc-text">路由器Router</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BrowserRouter"><span class="toc-number">6.1.1.1.</span> <span class="toc-text">BrowserRouter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HashRouter"><span class="toc-number">6.1.1.2.</span> <span class="toc-text">HashRouter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">6.1.1.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0"><span class="toc-number">6.1.1.4.</span> <span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%BA%BF%E5%8C%B9%E9%85%8D%E5%99%A8Route"><span class="toc-number">6.1.2.</span> <span class="toc-text">路线匹配器Route</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Route"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">Route</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.2.1.1.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%B8%B2%E6%9F%93%E6%96%B9%E5%BC%8F"><span class="toc-number">6.1.2.1.2.</span> <span class="toc-text">三种渲染方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-1"><span class="toc-number">6.1.2.1.3.</span> <span class="toc-text">参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swtich"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">Swtich</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-number">6.1.3.</span> <span class="toc-text">链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Link"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">Link</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NavLink"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">NavLink</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redirect"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">Redirect</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexRoute%E5%92%8CIndexRedirect"><span class="toc-number">6.1.4.</span> <span class="toc-text">IndexRoute和IndexRedirect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Index-Routes"><span class="toc-number">6.1.4.1.</span> <span class="toc-text">Index Routes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Index-Redirects"><span class="toc-number">6.1.4.2.</span> <span class="toc-text">Index Redirects</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.1.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hooks"><span class="toc-number">6.2.</span> <span class="toc-text">Hooks</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E9%9A%90%E5%BC%8F%E4%BC%A0%E9%80%92"><span class="toc-number">6.2.1.</span> <span class="toc-text">属性的隐式传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useHistory"><span class="toc-number">6.2.2.</span> <span class="toc-text">useHistory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useLocation"><span class="toc-number">6.2.3.</span> <span class="toc-text">useLocation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useParams"><span class="toc-number">6.2.4.</span> <span class="toc-text">useParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#useRouteMatch"><span class="toc-number">6.2.5.</span> <span class="toc-text">useRouteMatch</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">6.3.</span> <span class="toc-text">实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E5%B5%8C%E5%A5%97"><span class="toc-number">6.3.1.</span> <span class="toc-text">路由嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">6.3.2.</span> <span class="toc-text">路由懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#withRouter"><span class="toc-number">6.3.3.</span> <span class="toc-text">withRouter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">6.3.4.</span> <span class="toc-text">路由传参</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#param%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">6.3.4.1.</span> <span class="toc-text">param动态路由传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#search%E4%BC%A0%E5%8F%82"><span class="toc-number">6.3.4.2.</span> <span class="toc-text">search传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#query%E4%BC%A0%E5%8F%82"><span class="toc-number">6.3.4.3.</span> <span class="toc-text">query传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state%E4%BC%A0%E5%8F%82"><span class="toc-number">6.3.4.4.</span> <span class="toc-text">state传参</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">状态管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redux"><span class="toc-number">7.1.</span> <span class="toc-text">Redux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%8E%9F%E5%88%99"><span class="toc-number">7.1.1.</span> <span class="toc-text">三大原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%80%E6%95%B0%E6%8D%AE%E6%BA%90"><span class="toc-number">7.1.1.1.</span> <span class="toc-text">单一数据源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#State-%E6%98%AF%E5%8F%AA%E8%AF%BB%E7%9A%84"><span class="toc-number">7.1.1.2.</span> <span class="toc-text">State 是只读的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%AF%E5%87%BD%E6%95%B0%E6%9D%A5%E6%89%A7%E8%A1%8C%E4%BF%AE%E6%94%B9"><span class="toc-number">7.1.1.3.</span> <span class="toc-text">使用纯函数来执行修改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#store%E6%9E%84%E5%BB%BA"><span class="toc-number">7.1.2.</span> <span class="toc-text">store构建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#action"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">action</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Reducer"><span class="toc-number">7.1.2.3.</span> <span class="toc-text">Reducer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#store"><span class="toc-number">7.1.2.4.</span> <span class="toc-text">store</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redux-%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">7.1.3.</span> <span class="toc-text">redux 异步请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">7.1.4.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Provider-%E7%BB%84%E4%BB%B6"><span class="toc-number">7.1.4.1.</span> <span class="toc-text">Provider 组件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connect"><span class="toc-number">7.1.4.2.</span> <span class="toc-text">connect</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mapStateToProps"><span class="toc-number">7.1.4.2.1.</span> <span class="toc-text">mapStateToProps()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mapDispatchToProps"><span class="toc-number">7.1.4.2.2.</span> <span class="toc-text">mapDispatchToProps()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">7.1.4.2.3.</span> <span class="toc-text">实例：计数器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createStore"><span class="toc-number">7.1.4.3.</span> <span class="toc-text">createStore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Store-%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.4.4.</span> <span class="toc-text">Store 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#combineReducers"><span class="toc-number">7.1.4.5.</span> <span class="toc-text">combineReducers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#applyMiddleware"><span class="toc-number">7.1.4.6.</span> <span class="toc-text">applyMiddleware</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compose-functions"><span class="toc-number">7.1.4.7.</span> <span class="toc-text"> compose(...functions)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mobx"><span class="toc-number">7.2.</span> <span class="toc-text">Mobx</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hox"><span class="toc-number">7.3.</span> <span class="toc-text">hox</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TS%E4%B8%8EReact"><span class="toc-number">8.</span> <span class="toc-text">TS与React</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#jsx%E8%BD%ACts"><span class="toc-number">8.1.</span> <span class="toc-text">jsx转ts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AETS"><span class="toc-number">8.1.1.</span> <span class="toc-text">配置TS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#package"><span class="toc-number">8.1.2.</span> <span class="toc-text">package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-babel-%E5%92%8C-webpack"><span class="toc-number">8.1.3.</span> <span class="toc-text">配置 babel 和 webpack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89%E7%9A%84-package"><span class="toc-number">8.1.4.</span> <span class="toc-text">引入类型定义的 package</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TIP"><span class="toc-number">8.1.5.</span> <span class="toc-text">TIP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-FC"><span class="toc-number">8.2.</span> <span class="toc-text">React.FC</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NEXT"><span class="toc-number">9.</span> <span class="toc-text">NEXT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">9.1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">9.2.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2"><span class="toc-number">9.3.</span> <span class="toc-text">页面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%AF%BC%E8%88%AA"><span class="toc-number">9.3.1.</span> <span class="toc-text">客户端导航</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1"><span class="toc-number">9.3.2.</span> <span class="toc-text">动态路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8B%86%E5%88%86%E5%92%8C%E9%A2%84%E5%8F%96"><span class="toc-number">9.3.3.</span> <span class="toc-text">代码拆分和预取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML"><span class="toc-number">9.3.4.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#html"><span class="toc-number">9.3.4.1.</span> <span class="toc-text">html</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#img"><span class="toc-number">9.3.4.2.</span> <span class="toc-text">img</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#css"><span class="toc-number">9.3.4.3.</span> <span class="toc-text">css</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AEAPI"><span class="toc-number">9.4.</span> <span class="toc-text">内置API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mardown%E8%A7%A3%E6%9E%90"><span class="toc-number">9.5.</span> <span class="toc-text">mardown解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6"><span class="toc-number">9.5.1.</span> <span class="toc-text">插件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B"><span class="toc-number">9.5.2.</span> <span class="toc-text">流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tips"><span class="toc-number">9.6.</span> <span class="toc-text">Tips</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/02/07/post-name/" title="post_name"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="post_name"/></a><div class="content"><a class="title" href="/2024/02/07/post-name/" title="post_name">post_name</a><time datetime="2024-02-07T02:35:34.000Z" title="发表于 2024-02-07 10:35:34">2024-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="计算机"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机"/></a><div class="content"><a class="title" href="/2023/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/" title="计算机">计算机</a><time datetime="2023-05-30T03:39:50.217Z" title="发表于 2023-05-30 11:39:50">2023-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/02-%E6%80%BB%E7%BB%93/" title="无题"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2023/05/30/02-%E6%80%BB%E7%BB%93/" title="无题">无题</a><time datetime="2023-05-30T03:39:46.244Z" title="发表于 2023-05-30 11:39:46">2023-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/01-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/" title="项目构建"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="项目构建"/></a><div class="content"><a class="title" href="/2023/05/30/01-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/" title="项目构建">项目构建</a><time datetime="2023-05-30T03:39:46.242Z" title="发表于 2023-05-30 11:39:46">2023-05-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/30/00-%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81/" title="前端原理和源码"><img src="/img/header.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="前端原理和源码"/></a><div class="content"><a class="title" href="/2023/05/30/00-%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81/" title="前端原理和源码">前端原理和源码</a><time datetime="2023-05-30T03:39:46.239Z" title="发表于 2023-05-30 11:39:46">2023-05-30</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/header.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By LMTomorrow</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">因为热爱，所以专注</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: '6bfdb22315df9b919429',
      clientSecret: '80fa5ba42986f3960283146c3faf03bc34beb4ab',
      repo: 'TomorrowLM.github.io',
      owner: 'TomorrowLM',
      admin: ['TomorrowLM'],
      id: '7c55550e84e6a678cefb33a207f48b3d',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.textContent= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><div class="aplayer no-destroy" data-id="4929980436" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="false" muted></div><canvas id="universe"></canvas><script defer src="/js/custom/universe.js"></script><script data-pjax src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && location.pathname =='/'){
    
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/header.jpg" alt="/img/header.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-05-30</span><a class="blog-slider__title" href="2023/05/30/01-项目构建/">项目构建</a><div class="blog-slider__text">webpack,优化,项目构建,规范,业务,npm,git</div><a class="blog-slider__button" href="2023/05/30/01-项目构建/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/header.jpg" alt="/img/header.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-05-30</span><a class="blog-slider__title" href="2023/05/30/00-原理和源码/">前端原理和源码</a><div class="blog-slider__text">vue,webpack,响应式,路由,响应式,diff</div><a class="blog-slider__button" href="2023/05/30/00-原理和源码/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/header.jpg" alt="/img/header.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2020-09-25</span><a class="blog-slider__title" href="2020/09/25/04-ES6和TS/">ES6，TS和设计模式</a><div class="blog-slider__text">ES6,TS,设计模式</div><a class="blog-slider__button" href="2020/09/25/04-ES6和TS/">详情</a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms"><div class="blog-slider__img"><img src="/img/header.jpg" alt="/img/header.jpg"/></div><div class="blog-slider__content"><span class="blog-slider__code">2023-05-30</span><a class="blog-slider__title" href="2023/05/30/计算机/">计算机</a><div class="blog-slider__text">计算机,计算机网络,安全,通信,软考,linux,windows</div><a class="blog-slider__button" href="2023/05/30/计算机/">详情</a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载swiper')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper/swiper/swiper.min.js"></script>
<script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-swiper@0.18/swiper/swiperindex.js"></script>
<style></style><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = 'undefined';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = '20e4a5b832b5f4649f41ffc0a68c8c16# 高得地图web服务key';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>