<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>app</title>
    <url>/2020/09/25/08-app/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Hybrid"><a href="#Hybrid" class="headerlink" title="Hybrid"></a>Hybrid</h1><h2 id="webview"><a href="#webview" class="headerlink" title="webview"></a>webview</h2><p>嵌入在原生应用中 ，实现前端的混合式开发，大多数 <strong>Hybrid App</strong> 混合式开发框架都是基于WebView模式进行二次开发的。  webview就是原生应用中的浏览器引擎。 </p>
<p>运行在webview中的JS代码有能力调用原生的系统API，没有传统浏览器沙箱的限制。沙箱的存在是因为，你永远不能完全信任加载的web内容，所以不能允许它调用原生的系统API。而在webview中开发人员通常可以完全控制加载的内容，恶意代码进入并在设备上造成混乱的可能性很低。 </p>
<p><strong>Android容器</strong> 在安卓客户端中，webView容器与手机自带的浏览器内核一致，多为android-chrome。不存在兼容性和性能问题。 </p>
<p><strong>RN容器</strong> 在react-native开发中，从rn 0.37版本开始官方引入了组件，在安卓中调用原生浏览器，在IOS中默认调用的是UIWebView容器。从IOS12开始，苹果正式弃用UIWebView，统一采用WKWebView。 </p>
<h2 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h2><h3 id="前端通知客户端"><a href="#前端通知客户端" class="headerlink" title="前端通知客户端"></a>前端通知客户端</h3><p>在H5页面里触发链接跳转，App Webview检测到链接跳转再进行拦截，因此可以通过URL上携带参数来告知App下一步应该做些什么。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        location.href = &quot;lsbox://toast?msg=页面加载完毕&quot;; // 通知App</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">                &lt;button type=&quot;button&quot; onClick=&#123;this.openMask.bind(this)&#125;&gt;点它&lt;/button&gt;</span><br><span class="line">            &lt;/app&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    openMask() &#123;</span><br><span class="line">        location.href = &quot;lsbox://mask?toggle=1&quot;; // 通知App</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上执行了<code>location.href = &quot;lsbox://mask?toggle=1&quot;</code>来通知App打开遮罩层</p>
<ul>
<li><code>lsbox</code>：前端和客户端统一定义链接跳转的协议(喜欢怎样定义协议都行)</li>
<li><code>mask</code>：App需要执行的动作(喜欢怎样定义动作都行)</li>
<li><code>toggle=1</code>：动作执行参数(自定义参数，用于告知App怎样做)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果同步触发两个或以上的location.href(下一个location.href接着上一个location.href)，App可能只会接收到一个location.href发出的通知，所以需要对下一个location.href使用setTimeout设置通知时间间隔(可使用Async/Await封装优化)</span><br></pre></td></tr></table></figure>

<h3 id="客户端通知前端"><a href="#客户端通知前端" class="headerlink" title="客户端通知前端"></a>客户端通知前端</h3><p>使用<code>window.handleFunc = function() &#123;&#125;</code>这样的形式来定义注入的方法。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            list: [0, 1, 2, 3, 4]</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        window.addNum = this.addNum.bind(this); // 暴露方法给App</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&quot;app&quot;&gt;</span><br><span class="line">                &lt;ul&gt;&#123;this.state.list.map(v =&gt; &lt;li key=&#123;v&#125;&gt;&#123;v&#125;&lt;/li&gt;)&#125;&lt;/ul&gt;</span><br><span class="line">            &lt;/div&gt;;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    addNum(num) &#123;</span><br><span class="line">        this.setState(prevState =&gt; (&#123;</span><br><span class="line">            list: prevState.list.concat(num);</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上在组件加载完成后通过<code>window.addNum = this.addNum.bind(this)</code>将指定方法全局暴露到<code>window</code>上，App Webview可直接操作这些方法来控制H5页面 </p>
<h2 id="JSBridge"><a href="#JSBridge" class="headerlink" title="JSBridge"></a>JSBridge</h2><p>是 Native 和非 Native 之间的桥梁 ，简单来讲，主要是 给 JavaScript 提供调用 Native 功能的接口，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。 </p>
<h1 id="electron"><a href="#electron" class="headerlink" title="electron"></a>electron</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Electron 是利用 web 前端技术进行桌面应用开发的一套框架，它是由 Github 开发的，利用HTML、CSS、JavaScript 来构建跨平台桌面应用程序的一个开源库。Electron 通过将 Chromium 和 Node.js 合并到同一个运行时环境中，并将其打包成 Mac、Windowns、Linux 系统下的应用来实现这一目的。</p>
<p>chrome 和 chromium 用户界面几乎一摸一样，但是还是有一些差异的。比如 chrome 的系统标题和边框是被默认禁用的，而 chromium 是默认开启的。另外chrome地址栏里有分享功能，我们可以分享网站，但是 chromium 没有这个功能。界面的细微差别主要是这两个浏览器面向的用户是不一样的，一般来说使用 chrome 的用户是普通用户，用它来浏览网页使用，而使用 chromium 大部分是极客、开发人员和体验新功能的的用户。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/23/16f3040792c0936c~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>典型的三层结构, 和 MVC 非常相似：</p>
<ul>
<li><strong>M – 通用混合层</strong>。 C/C++ 封装核心、通用的业务模块以及业务数据存储。</li>
<li><strong>V – UI 层</strong>。视图层，使用跨平台视图解决方案，对于性能要求较高的部分使用原生实现。比如 Electron</li>
<li><strong>C – 平台桥接层</strong>。介于 M 和 V 之间，桥接<code>通用混合层</code>接口，同时也为 UI 层暴露一些<strong>平台相关</strong>的特性。比如在桌面端，这里会通过 Node 原生模块桥接通用混合层, 同时也补充一些 Electron 缺失或不完美的功能。</li>
</ul>
<h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><p><img src="https://img-blog.csdnimg.cn/94160f9fbbdc4ce0a9bab4e95689f54a.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>主进程：每个 Electron 应用都有一个单一的主进程，作为应用程序的入口点。 主进程在 Node.js 环境中运行，这意味着它具有 <code>require</code> 模块和使用所有 Node.js API 的能力。</p>
<ul>
<li>进程间通信</li>
<li>窗口管理。使用 <a href="https://www.electronjs.org/zh/docs/latest/api/browser-window"><code>BrowserWindow</code></a> 模块创建和管理应用程序窗口</li>
<li>全局通用服务。</li>
<li>一些只能或适合在主进程做的事情。例如浏览器下载、全局快捷键处理、托盘、session。</li>
<li>维护一些必要的全局状态</li>
<li>上面说的<code>通用混合层</code>也跑在这个进程。通过 Node C++ 插件暴露接口。</li>
</ul>
</li>
<li><p>渲染进程(Renderer Process)：每个 Electron 应用有一个或多个渲染进程, 对应多个 Web 页面</p>
</li>
<li><p>除此之外还有 GPU 进程、扩展进程等等。</p>
</li>
</ul>
<h2 id="IPC进程间通信"><a href="#IPC进程间通信" class="headerlink" title="IPC进程间通信"></a>IPC进程间通信</h2><blockquote>
<p>官方文档：</p>
<p><a href="https://link.juejin.cn/?target=https://www.electronjs.org/docs/api/ipc-main">ipcMain</a></p>
<p><a href="https://link.juejin.cn/?target=https://www.electronjs.org/docs/api/ipc-renderer">ipcRenderer</a></p>
<p><a href="https://link.juejin.cn/?target=https://www.electronjs.org/docs/api/web-contents%23contentssendchannel-args">webContents</a></p>
</blockquote>
<p><code>ipcRenderer</code> 是一个 <a href="https://nodejs.org/api/events.html#events_class_eventemitter">EventEmitter</a> 的实例</p>
<h3 id="渲染器进程到主进程（单向）"><a href="#渲染器进程到主进程（单向）" class="headerlink" title="渲染器进程到主进程（单向）"></a>渲染器进程到主进程（单向）</h3><p><strong>渲染线程</strong> 到 <strong>主线程</strong> 需要通过  <code>ipcRenderer.send</code>发送  —&gt; <code>ipcMain.on</code>来监听</p>
<h3 id="渲染器进程到主进程（双向）"><a href="#渲染器进程到主进程（双向）" class="headerlink" title="渲染器进程到主进程（双向）"></a>渲染器进程到主进程（双向）</h3><h3 id="主进程到渲染器进程"><a href="#主进程到渲染器进程" class="headerlink" title="主进程到渲染器进程"></a>主进程到渲染器进程</h3><p><strong>主线程</strong> 到 <strong>渲染线程</strong> 通过 <code>webContents.send</code> 来发送 —&gt;<code>ipcRenderer.on</code> 来监听</p>
<h2 id="Remote-模块"><a href="#Remote-模块" class="headerlink" title="Remote 模块"></a>Remote 模块</h2><p>在渲染进程里（比如<code>index.html</code>里面加载了一些<strong>js文件</strong>，那里面的<strong>js</strong>如果要使用到 <strong>BrowserWindow</strong> 这些属性的话就必须使用 <code>remote</code>）</p>
<p>使用 <code>remote</code> 模块, 你可以调用 <code>main</code> <strong>进程对象的方法</strong></p>
<h2 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h2><p><a href="https://www.misterma.com/archives/896/">https://www.misterma.com/archives/896/</a></p>
<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="网站信息"><a href="#网站信息" class="headerlink" title="网站信息"></a>网站信息</h3><p>app.setAboutPanelOptions(options)</p>
<ul>
<li>选项 对象<ul>
<li>applicationName string (可选) - 应用程序的名字</li>
<li>applicationVersion string (可选) - 应用程序版本</li>
<li>copyright string (可选) - 版权信息</li>
<li>version string (可选) macOS - 应用程序版本号</li>
<li>credits string (可选) macOS Windows - 信用信息。</li>
<li>authors string[] (可选) Linux - 应用程序作者列表。</li>
<li>website string (可选) Linux - 应用程序的网站。</li>
<li>iconPath string (可选) Linux Windows - 以JPEG 或 PNG 文件格式为应用程序图标路径。 在 Linux 上，将显示为 64x64 像素，同时保留纵横比。</li>
</ul>
</li>
</ul>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>(1)、ready 当electron完成初始化时被触发</p>
<p>app.on(‘ready’, () =&gt; {<br>      createWindow();<br>})</p>
<p>(2)、window-all-closed 所有窗口被关闭</p>
<p>app.on(‘window-all-closed’, function () {<br>})</p>
<p>(3)、quit 在所有应用程序退出时发出</p>
<p>app.on(‘window-all-closed’, function () {<br>      if (process.platform !== ‘darwin’) {<br>        app.quit()<br>      }<br>})</p>
<p>(4)、open-file 在应用中要打开一个文件时发出</p>
<p>(5)、open-url 应用中要打开一个URL网址时发出</p>
<p>(6)、activate 当应用被激活时发出</p>
<h3 id="webContents"><a href="#webContents" class="headerlink" title="webContents"></a>webContents</h3><p>did-finish-load 导航完成时触发，即选项卡的旋转器将停止旋转，并指派 onload 事件后</p>
<p>mainWindow.webContents.on(‘did-finish-load’,()=&gt;{<br>    console.log(“did-finish-load”)<br>})</p>
<p>dom-ready 一个框架中的文本加载完成后触发该事件</p>
<p>mainWindow.webContents.on(‘dom-ready’,()=&gt;{<br>    console.log(“dom-ready”)<br>})</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>ready: app 初始化完成<br>dom-ready: 一个窗口中的文本加载完成<br>did-finish-load: 导航完成时触发<br>closed: 当窗口关闭时触发，此时应删除窗口引用<br>window-all-closed: 所有窗口都被关闭时触发<br>before-quit: 在关闭窗口之前触发<br>will-quit: 在窗口关闭并且应用退出时触发<br>quit: 当所有窗口被关闭时触发</p>
<h1 id="uniapp手册"><a href="#uniapp手册" class="headerlink" title="uniapp手册"></a>uniapp手册</h1><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p>一个uni-app工程，默认包含如下目录及文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">┌─cloudfunctions        云函数目录（阿里云为aliyun，腾讯云为tcb，详见uniCloud）</span><br><span class="line">│─components            符合vue组件规范的uni-app组件目录</span><br><span class="line">│  └─comp-a.vue         可复用的a组件</span><br><span class="line">├─hybrid                存放本地网页的目录，详见</span><br><span class="line">├─platforms             存放各平台专用页面的目录，详见</span><br><span class="line">├─pages                 业务页面文件存放的目录</span><br><span class="line">│  ├─index</span><br><span class="line">│  │  └─index.vue       index页面</span><br><span class="line">│  └─list</span><br><span class="line">│     └─list.vue        list页面</span><br><span class="line">├─static                存放应用引用静态资源（如图片、视频等）的目录，注意：静态资源只能存放于此</span><br><span class="line">├─wxcomponents          存放小程序组件的目录，详见</span><br><span class="line">├─main.js               Vue初始化入口文件</span><br><span class="line">├─App.vue               应用配置，用来配置App全局样式以及监听 应用生命周期</span><br><span class="line">├─manifest.json         配置应用名称、appid、logo、版本等打包信息，详见</span><br><span class="line">└─pages.json            配置页面路由、导航条、选项卡等页面类信息，详见</span><br></pre></td></tr></table></figure>

<h2 id="资源路径说明"><a href="#资源路径说明" class="headerlink" title="资源路径说明"></a>资源路径说明</h2><ul>
<li><p>编译到任意平台时，<code>static</code> 目录下的文件均会被打包进去，非 <code>static</code> 目录下的文件（vue、js、css 等）被引用到才会被包含进去。</p>
</li>
<li><p><code>static</code> 目录下的 <code>js</code> 文件不会被编译，如果里面有 <code>es6</code> 的代码，不经过转换直接运行，在手机设备上会报错。</p>
</li>
<li><p><code>css</code>、<code>less/scss</code> 等资源同样不要放在 <code>static</code> 目录下，建议这些公用的资源放在 <code>common</code> 目录下。</p>
</li>
<li><p>```</p>
<!-- 绝对路径，/static指根目录下的static目录，在cli项目中/static指src目录下的static目录 -->
<p><image class="logo" src="/static/logo.png"></image><br><image class="logo" src="@/static/logo.png"></image></p>
<!-- 相对路径 -->
<p><image class="logo" src="../../static/logo.png"></image></p>
<p>// 绝对路径，@指向项目根目录，在cli项目中@指向src目录<br>import add from ‘@/common/add.js’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 本地背景图片/字体文件的引用路径推荐使用以 ~@ 开头的绝对路径。</span><br><span class="line"></span><br><span class="line">## 页面样式与布局</span><br><span class="line"></span><br><span class="line">`uni-app` 支持的通用 css 单位包括 px、rpx</span><br><span class="line"></span><br><span class="line">- px 即屏幕像素</span><br><span class="line"></span><br><span class="line">- rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。以750宽的屏幕为基准，750rpx恰好为屏幕宽度。屏幕变宽，rpx 实际显示效果会等比放大，但在 App 端和 H5 端屏幕宽度达到 960px 时，默认将按照 375px 的屏幕宽度进行计算，</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>{<br>  “globalStyle”: {</p>
<pre><code>&quot;rpxCalcMaxDeviceWidth&quot;: 960, // rpx 计算所支持的最大设备宽度，单位 px，默认值为 960
&quot;rpxCalcBaseDeviceWidth&quot;: 375, // rpx 计算使用的基准设备宽度，设备实际宽度超出 rpx 计算所支持的最大设备宽度时将按基准宽度计算，单位 px，默认值为 375
&quot;rpxCalcIncludeWidth&quot;: 750 // rpx 计算特殊处理的值，始终按实际的设备宽度计算，单位 rpx，默认值为 750
</code></pre>
<p>  },<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - match-media组件  为组件指定一组 media query 媒体查询规则</span><br><span class="line"></span><br><span class="line">vue页面支持下面这些普通H5单位，但在nvue里不支持：</span><br><span class="line"></span><br><span class="line">- rem 根字体大小可以通过 [page-meta](https://uniapp.dcloud.io/component/page-meta?id=page-meta) 配置</span><br><span class="line">- vh viewpoint height，视窗高度，1vh等于视窗高度的1%</span><br><span class="line">- vw viewpoint width，视窗宽度，1vw等于视窗宽度的1%</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 750，结果为：100rpx。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**tip:**</span><br><span class="line"></span><br><span class="line">- rpx不支持动态横竖屏切换计算，使用rpx建议锁定屏幕方向</span><br><span class="line"></span><br><span class="line">## 生命周期</span><br><span class="line"></span><br><span class="line">https://uniapp.dcloud.io/collocation/frame/lifecycle?id=%e5%ba%94%e7%94%a8%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f</span><br><span class="line"></span><br><span class="line">- `uni-app` 支持如下**应用生命周期**函数：</span><br><span class="line"></span><br><span class="line">  | 函数名               | 说明                                                         |</span><br><span class="line">  | :------------------- | :----------------------------------------------------------- |</span><br><span class="line">  | onLaunch             | 当`uni-app` 初始化完成时触发（全局只触发一次）               |</span><br><span class="line">  | onShow               | 当 `uni-app` 启动，或从后台进入前台显示                      |</span><br><span class="line">  | onHide               | 当 `uni-app` 从前台进入后台                                  |</span><br><span class="line">  | onError              | 当 `uni-app` 报错时触发                                      |</span><br><span class="line">  | onUniNViewMessage    | 对 `nvue` 页面发送的数据进行监听，可参考 [nvue 向 vue 通讯](https://uniapp.dcloud.io/use-weex?id=nvue-向-vue-通讯) |</span><br><span class="line">  | onUnhandledRejection | 对未处理的 Promise 拒绝事件监听函数（2.8.1+）                |</span><br><span class="line">  | onPageNotFound       | 页面不存在监听函数                                           |</span><br><span class="line">  | onThemeChange        | 监听系统主题变化                                             |</span><br><span class="line"></span><br><span class="line">  **注意**</span><br><span class="line"></span><br><span class="line">  - 应用生命周期仅可在`App.vue`中监听，在其它页面监听无效。</span><br><span class="line">  - onlaunch里进行页面跳转，如遇白屏报错，请参考https://ask.dcloud.net.cn/article/35942</span><br><span class="line"></span><br><span class="line">- **页面生命周期**</span><br><span class="line"></span><br><span class="line">  | onInit                              | 监听页面初始化，其参数同 onLoad 参数，为上个页面传递的数据，参数类型为 Object（用于页面传参），触发时机早于 onLoad | 百度小程序                                                   | 3.1.0+ |</span><br><span class="line">  | ----------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------ |</span><br><span class="line">  | onLoad                              | 监听页面加载，其参数为上个页面传递的数据，参数类型为 Object（用于页面传参），参考[示例](https://uniapp.dcloud.io/api/router?id=navigateto) |                                                              |        |</span><br><span class="line">  | onShow                              | 监听页面显示。页面每次出现在屏幕上都触发，包括从下级页面点返回露出当前页面 |                                                              |        |</span><br><span class="line">  | onReady                             | 监听页面初次渲染完成。注意如果渲染速度快，会在页面进入动画完成前触发 |                                                              |        |</span><br><span class="line">  | onHide                              | 监听页面隐藏                                                 |                                                              |        |</span><br><span class="line">  | onUnload                            | 监听页面卸载                                                 |                                                              |        |</span><br><span class="line">  | onResize                            | 监听窗口尺寸变化                                             | App、微信小程序                                              |        |</span><br><span class="line">  | onPullDownRefresh                   | 监听用户下拉动作，一般用于下拉刷新，参考[示例](https://uniapp.dcloud.io/api/ui/pulldown) |                                                              |        |</span><br><span class="line">  | onReachBottom                       | 可在pages.json里定义具体页面底部的触发距离[onReachBottomDistance](https://uniapp.dcloud.io/collocation/pages)，比如设为50，那么滚动页面到距离底部50px时，就会触发onReachBottom事件。 |                                                              |        |</span><br><span class="line">  | onTabItemTap                        | 点击 tab 时触发，参数为Object，具体见下方注意事项            | 微信小程序、支付宝小程序、百度小程序、H5、App（自定义组件模式） |        |</span><br><span class="line">  | onShareAppMessage                   | 用户点击右上角分享                                           | 微信小程序、百度小程序、字节跳动小程序、支付宝小程序         |        |</span><br><span class="line">  | onPageScroll                        | 监听页面滚动，参数为Object                                   | nvue暂不支持                                                 |        |</span><br><span class="line">  | onNavigationBarButtonTap            | 监听原生标题栏按钮点击事件，参数为Object                     | App、H5                                                      |        |</span><br><span class="line">  | onBackPress                         | 监听页面返回，返回 event = &#123;from:backbutton、 navigateBack&#125; ，backbutton 表示来源是左上角返回按钮或 android 返回键；navigateBack表示来源是 uni.navigateBack ；详细说明及使用：[onBackPress 详解](http://ask.dcloud.net.cn/article/35120)。支付宝小程序只有真机能触发，只能监听非navigateBack引起的返回，不可阻止默认行为。 | app、H5、支付宝小程序                                        |        |</span><br><span class="line">  | onNavigationBarSearchInputChanged   | 监听原生标题栏搜索输入框输入内容变化事件                     | App、H5                                                      | 1.6.0  |</span><br><span class="line">  | onNavigationBarSearchInputConfirmed | 监听原生标题栏搜索输入框搜索事件，用户点击软键盘上的“搜索”按钮时触发。 | App、H5                                                      | 1.6.0  |</span><br><span class="line">  | onNavigationBarSearchInputClicked   | 监听原生标题栏搜索输入框点击事件                             | App、H5                                                      | 1.6.0  |</span><br><span class="line">  | onShareTimeline                     | 监听用户点击右上角转发到朋友圈                               | 微信小程序                                                   | 2.8.1+ |</span><br><span class="line">  | onAddToFavorites                    | 监听用户点击右上角收藏                                       | 微信小程序                                                   | 2.8.1+ |</span><br><span class="line"></span><br><span class="line">- **组件生命周期**</span><br><span class="line"></span><br><span class="line">  `uni-app` 组件支持的生命周期，与vue标准组件的生命周期相同。这里没有页面级的onLoad等生命周期：</span><br><span class="line"></span><br><span class="line">  | 函数名        | 说明                                                         | 平台差异说明 | 最低版本 |</span><br><span class="line">  | :------------ | :----------------------------------------------------------- | :----------- | :------- |</span><br><span class="line">  | beforeCreate  | 在实例初始化之后被调用。[详见](https://cn.vuejs.org/v2/api/#beforeCreate) |              |          |</span><br><span class="line">  | created       | 在实例创建完成后被立即调用。[详见](https://cn.vuejs.org/v2/api/#created) |              |          |</span><br><span class="line">  | beforeMount   | 在挂载开始之前被调用。[详见](https://cn.vuejs.org/v2/api/#beforeMount) |              |          |</span><br><span class="line">  | mounted       | 挂载到实例上去之后调用。[详见](https://cn.vuejs.org/v2/api/#mounted) 注意：此处并不能确定子组件被全部挂载，如果需要子组件完全挂载之后在执行操作可以使用`$nextTick`[Vue官方文档](https://cn.vuejs.org/v2/api/#Vue-nextTick) |              |          |</span><br><span class="line">  | beforeUpdate  | 数据更新时调用，发生在虚拟 DOM 打补丁之前。[详见](https://cn.vuejs.org/v2/api/#beforeUpdate) | 仅H5平台支持 |          |</span><br><span class="line">  | updated       | 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。[详见](https://cn.vuejs.org/v2/api/#updated) | 仅H5平台支持 |          |</span><br><span class="line">  | beforeDestroy | 实例销毁之前调用。在这一步，实例仍然完全可用。[详见](https://cn.vuejs.org/v2/api/#beforeDestroy) |              |          |</span><br><span class="line">  | destroyed     | Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。[详见](https://cn.vuejs.org/v2/api/#destroyed) |              |          |</span><br><span class="line"></span><br><span class="line">## 路由</span><br><span class="line"></span><br><span class="line">### API</span><br><span class="line"></span><br><span class="line">框架以栈的形式管理当前所有页面， 当发生路由切换的时候，页面栈的表现如下：</span><br><span class="line"></span><br><span class="line">| 路由方式   | 页面栈表现                        | 触发时机                                                     |</span><br><span class="line">| ---------- | --------------------------------- | ------------------------------------------------------------ |</span><br><span class="line">| 初始化     | 新页面入栈                        | uni-app 打开的第一个页面                                     |</span><br><span class="line">| 打开新页面 | 新页面入栈                        | 调用 API  [uni.navigateTo](https://uniapp.dcloud.io/api/router?id=navigateto) 、使用组件  [](https://uniapp.dcloud.io/component/navigator?id=navigator) |</span><br><span class="line">| 页面重定向 | 当前页面出栈，新页面入栈          | 调用 API  [uni.redirectTo](https://uniapp.dcloud.io/api/router?id=redirectto) 、使用组件 [](https://uniapp.dcloud.io/component/navigator?id=navigator) |</span><br><span class="line">| 页面返回   | 页面不断出栈，直到目标返回页      | 调用 API  [uni.navigateBack](https://uniapp.dcloud.io/api/router?id=navigateback)  、使用组件 [](https://uniapp.dcloud.io/component/navigator?id=navigator) 、用户按左上角返回按钮、安卓用户点击物理back按键 |</span><br><span class="line">| Tab 切换   | 页面全部出栈，只留下新的 Tab 页面 | 调用 API  [uni.switchTab](https://uniapp.dcloud.io/api/router?id=switchtab) 、使用组件 [](https://uniapp.dcloud.io/component/navigator?id=navigator) 、用户切换 Tab |</span><br><span class="line">| 重加载     | 页面全部出栈，只留下新的页面      | 调用 API  [uni.reLaunch](https://uniapp.dcloud.io/api/router?id=relaunch) 、使用组件  [](https://uniapp.dcloud.io/component/navigator?id=navigator) |</span><br><span class="line"></span><br><span class="line">### 传参</span><br><span class="line"></span><br><span class="line">#### navigateBack</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>//page-A<br>let pages = getCurrentPages();<br>let currPage = pages[pages.length - 1]; // 当前页的实例<br>this.cityCul = currPage.$vm.cityCul</p>
</li>
</ul>
<p>//page-B<br>let pages = getCurrentPages()<br>let nowPage = pages[pages.length - 1]; //当前页页面实例<br>let prevPage = pages[pages.length - 2]; //上一页页面实例<br>prevPage.$vm.cityCul = this.CityCul<br>uni.navigateBack({<br>        url: “../index/index?city=” + this.CityCul</p>
<p>});</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### Tips:</span><br><span class="line"></span><br><span class="line">- **目前页面路径最多只能十层。**</span><br><span class="line"></span><br><span class="line">## 运行环境判断</span><br><span class="line"></span><br><span class="line">[开发环境和生产环境](https://uniapp.dcloud.io/frame?id=开发环境和生产环境)</span><br><span class="line"></span><br><span class="line">`uni-app` 可通过 `process.env.NODE_ENV` 判断当前环境是开发环境还是生产环境。一般用于连接测试服务器或生产服务器的动态切换。</span><br><span class="line"></span><br><span class="line">- 在HBuilderX 中，点击“运行”编译出来的代码是开发环境，点击“发行”编译出来的代码是生产环境</span><br><span class="line">- cli模式下，是通行的编译环境处理方式。</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">if(process.env.NODE_ENV === &#x27;development&#x27;)&#123;</span><br><span class="line">    console.log(&#x27;开发环境&#x27;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    console.log(&#x27;生产环境&#x27;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><a href="https://uniapp.dcloud.io/frame?id=%E5%88%A4%E6%96%AD%E5%B9%B3%E5%8F%B0">判断平台</a></strong></p>
<p>平台判断有2种场景，一种是在编译期判断，一种是在运行期判断。</p>
<ul>
<li>编译期判断 编译期判断，即条件编译，不同平台在编译出包后已经是不同的代码。详见：<a href="https://uniapp.dcloud.io/platform">条件编译</a></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// #ifdef H5</span></span><br><span class="line">    alert(<span class="string">&quot;只有h5平台才有alert方法&quot;</span>)</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>运行期判断 运行期判断是指代码已经打入包中，仍然需要在运行期判断平台，此时可使用 <code>uni.getSystemInfoSync().platform</code> 判断客户端环境是 Android、iOS 还是小程序开发工具（在百度小程序开发工具、微信小程序开发工具、支付宝小程序开发工具中使用 <code>uni.getSystemInfoSync().platform</code> 返回值均为 devtools）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(uni.getSystemInfoSync().platform)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;android&#x27;</span>:</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;运行Android上&#x27;</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ios&#x27;</span>:</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;运行iOS上&#x27;</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">&#x27;运行在开发者工具上&#x27;</span>)</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="页面样式与尺寸"><a href="#页面样式与尺寸" class="headerlink" title="页面样式与尺寸"></a>页面样式与尺寸</h2><p><a href="https://uniapp.dcloud.io/frame?id=%E5%B0%BA%E5%AF%B8%E5%8D%95%E4%BD%8D">尺寸单位</a></p>
<p><code>uni-app</code> 支持的通用 css 单位包括 px、rpx</p>
<ul>
<li><p>px 即屏幕像素</p>
</li>
<li><p>rpx 即响应式px，一种根据屏幕宽度自适应的动态单位。</p>
<p>rpx 是相对于基准宽度的单位，可以根据屏幕宽度进行自适应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开发者可以通过设计稿基准宽度计算页面元素 rpx 值，设计稿 1px 与框架样式 1rpx 转换公式如下：</span><br><span class="line">设计稿 1px / 设计稿基准宽度 = 框架样式 1rpx / 750rpx</span><br><span class="line">750 * 元素在设计稿中的宽度 / 设计稿基准宽度</span><br><span class="line"></span><br><span class="line">举例说明：</span><br><span class="line">若设计稿宽度为 750px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 750，结果为：100rpx。</span><br><span class="line">若设计稿宽度为 640px，元素 A 在设计稿上的宽度为 100px，那么元素 A 在 uni-app 里面的宽度应该设为：750 * 100 / 640，结果为：117rpx。</span><br></pre></td></tr></table></figure></li>
<li><h3 id="固定值"><a href="#固定值" class="headerlink" title="固定值"></a>固定值</h3></li>
</ul>
<p><code>uni-app</code> 中以下组件的高度是固定的，不可修改：</p>
<table>
<thead>
<tr>
<th align="left">组件</th>
<th align="left">描述</th>
<th align="left">App</th>
<th align="left">H5</th>
</tr>
</thead>
<tbody><tr>
<td align="left">NavigationBar</td>
<td align="left">导航栏</td>
<td align="left">44px</td>
<td align="left">44px</td>
</tr>
<tr>
<td align="left">TabBar</td>
<td align="left">底部选项卡</td>
<td align="left">HBuilderX 2.3.4之前为56px，2.3.4起和H5调为一致，统一为 50px。但可以自主更改高度）</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="renderjs"><a href="#renderjs" class="headerlink" title="renderjs"></a>renderjs</h2><p><code>renderjs</code>是一个运行在视图层的js。它比<a href="https://uniapp.dcloud.io/?id=wxs">WXS</a>更加强大。它只支持app-vue和h5。</p>
<p><code>renderjs</code>的主要作用有2个：</p>
<ul>
<li>大幅降低逻辑层和视图层的通讯损耗，提供高性能视图交互能力</li>
<li>在视图层操作dom，运行for web的js库</li>
</ul>
<p><strong>使用方式</strong></p>
<p>设置 script 节点的 lang 为 renderjs</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">module</span>=<span class="string">&quot;test&quot;</span> <span class="attr">lang</span>=<span class="string">&quot;renderjs&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// ...</span></span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="使用vue注意事项"><a href="#使用vue注意事项" class="headerlink" title="使用vue注意事项"></a>使用vue注意事项</h2><h3 id="uniapp中nvue与vue的区别"><a href="#uniapp中nvue与vue的区别" class="headerlink" title="uniapp中nvue与vue的区别"></a>uniapp中nvue与vue的区别</h3><p>uni-app是逻辑和渲染分离的，渲染层在<strong>app端</strong>提供了两套排版引擎。<br>小程序方式的webview渲染，和weex方式的原生渲染，两种渲染引擎可以自己根据需要选。<br> <strong>vue文件走的webview渲染</strong><br> <strong>nvue走weex方式的原生渲染</strong></p>
<p>组件和js写法是一样的，css不一样，原生排版的能用的css必须是flex布局</p>
<p>虽然nvue也可以多端编译，输出H5和小程序，但nvue的css写法受限，所以如果你不开发App，那么不需要使用nvue。</p>
<p>一个<strong>App</strong>中可以同时使用两种页面，比如首页使用nvue，二级页使用vue页面，hello uni-app示例就是如此。</p>
<h3 id="nvue适用场景"><a href="#nvue适用场景" class="headerlink" title="nvue适用场景"></a>nvue适用场景</h3><p>在App端某些vue页面表现不佳的场景下使用 nvue 作为强化补充。这些场景如下：</p>
<ol>
<li>需要高性能的区域长列表或瀑布流滚动。webview的页面级长列表滚动时没有性能问题的（就是滚动条覆盖webview整体高度），但页面中某个区域做长列表滚动，则需要使用nvue的<code>list</code>、<code>recycle-list</code>、<code>waterfall</code>等组件(<a href="https://uniapp.dcloud.io/component/list">详见</a>)。这些组件的性能要高于vue页面里的区域滚动组件<code>scroll-view</code>。</li>
<li>复杂高性能的自定义下拉刷新。uni-app的pages.json里可以配置原生下拉刷新，但引擎内置的下拉刷新样式只有雪花和circle圈2种样式。如果你需要自己做复杂的下拉刷新，推荐使用nvue的refresh组件。当然<a href="https://ext.dcloud.net.cn/search?q=%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0">插件市场</a>里也有很多vue下的自定义下拉刷新插件，只要是基于renderjs或wxs的，性能也可以商用，只是没有nvue的<code>refresh</code>组件更极致。</li>
<li>左右拖动的长列表。在webview里，通过<code>swiper</code>+<code>scroll-view</code>实现左右拖动的长列表，前端模拟下拉刷新，这套方案的性能不好。此时推荐使用nvue，比如新建uni-app项目时的<a href="https://ext.dcloud.net.cn/plugin?id=103">新闻示例模板</a>，就采用了nvue，切换很流畅。</li>
<li>实现区域滚动长列表+左右拖动列表+吸顶的复杂排版效果，效果可参考hello uni-app模板里的<code>swiper-list</code>。<a href="https://ext.dcloud.net.cn/plugin?id=2128">详见</a></li>
<li>如需要将软键盘右下角按钮文字改为“发送”，则需要使用nvue。比如聊天场景，除了软键盘右下角的按钮文字处理外，还涉及聊天记录区域长列表滚动，适合nvue来做。</li>
<li>解决前端控件无法覆盖原生控件的层级问题。当你使用<code>map</code>、<code>video</code>、<code>live-pusher</code>等原生组件时，会发现前端写的<code>view</code>等组件无法覆盖原生组件，层级问题处理比较麻烦，此时使用nvue更好。或者在vue页面上也可以覆盖一个subnvue（一种非全屏的nvue页面覆盖在webview上），以解决App上的原生控件层级问题。<a href="https://uniapp.dcloud.io/component/native-component">详见</a></li>
<li>如深度使用<code>map</code>组件，建议使用nvue。除了层级问题，App端nvue文件的map功能更完善，和小程序拉齐度更高，多端一致性更好。</li>
<li>如深度使用<code>video</code>，建议使用nvue。比如如下2个场景：video内嵌到swiper中，以实现抖音式视频滑动切换，例子见<a href="https://ext.dcloud.net.cn/search?q=%E4%BB%BF%E6%8A%96%E9%9F%B3">插件市场</a>；nvue的视频全屏后，通过<code>cover-view</code>实现内容覆盖，比如增加文字标题、分享按钮。</li>
<li>直播推流：nvue下有<code>live-pusher</code>组件，和小程序对齐，功能更完善，也没有层级问题。</li>
<li>对App启动速度要求极致化。App端v3编译器模式下，如果首页使用nvue且在manifest里配置fast模式，那么App的启动速度可以控制在1秒左右。而使用vue页面的话，App的启动速度一般是3秒起，取决于你的代码性能和体积。</li>
</ol>
<h3 id="nvue开发与vue开发的常见区别"><a href="#nvue开发与vue开发的常见区别" class="headerlink" title="nvue开发与vue开发的常见区别"></a><a href="https://uniapp.dcloud.io/use-weex?id=nvue%E5%BC%80%E5%8F%91%E4%B8%8Evue%E5%BC%80%E5%8F%91%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8C%BA%E5%88%AB">nvue开发与vue开发的常见区别</a></h3><p>基于原生引擎的渲染，虽然还是前端技术栈，但和web开发肯定是有区别的。</p>
<ol>
<li>nvue 页面控制显隐只可以使用<code>v-if</code>不可以使用<code>v-show</code></li>
<li>nvue 页面只能使用<code>flex</code>布局，不支持其他布局方式。页面开发前，首先想清楚这个页面的纵向内容有什么，哪些是要滚动的，然后每个纵向内容的横轴排布有什么，按 flex 布局设计好界面。</li>
<li>nvue 页面的布局排列方向默认为竖排（<code>column</code>），如需改变布局方向，可以在 <code>manifest.json</code> -&gt; <code>app-plus</code> -&gt; <code>nvue</code> -&gt; <code>flex-direction</code> 节点下修改，仅在 uni-app 模式下生效。<a href="https://uniapp.dcloud.io/collocation/manifest?id=nvue">详情</a>。</li>
<li>nvue页面编译为H5、小程序时，会做一件css默认值对齐的工作。因为weex渲染引擎只支持flex，并且默认flex方向是垂直。而H5和小程序端，使用web渲染，默认不是flex，并且设置<code>display:flex</code>后，它的flex方向默认是水平而不是垂直的。所以nvue编译为H5、小程序时，会自动把页面默认布局设为flex、方向为垂直。当然开发者手动设置后会覆盖默认设置。</li>
<li>文字内容，必须、只能在<code>&lt;text&gt;</code>组件下。不能在<code>&lt;div&gt;</code>、<code>&lt;view&gt;</code>的<code>text</code>区域里直接写文字。否则即使渲染了，也无法绑定js里的变量。</li>
<li>只有<code>text</code>标签可以设置字体大小，字体颜色。</li>
<li>布局不能使用百分比、没有媒体查询。</li>
<li>nvue 切换横竖屏时可能导致样式出现问题，建议有 nvue 的页面锁定手机方向。</li>
<li>支持的css有限，不过并不影响布局出你需要的界面，<code>flex</code>还是非常强大的。详见</li>
<li>不支持背景图。但可以使用<code>image</code>组件和层级来实现类似web中的背景效果。因为原生开发本身也没有web这种背景图概念</li>
<li>css选择器支持的比较少，只能使用 class 选择器。<a href="https://uniapp.dcloud.io/use-weex?id=%E6%A0%B7%E5%BC%8F">详见</a></li>
<li>nvue 的各组件在安卓端默认是透明的，如果不设置<code>background-color</code>，可能会导致出现重影的问题。</li>
<li><code>class</code> 进行绑定时只支持数组语法。</li>
<li>Android端在一个页面内使用大量圆角边框会造成性能问题，尤其是多个角的样式还不一样的话更耗费性能。应避免这类使用。</li>
<li>nvue页面没有<code>bounce</code>回弹效果，只有几个列表组件有<code>bounce</code>效果，包括 <code>list</code>、<code>recycle-list</code>、<code>waterfall</code>。</li>
<li>原生开发没有页面滚动的概念，页面内容高过屏幕高度并不会自动滚动，只有部分组件可滚动（<code>list</code>、<code>waterfall</code>、<code>scroll-view/scroller</code>），要滚得内容需要套在可滚动组件下。这不符合前端开发的习惯，所以在 nvue 编译为 uni-app模式时，给页面外层自动套了一个 <code>scroller</code>，页面内容过高会自动滚动。（组件不会套，页面有<code>recycle-list</code>时也不会套）。后续会提供配置，可以设置不自动套。</li>
<li>在 App.vue 中定义的全局js变量不会在 nvue 页面生效。<code>globalData</code>和<code>vuex</code>是生效的。</li>
<li>App.vue 中定义的全局css，对nvue和vue页面同时生效。如果全局css中有些css在nvue下不支持，编译时控制台会报警，建议把这些不支持的css包裹在<a href="https://uniapp.dcloud.io/platform">条件编译</a>里，<code>APP-PLUS-NVUE</code></li>
<li>不能在 <code>style</code> 中引入字体文件，nvue 中字体图标的使用参考：<a href="https://uniapp.dcloud.io/use-weex?id=addrule">加载自定义字体</a>。如果是本地字体，可以用<code>plus.io</code>的API转换路径。</li>
<li>目前不支持在 nvue 页面使用 <code>typescript/ts</code>。</li>
<li>nvue 页面关闭原生导航栏时，想要模拟状态栏，可以<a href="https://ask.dcloud.net.cn/article/35111">参考文章</a>。但是，仍然强烈建议在nvue页面使用原生导航栏。nvue的渲染速度再快，也没有原生导航栏快。原生排版引擎解析<code>json</code>绘制原生导航栏耗时很少，而解析nvue的js绘制整个页面的耗时要大的多，尤其在新页面进入动画期间，对于复杂页面，没有原生导航栏会在动画期间产生整个屏幕的白屏或闪屏。</li>
</ol>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><ul>
<li><p><code>uni-app</code> 完整支持 <code>Vue</code> 实例的生命周期，同时还新增 <a href="https://uniapp.dcloud.io/frame?id=%E5%BA%94%E7%94%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">应用生命周期</a> 及 <a href="https://uniapp.dcloud.io/frame?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">页面生命周期</a>。</p>
</li>
<li><p><code>uni-app</code> 完整支持 <code>Vue</code> 模板语法</p>
</li>
<li><p><code>data</code> 必须声明为返回一个初始数据对象的函数（注意函数内返回的数据对象不要直接引用函数外的对象）；否则页面关闭时，数据不会自动销毁，再次打开该页面时，会显示上次数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        title: &#x27;Hello&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p>条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。</p>
<p><strong>写法：</strong>以 #ifdef 或 #ifndef 加 <strong>%PLATFORM%</strong> 开头，以 #endif 结尾。</p>
<ul>
<li>#ifdef：if defined 仅在某平台存在</li>
<li>#ifndef：if not defined 除了某平台均存在</li>
<li>**%PLATFORM%**：平台名称</li>
</ul>
<table>
<thead>
<tr>
<th>#ifdef <strong>APP-PLUS</strong> 需条件编译的代码 #endif</th>
<th>仅出现在 App 平台下的代码</th>
</tr>
</thead>
<tbody><tr>
<td>#ifndef <strong>H5</strong> 需条件编译的代码 #endif</td>
<td>除了 H5 平台，其它平台均存在的代码</td>
</tr>
<tr>
<td>#ifdef <strong>H5</strong> || <strong>MP-WEIXIN</strong> 需条件编译的代码 #endif</td>
<td>在 H5 平台或微信小程序平台存在的代码（这里只有||，不可能出现&amp;&amp;，因为没有交集）</td>
</tr>
</tbody></table>
<p><strong>%PLATFORM%</strong> <strong>可取值如下：</strong></p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">平台</th>
</tr>
</thead>
<tbody><tr>
<td align="left">APP-PLUS</td>
<td align="left">App</td>
</tr>
<tr>
<td align="left">APP-PLUS-NVUE</td>
<td align="left">App nvue</td>
</tr>
<tr>
<td align="left">H5</td>
<td align="left">H5</td>
</tr>
<tr>
<td align="left">MP-WEIXIN</td>
<td align="left">微信小程序</td>
</tr>
<tr>
<td align="left">MP-ALIPAY</td>
<td align="left">支付宝小程序</td>
</tr>
<tr>
<td align="left">MP-BAIDU</td>
<td align="left">百度小程序</td>
</tr>
<tr>
<td align="left">MP-TOUTIAO</td>
<td align="left">字节跳动小程序</td>
</tr>
</tbody></table>
<h3 id="pages-json-的条件编译"><a href="#pages-json-的条件编译" class="headerlink" title="pages.json 的条件编译"></a>pages.json 的条件编译</h3><p>下面的页面，只有运行至 App 时才会编译进去。</p>
<p><img src="https://img-cdn-qiniu.dcloud.net.cn/uniapp/doc/img/platform-4.png" alt="img"></p>
<h1 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h1><h2 id="页面实例"><a href="#页面实例" class="headerlink" title="页面实例"></a>页面实例</h2><h3 id="getApp"><a href="#getApp" class="headerlink" title="getApp"></a>getApp</h3><p><code>getApp()</code> 函数用于获取当前应用实例，一般用于获取globalData 。</p>
<p><strong>实例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = getApp()</span><br><span class="line"><span class="built_in">console</span>.log(app.globalData)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>不要在定义于 <code>App()</code> 内的函数中，或调用 <code>App</code> 前调用 <code>getApp()</code> ，可以通过 <code>this.$scope</code> 获取对应的app实例</li>
<li>通过 <code>getApp()</code> 获取实例之后，不要私自调用生命周期函数。</li>
<li>v3模式加速了首页<code>nvue</code>的启动速度，当在首页<code>nvue</code>中使用<code>getApp()</code>不一定可以获取真正的<code>App</code>对象。对此v3版本提供了<code>const app = getApp(&#123;allowDefault: true&#125;)</code>用来获取原始的<code>App</code>对象，可以用来在首页对<code>globalData</code>等初始化</li>
</ul>
<h3 id="getCurrentPages"><a href="#getCurrentPages" class="headerlink" title="getCurrentPages()"></a><a href="https://uniapp.dcloud.io/collocation/frame/window?id=getcurrentpages">getCurrentPages()</a></h3><p><code>getCurrentPages()</code> 函数用于获取当前<strong>页面栈的实例</strong>，以数组形式按栈的顺序给出，第一个元素为首页，最后一个元素为当前页面。</p>
<p><strong>注意：</strong> <code>getCurrentPages()</code>仅用于展示页面栈的情况，请勿修改页面栈，以免造成页面状态错误。</p>
<p>每个页面实例的方法属性列表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>平台说明</th>
</tr>
</thead>
<tbody><tr>
<td>page.$getAppWebview()</td>
<td>获取当前页面的webview对象实例</td>
<td>App</td>
</tr>
<tr>
<td>page.route</td>
<td>获取当前页面的路由</td>
<td></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pages = getCurrentPages()</span><br><span class="line"><span class="keyword">let</span> nowPage = pages[pages.length - <span class="number">1</span>]; <span class="comment">//当前页页面实例</span></span><br><span class="line"><span class="keyword">let</span> prevPage = pages[pages.length - <span class="number">2</span>]; <span class="comment">//上一页页面实例</span></span><br><span class="line"><span class="built_in">console</span>.log(prevPage)</span><br><span class="line">prevPage.$vm.cityCul = <span class="built_in">this</span>.CityCul <span class="comment">//给上一个页面实例添加一个data</span></span><br></pre></td></tr></table></figure>

<p>Tips：</p>
<ul>
<li><code>navigateTo</code>, <code>redirectTo</code> 只能打开非 tabBar 页面。</li>
<li><code>switchTab</code> 只能打开 <code>tabBar</code> 页面。</li>
<li><code>reLaunch</code> 可以打开任意页面。</li>
<li>页面底部的 <code>tabBar</code> 由页面决定，即只要是定义为 <code>tabBar</code> 的页面，底部都有 <code>tabBar</code>。</li>
<li>不能在 <code>App.vue</code> 里面进行页面跳转。</li>
</ul>
<h3 id="getAppWebview"><a href="#getAppWebview" class="headerlink" title="$getAppWebview()"></a><a href="https://uniapp.dcloud.io/collocation/frame/window?id=getappwebview">$getAppWebview()</a></h3><p><code>uni-app</code> 在 <code>getCurrentPages()</code>获得的页面里内置了一个方法 <code>$getAppWebview()</code> 可以得到当前webview的对象实例，从而实现对 webview 更强大的控制。在 html5Plus 中，plus.webview具有强大的控制能力，可参考：<a href="http://www.html5plus.org/doc/zh_cn/webview.html#plus.webview.WebviewObject">WebviewObject</a>。</p>
<p>但<code>uni-app</code>框架有自己的窗口管理机制，请不要自己创建和销毁webview，如有需求覆盖子窗体上去，请使用<a href="https://uniapp.dcloud.io/api/window/subNVues">原生子窗体subNvue</a>。</p>
<p><strong>注意：此方法仅 App 支持</strong></p>
<p><strong>示例：</strong></p>
<p>获取当前页面 webview 的对象实例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onLoad</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// #ifdef APP-PLUS</span></span><br><span class="line">    <span class="keyword">const</span> currentWebview = <span class="built_in">this</span>.$scope.$getAppWebview(); <span class="comment">//此对象相当于html5plus里的plus.webview.currentWebview()。在uni-app里vue页面直接使用plus.webview.currentWebview()无效，非v3编译模式使用this.$mp.page.$getAppWebview()</span></span><br><span class="line">    currentWebview.setBounce(&#123;<span class="attr">position</span>:&#123;<span class="attr">top</span>:<span class="string">&#x27;100px&#x27;</span>&#125;,<span class="attr">changeoffset</span>:&#123;<span class="attr">top</span>:<span class="string">&#x27;0px&#x27;</span>&#125;&#125;); <span class="comment">//动态重设bounce效果</span></span><br><span class="line">    <span class="comment">// #endif</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取指定页面 webview 的对象实例</p>
<p><code>getCurrentPages()</code>可以得到所有页面对象，然后根据数组，可以取指定的页面webview对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pages = getCurrentPages();</span><br><span class="line"><span class="keyword">var</span> page = pages[pages.length - <span class="number">1</span>];</span><br><span class="line"><span class="comment">// #ifdef APP-PLUS</span></span><br><span class="line"><span class="keyword">var</span> currentWebview = page.$getAppWebview();</span><br><span class="line"><span class="built_in">console</span>.log(currentWebview.id);<span class="comment">//获得当前webview的id</span></span><br><span class="line"><span class="built_in">console</span>.log(currentWebview.isVisible());<span class="comment">//查询当前webview是否可见</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// #endif</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>uniapp,electron</category>
      </categories>
      <tags>
        <tag>uniapp</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>前端原理和源码</title>
    <url>/2023/05/30/00-%E5%8E%9F%E7%90%86%E5%92%8C%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><h2 id="webpack执⾏流程"><a href="#webpack执⾏流程" class="headerlink" title="webpack执⾏流程"></a>webpack执⾏流程</h2><h3 id="简略流程"><a href="#简略流程" class="headerlink" title="简略流程"></a>简略流程</h3><img src="img/常识/image-20220909135015955.png" alt="image-20220909135015955" style="zoom: 50%;" />

<p>图示流程理解分析：</p>
<ol>
<li><p>读取⼊⼝⽂件；</p>
</li>
<li><p>基于 AST（抽象语法树） 分析⼊⼝⽂件，并产出依赖列表；</p>
</li>
<li><p>AST （Abstract Syntax Tree）抽象语法树 在计算机科学中，或简称语法树（Syntax tree），是源代码语法结构的⼀种抽象表示。它以树状的形式表现编程语⾔的语法结构，树上的每个节点都表示源代码中的⼀种结构。</p>
</li>
<li><p>使⽤ Babel 将相关模块编译到 ES5；</p>
</li>
<li><p>webpack有⼀个智能解析器（各种babel），⼏乎可以处理任何第三⽅库。⽆论它们的模块形式是CommonJS、AMD还是普通的JS⽂件；甚⾄在加载依赖的时候，允许使⽤动态表require(“、/templates/“+name+”、jade”)。以下这些⼯具底层依赖了不同的解析器⽣成AST，⽐如eslint使⽤了espree、babel使⽤了acorn</p>
</li>
<li><p>对每个依赖模块产出⼀个唯⼀的 ID，⽅便后续读取模块相关内容；</p>
</li>
<li><p>将每个依赖以及经过 Babel 编译过后的内容，存储在⼀个对象中进⾏维护；</p>
</li>
<li><p>遍历上⼀步中的对象，构建出⼀个依赖图（Dependency Graph）；</p>
</li>
<li><p>将各模块内容 bundle 产出</p>
</li>
</ol>
<h3 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h3><img src="http://blog.51weblove.com/wp-content/uploads/2021/10/webpack%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-scaled.jpg" alt="img" style="zoom: 150%;" />

<p>流程：</p>
<ol>
<li>通过命令行和 <code>webpack.config.js</code> 来获取参数</li>
<li>创建<code>compiler</code>对象，初始化<code>plugins</code></li>
<li>开始编译阶段，<code>addEntry</code>添加入口资源</li>
<li><code>addModule</code> 创建模块</li>
<li><code>runLoaders</code> 执行 <code>loader</code></li>
<li>依赖收集，js 通过<code>acorn</code>解析为 <code>AST</code>，然后查找依赖，并重复 4 步</li>
<li>构建完<strong>依赖树</strong>后，进入生成阶段，调用<code>compilation.seal</code></li>
<li>经过一系列的<code>optimize</code>优化依赖，生成 <code>chunks</code>，写入文件</li>
</ol>
<h2 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h2><p>⼿写webpack原理 <a href="https://juejin.cn/post/6854573217336541192">https://juejin.cn/post/6854573217336541192</a></p>
<p>webpack打包原理 <a href="https://blog.csdn.net/weixin_41319237/article/details/116194091">https://blog.csdn.net/weixin_41319237/article/details/116194091</a></p>
<p><strong>主要流程</strong></p>
<ol>
<li>需要读到入口文件里面的内容</li>
<li>分析入口文件，递归的去读取模块所依赖的文件内容，生成AST语法树。</li>
<li>根据AST语法树，生成浏览器能够运行的代码</li>
</ol>
<p><strong>具体细节</strong></p>
<ol>
<li>获取主模块内容</li>
<li>分析模块<ul>
<li>安装@babel/parser包（生成AST）</li>
</ul>
</li>
<li>对模块内容进行处理<ul>
<li>安装@babel/traverse包（遍历AST收集依赖）</li>
<li>安装@babel/core和@babel/preset-env包   （es6转ES5）</li>
</ul>
</li>
<li>递归所有模块</li>
<li>执行require和exports。生成最终代码</li>
</ol>
<h3 id="基本准备工作"><a href="#基本准备工作" class="headerlink" title="基本准备工作"></a>基本准备工作</h3><p>先建一个项目</p>
<p>我们创建了add.js文件和minus.js文件,然后 在index.js中引入，再将index.js文件引入index.html。</p>
<p>代码如下:</p>
<p>add.js</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">export default (<span class="selector-tag">a</span>,<span class="selector-tag">b</span>)=&gt;&#123;</span><br><span class="line">  return <span class="selector-tag">a</span>+<span class="selector-tag">b</span>;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>minus.js</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">export const minus = (<span class="selector-tag">a</span>,<span class="selector-tag">b</span>)=&gt;&#123;</span><br><span class="line">    return <span class="selector-tag">a</span>-<span class="selector-tag">b</span></span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">&quot;./add.js&quot;</span></span><br><span class="line"><span class="keyword">import</span> &#123;minus&#125; <span class="keyword">from</span> <span class="string">&quot;./minus.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sum = add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">const</span> division = minus(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum);</span><br><span class="line"><span class="built_in">console</span>.log(division);</span><br></pre></td></tr></table></figure>

<p>index.html</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./src/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>现在我们打开index.html。你猜会发生什么？？？显然会报错，因为浏览器还不能识别import等ES6语法</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e4428e16ee77~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="获取主模块内容"><a href="#获取主模块内容" class="headerlink" title="获取主模块内容"></a>获取主模块内容</h3><p>bundle.js文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主入口文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(body);</span><br><span class="line">&#125;</span><br><span class="line">getModuleInfo(<span class="string">&quot;./src/index.js&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行一下bundle.js：<code>node bundle.js</code></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e4428eab35af~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="分析模块babel-parser"><a href="#分析模块babel-parser" class="headerlink" title="分析模块babel/parser"></a>分析模块babel/parser</h3><p>分析模块的主要任务是 将获取到的主模块内容 解析成AST语法树，这个需要用到一个依赖包@babel/parser</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/parser</span><br></pre></td></tr></table></figure>

<p>ok,安装完成我们将@babel/parser引入bundle.js,</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取主入口文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(body,&#123;</span><br><span class="line">        <span class="attr">sourceType</span>:<span class="string">&#x27;module&#x27;</span> <span class="comment">//表示我们要解析的是ES模块</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(ast);</span><br><span class="line"><span class="comment">//当前我们解析出来的不单单是index.js文件里的内容，它也包括了文件的其他信息。 而它的内容其实是它的属性program里的body里</span></span><br><span class="line">    <span class="built_in">console</span>.log(ast.program.body);</span><br><span class="line">&#125;</span><br><span class="line">getModuleInfo(<span class="string">&quot;./src/index.js&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="收集依赖babel-traverse"><a href="#收集依赖babel-traverse" class="headerlink" title="收集依赖babel/traverse"></a>收集依赖babel/traverse</h3><p>现在我们需要 遍历AST，将用到的依赖收集起来。什么意思呢？其实就是将用import语句引入的文件路径收集起来。我们将收集起来的路径放到deps里。</p>
<p>前面我们提到过，遍历AST要用到@babel/traverse依赖包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/traverse</span><br></pre></td></tr></table></figure>

<p>现在，我们引入。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(body,&#123;</span><br><span class="line">        <span class="attr">sourceType</span>:<span class="string">&#x27;module&#x27;</span> <span class="comment">//表示我们要解析的是ES模块</span></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">    traverse(ast,&#123;</span><br><span class="line">         <span class="comment">//ImportDeclaration方法代表的是对ast中type类型为ImportDeclaration的节点的处理。</span></span><br><span class="line">        <span class="function"><span class="title">ImportDeclaration</span>(<span class="params">&#123;node&#125;</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">            <span class="keyword">const</span> abspath = <span class="string">&#x27;./&#x27;</span> + path.join(dirname,node.source.value)</span><br><span class="line">            deps[node.source.value] = abspath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(deps);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">getModuleInfo(<span class="string">&quot;./src/index.js&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="ES6的AST转化成ES5"><a href="#ES6的AST转化成ES5" class="headerlink" title="ES6的AST转化成ES5"></a>ES6的AST转化成ES5</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install @babel/core @babel/preset-env</span><br></pre></td></tr></table></figure>

<p>我们现在将依赖引入并使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">&#x27;@babel/parser&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">&#x27;@babel/traverse&#x27;</span>).default</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">&#x27;@babel/core&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(body,&#123;</span><br><span class="line">        <span class="attr">sourceType</span>:<span class="string">&#x27;module&#x27;</span> <span class="comment">//表示我们要解析的是ES模块</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">    traverse(ast,&#123;</span><br><span class="line">        <span class="function"><span class="title">ImportDeclaration</span>(<span class="params">&#123;node&#125;</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">            <span class="keyword">const</span> abspath = <span class="string">&quot;./&quot;</span> + path.join(dirname,node.source.value)</span><br><span class="line">            deps[node.source.value] = abspath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    新增代码</span><br><span class="line">    <span class="keyword">const</span> &#123;code&#125; = babel.transformFromAst(ast,<span class="literal">null</span>,&#123;</span><br><span class="line">        <span class="attr">presets</span>:[<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(code);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">getModuleInfo(<span class="string">&quot;./src/index.js&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="递归获取所有依赖"><a href="#递归获取所有依赖" class="headerlink" title="递归获取所有依赖"></a>递归获取所有依赖</h3><p>经过上面的过程，现在我们知道getModuleInfo是用来获取一个模块的内容，不过我们还没把获取的内容return出来，因此，更改下getModuleInfo方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getModuleInfo = <span class="function">(<span class="params">file</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> body = fs.readFileSync(file,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="keyword">const</span> ast = parser.parse(body,&#123;</span><br><span class="line">        <span class="attr">sourceType</span>:<span class="string">&#x27;module&#x27;</span> <span class="comment">//表示我们要解析的是ES模块</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> deps = &#123;&#125;</span><br><span class="line">    traverse(ast,&#123;</span><br><span class="line">        <span class="function"><span class="title">ImportDeclaration</span>(<span class="params">&#123;node&#125;</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> dirname = path.dirname(file)</span><br><span class="line">            <span class="keyword">const</span> abspath = <span class="string">&quot;./&quot;</span> + path.join(dirname,node.source.value)</span><br><span class="line">            deps[node.source.value] = abspath</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> &#123;code&#125; = babel.transformFromAst(ast,<span class="literal">null</span>,&#123;</span><br><span class="line">        <span class="attr">presets</span>:[<span class="string">&quot;@babel/preset-env&quot;</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="keyword">const</span> moduleInfo = &#123;file,deps,code&#125;</span><br><span class="line">    <span class="keyword">return</span> moduleInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们返回了一个对象 ，这个对象包括<strong>主模块的路径（file）</strong>，<strong>主模块的依赖（deps）</strong>，<strong>主模块转化成es5的代码</strong></p>
<p>该方法只能获取一个模块的的信息，但是我们要怎么获取一个模块里面的依赖模块的信息呢？递归。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//递归获取依赖</span><br><span class="line">const parseModules = (file) =&gt;&#123;</span><br><span class="line">    const entry =  getModuleInfo(file)</span><br><span class="line">    const temp = [entry]</span><br><span class="line">    for (let i = 0;i&lt;temp.length;i++)&#123;</span><br><span class="line">        const deps = temp[i].deps</span><br><span class="line">        if (deps)&#123;</span><br><span class="line">            for (const key in deps)&#123;</span><br><span class="line">                if (deps.hasOwnProperty(key))&#123;</span><br><span class="line">                    temp.push(getModuleInfo(deps[key]))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(temp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲解下parseModules方法：</p>
<ol>
<li>我们首先传入主模块路径</li>
<li>将获得的模块信息放到temp数组里。</li>
<li>外面的循坏遍历temp数组，此时的temp数组只有主模块</li>
<li>循环里面再获得主模块的依赖deps</li>
<li>遍历deps，通过调用getModuleInfo将获得的依赖模块信息push到temp数组里。</li>
</ol>
<p>按照目前我们的项目来说执行完，应当是temp 应当是存放了index.js,add.js,minus.js三个模块。 ,执行看看。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e442e4a822fc~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<p>不过现在的temp数组里的对象格式不利于后面的操作，我们希望是以文件的路径为key，{code，deps}为值的形式存储。因此，我们创建一个新的对象depsGraph。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> parseModules = <span class="function">(<span class="params">file</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> entry =  getModuleInfo(file)</span><br><span class="line">    <span class="keyword">const</span> temp = [entry] </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;temp.length;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> deps = temp[i].deps</span><br><span class="line">        <span class="keyword">if</span> (deps)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> deps)&#123;</span><br><span class="line">                <span class="keyword">if</span> (deps.hasOwnProperty(key))&#123;</span><br><span class="line">                    temp.push(getModuleInfo(deps[key]))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新增代码</span></span><br><span class="line">    <span class="keyword">const</span> depsGraph = &#123;&#125;</span><br><span class="line">    temp.forEach(<span class="function"><span class="params">moduleInfo</span>=&gt;</span>&#123;</span><br><span class="line">        depsGraph[moduleInfo.file] = &#123;</span><br><span class="line">            <span class="attr">deps</span>:moduleInfo.deps,</span><br><span class="line">            <span class="attr">code</span>:moduleInfo.code</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(depsGraph)</span><br><span class="line">    <span class="keyword">return</span> depsGraph</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/24/1737e442ed76d596~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><p>我们现在的目的就是要生成一个bundle.js文件，也就是打包后的一个文件。其实思路很简单，就是把index.js的内容和它的依赖模块整合起来。然后把代码写到一个新建的js文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">var</span> _add = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&quot;./add.js&quot;</span>));</span><br><span class="line"><span class="keyword">var</span> _minus = <span class="built_in">require</span>(<span class="string">&quot;./minus.js&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="string">&quot;default&quot;</span>: obj &#125;; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = (<span class="number">0</span>, _add[<span class="string">&quot;default&quot;</span>])(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> division = (<span class="number">0</span>, _minus.minus)(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="built_in">console</span>.log(division);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123;  <span class="attr">value</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> _default = <span class="function"><span class="keyword">function</span> <span class="title">_default</span>(<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = _default;</span><br></pre></td></tr></table></figure>

<p>但是我们现在是不能执行index.js这段代码的，因为浏览器不会识别执行require和exports。</p>
<p>不能识别是为什么？因为没有定义这<strong>require函数，和exports对象</strong>。那我们可以自己定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bundle = <span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//返回一个整合完整的字符串代码</span></span><br><span class="line">  <span class="keyword">const</span> depsGraph = <span class="built_in">JSON</span>.stringify(parseModules(file)); </span><br><span class="line">  <span class="built_in">console</span>.log(depsGraph);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把保存下来的depsGraph，传入一个立即执行函数。</span></span><br><span class="line"><span class="comment">    将主模块路径传入require函数执行</span></span><br><span class="line"><span class="comment">    执行reuire函数的时候，又立即执行一个立即执行函数，这里是把code的值传进去了</span></span><br><span class="line"><span class="comment">    执行eval（code）。也就是执行主模块的code这段代码</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">`(function (graph) &#123;</span></span><br><span class="line"><span class="string">    function require(file) &#123;</span></span><br><span class="line"><span class="string">      //转化成绝对路径</span></span><br><span class="line"><span class="string">      function absRequire(relPath) &#123;</span></span><br><span class="line"><span class="string">        return require(graph[file].deps[relPath])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      //执行add.js的code时候，会遇到exports这个还没定义的问题.因此我们可以自己定义一个exports对象。</span></span><br><span class="line"><span class="string">      var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">      (function (require, exports, code) &#123;</span></span><br><span class="line"><span class="string">        console.log(1, exports);</span></span><br><span class="line"><span class="string">        //code代码执行过程中会执行到require函数。</span></span><br><span class="line"><span class="string">        //这时会调用这个require，也就是我们传入的absRequire</span></span><br><span class="line"><span class="string">        eval(code);</span></span><br><span class="line"><span class="string">      &#125;)(absRequire, exports, graph[file].code)</span></span><br><span class="line"><span class="string">      return exports;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require(&#x27;<span class="subst">$&#123;file&#125;</span>&#x27;)</span></span><br><span class="line"><span class="string">  &#125;)(<span class="subst">$&#123;depsGraph&#125;</span>)`</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> content = bundle(<span class="string">&quot;./src/index.js&quot;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>把保存下来的depsGraph，传入一个立即执行函数。</p>
<ul>
<li><p>将主模块路径传入require函数执行</p>
<ul>
<li><p>reuire函数中立即执行函数</p>
<ul>
<li><p>require：absRequire，因为code代码中require路径不是绝对路径，需要转化成绝对路径，因此写一个函数absRequire来转化</p>
</li>
<li><p>exports：exports</p>
<ul>
<li><p>增添了一个空对象 exports，执行add.js代码的时候，会往这个空对象上增加一些属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add.js</span></span><br><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span>&#125;);</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> _default = <span class="function"><span class="keyword">function</span> <span class="title">_default</span>(<span class="params">a, b</span>) </span>&#123;  <span class="keyword">return</span> a + b;&#125;;</span><br><span class="line"><span class="built_in">exports</span>[<span class="string">&quot;default&quot;</span>] = _default;</span><br><span class="line"><span class="comment">//执行完这段代码后</span></span><br><span class="line"><span class="built_in">exports</span> = &#123;</span><br><span class="line">  __esModule：&#123;  <span class="attr">value</span>: <span class="literal">true</span>&#125;，</span><br><span class="line">  <span class="keyword">default</span>：<span class="function"><span class="keyword">function</span> <span class="title">_default</span>(<span class="params">a, b</span>) </span>&#123;  <span class="keyword">return</span> a + b;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>然后我们把exports对象return出去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _add = _interopRequireDefault(<span class="built_in">require</span>(<span class="string">&quot;./add.js&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>return出去的值，被_interopRequireDefault接收，_interopRequireDefault再返回default这个属性给_add，因此<code>_add = function _default(a, b) &#123; return a + b;&#125;</code></p>
</li>
</ul>
</li>
<li><p>code：graph[file].code</p>
<ul>
<li>执行eval（code）,也就是执行模块的code这段代码<ul>
<li>执行eval（code）过程会执行到require函数，这时会调用这个require，也就是我们传入的absRequire，而执行absRequire就执行了<code>return require(graph[file].deps[relPath])</code>这段代码，也就是执行了外面这个require。而执行require（”./src/add.js”）之后，又会执行eval，也就是执行add.js文件的代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Sourcemap"><a href="#Sourcemap" class="headerlink" title="Sourcemap"></a>Sourcemap</h2><p><a href="https://mp.weixin.qq.com/s/g5GcZ10G89Xb9hZ1SibVrA">https://mp.weixin.qq.com/s/g5GcZ10G89Xb9hZ1SibVrA</a></p>
<p><strong><code>Sourcemap</code> 本质上是一个信息文件（储存着代码转换前后的对应位置信息），关联编译后的代码和源码的，通过一个个行列号的映射。</strong>比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个mapping。简单说 <code>Sourcemap</code> 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 <code>bug</code> 的位置。</p>
<p>sourcemap 的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    version : 3,</span><br><span class="line">    file: &quot;out.js&quot;,</span><br><span class="line">    sourceRoot : &quot;&quot;,</span><br><span class="line">    sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span><br><span class="line">    names: [&quot;a&quot;, &quot;b&quot;],</span><br><span class="line">    mappings: &quot;AAgBC,SAAQ,CAAEA;AAAEA&quot;,</span><br><span class="line">    sourcesContent: [&#x27;const a = 1; console.log(a)&#x27;, &#x27;const b = 2; console.log(b)&#x27;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>version 是版本号，file 是文件名，sourceRoot 是源码根目录，names 是转换前的变量名，sources 是源码文件，sourcesContent 是每个 sources 对应的源码的内容，mappings 就是一个个位置映射了。</p>
<p><strong>为什么 sources 可以有多个呢？</strong></p>
<p>因为可能编译产物是多个源文件合并的，比如打包，一个 bundle.js 就对应了 n 个 sources 源文件。</p>
<p><strong>为什么要把变量名单独摘出来到 names 里呢？</strong></p>
<p>因为这样就可以通过下标来索引了，mapping 里面就不用保存变量名，只保留 names 的索引就行。</p>
<p><strong>重点是 mappings 部分：</strong></p>
<p>mappings 部分是通过分号<code>;</code> 和逗号 <code>,</code> 分隔的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mappings:&quot;AAAAA,BBBBB;CCCCC&quot;</span><br></pre></td></tr></table></figure>

<p>一个分号就代表一行，这样就免去了行的映射。</p>
<p>然后每一行可能有多个位置的映射，用 <code>,</code> 分隔</p>
<p>那具体的每一个 mapping 都是啥呢？</p>
<p>比如 AAAAA 一共五位，分别有不同的含义：</p>
<ul>
<li>第一位：转换后代码的第几列（行数通过分号 ; 来确定）</li>
<li>第二位：对应转换前的哪个源码文件，保存在 sources 里的，这里通过下标索引</li>
<li>第三位：对应转换前的源码的第几行</li>
<li>第四位：对应转换前的源码的第几列</li>
<li>第五位：对应转换前的源码的哪个变量名，保存在 names 里的，这里通过下标索引</li>
</ul>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><ul>
<li>eval：浏览器 devtool 支持通过 sourceUrl 来把 eval 的内容单独生成文件，还可以进一步通过 sourceMappingUrl 来映射回源码，webpack 利用这个特性来简化了 sourcemap 的处理，可以直接从模块开始映射，不用从 bundle 级别。</li>
<li>cheap：只映射到源代码的某一行，不精确到列，可以提升 sourcemap 生成速度</li>
<li>source-map：生成 sourcemap 文件，可以配置 inline，会以 dataURL 的方式内联，可以配置 hidden，只生成 sourcemap，不和生成的文件关联。</li>
<li>nosources：不生成 sourceContent 内容，可以减小 sourcemap 文件的大小</li>
<li>module：sourcemap 生成时会关联每一步 loader 生成的 sourcemap，配合 sourcemap-loader 可以映射回最初的源码</li>
</ul>
<p>理解了这些基础配置项，根据 ^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$ 的规律来进行组合，就可以实现各种需求下的 sourcemap 配置。</p>
<p>当然，这种 sourcemap 配置还不够细致，比如 sourcemap 的 url 怎么生成，文件名是什么。如果想对这些做配置，可以关掉 devtool，启用 SourceMapDevToolPlugin 来配置。</p>
<p>虽然 webapck 的 sourcemap 配置方式比较多，但最底层也就是浏览器支持的文件级别的 sourcemap 还有 eval 代码的 source 映射和 sourcemap 这两种机制。其余的方式都是基于这两种机制的封装。</p>
<h1 id="单应用框架"><a href="#单应用框架" class="headerlink" title="单应用框架"></a>单应用框架</h1><h2 id="软件架构模式"><a href="#软件架构模式" class="headerlink" title="软件架构模式"></a>软件架构模式</h2><p><a href="https://www.pianshen.com/article/3716256399/">https://www.pianshen.com/article/3716256399/</a></p>
<p>MVC，MVP和MVVM都是常见的<a href="https://www.zhihu.com/search?q=%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2396493957%7D">软件架构设计模式</a>（Architectural Pattern），它通过分离关注点来改进代码的组织方式。它们目标都是解耦，解耦好处一个是关注点分离，提升代码可维护和可读性，并且提升代码复用性。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的软件设计规范。</p>
<ul>
<li><p><strong>Model（模型）</strong> ：数据层。将js的ajax当做Model，也就是数据层，通过ajax从服务器获取数据。</p>
</li>
<li><p><strong>View（视图）</strong> ：视图层。</p>
</li>
<li><p><strong>Controller（控制器）</strong>：交互层。用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新</p>
</li>
</ul>
<p><img src="https://pics7.baidu.com/feed/8ad4b31c8701a18b40c30015c909c8002838fe6b.png@f_auto?token=e2763c67fdda4b27897e546b2a2b2367" alt="img"></p>
<blockquote>
<p>1.View传送指令到Controller。</p>
<p>2.Controller完成业务逻辑后改变Model状态。</p>
<p>3.Model将新的数据发送至View,用户得到反馈。    </p>
</blockquote>
<p><strong>缺点</strong></p>
<p><strong>1.m层和v层直接打交道，导致这两层耦合度高</strong></p>
<p><strong>2.因为所有逻辑都写在c层，导致c层特别臃肿</strong></p>
<p>控制div是否显示：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span>我显示的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(box.style.display === <span class="string">&#x27;none&#x27;</span>) box.style.display = <span class="string">&#x27;block&#x27;</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">else</span> box.style.display = <span class="string">&#x27;none&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>用数据驱动模型模型来写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;box&quot;</span>&gt;</span>我显示的<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">let</span> is_shown = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">el, is_shown</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">if</span>(is_shown) el.style.display = <span class="string">&#x27;block&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">else</span> el.style.display = <span class="string">&#x27;none&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            is_shown = !is_shown;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            render(box, is_shown);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>看起来好像多了几行代码，但是对于第二种代码来说，简单抽象封装了 <code>render</code> 函数，我们只需要修改 <code>is_shown</code> 的 <code>bool</code> 值，而无需在意 <code>render</code> 函数内部的执行，就可以实现通过数据修改来驱动视图的更新。</p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>mvc中Controller演变成mvvm中的viewModel。 <strong>mvvm主要解决了mvc中大量DOM操作使页面首次渲染性能降低，加载速度变慢的问题 。</strong></p>
<p><strong>Model-View-ViewModel</strong>即模型-视图-视图模型。</p>
<ul>
<li><p>模型：数据层。后端传递的数据。</p>
</li>
<li><p>视图：视图层。</p>
</li>
<li><p>视图模型：mvvm模式的核心，它是连接view和model的桥梁。</p>
</li>
</ul>
<p><strong>总结</strong>：<strong>在MVVM的框架下视图和模型是不能直接通信的</strong>。它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，当数据发生变化，ViewModel能够监听到数据的这种变化，然后通知到对应的视图做自动更新，而当用户操作视图，ViewModel也能监听到视图的变化，然后通知数据做改动，这实际上就实现了数据的<strong>双向绑定</strong>。</p>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><p>dom操作方式</p>
<ul>
<li>MVC来讲，MVC操作的是真实dom，对于数据的更新需要找到对应抽象类来直接操作真实dom</li>
<li>对于MVVM来讲，它操作的是虚拟dom、<strong>在数据的更新后，该框架重新生成一个虚拟dom树，与旧虚拟dom树进行比对，然后替换修改的地方，所以可以将渲染视图抽象成一个函数类</strong></li>
</ul>
</li>
<li><p>视图更新</p>
<ul>
<li>MVVM完全不需要考虑视图更新对dom树的操作，框架会自动响应绑定对视图的更新</li>
</ul>
</li>
<li><p>性能</p>
<ul>
<li>页面首次渲染，MVVM框架可能会比MVC框架快一些，因为MVVM只会进行一次对真实dom的操作，而MVC可能会进行多次真实dom的操作</li>
<li>在首屏渲染完毕后，用户开始对页面进行直接操作时，MVVM的性能肯定会输MVC的<ul>
<li>对于MVC构建的页面来说，用户修改数据，该框架会根据绑定的dom元素直接进行修改</li>
<li>而对于MVVM构建的页面来说，用户修改数据，该框架会重新生成虚拟dom树与原树进行比对，再修改</li>
<li>虽然可以进行diff（新旧虚拟dom树比对算法）优化，但是一个是直接操作，一个需要最少O(n)算法比对在进行真实dom操作</li>
</ul>
</li>
</ul>
</li>
<li><p>框架</p>
<ul>
<li>常见的MVC框架有：Angular.js</li>
</ul>
</li>
</ul>
<h2 id="框架对比"><a href="#框架对比" class="headerlink" title="框架对比"></a>框架对比</h2><p><a href="https://juejin.cn/post/6844903974437388295">https://juejin.cn/post/6844903974437388295</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/100228073">https://zhuanlan.zhihu.com/p/100228073</a></p>
<h3 id="渐进式"><a href="#渐进式" class="headerlink" title="渐进式"></a>渐进式</h3><p>我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架，这都是可选的</p>
<h3 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h3><ul>
<li>React是由FaceBook前端官方团队进行维护和更新的；因此，React的维护开发团队，技术实力比较雄厚；</li>
<li>Vue：第一版，主要是有作者 尤雨溪 专门进行维护的，当 Vue更新到 2.x 版本后，也有了一个小团队进行相关的维护和开发；</li>
</ul>
<h3 id="编写语法"><a href="#编写语法" class="headerlink" title="编写语法"></a>编写语法</h3><h4 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h4><p>vue推荐的做法是webpack+vue-loader的单文件组件格式，<strong>vue保留了html、css、js分离的写法</strong>，使得现有的前端开发者在开发的时候能保持原有的习惯，更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css。其中<style>标签还提供了一个可选的scoped属性，它会为组件内 CSS 指定作用域，用它来控制仅对当前组件有效还是全局生效。</p>
<p>模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。</p>
<p>同时vue也支持JSX语法，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。</p>
<h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><p>用过react的开发者可能知道，<strong>react是没有模板的，直接就是一个渲染函数</strong>，它中间返回的就是一个虚拟DOM树，**React推荐的做法是 JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in js’**。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。在react中，所有的组件的渲染功能都依靠JSX。你可以在render()中编写类似XML的语法，它最终会被编译成原生JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。JSX是基于 JS 之上的一套额外语法，学习使用起来有一定的成本。</p>
<h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><h4 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h4><p>vue提供了CLI 脚手架，可以帮助你非常容易地构建项目。全局安装之后，我们就可以用 vue create命令创建一个新的项目，vue 的 CLI 跟其他 CLI不同之处在于，有多个可选模板，有简单的也有复杂的，可以让用户自定义选择需要安装的模块，还可以将你的选择保存成模板，便于后续使用。</p>
<p>极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。</p>
<h4 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h4><p>React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：</p>
<ul>
<li>它不允许在项目生成时进行任何配置，而 Vue CLI 运行于可升级的运行时依赖之上，该运行时可以通过插件进行扩展。</li>
<li>它只提供一个构建单页面应用的默认选项，而 Vue 提供了各种用途的模板。</li>
<li>它不能用用户自建的预设配置构建项目，这对企业环境下预先建立约定是特别有用的。</li>
</ul>
<p>而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。</p>
<h3 id="数据流和数据绑定"><a href="#数据流和数据绑定" class="headerlink" title="数据流和数据绑定"></a>数据流和数据绑定</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/f05acead6d25707b82895cb43a8f7695.png" alt="img"></p>
<p><strong>Vue和React均是单向数据流传递</strong>，子组件不能直接改变父组件的状态</p>
<p><strong>Vue是双向绑定和React是单向绑定</strong></p>
<h4 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h4><p>Vue是双向数据。Vue采用数据劫持&amp;发布-订阅模式的方式，vue在创建vm的时候，会将数据配置在实例当中，然后通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，当获取数据的时候会触发对应的getter方法，当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后数据更改，vm则会进一步触发视图更新操作</p>
<h4 id="react-2"><a href="#react-2" class="headerlink" title="react"></a>react</h4><p>在<a href="https://so.csdn.net/so/search?q=React&spm=1001.2101.3001.7020">React</a>中虽然modal和view之间也是通过ViewMode处理,但是却需要setState去手动刷新渲染view，所以叫单向绑定</p>
<h3 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h3><p>相同点</p>
<ol>
<li>虚拟DOM在比较时只比较同一层级节点，复杂度都为 O(n)，降低了算法复杂度；</li>
<li>都使用key比较是否是相同节点，都是为了尽可能的复用节点</li>
<li>都是操作虚拟DOM，最小化操作真实DOM，提高性能（其实虚拟DOM的优势 并不是在于它操作DOM快）</li>
</ol>
<h4 id="vue-3"><a href="#vue-3" class="headerlink" title="vue"></a>vue</h4><p>vue中diff算法实现流程</p>
<ol>
<li>在内存中构建虚拟dom树</li>
<li>将内存中虚拟dom树渲染成真实dom结构</li>
<li>数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树</li>
<li>将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对（diff算法进行比对），来更新只需要被替换的DOM，而<strong>不是全部重绘</strong>。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。</li>
<li>会将对比出来的差异进行重新渲染</li>
</ol>
<h4 id="react-3"><a href="#react-3" class="headerlink" title="react"></a>react</h4><p>react中diff算法实现流程</p>
<ol>
<li>DOM结构发生改变—–直接卸载并重新create</li>
<li>DOM结构一样—–不会卸载,但是会update变化的内容</li>
<li>所有同一层级的子节点.他们都可以通过key来区分—–同时遵循1.2两点<br> （其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作）</li>
</ol>
<p>React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点，涉及到的DOM操作非常多。diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。</p>
<p>vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。<strong>而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。</strong></p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><h4 id="react-4"><a href="#react-4" class="headerlink" title="react"></a>react</h4><p>当props或state发生改变的时候会触发shouldComponentUpdate生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；如果它返回false，则不会触发重新渲染的过程。</p>
<p>有的时候我们希望它在更新之前，和之前的状态进行一个对比，这个时候我们就需要重写shouldComponentUpdate来避免不必要的dom操作，对比当前的props或state和更新之后的nextProps或nextState，返回true时 ，组件更新；返回false，则不会更新，节省性能。</p>
<h4 id="vue-4"><a href="#vue-4" class="headerlink" title="vue"></a>vue</h4><p>vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要shouldComponentUpdate手动优化。但是当数据特别多的时候vue中的watcher也会特别多，从而造成页面卡顿，所以一般数据比较多的大型项目会倾向于使用react。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="vue-5"><a href="#vue-5" class="headerlink" title="vue"></a>vue</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate	</span><br><span class="line">组件实例刚刚被创建，组件的el（Vue实例挂载的元素节点，简单来说el的作用就是将当前vue组件生成的实例插入到页面元素中）和data，methods都未被初始化，调用不了</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">created			     </span><br><span class="line">实例已经创建完成，data，methods都已经被初始化，可以被调用但是el还处于未被创建状态。如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作</span><br><span class="line"></span><br><span class="line">beforeMount		</span><br><span class="line">template模板已经编译完成，el已经创建完成，但是还没有挂载到页面上，而只是放在内存中</span><br><span class="line"></span><br><span class="line">mounted			</span><br><span class="line">页面渲染完成初始化完毕。可以在 mounted 内部使用 vm.$nextTick。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行</span><br><span class="line"></span><br><span class="line">beforeUpdate	组件更新之前</span><br><span class="line">updated			组件更新完毕	</span><br><span class="line">更新前/后：当data变化时，会触发beforeUpdate和updated方法。</span><br><span class="line"></span><br><span class="line">beforeDestroy	组件销毁前</span><br><span class="line">destroyed		组件销毁后</span><br><span class="line">销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br><span class="line"></span><br><span class="line">activated	keep-alive 组件激活时调用。</span><br><span class="line">deactivated	keep-alive 组件停用时调用。</span><br></pre></td></tr></table></figure>

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16debf6f691f598a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img" style="zoom:50%;" />

<h4 id="react-5"><a href="#react-5" class="headerlink" title="react"></a>react</h4><ul>
<li><p>初始化阶段（5个）：</p>
<ul>
<li><p>getDefaultProps：实例化组件之后，组件的getDefaultProps钩子函数会执行</p>
<p>这个钩子函数的目的是为组件的实例挂载默认的属性</p>
<p>这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p>
<p>理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p>
<p>组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p>
</li>
</ul>
</li>
</ul>
<p>（2）getInitialState：为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态。</p>
<p>（3）componentWillMount：执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行。</p>
<p>（4）render：渲染dom</p>
<p>render()方法必须是一个纯函数，他不应该改变</p>
<p>state，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果</p>
<p>shouldComponentUpdate()返回</p>
<p>false，</p>
<p>render()不会被调用。</p>
<p>（5）componentDidMount：相当于Vue里的mounted,多用于操作真实dom</p>
<p>【运行中阶段（5个）】</p>
<p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p>
<p>（1）componentWillReceiveProps(nextProps,nextState)</p>
<p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行。初始化props时候不会主动执行</p>
<p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态。</p>
<p>（2）接下来就会执行shouldComponentUpdate(nextProps,nextState),这个函数的作用：当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true。</p>
<p>接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p>
<p>如果</p>
<p>shouldComponentUpdate()返回</p>
<p>false，</p>
<p>componentWillUpdate,</p>
<p>render和</p>
<p>componentDidUpdate不会被调用。</p>
<p>（3）componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环 相当于Vue中的beforeUpdate</p>
<p>（4）render，重新渲染dom</p>
<p>（5）componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p>
<p>【销毁阶段】</p>
<p>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</p>
<p>相当于Vue里的beforeDestroy，所以说一般会做一些善后的事情，例如使定时器无效，取消网络请求或清理在</p>
<p>componentDidMount中创建的任何监听。</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/21/16debf7c76553b3b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" alt="img"></p>
<h3 id="销毁组件"><a href="#销毁组件" class="headerlink" title="销毁组件"></a>销毁组件</h3><h4 id="vue-6"><a href="#vue-6" class="headerlink" title="vue"></a>vue</h4><p>vue在调用$destroy方法的时候就会执行beforeDestroy生命周期函数，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed生命周期函数中处理。</p>
<h4 id="react-6"><a href="#react-6" class="headerlink" title="react"></a>react</h4><p>react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，也就是说当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁，所以根本不需要其他的钩子函数了。react销毁组件的时候，会将组件的dom结构也移除，vue则不然，在调用destory方法销毁组件的时候，组件的dom结构还是存在于页面中的，this.$destory组件结构还是存在的，只是移除了事件监听，所以这就是为什么vue中有destroyed，而react却没有componentDidUnmount。</p>
<h3 id="移动APP开发体验方面"><a href="#移动APP开发体验方面" class="headerlink" title="移动APP开发体验方面"></a>移动APP开发体验方面</h3><ul>
<li>Vue，结合 Weex 这门技术，提供了 迁移到 移动端App开发的体验（Weex，目前只是一个 小的玩具， 并没有很成功的 大案例；）</li>
<li>React，结合 ReactNative，也提供了无缝迁移到 移动App的开发体验（RN用的最多，也是最火最流行的）；</li>
</ul>
<h2 id="SPA、SSR、CSR"><a href="#SPA、SSR、CSR" class="headerlink" title="SPA、SSR、CSR"></a>SPA、SSR、CSR</h2><p><a href="https://zhuanlan.zhihu.com/p/299598903">https://zhuanlan.zhihu.com/p/299598903</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/138356519">https://zhuanlan.zhihu.com/p/138356519</a></p>
<h3 id="一、SPA"><a href="#一、SPA" class="headerlink" title="一、SPA"></a>一、SPA</h3><p>single page web application，单页Web应用，就是只有一张Web页面的应用，<strong>与后台仅仅是数据的交互，不会再请求其它页面</strong>。浏览器一开始会加载必需的HTML、CSS和JavaScript，所有的操作都在这张页面上完成，都由JavaScript来控制。</p>
<p>典型编写SPA的前端框架：React、Angular、Vue。</p>
<ul>
<li>概念：<ul>
<li>网站的效果都是显示在<code>一个静态页面</code>中的</li>
<li>在页面切换时，其实并没有从一个页面中跳转到另一个页面中，只是通过 <code>js</code> 动态的将内容进行了修改</li>
<li>在网站的源代码中是看不到任何数据的</li>
</ul>
</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li>优点：<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
</li>
<li>缺点：<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；（vue-router 已经解决了这个问题）</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。<ul>
<li>因为单页应用的所有内容都在 index.html 中，页面的切换是通过 js 动态切换的</li>
<li>由于所有的内容切换都是通过 js 动态切换的，所以在页面的源代码中是看不到任何的数据的</li>
<li>由于源代码中看不到任何数据，这是非常不利于 SEO 的，所以我们说 SPA 在 SEO 上有其天然的弱势。</li>
<li>vue 中的 SSR 就可以用来解决这个问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二、SSR"><a href="#二、SSR" class="headerlink" title="二、SSR"></a>二、SSR</h3><p>Server Side Rendering，服务器端渲染，传统的渲染方式，由服务端把渲染的完整的页面吐给客户端。这样减少了一次客户端到服务端的一次http请求，加快相应速度，一般用于首屏的性能优化。</p>
<p>典型服务器端渲染的例子就是jsp、asp、php等各种后台模板生成的页面，前端会直接拿到整张页面，不用自己过多的去拼接DOM。</p>
<img src="https://pic1.zhimg.com/80/v2-b4c8866154ac2158d887e04e1e73c2f8_720w.jpg" alt="img" style="zoom:50%;" />

<img src="https://pic3.zhimg.com/80/v2-26e5fd8c489d700be758d43eba801f26_720w.jpg" alt="img" style="zoom:50%;" />

<p><strong>渲染流程</strong>：</p>
<ul>
<li>阶段一：浏览器请求url –&gt; 服务器路由分析、执行渲染 –&gt; 服务器返回index.html(实时渲染的内容，字符串) –&gt; 浏览器渲染</li>
<li>阶段二：浏览器请求bundle.js –&gt; 服务器返回bundle.js –&gt; 浏览器路由分析、生成虚拟DOM –&gt; 比较DOM变化、绑定事件 –&gt; 二次渲染</li>
</ul>
<p>尽管服务器渲染第一阶段的流程图很长，但是因为服务器渲染速度很快，因此实际耗时与客户端渲染几乎相同。<br>第一阶段结束时，服务器端返回渲染结果，用户即可看到首屏。而对于客户端渲染，需要等待一次脚本下载时间，以及在客户端的渲染时间。由于客户端的硬件以及网络条件的差异，这两段时间开销可能十分显著。<br>客户渲染与服务器渲染第二阶段基本一致。所不同的是，服务器渲染流程中，在客户端生成vdom后，并不会重新渲染，而是比较现有dom的checksum来决定是否重新渲染。</p>
<p><strong>原理</strong>：基于<code>Virtual DOM</code>实现了客户端与服务端的同构渲染。</p>
<ul>
<li>在服务器，我可以操作 JavaScript 对象，判断环境是服务器环境，我们把虚拟 DOM 映射成字符串输出；</li>
<li>在客户端，我也可以操作 JavaScript 对象，判断环境是客户端环境，我就直接将虚拟 DOM 映射成真实 DOM，完成页面挂载。</li>
</ul>
<h3 id="三、CSR"><a href="#三、CSR" class="headerlink" title="三、CSR"></a>三、CSR</h3><p>客户端渲染(Client Side Render)。渲染过程全部交给浏览器进行处理，服务器不参与任何渲染。页面初始加载的HTML文档中无内容，需要下载执行JS文件，由浏览器动态生成页面，并通过JS进行页面交互事件与状态管理。</p>
<img src="https://pic4.zhimg.com/80/v2-6a8fe007fcf263214074f72ea3971b87_720w.jpg" alt="img" style="zoom:67%;" />

<p><strong>渲染流程</strong>：浏览器请求url –&gt; 服务器返回index.html(空body、白屏) –&gt; 再次请求bundle.js、路由分析 –&gt; 浏览器渲染</p>
<p>bundle.js体积越大，会导致浏览器白屏时间越长。</p>
<h3 id="四、SSR与CSR对比"><a href="#四、SSR与CSR对比" class="headerlink" title="四、SSR与CSR对比"></a>四、SSR与CSR对比</h3><p>CSR与SSR的区别简而言之，就是数据拼接HTML字符串这件事放在服务端还是客户端。</p>
<p><img src="https://pic2.zhimg.com/80/v2-e12ce3a06497fcffaa51d3a720b46649_720w.jpg" alt="img"></p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p><strong>1. 相比于纯静态网站</strong></p>
<p>纯静态的网站很难承载动态的内容，内容改动通常都是要直接修改页面的代码，这<strong>对于内容管理人员（很可能是非技术人员）来说非常不友好</strong>。</p>
<p>而 Jamstack 的网站，通常会使用无头 CMS 来将内容管理抽离出去，内容管理人员可以直接在这些 CMS 系统的 UI 界面上进行内容修改，然后触发整个网站的重新预渲染，以及部署。</p>
<p><strong>2. 相比于传统动态网站</strong></p>
<p>这里的“传统动态网站”指的是用 PHP、Ruby On Rails、JSP 甚至更古老的 CGI 构建的网站，以及基于这些技术产生的建站工具比如 WordPress、Drupal 等等。</p>
<p>这些传统网站的劣势在于，它们在运行时都需要一个实时在线的服务端，这些服务端负责处理请求、渲染页面，这就很大程度上降低了<strong>服务的可伸缩性和稳定性</strong>（想象一下，你迁移扩容一个在线的 WordPress 网站有多么麻烦）。</p>
<p>Jamstack 由于是直接使用 CDN 分发静态的页面，完全不需要渲染页面的服务，网站的伸缩性、稳定性可以得到最大的保障。</p>
<p><strong>3. 相比于单页应用（SPA）</strong></p>
<p>大概五年前，随着各种前端框架的成熟，越来越多的业务逻辑迁移到了前端处理，这也就诞生了 SPA 的概念，也就是整个网站的 UI 层，由浏览器端来完全接管。得益于 HTML5 和现代浏览器的一系列特性，这样的做法可以保证最好的用户体验。</p>
<p>但是 SPA 最大的问题在于它<strong>对 SEO 不友好</strong>，因为 SPA 的页面内容都是靠浏览器异步获取、渲染的，虽然 Google 为首的大多数搜索引擎渐渐地支持爬取 SPA 的内容，但是这依然是一个隐患。另外，由于 SPA 需要异步加载数据，首屏内容需要在在加载、运行 JS 之后才能看到，也给用户打开网站的体验带来影响。</p>
<p>而 Jamstack 的页面本质上都是托管在 CDN 上的静态页面，搜索引擎可以直接爬取这些静态内容，首屏与静态网站一样，可以直接展示内容，而不需要等到加载运行 JS 之后。</p>
<p><strong>4. 相比于 SSR 应用</strong></p>
<p>目前市面上的几大前端框架都支持了服务器端渲染，也就是 SSR 的概念，这些 SSR 技术也成为了 Jamstack 的基础之一。但是典型的 SSR 应用和传统动态网站一样，都是需要一个在线的服务来渲染页面，同样<strong>会有运维和安全性上的风险</strong>。</p>
<p>Jamstack 从技术角度上讲，可以认为是 SSR 技术的进阶，也就是提前用 SSR 预渲染大部分页面，然后将这些页面部署在 CDN 上，随后根据网站的数据变化，重复预渲染、部署即可。</p>
<p>当然，Jamstack 也不是万金油，不可能完美适应所有场景，Jamstack 最适合一些<strong>内容更新不太频繁的网站</strong>（比如新闻、电商、文档）。它不适合 Feeds 流、聊天室、论坛、个性化推荐这样高度动态化的网站，以及邮箱、编辑器这样偏重型的 Web 应用。</p>
<h1 id="框架原理"><a href="#框架原理" class="headerlink" title="框架原理"></a>框架原理</h1><h2 id="虚拟DOM和diff算法"><a href="#虚拟DOM和diff算法" class="headerlink" title="虚拟DOM和diff算法"></a>虚拟DOM和diff算法</h2><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a><strong>背景</strong></h4><p>前端主流框架 vue 和 react 中都使用了虚拟DOM（virtual DOM）技术，因为渲染真实DOM的开销是很大的，性能代价昂贵，比如有时候我们修改了某个数据，如果直接渲染到真实dom上会引起整个dom树的重绘和重排，而我们只需要更新修改过的那一小块dom而不要更新整个dom，这时使用diff算法能够帮助我们。</p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a><strong>DOM</strong></h4><p>DOM全称<code>文档对象模型</code>，本质也是一个JS对象。每操作一次DOM都会对页面进行重新渲染，且新生成一颗DOM树。</p>
<p>DOM的本质： 浏览器中的概念，用js对象来表示页面上的元素，并提供操作DOM对象的API</p>
<p>浏览器渲染引擎工作流程都差不多，大致分为5步</p>
<p><strong>创建DOM树——创建StyleRules——创建Render树——布局Layout——绘制Painting</strong></p>
<ul>
<li>  第一步，用HTML分析器，分析HTML元素，<strong>构建一颗DOM树</strong>(标记化和树构建)。</li>
<li>  第二步，用CSS分析器，分析CSS文件和元素上的inline样式，生成页面的样式表。</li>
<li>  第三步，将DOM树和样式表，关联起来，构建一颗Render树(这一过程又称为Attachment)。每个DOM节点都有<strong>attach方法，接受样式信息</strong>，返回一个render对象(又名renderer)。这些render对象最终会被构建成一颗Render树。</li>
<li>  第四步，有了Render树，浏览器开始布局，为每个Render树上的节点确定一个在显示屏上出现的精确坐标。</li>
<li>  第五步，Render树和节点显示坐标都有了，就调用每个节点<strong>paint方法，把它们绘制</strong>出来。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>修改了某个数据，会直接渲染到真实dom上引起整个dom树的重绘和重排</li>
<li>原生JS或JQ操作DOM时，浏览器会从构建DOM树开始从头到尾执行一遍流程。在一次操作中，我需要更新10个DOM节点，浏览器收到第一个DOM请求后并不知道还有9次更新操作，因此会马上执行流程，最终执行10次。</li>
</ul>
<h4 id="VDOM"><a href="#VDOM" class="headerlink" title="VDOM"></a><strong>VDOM</strong></h4><p>虚拟dom(JS模拟DOM中的真实节点对象)， 通过VDom和真实DOM的比对，再通过特定的render方法将其渲染成真实的DOM节点。</p>
<ul>
<li>只会更新对应的节点。<strong>diff算法</strong></li>
<li>更新10个DOM节点，只会执行最后一次。<strong>例如批处理</strong></li>
</ul>
<p> <img src="https://img2020.cnblogs.com/blog/1569466/202101/1569466-20210129140258056-1083022081.png" alt="img"></p>
<h3 id="diff算法-1"><a href="#diff算法-1" class="headerlink" title="diff算法"></a><strong>diff算法</strong></h3><p>现有一个真实的<code>DOM</code>，首先会映射为虚拟<code>DOM</code>，这个时候，我们删除了最后一个<code>p</code>节点和<code>son2</code>的节点，得到了新的一个虚拟<code>DOM</code>，新的<code>vdom</code>会和旧的<code>vdom</code>进行差异对比，得到了<code>pathes</code>对象，之后，对旧的真实<code>dom</code>进行操作，得到了新的<code>DOM</code>。</p>
<p>传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。</p>
<p><strong>diff策略</strong></p>
<p>三大策略 将O(n^3)复杂度 转化为 O(n)复杂度</p>
<ul>
<li><p>策略一（tree diff）：新旧DOM树，逐层对比的方式。DOM节点跨层级的操作不做优化，因为很少这么做</p>
<p>1.只会对相同层级的节点进行比较； </p>
<p>2.只有<strong>删除、创建</strong>操作，没有移动操作； </p>
<img src="https://pic2.zhimg.com/80/d712a73769688afe1ef1a055391d99ed_1440w.png" alt="img" style="zoom: 50%;" />

<p>如图所示，react发现新树中，R节点下没有了A，那么直接删除A，在D节点下创建A以及下属节点。过程就是删除、创建，直接粗暴。</p>
<p>3.由于没做性能优化，所以<strong>官方建议少做这样的跨层级操作</strong>；</p>
<p> <img src="https://images2018.cnblogs.com/blog/1455367/201808/1455367-20180808083547179-1944470540.jpg" alt="img"> </p>
<p>只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。</p>
<p>当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。</p>
</li>
<li><p>策略二（component diff）：</p>
<p>如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。</p>
<p>如果不是，那么直接删除旧的，创建新的；</p>
<blockquote>
<p>tips： 对于同一个类的组件，用户可以控制其不要进行diff运算，具体就是，用户可以使用<code>shouldComponentUpdate()</code>来告诉react要不要对此组件进行diff运算。</p>
</blockquote>
<p><img src="https://pic1.zhimg.com/80/52654992aba15fc90e2dac8b2387d0c4_1440w.png" alt="img"></p>
</li>
<li><p>策略三（element diff）：</p>
<p>当节点处于<strong>同一层级</strong>时，拥有同层唯一的key值，来做删除、插入、移动的操作，这是针对element层级的策略；</p>
<ul>
<li>插入：INSERT_MARKUP，新的组件类型不在旧集合中，即全新的节点，需要对新节点进行插入操作。</li>
<li>删除：REMOVE_NODE，在新集合里也有，但对应的element不同则不能直接复用和更新，需要执行删除操作。或者旧组件不在新集合里的，也需要执行删除操作。</li>
<li>移动：MOVE_EXISTING，旧集合中有新组件类型，且element是可更新的类型，这时候就需要做移动操作，可以复用以前的DOM节点。</li>
</ul>
</li>
</ul>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p><a href="https://www.jianshu.com/p/af0b398602bc">https://www.jianshu.com/p/af0b398602bc</a></p>
<p><a href="https://juejin.cn/post/6984939221681176607">https://juejin.cn/post/6984939221681176607</a></p>
<h4 id="创建vNode对象"><a href="#创建vNode对象" class="headerlink" title="创建vNode对象"></a>创建vNode对象</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h = <span class="function">(<span class="params">tag, data = &#123;&#125;, children</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> text = <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">let</span> el</span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="comment">// 文本节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> children === <span class="string">&#x27;string&#x27;</span> || <span class="keyword">typeof</span> children === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">    text = children</span><br><span class="line">    children = <span class="literal">undefined</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    children = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (data &amp;&amp; data.key) &#123;</span><br><span class="line">    key = data.key</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    tag, <span class="comment">// 元素标签</span></span><br><span class="line">    children, <span class="comment">// 子元素</span></span><br><span class="line">    text, <span class="comment">// 文本节点的文本</span></span><br><span class="line">    el, <span class="comment">// 真实dom</span></span><br><span class="line">    key,</span><br><span class="line">    data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理函数"><a href="#处理函数" class="headerlink" title="处理函数"></a>处理函数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理样式</span></span><br><span class="line"><span class="keyword">const</span> handleStyle = &#123;</span><br><span class="line">  <span class="attr">updateClass</span>: <span class="function">(<span class="params">el, newVNode</span>) =&gt;</span> &#123;</span><br><span class="line">    el.className = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> (newVNode.data &amp;&amp; newVNode.data.class) &#123;</span><br><span class="line">      <span class="keyword">let</span> className = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(newVNode.data.class).forEach(<span class="function">(<span class="params">cla</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newVNode.data.class[cla]) &#123;</span><br><span class="line">          className += cla + <span class="string">&#x27; &#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      el.className = className</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">updateStyle</span>: <span class="function">(<span class="params">el, oldVNode, newVNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldStyle = oldVNode &amp;&amp; oldVNode.data &amp;&amp; oldVNode.data.style || &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> newStyle = newVNode &amp;&amp; newVNode.data &amp;&amp; newVNode.data.style || &#123;&#125;</span><br><span class="line">    <span class="comment">// 移除旧节点里存在新节点里不存在的样式</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(oldStyle).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newStyle[item] === <span class="literal">undefined</span> || newStyle[item] === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        el.style[item] = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 添加旧节点不存在的新样式</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(newStyle).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldStyle[item] !== newStyle[item]) &#123;</span><br><span class="line">        el.style[item] = newStyle[item]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">updateAttr</span>: <span class="function">(<span class="params">el, oldVNode, newVNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldAttr = oldVNode &amp;&amp; oldVNode.data &amp;&amp; oldVNode.data.attr ? oldVNode.data.attr : &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> newAttr = newVNode &amp;&amp; newVNode.data &amp;&amp; newVNode.data.attr || &#123;&#125;</span><br><span class="line">    <span class="comment">// 移除旧节点里存在新节点里不存在的属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(oldAttr).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newAttr[item] === <span class="literal">undefined</span> || newAttr[item] === <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        el.removeAttribute(item)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 添加旧节点不存在的新属性</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(newAttr).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldAttr[item] !== newAttr[item]) &#123;</span><br><span class="line">        el.setAttribute(item, newAttr[item])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理事件</span></span><br><span class="line"><span class="keyword">const</span> handleEvent = &#123;</span><br><span class="line">  <span class="attr">removeEvent</span>: <span class="function">(<span class="params">oldVNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log();</span><br><span class="line">    <span class="keyword">if</span> (oldVNode &amp;&amp; oldVNode.data &amp;&amp; oldVNode.data.event) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.keys(oldVNode.data.event).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        oldVNode.el.removeEventListener(item, oldVNode.data.event[item])</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">updateEvent</span>: <span class="function">(<span class="params">el, oldVNode, newVNode</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldEvent = oldVNode &amp;&amp; oldVNode.data &amp;&amp; oldVNode.data.event ? oldVNode.data.event : &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> newEvent = newVNode &amp;&amp; newVNode.data &amp;&amp; newVNode.data.event || &#123;&#125;</span><br><span class="line">    <span class="comment">// 移除旧节点里存在新节点里不存在的事件</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(oldEvent).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (newEvent[item] === <span class="literal">undefined</span> || oldEvent[item] !== newEvent[item]) &#123;</span><br><span class="line">        el.removeEventListener(item, oldEvent[item])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 添加旧节点不存在的新事件</span></span><br><span class="line">    <span class="built_in">Object</span>.keys(newEvent).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldEvent[item] !== newEvent[item]) &#123;</span><br><span class="line">        el.addEventListener(item, newEvent[item])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="打补丁"><a href="#打补丁" class="headerlink" title="打补丁"></a>打补丁</h4><p><strong>打补丁，针对同级的节点处理</strong></p>
<ul>
<li>元素标签相同，进行patch<ul>
<li>新节点的子节点是文本节点,那么就直接替换</li>
<li>新节点的子节点是标签节点（递推）<ul>
<li><strong>新旧节点都存在子节点，那么就要进行diff</strong></li>
<li>新节点存在子节点</li>
<li>新节点不存在子节点，那么移除旧节点的所有子节点</li>
<li>新节点啥也没有，旧节点存在文本节点</li>
</ul>
</li>
</ul>
</li>
<li> 元素标签不同，使用newNode替换oldNode</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> patchVNode = <span class="function">(<span class="params">oldVNode, newVNode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (oldVNode === newVNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 元素标签相同，进行patch</span></span><br><span class="line">  <span class="keyword">if</span> (oldVNode.tag === newVNode.tag) &#123;</span><br><span class="line">    <span class="comment">// 元素类型相同，那么旧元素肯定是进行复用的</span></span><br><span class="line">    newVNode.el = oldVNode.el;</span><br><span class="line">    <span class="keyword">let</span> el = newVNode.el;</span><br><span class="line">    <span class="built_in">console</span>.log(oldVNode, newVNode);</span><br><span class="line">    handleStyle.updateClass(el, newVNode)</span><br><span class="line">    handleStyle.updateStyle(el, oldVNode, newVNode)</span><br><span class="line">    handleStyle.updateAttr(el, oldVNode, newVNode)</span><br><span class="line">    handleEvent.updateEvent(el, oldVNode, newVNode)</span><br><span class="line">    <span class="comment">// 新节点的子节点是文本节点,那么就直接替换</span></span><br><span class="line">    <span class="keyword">if</span> (newVNode.text) &#123;</span><br><span class="line">      <span class="comment">// 移除旧节点的子节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode.children) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(oldVNode.children);</span><br><span class="line">        oldVNode.children.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(item);</span><br><span class="line">          handleEvent.removeEvent(item)</span><br><span class="line">          <span class="comment">// el.removeChild(h(item).el)</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 文本内容不相同则更新文本</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode.text !== newVNode.text) &#123;</span><br><span class="line">        el.textContent = newVNode.text</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新旧节点都存在子节点，那么就要进行diff</span></span><br><span class="line">      <span class="keyword">if</span> (oldVNode.children &amp;&amp; newVNode.children) &#123;</span><br><span class="line">        diff(el, oldVNode.children, newVNode.children)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newVNode.children) &#123; <span class="comment">// 新节点存在子节点</span></span><br><span class="line">        <span class="comment">// 旧节点存在文本节点则移除</span></span><br><span class="line">        <span class="keyword">if</span> (oldVNode.text) &#123;</span><br><span class="line">          el.textContent = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加新节点的子节点</span></span><br><span class="line">        newVNode.children.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">          el.appendChild(createEl(newVNode.children[index]))</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVNode.children) &#123; <span class="comment">// 新节点不存在子节点，那么移除旧节点的所有子节点</span></span><br><span class="line">        oldVNode.children.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">          handleEvent.removeEvent(item)</span><br><span class="line">          el.removeChild(item.el)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldVNode.text) &#123; <span class="comment">// 新节点啥也没有，旧节点存在文本节点</span></span><br><span class="line">        el.textContent = <span class="string">&#x27;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; <span class="comment">// 元素标签不同，使用newNode替换oldNode</span></span><br><span class="line">    <span class="keyword">let</span> newEl = createEl(newVNode)</span><br><span class="line">    updateClass(newEl, newVNode)</span><br><span class="line">    updateStyle(newEl, <span class="literal">null</span>, newVNode)</span><br><span class="line">    updateAttr(newEl, <span class="literal">null</span>, newVNode)</span><br><span class="line">    handleEvent.removeEvent(oldNode)</span><br><span class="line">    updateEvent(newEl, <span class="literal">null</span>, newVNode)</span><br><span class="line">    <span class="keyword">let</span> parent = oldVNode.el.parentNode</span><br><span class="line">    parent.insertBefore(newEl, oldVNode.el)</span><br><span class="line">    parent.removeChild(oldVNode.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="渲染dom"><a href="#渲染dom" class="headerlink" title="渲染dom"></a>渲染dom</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//渲染dom</span></span><br><span class="line"><span class="keyword">const</span> createEl = <span class="function">(<span class="params">vnode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(vnode);</span><br><span class="line">  <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(vnode.tag)</span><br><span class="line">  vnode.el = el;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.children &amp;&amp; vnode.children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    vnode.children.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      el.appendChild(createEl(item))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//重点：初始化的时候需要给虚拟节点赋值text，children。下次比较新旧节点的时候才是正确的。这里需要优化</span></span><br><span class="line">    vnode.text = vnode.children</span><br><span class="line">    vnode.children = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vnode.text) &#123;</span><br><span class="line">    el.appendChild(<span class="built_in">document</span>.createTextNode(vnode.text))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;createEl:vnode&#x27;</span>, vnode);</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="diff函数（只针对新旧节点的比较）"><a href="#diff函数（只针对新旧节点的比较）" class="headerlink" title="diff函数（只针对新旧节点的比较）"></a>diff函数（只针对新旧节点的比较）</h4><p>1、<strong>节点类型变了</strong>。直接将旧节点卸载并装载新节点。<strong>旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做效率不高</strong>。但为了避免O(n^3)的时间复杂度，这样是值得的。这也提醒了开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p没有意义。</p>
<p>2、<strong>节点类型一样，仅仅属性或属性值变了。</strong>我们将这个过程称之为<strong>PROPS</strong>。此时不会触发节点卸载和装载，而是节点更新。</p>
<p>3、<strong>文本变了</strong>，文本对也是一个Text Node，也比较简单，直接修改文字内容就行了，我们将这个过程称之为<strong>TEXT</strong>。</p>
<p>4、移动／增加／删除 子节点，我们将这个过程称之为<strong>REORDER</strong>。</p>
<p>前三个以及在打补丁函数中执行了。后面节点的操作在下面执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//diff算法</span></span><br><span class="line"><span class="keyword">const</span> diff = <span class="function">(<span class="params">el, oldChildren, newChildren</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;diff&#x27;</span>);</span><br><span class="line">  <span class="comment">// 指针</span></span><br><span class="line">  <span class="keyword">let</span> oldStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldEndIdx = oldChildren.length - <span class="number">1</span></span><br><span class="line">  <span class="keyword">let</span> newStartIdx = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> newEndIdx = newChildren.length - <span class="number">1</span></span><br><span class="line">  <span class="comment">// 节点</span></span><br><span class="line">  <span class="keyword">let</span> oldStartVNode = oldChildren[oldStartIdx]</span><br><span class="line">  <span class="keyword">let</span> oldEndVNode = oldChildren[oldEndIdx]</span><br><span class="line">  <span class="keyword">let</span> newStartVNode = newChildren[newStartIdx]</span><br><span class="line">  <span class="keyword">let</span> newEndVNode = newChildren[newEndIdx]</span><br><span class="line">  <span class="comment">//子节点个数都要大于1</span></span><br><span class="line">  <span class="keyword">while</span> (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldStartVNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldEndVNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartVNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      newStartVNode = oldChildren[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newEndVNode === <span class="literal">null</span>) &#123;</span><br><span class="line">      newEndVNode = oldChildren[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameNode(oldStartVNode, newStartVNode)) &#123; <span class="comment">// 头-头</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;头-头&#x27;</span>, oldStartVNode, newStartVNode);</span><br><span class="line">      <span class="comment">// 更新指针</span></span><br><span class="line">      oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">      newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameNode(oldStartVNode, newEndVNode)) &#123; <span class="comment">// 头-尾</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;头-尾&#x27;</span>);</span><br><span class="line">      patchVNode(oldStartVNode, newEndVNode)</span><br><span class="line">      <span class="comment">// 把oldStartVNode节点移动到最后</span></span><br><span class="line">      el.insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling)</span><br><span class="line">      <span class="comment">// 更新指针</span></span><br><span class="line">      oldStartVNode = oldChildren[++oldStartIdx]</span><br><span class="line">      newEndVNode = newChildren[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameNode(oldEndVNode, newStartVNode)) &#123; <span class="comment">// 尾-头</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;尾-头&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      patchVNode(oldEndVNode, newStartVNode)</span><br><span class="line">      <span class="comment">// 把oldEndVNode节点移动到oldStartVNode前</span></span><br><span class="line">      el.insertBefore(oldEndVNode.el, oldStartVNode.el)</span><br><span class="line">      <span class="comment">// 更新指针</span></span><br><span class="line">      oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">      newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isSameNode(oldEndVNode, newEndVNode)) &#123; <span class="comment">// 尾-尾</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;尾-尾&#x27;</span>);</span><br><span class="line"></span><br><span class="line">      patchVNode(oldEndVNode, newEndVNode)</span><br><span class="line">      <span class="comment">// 更新指针</span></span><br><span class="line">      oldEndVNode = oldChildren[--oldEndIdx]</span><br><span class="line">      newEndVNode = newChildren[--newEndIdx]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;insertBefore&#x27;</span>);</span><br><span class="line">      <span class="keyword">let</span> findIndex = findSameNode(oldChildren, newStartVNode)</span><br><span class="line">      <span class="comment">// newStartVNode在旧列表里不存在，那么是新节点，创建插入</span></span><br><span class="line">      <span class="keyword">if</span> (findIndex === -<span class="number">1</span>) &#123;</span><br><span class="line">        el.insertBefore(createEl(newStartVNode), oldStartVNode.el)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 在旧列表里存在，那么进行patch，并且移动到oldStartVNode前</span></span><br><span class="line">        <span class="keyword">let</span> oldVNode = oldChildren[findIndex]</span><br><span class="line">        patchVNode(oldVNode, newStartVNode)</span><br><span class="line">        el.insertBefore(oldVNode.el, oldStartVNode.el)</span><br><span class="line">        oldChildren[findIndex] = <span class="literal">null</span></span><br><span class="line">      &#125;</span><br><span class="line">      newStartVNode = newChildren[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 旧列表里存在新列表里没有的节点，需要删除</span></span><br><span class="line">  <span class="keyword">if</span> (oldStartIdx &lt;= oldEndIdx) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = oldStartIdx; i &lt;= oldEndIdx; i++) &#123;</span><br><span class="line">      handleEvent.removeEvent(oldChildren[i])</span><br><span class="line">      oldChildren[i] &amp;&amp; el.removeChild(oldChildren[i].el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">    <span class="keyword">let</span> before = newChildren[newEndIdx + <span class="number">1</span>] ? newChildren[newEndIdx + <span class="number">1</span>].el : <span class="literal">null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = newStartIdx; i &lt;= newEndIdx; i++) &#123;</span><br><span class="line">      el.insertBefore(createEl(newChildren[i]), before)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="入口方法以及调用"><a href="#入口方法以及调用" class="headerlink" title="入口方法以及调用"></a>入口方法以及调用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入口方法</span></span><br><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params">oldVNode, newVNode</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化的时候，dom元素转换成vnode</span></span><br><span class="line">  <span class="keyword">if</span> (!oldVNode.tag) &#123;</span><br><span class="line">    <span class="keyword">let</span> el = oldVNode</span><br><span class="line">    el.innerHTML = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    oldVNode = h(oldVNode.tagName.toLowerCase())</span><br><span class="line">    oldVNode.el = el</span><br><span class="line">  &#125;</span><br><span class="line">  patchVNode(oldVNode, newVNode)</span><br><span class="line">  <span class="keyword">return</span> newVNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">let</span> preVNode = patch(</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;app&quot;</span>),</span><br><span class="line">  h(</span><br><span class="line">    <span class="string">&quot;div&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">class</span>: &#123;</span><br><span class="line">        <span class="attr">btn</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">style</span>: &#123;</span><br><span class="line">        <span class="attr">fontSize</span>: <span class="string">&quot;30px&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">attr</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&quot;oldId&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">event</span>: &#123;</span><br><span class="line">        <span class="attr">mouseover</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> newVNode = h(</span><br><span class="line">              <span class="string">&quot;div&quot;</span>,</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">class</span>: &#123;<span class="comment">//类名改变</span></span><br><span class="line">                  <span class="attr">btn</span>: <span class="literal">true</span>,</span><br><span class="line">                  <span class="attr">warning</span>: <span class="literal">false</span>,</span><br><span class="line">                  <span class="attr">bg</span>: <span class="literal">true</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">style</span>: &#123;<span class="comment">//样式改变</span></span><br><span class="line">                  <span class="attr">fontWeight</span>: <span class="string">&quot;bold&quot;</span>,</span><br><span class="line">                  <span class="attr">fontStyle</span>: <span class="string">&quot;italic&quot;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">attr</span>: &#123;</span><br><span class="line">                  <span class="attr">id</span>: <span class="string">&quot;newId&quot;</span>,<span class="comment">//id改变</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">event</span>: &#123;</span><br><span class="line">                  <span class="attr">click</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">                    alert(<span class="string">&quot;点了我&quot;</span>);</span><br><span class="line">                  &#125;,</span><br><span class="line">                &#125;,</span><br><span class="line">              &#125;,</span><br><span class="line">              [<span class="comment">//reorder 移动／增加／删除 子节点</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">tag</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">                  <span class="attr">children</span>: <span class="string">&#x27;已经移入&#x27;</span><span class="comment">//text 文本变了 此时不会触发节点卸载和装载，而是节点更新</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">tag</span>: <span class="string">&#x27;h3&#x27;</span>,<span class="comment">//replace 节点类型变了 直接将旧节点卸载并装载新节点</span></span><br><span class="line">                  <span class="attr">children</span>: <span class="string">&#x27;item3&#x27;</span></span><br><span class="line">                &#125;,</span><br><span class="line">              ]</span><br><span class="line">            );</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;preVNode:&#x27;</span>, preVNode, <span class="string">&#x27;newVNode:&#x27;</span>, newVNode);</span><br><span class="line">            patch(preVNode, newVNode);</span><br><span class="line">          &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">tag</span>: <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;移入我&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">tag</span>: <span class="string">&#x27;h2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;item1&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">tag</span>: <span class="string">&#x27;h2&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: <span class="string">&#x27;item2&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  )</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="html引入"><a href="#html引入" class="headerlink" title="html引入"></a>html引入</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.warning</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">border</span>: <span class="number">1px</span> solid lightcoral;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.bg</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: lightgoldenrodyellow;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./newIndex.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a><strong>响应式</strong></h2><p><strong>1. 脏值检查：</strong> angular是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图，最简单的方式就是通过 setInterval() 定时轮询检测数据变动，当然Google不会这么low，angular只有在指定的事件触发时进入脏值检测，大致如下： DOM事件，譬如用户输入文本，点击按钮等。( ng-click ) XHR响应事件 ( $http ) 浏览器Location变更事件 ( $location ) Timer事件( $timeout , $interval ) 执行 $digest() 或 $apply()在 Angular 中组件是以树的形式组织起来的，相应地，检测器也是一棵树的形状。当一个异步事件发生时，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查，这种检查方式的性能存在很大问题。</p>
<p><strong>2.观察者-订阅者（数据劫持）：vue</strong>Observer 数据监听器，把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用Object.defineProperty()方法把这些属性全部转成setter、getter方法。当data中的某个属性被访问时，则会调用getter方法，当data中的属性被改变时，则会调用setter方法。Compile指令解析器，它的作用对每个元素节点的指令进行解析，替换模板数据，并绑定对应的更新函数，初始化相应的订阅。Watcher 订阅者，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数。Dep 消息订阅器，内部维护了一个数组，用来收集订阅者（Watcher），数据变动触发notify 函数，再调用订阅者的 update 方法。执行流程如下：</p>
<p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=1581589677,2197583542&fm=173&app=25&f=JPEG?w=640&h=342&s=5926347301CA614B4E65C0CA0000E0B3" alt="img"></p>
<p>从图中可以看出，当执行 new Vue() 时，Vue 就进入了初始化阶段，一方面Vue 会遍历 data 选项中的属性，并用 Object.defineProperty 将它们转为 getter/setter，实现数据变化监听功能；另一方面，Vue 的指令编译器Compile 对元素节点的指令进行解析，初始化视图，并订阅Watcher 来更新视图， 此时Wather 会将自己添加到消息订阅器中(Dep),初始化完毕。当数据发生变化时，Observer 中的 setter 方法被触发，setter 会立即调用Dep.notify()，Dep 开始遍历所有的订阅者，并调用订阅者的 update 方法，订阅者收到通知后对视图进行相应的更新。因为VUE使用Object.defineProperty方法来做数据绑定，而这个方法又无法通过兼容性处理，所以Vue 不支持 IE8 以及更低版本浏览器。另外，查看vue原代码，发现在vue初始化实例时， 有一个proxy代理方法，它的作用就是遍历data中的属性，把它代理到vm的实例上，这也就是我们可以这样调用属性：vm.aaa等于vm.data.aaa。</p>
<h3 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h3><p><a href="https://juejin.cn/post/6950826293923414047">https://juejin.cn/post/6950826293923414047</a></p>
<p><a href="https://juejin.cn/post/6844903597986037768">https://juejin.cn/post/6844903597986037768</a></p>
<p><a href="https://juejin.cn/post/6989106100582744072">https://juejin.cn/post/6989106100582744072</a></p>
<p>什么是响应式？数据发生改变的时候，视图会重新渲染，匹配更新为最新的值。</p>
<p>我们可以问出下面三个问题</p>
<p>1、Vue 是怎么知道数据改变？<strong>Object.defineProperty</strong></p>
<p>2、Vue 在数据改变时，怎么知道通知哪些视图更新？<strong>dep</strong></p>
<p>3、Vue 在数据改变时，视图怎么知道什么时候更新？</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/2/8/1617554b425a3431~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="vue响应式"></p>
<h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p><code>vue.js</code> 则是采用数据劫持结合发布者-订阅者模式的方式，通过<code>Object.defineProperty()</code>来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应的监听回调</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;text&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    input.value = value;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">input.onChange = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  data.text = e.target.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h4><p><strong>Watcher是一个观察者对象（本质上是一个组件）</strong>。</p>
<ul>
<li><p>一个组件生成一个Watcher实例</p>
</li>
<li><p>依赖收集：执行addSub把Watcher实例保存在Dep实例的subs中</p>
</li>
<li><p>更新：数据变动的时候Dep执行notify通知Watcher实例，然后由Watcher实例回调update进行视图的更新</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Watcher = <span class="function"><span class="keyword">function</span> (<span class="params">vm, fn</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(vm, fn);</span><br><span class="line">    <span class="built_in">this</span>.vm = vm;</span><br><span class="line">    <span class="comment">// 将当前Dep.target指向自己</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span>;</span><br><span class="line">    <span class="comment">// 在 dep 中添加 watcher</span></span><br><span class="line">    <span class="built_in">this</span>.addDep = <span class="function"><span class="keyword">function</span> (<span class="params">dep</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;addDep-this&quot;</span>, <span class="built_in">this</span>); <span class="comment">//Watcher实例</span></span><br><span class="line">      dep.addSub(<span class="built_in">this</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新方法，用于触发vm.$render</span></span><br><span class="line">    <span class="built_in">this</span>.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">this</span>, <span class="string">&quot;update-this&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;in watcher update&quot;</span>);</span><br><span class="line">      fn.call(<span class="built_in">this</span>.vm);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 这里会首次调用vm._render，从而触发text的get</span></span><br><span class="line">    <span class="comment">// 从而将当前的Wathcer与Dep关联起来</span></span><br><span class="line">    fn.call(<span class="built_in">this</span>.vm);</span><br><span class="line">    <span class="comment">// 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，</span></span><br><span class="line">    <span class="comment">// 造成代码死循环</span></span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="依赖收集Dep"><a href="#依赖收集Dep" class="headerlink" title="依赖收集Dep"></a><strong>依赖收集</strong>Dep</h4><ul>
<li>生成Dep实例（一个目标对象obj.key(即data)会生成一个Dep实例）</li>
<li>getter读取响应式数据时，执行depend负责收集Watcher依赖</li>
<li>setter设置响应式数据时，执行notify通知 dep 中那些 watcher 去执行 update 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Dep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.target = <span class="literal">null</span>; <span class="comment">// 收集目标</span></span><br><span class="line">  <span class="built_in">this</span>.subs = []; <span class="comment">// dep收集器存储需要通知的Watcher</span></span><br><span class="line">  <span class="built_in">this</span>.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 在 dep 中添加 watcher</span></span><br><span class="line">    <span class="built_in">this</span>.subs.push(watcher);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 向 watcher 中添加 dep</span></span><br><span class="line">  <span class="built_in">this</span>.depend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当有目标时，绑定Dep与Wathcer的关系</span></span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;Dep.target&quot;</span>, Dep.target);<span class="comment">//</span></span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">this</span>.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通知收集器 dep 中的所有 watcher，执行 watcher.update() 方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.subs.length; i += <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.subs[i].update();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h4><p>Observer类是将每个目标对象（即data）的键值转换成getter/setter形式，用于进行依赖收集以及调度更新。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> defineReactive = <span class="function"><span class="keyword">function</span> (<span class="params">obj, key</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 实例化 dep，一个 key 一个 dep</span></span><br><span class="line">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;dep&quot;</span>, dep, obj, key);</span><br><span class="line">    <span class="comment">// 获取当前值</span></span><br><span class="line">    <span class="keyword">let</span> val = obj[key];</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">      <span class="comment">// 设置当前描述属性为可被循环</span></span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 设置当前描述属性可被修改</span></span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;in get&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系</span></span><br><span class="line">        dep.depend();</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;in set&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (newVal === val) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        val = newVal;</span><br><span class="line">        <span class="comment">// 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，</span></span><br><span class="line">        <span class="comment">// 这里每个需要更新通过什么断定？dep.subs</span></span><br><span class="line">        dep.notify();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;; </span><br><span class="line"><span class="keyword">const</span> Observer = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 循环修改为每个属性添加get set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      defineReactive(data, key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> observe = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observer(data);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>只针对了对象进行响应式</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h3</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 响应式的数据分为两类：</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 对象，循环遍历对象的所有属性，为每个属性设置 getter、setter，以达到拦截访问和设置的目的，如果属性值依旧为对象，则递归为属性值上的每个 key 设置 getter、setter</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 访问数据时（obj.key)进行依赖收集，在 dep 中存储相关的 watcher</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 设置数据时由 dep 通知相关的 watcher 去更新</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 数组，增强数组的那 7 个可以更改自身的原型方法，然后拦截对这些方法的操作</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 添加新数据时进行响应式处理，然后由 dep 通知 watcher 去更新</span></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 删除数据时，也要由 dep 通知 watcher 去更新</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   * 一个 dep 对应一个 obj.key</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   * 在读取响应式数据时，负责收集依赖，每个 dep（或者说 obj.key）依赖的 watcher 有哪些</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   * 在响应式数据更新时，负责通知 dep 中那些 watcher 去执行 update 方法</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   */</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> Dep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.target = <span class="literal">null</span>; <span class="comment">// 收集目标</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.subs = []; <span class="comment">// dep收集器存储需要通知的Watcher</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.addSub = <span class="function"><span class="keyword">function</span> (<span class="params">watcher</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 在 dep 中添加 watcher</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.subs.push(watcher);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 向 watcher 中添加 dep</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.depend = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 当有目标时，绑定Dep与Wathcer的关系</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (Dep.target) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;Dep.target&quot;</span>, Dep.target);</span></span><br><span class="line"><span class="javascript">        Dep.target.addDep(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.notify = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通知收集器 dep 中的所有 watcher，执行 watcher.update() 方法</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.subs.length; i += <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.subs[i].update();</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript">  <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   * 拦截 obj[key] 的读取和设置操作：</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   *   1、在第一次读取时收集依赖，比如执行 render 函数生成虚拟 DOM 时会有读取操作</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   *   2、在更新时设置新值并通知依赖更新</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   */</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> defineReactive = <span class="function"><span class="keyword">function</span> (<span class="params">obj, key</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 实例化 dep，一个 key 一个 dep</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&quot;dep&quot;</span>, dep, obj, key);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取当前值</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> val = obj[key];</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置当前描述属性为可被循环</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 设置当前描述属性可被修改</span></span></span><br><span class="line"><span class="javascript">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;in get&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 调用依赖收集器中的addSub，用于收集当前属性与Watcher中的依赖关系</span></span></span><br><span class="line"><span class="javascript">        dep.depend();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> val;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">set</span>(<span class="params">newVal</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&quot;in set&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (newVal === val) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        val = newVal;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 当值发生变更时，通知依赖收集器，更新每个需要更新的Watcher，</span></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 这里每个需要更新通过什么断定？dep.subs</span></span></span><br><span class="line"><span class="javascript">        dep.notify();</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> Observer = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 循环修改为每个属性添加get set</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span></span><br><span class="line"><span class="javascript">      defineReactive(data, key);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> observe = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> Observer(data);</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">/**</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   * 一个组件一个 watcher（渲染 watcher）或者一个表达式一个 watcher（用户watcher）</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   * 当数据更新时 watcher 会被触发，访问 this.computedProperty 时也会触发 watcher</span></span></span><br><span class="line"><span class="comment"><span class="javascript">   */</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> Watcher = <span class="function"><span class="keyword">function</span> (<span class="params">vm, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(vm, fn);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.vm = vm;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将当前Dep.target指向自己</span></span></span><br><span class="line"><span class="javascript">    Dep.target = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 在 dep 中添加 watcher</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.addDep = <span class="function"><span class="keyword">function</span> (<span class="params">dep</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;addDep-this&quot;</span>, <span class="built_in">this</span>); <span class="comment">//Watcher实例</span></span></span><br><span class="line"><span class="javascript">      dep.addSub(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 更新方法，用于触发vm.$render</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.update = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="built_in">this</span>, <span class="string">&quot;update-this&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;in watcher update&quot;</span>);</span></span><br><span class="line"><span class="javascript">      fn.call(<span class="built_in">this</span>.vm);</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里会首次调用vm._render，从而触发text的get</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 从而将当前的Wathcer与Dep关联起来</span></span></span><br><span class="line"><span class="javascript">    fn.call(<span class="built_in">this</span>.vm);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 这里清空了Dep.target，为了防止notify触发时，不停的绑定Watcher与Dep，</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 造成代码死循环</span></span></span><br><span class="line"><span class="javascript">    Dep.target = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> Vue = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将data赋值给this.$data，源码这部分用的Proxy所以我们用最简单的方式临时实现</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (options &amp;&amp; <span class="keyword">typeof</span> options.data === <span class="string">&quot;function&quot;</span>) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$data = options.data.apply(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 监听this.$data</span></span></span><br><span class="line"><span class="javascript">    observe(<span class="built_in">this</span>.$data);</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 挂载函数</span></span></span><br><span class="line"><span class="javascript">  Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> self = <span class="built_in">this</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Watcher(self, self.$render);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// new Watcher(self, self.$render);</span></span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 渲染函数</span></span></span><br><span class="line"><span class="javascript">  Vue.prototype.$render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//渲染视图</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//vue2渲染函数返回的是虚拟dom,这里暂时返回真实的dom</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> h3 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;h3&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    h3.innerText = <span class="built_in">this</span>.$data.text + <span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.$data.text1&#125;</span>`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> h3;</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> myApp = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">text</span>: <span class="string">&quot;hello world&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">text1</span>: <span class="string">&quot;123&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$data.text = <span class="string">&quot;这是新的标题&quot;</span>;</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="number">1000</span>);</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  myApp.$mount(<span class="string">&quot;app&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="comment">// myApp.$data.text = &quot;123&quot;; // in watcher update /n in get</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h4><p><strong>Object.defineProperty</strong>可以为对象中的每一个属性，设置 get 和 set 方法</p>
<p>get 值是一个函数，当属性被访问时，会触发 get 函数</p>
<p>set 值同样是一个函数，当属性被赋值时，会触发 set 函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get 被触发&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;神仙&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set 被触发&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);</span><br><span class="line"></span><br><span class="line">当我访问 obj.name 时，会打印 <span class="string">&#x27; get 被触发 &#x27;</span></span><br><span class="line">当我为 obj.name 赋值时，obj.name = <span class="number">5</span>，会打印 <span class="string">&#x27; set 被触发 &#x27;</span></span><br></pre></td></tr></table></figure>



<h2 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h2><p><a href="https://blog.csdn.net/qq_41887214/article/details/121922348">https://blog.csdn.net/qq_41887214/article/details/121922348</a></p>
<h1 id="vue-7"><a href="#vue-7" class="headerlink" title="vue"></a>vue</h1><h2 id="this直接获取data和methods"><a href="#this直接获取data和methods" class="headerlink" title="this直接获取data和methods"></a>this直接获取data和methods</h2><p><a href="https://mp.weixin.qq.com/s/Uq-LYSrmn1lOjRuAl4jc2A">https://mp.weixin.qq.com/s/Uq-LYSrmn1lOjRuAl4jc2A</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;我是pino&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(vm.name); <span class="comment">// 我是pino</span></span><br><span class="line">vm.print(); <span class="comment">// 我是pino</span></span><br></pre></td></tr></table></figure>

<p>但是我们自己实现一个构造函数却实现不了这种效果呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">options</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Super(&#123;</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;pino&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="function"><span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.name); <span class="comment">// undefined</span></span><br><span class="line">p.print(); <span class="comment">// p.print is not a function</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong></p>
<p>通过<code>this</code>直接访问到<code>methods</code>里面的函数的原因是：因为<code>methods</code>里的方法通过 <code>bind</code> 指定了<code>this</code>为 <code>new Vue</code>的实例(<code>vm</code>)</p>
<p>通过 <code>this</code> 直接访问到 <code>data</code> 里面的数据的原因是：data里的属性最终会存储到<code>new Vue</code>的实例（<code>vm</code>）上的 <code>_data</code>对象中，访问 <code>this.xxx</code>，是访问<code>Object.defineProperty</code>代理后的 <code>this._data.xxx</code>。</p>
<h1 id="react-7"><a href="#react-7" class="headerlink" title="react"></a>react</h1><h2 id="fiber"><a href="#fiber" class="headerlink" title="fiber"></a>fiber</h2><p><a href="https://m.php.cn/article/490176.html">https://m.php.cn/article/490176.html</a></p>
<p><strong>fiber就是链表结构的虚拟Dom</strong></p>
<p>Fiber是React新的调度算法，是对核心算法的一次重新实现。React Fiber把更新过程碎片化，每执行完一段更新过程，就把控制权交还给React负责任务协调的模块，看看有没有其他紧急任务要做，如果有紧急任务，就去做紧急任务。</p>
<p>react在进行组件渲染时，从setState开始到渲染完成整个过程是同步的（“一气呵成”）。如果需要渲染的组件比较庞大，js执行会占据主线程时间较长，会导致页面响应度变差，使得react在动画、手势等应用中效果比较差。</p>
<p>为了解决这个问题，react团队经过两年的工作，重写了react中核心算法——reconciliation。并在v16版本中发布了这个新的特性。为了区别之前和之后的reconciler，通常将之前的reconciler称为stack reconciler，重写后的称为fiber reconciler，简称为Fiber。</p>
<p><img src="https://img.php.cn/upload/image/897/958/792/1647925041816601.gif" alt="1.gif"></p>
<p><img src="https://img.php.cn/upload/image/773/873/534/1647925045329977.gif" alt="2.gif"></p>
<p><strong>卡顿原因</strong></p>
<p>Stack reconciler的工作流程很像函数的调用过程。父组件里调子组件，可以类比为函数的递归（这也是为什么被称为stack reconciler的原因）。在setState后，react会立即开始reconciliation过程，从父节点（Virtual DOM）开始遍历，以找出不同。将所有的Virtual DOM遍历完成后，reconciler才能给出当前需要修改真实DOM的信息，并传递给renderer，进行渲染，然后屏幕上才会显示此次更新内容。对于特别庞大的vDOM树来说，reconciliation过程会很长(x00ms)，在这期间，主线程是被js占用的，因此任何交互、布局、渲染都会停止，给用户的感觉就是页面被卡住了。</p>
<p><strong>Scheduler</strong></p>
<p>scheduling(调度)是fiber reconciliation的一个过程，主要决定应该在何时做什么。?的过程表明在stack reconciler中，reconciliation是“一气呵成”，对于函数来说，这没什么问题，因为我们只想要函数的运行结果，但对于UI来说还需要考虑以下问题：</p>
<ul>
<li>并不是所有的state更新都需要立即显示出来，比如屏幕之外的部分的更新</li>
<li>并不是所有的更新优先级都是一样的，比如用户输入的响应优先级要比通过请求填充内容的响应优先级更高</li>
<li>理想情况下，对于某些高优先级的操作，应该是可以打断低优先级的操作执行的，比如用户输入时，页面的某个评论还在reconciliation，应该优先响应用户输入</li>
</ul>
<p>所以理想状况下reconciliation的过程应该是，每次只做一个很小的任务，做完后能够“喘口气儿”，回到主线程看下有没有什么更高优先级的任务需要处理，如果又则先处理更高优先级的任务，没有则继续执行(<a href="https://link.juejin.cn/?target=https://www.w3.org/TR/requestidlecallback/">cooperative scheduling 合作式调度</a>)。</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p><a href="https://mp.weixin.qq.com/s/2o7VvwyPISMQ7k0IBNoXmg">https://mp.weixin.qq.com/s/2o7VvwyPISMQ7k0IBNoXmg</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/37730038">https://zhuanlan.zhihu.com/p/37730038</a></p>
<p><strong>路由就是 URL 到函数的映射</strong>，这种映射是单向的，即 URL 变化引起 UI 更新（无需刷新页面）。</p>
<p>要实现前端路由，需要解决两个核心：</p>
<p>如何改变 URL 却不引起页面刷新？<br>如何检测 URL 变化了？</p>
<p>下面分别使用 hash 和 history 两种实现方式回答上面的两个核心问题。</p>
<h2 id="hash-实现"><a href="#hash-实现" class="headerlink" title="hash 实现"></a><strong>hash 实现</strong></h2><p>hash 是 URL 中 hash (#) 及后面的那部分，常用作锚点在页面内进行导航，改变 URL 中的 hash 部分不会引起页面刷新<br>通过 hashchange 事件监听 URL 的变化。<br>改变 URL 的方式只有这几种：</p>
<ul>
<li><p>通过浏览器前进后退改变 URL</p>
</li>
<li><p>通过a标签改变 URL、</p>
</li>
<li><p>通过window.location改变URL</p>
</li>
</ul>
<p>这几种情况改变 URL 都会触发 hashchange 事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;ul&gt;</span><br><span class="line">   &lt;!-- 定义路由 --&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>home<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>about<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">   &lt;!-- 渲染路由对应的 UI --&gt;</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;routeView&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"> &lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="comment">// 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, onLoad)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="comment">// 监听路由变化</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, onHashChange)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   </span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="comment">// 路由视图</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="keyword">var</span> routerView = <span class="literal">null</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   </span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="function"><span class="keyword">function</span> <span class="title">onLoad</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">     routerView = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#routeView&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">     onHashChange()</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   </span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="comment">// 路由变化时，根据路由渲染对应 UI</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">   <span class="function"><span class="keyword">function</span> <span class="title">onHashChange</span> (<span class="params"></span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">     <span class="keyword">switch</span> (location.hash) &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">       <span class="keyword">case</span> <span class="string">&#x27;#/home&#x27;</span>:</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         routerView.innerHTML = <span class="string">&#x27;Home&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="keyword">return</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">       <span class="keyword">case</span> <span class="string">&#x27;#/about&#x27;</span>:</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         routerView.innerHTML = <span class="string">&#x27;About&#x27;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="keyword">return</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">       <span class="keyword">default</span>:</span></span></span><br><span class="line"><span class="javascript"><span class="xml">         <span class="keyword">return</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">     &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">   &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span> </span><br></pre></td></tr></table></figure>



<h2 id="history-实现"><a href="#history-实现" class="headerlink" title="history 实现"></a><strong>history 实现</strong></h2><p>history 提供了 pushState 和 replaceState 两个方法，这两个方法改变 URL 的 path 部分不会引起页面刷新。<br>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：</p>
<ul>
<li><p>通过浏览器前进后退改变 URL 时会触发 popstate 事件（或者在 JavaScript 中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>方法）</p>
</li>
<li><p>通过pushState/replaceState或a标签改变 URL 不会触发 popstate 事件。</p>
</li>
</ul>
<p>好在我们可以拦截 pushState/replaceState的调用和a标签的点击事件来检测 URL 变化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   // 页面加载完不会触发 hashchange，这里主动触发一次 hashchange 事件</span><br><span class="line">   window.addEventListener(&#x27;DOMContentLoaded&#x27;, onLoad);</span><br><span class="line">   // 监听路由变化</span><br><span class="line">   window.addEventListener(&#x27;popstate&#x27;, onPopState);</span><br><span class="line">   </span><br><span class="line">   // 路由视图</span><br><span class="line">   var routerView = null;</span><br><span class="line">   </span><br><span class="line">   function onLoad() &#123;</span><br><span class="line">       routerView = document.querySelector(&#x27;.vanilla.history .container&#x27;);</span><br><span class="line">       onPopState();</span><br><span class="line">   </span><br><span class="line">       // 拦截 &lt;a&gt; 标签点击事件默认行为， 点击时使用 pushState 修改 URL并更新手动 UI，从而实现点击链接更新 URL 和 UI 的效果。</span><br><span class="line">       var linkList = document.querySelectorAll(&#x27;.vanilla.history a[href]&#x27;);</span><br><span class="line">       linkList.forEach(el =&gt;</span><br><span class="line">           el.addEventListener(&#x27;click&#x27;, function(e) &#123;</span><br><span class="line">               e.preventDefault();</span><br><span class="line">               history.pushState(null, &#x27;&#x27;, el.getAttribute(&#x27;href&#x27;));</span><br><span class="line">               onPopState();</span><br><span class="line">           &#125;)</span><br><span class="line">       );</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // 路由变化时，根据路由渲染对应 UI</span><br><span class="line">   function onPopState() &#123;</span><br><span class="line">       switch (location.pathname) &#123;</span><br><span class="line">           case &#x27;/home&#x27;:</span><br><span class="line">               routerView.innerHTML = &#x27;&lt;h2&gt;Home&lt;/h2&gt;&#x27;;</span><br><span class="line">               return;</span><br><span class="line">           case &#x27;/about&#x27;:</span><br><span class="line">               routerView.innerHTML = &#x27;&lt;h2&gt;About&lt;/h2&gt;&#x27;;</span><br><span class="line">               return;</span><br><span class="line">           default:</span><br><span class="line">               return;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt; </span><br></pre></td></tr></table></figure>

<h2 id="router-和-route-的区别"><a href="#router-和-route-的区别" class="headerlink" title="router 和 route 的区别"></a>router 和 route 的区别</h2><p>route 就是一条路由，它将一个 URL 路径和一个函数进行映射。而 router 可以理解为一个容器，或者说一种机制，它管理了一组 route。</p>
<p>概括为：route 只是进行了 URL 和函数的映射，在当接收到一个 URL 后，需要去路由映射表中查找相应的函数（组件函数），这个过程是由 router 来处理的。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="vue-react路由"><a href="#vue-react路由" class="headerlink" title="vue/react路由"></a>vue/react路由</h3><ul>
<li>以 Vue为例，需要有 <code>&lt;router-link&gt;</code>链接、<code>&lt;router-view&gt;</code>容器、<code>component</code>组件和<code>path</code>路由路径：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">        &lt;!-- 使用 router-link 组件进行导航 --&gt;</span><br><span class="line">        &lt;!-- 通过传递 to 来指定链接 --&gt;</span><br><span class="line">        &lt;!-- &lt;router-link&gt; 将呈现一个带有正确 href属性的&lt;a&gt;标签 --&gt;</span><br><span class="line">        &lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt;</span><br><span class="line">        &lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">    &lt;!-- 路由出口 --&gt;</span><br><span class="line">    &lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码</span><br><span class="line">const routes = [&#123;</span><br><span class="line">    path: &#x27;/&#x27;,</span><br><span class="line">    component: Home</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">    path: &#x27;/about&#x27;,</span><br><span class="line">    component: About</span><br><span class="line">&#125;]</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>以React为例，需要有<code>&lt;BrowserRouter&gt;</code>容器、<code>&lt;Route&gt;</code>路由、组件和链接：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;</span><br><span class="line">    &lt;Routes&gt;</span><br><span class="line">        &lt;Route path=&quot;/&quot; element=&#123;&lt;App /&gt;&#125;&gt;</span><br><span class="line">            &lt;Route index element=&#123;&lt;Home /&gt;&#125; /&gt;</span><br><span class="line">            &lt;Route path=&quot;teams&quot; element=&#123;&lt;Teams /&gt;&#125;&gt;</span><br><span class="line">                &lt;Route path=&quot;:teamId&quot; element=&#123;&lt;Team /&gt;&#125; /&gt;</span><br><span class="line">                &lt;Route path=&quot;new&quot; element=&#123;&lt;NewTeamForm /&gt;&#125; /&gt;</span><br><span class="line">                &lt;Route index element=&#123;&lt;LeagueStandings /&gt;&#125; /&gt;</span><br><span class="line">            &lt;/Route&gt;</span><br><span class="line">        &lt;/Route&gt;</span><br><span class="line">    &lt;/Routes&gt;</span><br><span class="line">&lt;/BrowserRouter&gt;</span><br><span class="line">复制代码</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Home&lt;/h1&gt;</span><br><span class="line">    &lt;nav&gt;</span><br><span class="line">        &lt;Link to=&quot;/&quot;&gt;Home&lt;/Link&gt; | &#123;&quot;&quot;&#125;</span><br><span class="line">        &lt;Link to=&quot;about&quot;&gt;About&lt;/Link&gt;</span><br><span class="line">    &lt;/nav&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>综上，一个简单的 Router 应该具备以下功能：</p>
<ul>
<li><p>容器（组件）</p>
</li>
<li><p>路由</p>
</li>
<li><p>业务组件（router-view） &amp; 链接组件（router-link）</p>
</li>
</ul>
<h3 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h3><p><a href="https://www.ruanyifeng.com/blog/2019/08/web_components.html">https://www.ruanyifeng.com/blog/2019/08/web_components.html</a></p>
<ol>
<li><p>使用<code>CustomElementRegistry.define()</code>注册自定义元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-text&gt;&lt;/my-text&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    class MyText extends HTMLElement&#123;</span><br><span class="line">        constructor()&#123;</span><br><span class="line">            super();</span><br><span class="line">            this.append(“我的文本”);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    window.customElements.define(&quot;my-text&quot;,MyText);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li><p>Web Components 的生命周期：</p>
<p><strong>connectedCallback</strong>：当 custom element 首次被插入文档DOM时，被调用</p>
<p><strong>disconnectedCallback</strong>：当 custom element 从文档DOM中删除时，被调用</p>
<p><strong>adoptedCallback</strong>：当custom element 被移动到新的文档时，被调用</p>
<p><strong>attributeChangedCallback</strong>：当 custom element 增加、删除、修改自身属性时，被调用</p>
</li>
</ol>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p><img src="https://mmbiz.qpic.cn/sz_mmbiz/H8M5QJDxMHq2mFYEc2kKuKic6OraWTibeRrLP7HiasHoz5fbSc2uD16SIxhSkkZiaYaLpZeoJJ9YKuCrjg6FvSf9gQ/640?wx_fmt=other&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="链接组件"><a href="#链接组件" class="headerlink" title="链接组件"></a>链接组件</h4><p>链接组件 — CustomLink(c-link)</p>
<p>当用户点击<code>&lt;c-link&gt;</code>标签后，通过<code>event.preventDefault();</code>阻止页面默认跳转。根据当前标签的<code>to</code>属性获取路由，通过<code>history.pushState(&quot;&quot;,&quot;&quot;,to)</code>进行路由切换。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//  &lt;c-link to=&quot;/&quot; class=&quot;c-link&quot;&gt;首页&lt;/c-link&gt;</span><br><span class="line">class CustomLink extends HTMLElement &#123;</span><br><span class="line">    connectedCallback() &#123;</span><br><span class="line">        this.addEventListener(&quot;click&quot;, ev =&gt; &#123;</span><br><span class="line">            ev.preventDefault();</span><br><span class="line">            const to = this.getAttribute(&quot;to&quot;);</span><br><span class="line">            // 更新浏览器历史记录</span><br><span class="line">            history.pushState(&quot;&quot;, &quot;&quot;, to)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.customElements.define(&quot;c-link&quot;, CustomLink);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h4 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h4><p>容器组件 — CustomRouter(c-router)</p>
<p>主要是收集路由信息，监听路由信息的变化，然后加载对应的组件</p>
<h4 id="路由组件"><a href="#路由组件" class="headerlink" title="路由组件"></a>路由组件</h4><p>路由 — CustomRoute(c-route)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 优先于c-router注册</span><br><span class="line">//  &lt;c-route path=&quot;/&quot; component=&quot;home&quot; default&gt;&lt;/c-route&gt;</span><br><span class="line">class CustomRoute extends HTMLElement &#123;</span><br><span class="line">    #data = null;</span><br><span class="line">    getData() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            default: this.hasAttribute(&quot;default&quot;),</span><br><span class="line">            path: this.getAttribute(&quot;path&quot;),</span><br><span class="line">            component: this.getAttribute(&quot;component&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">window.customElements.define(&quot;c-route&quot;, CustomRoute);</span><br></pre></td></tr></table></figure>



<h2 id="install分析"><a href="#install分析" class="headerlink" title="install分析"></a>install分析</h2><ol>
<li><p>首先会对重复安装进行过滤</p>
</li>
<li><p>全局混入beforeCreate和destroyed 生命钩子，为每个Vue实例设置 _routerRoot属性，并为跟实例设置_router属性</p>
</li>
<li><p>调用Vue中定义的defineReactive对_route进行劫持，其实是执行的依赖收集的过程，执行_route的get就会对当前的组件进行依赖收集，如果对_route进行重新赋值触发setter就会使收集的组件重新渲染，这里也是路由重新渲染的核心所在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123; // 设置根路由-根组件实例</span><br><span class="line">        this._routerRoot = this</span><br><span class="line">        this._router = this.$options.router</span><br><span class="line">        this._router.init(this)</span><br><span class="line">        // 定义响应式的 _route 对象</span><br><span class="line">        Vue.util.defineReactive(this, &#x27;_route&#x27;, this._router.history.current)</span><br><span class="line">      &#125; else &#123; // 非根组件设置</span><br><span class="line">        this._routerRoot = (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(this, this)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>为Vue原型对象定义router和router和router和route属性，并对两个属性进行了劫持，使我们可以直接通过Vue对象实例访问到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(Vue.prototype, &#x27;$router&#x27;, &#123;</span><br><span class="line">   get () &#123; return this._routerRoot._router &#125;</span><br><span class="line"> &#125;)</span><br><span class="line">   </span><br><span class="line"> Object.defineProperty(Vue.prototype, &#x27;$route&#x27;, &#123;</span><br><span class="line">   get () &#123; return this._routerRoot._route &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>全局注册了Routerview和RouterLink两个组件，所以我们才可以在任何地方使用这两个组件，这两个组件的内容我们稍后分析</p>
</li>
</ol>
<h2 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h2><p>浏览器刷新vue为什么不会走beforeDestroy和destroyed生命周期<br>业务场景:<br>需要在页面卸载的时候去处理一些数据,比如清空 localStorage<br>然后就会把一些业务逻辑写在beforeDestroy或者destroyed的生命周期里</p>
<p>浏览器刷新的时候会走这两个生命周期吗<br>答案是不会<br>不是说在组件卸载的时候会走这两个生命周期么,为什么不会走呢?</p>
<p>浏览器刷新是做了些什么<br>浏览器的刷新其实相当于重新访问这个ip地址,包括html和js,css文件都会重新获取(这里会涉及到文件缓存的问题,但与vue的生命周期没有关系)<br>浏览器不在乎你之前的页面是什么,相当于把你之前的页面给关了再打开(直接拉闸再接电)</p>
<p>这种情况怎么处理<br>可以在页面加载的时候添加一个监听事件去监听浏览器刷新,关闭,这样就可以在浏览器刷新或者关闭的时候也能处理对应的业务逻辑</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>响应式</tag>
        <tag>路由</tag>
        <tag>diff</tag>
      </tags>
  </entry>
  <entry>
    <title>代码片段</title>
    <url>/2020/09/25/03-%E4%BB%A3%E7%A0%81%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="代码合集收藏"><a href="#代码合集收藏" class="headerlink" title="代码合集收藏"></a>代码合集收藏</h1><p><a href="https://mp.weixin.qq.com/s/w9iLd56H4xyXSlRwiKs04g">https://mp.weixin.qq.com/s/w9iLd56H4xyXSlRwiKs04g</a></p>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><p>​     &lt;!– <div class="dash" style="position: absolute; bottom: 0; width: 150px; height: 150px; margin-right: 20px"></p>
<pre><code>        &lt;div style=&quot;width: 150px; height: 150px; background: rgb(204 204 204 / 35%)&quot;&gt;&lt;/div&gt;
</code></pre>
<p>​     </div> –&gt;</p>
<h2 id="蒙版"><a href="#蒙版" class="headerlink" title="蒙版"></a>蒙版</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.page</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:relative;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.page</span>:after&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="attribute">content</span>: <span class="built_in">attr</span>(data-text);</span><br><span class="line">    <span class="comment">/* transition:all 1s ease; */</span></span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">100%</span>);</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#FFF</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* .page:hover:after&#123;</span></span><br><span class="line"><span class="comment">    transform: translateY(0);</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure>

<h2 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0px</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">border-top-color</span>: deeppink;</span><br><span class="line">    <span class="attribute">border-left-color</span>: deeppink;</span><br><span class="line">    <span class="comment">/*border-right-color: deeppink;*/</span></span><br><span class="line">    <span class="comment">/*border-bottom-color: deeppink;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h2><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.PI						<span class="comment">// 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.random()				<span class="comment">// 返回介于0（包含） ~ 1（不包含） 之间的一个随机数</span></span><br><span class="line"><span class="built_in">Math</span>.floor()/<span class="built_in">Math</span>.ceil()	 <span class="comment">// 向下取整/向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.round()				<span class="comment">// 取整，四舍五入</span></span><br><span class="line"><span class="built_in">Math</span>.abs()					<span class="comment">// 绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max()/<span class="built_in">Math</span>.min()		 <span class="comment">// 求最大和最小值                                                                                                           </span></span><br><span class="line"><span class="built_in">Math</span>.sin()<span class="built_in">Math</span>.cos()		 <span class="comment">// 正弦/余弦</span></span><br><span class="line"><span class="built_in">Math</span>.power(基数，指数)/<span class="built_in">Math</span>.sqrt()	 <span class="comment">// 求指数次幂/求平方根</span></span><br></pre></td></tr></table></figure>

<h4 id="round"><a href="#round" class="headerlink" title="round"></a>round</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Math.ceil(Math.random()*10);     // 获取从 1 到 10 的随机整数，取 0 的概率极小。</span><br><span class="line"></span><br><span class="line">Math.round(Math.random());       // 可均衡获取 0 到 1 的随机整数。</span><br><span class="line"></span><br><span class="line">Math.floor(Math.random()*10);    // 可均衡获取 0 到 9 的随机整数。</span><br><span class="line"></span><br><span class="line">Math.round(Math.random()*10);    // 基本均衡获取 0 到 10 的随机整数，其中获取最小值 0 和最大值 10 的几率少一半。</span><br></pre></td></tr></table></figure>

<h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="comment">//Math.trunc方法用于去除一个数的小数部分，返回整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="comment">//对于非数值，Math.trunc内部使用Number方法将其先转为数值。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;123.456&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//对于空值和无法截取整数的值，返回NaN。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;9&#x27;</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign()  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p>方法用于计算一个数的立方根。对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h5 id="生成从minNum到maxNum的随机数"><a href="#生成从minNum到maxNum的随机数" class="headerlink" title="生成从minNum到maxNum的随机数"></a>生成从minNum到maxNum的随机数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//生成从minNum到maxNum的随机数</span><br><span class="line">function randomNum(minNum,maxNum)&#123; </span><br><span class="line">    switch(arguments.length)&#123; </span><br><span class="line">        case 1: </span><br><span class="line">            return parseInt(Math.random()*minNum+1,10); </span><br><span class="line">        break; </span><br><span class="line">        case 2: </span><br><span class="line">            return parseInt(Math.random()*(maxNum-minNum+1)+minNum,10); </span><br><span class="line">        break; </span><br><span class="line">            default: </span><br><span class="line">                return 0; </span><br><span class="line">            break; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><h4 id="new-Date-创建新的日期对象"><a href="#new-Date-创建新的日期对象" class="headerlink" title="**new Date()**创建新的日期对象"></a>**new Date()**创建新的日期对象</h4><ol>
<li><p>用整数初始化日期对象</p>
<p>new Date(yyyy,mth,dd,hh,mm,ss);<br>new Date(yyyy,mth,dd); </p>
<p>注意：</p>
<ul>
<li>您不能省略月份。如果只提供一个参数，则将其视为毫秒。</li>
<li>一位和两位数年份将被解释为 19xx 年：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yyyy:四位数表示的年份</span><br><span class="line">mth:用整数表示月份，从（１月）0到１１（１２月）</span><br><span class="line">dd:表示一个 月中的第几天，从1到31</span><br><span class="line">hh:小时数，从0（午夜）到23（晚11点）</span><br><span class="line">mm: 分钟数，从0到59的整数</span><br><span class="line">ss:秒数，从0到59的整数</span><br></pre></td></tr></table></figure></li>
<li><p>用字符串初始化日期对象</p>
<p>new Date(“2017/06/06”); </p>
<p>new Date(“2017-08-08”); </p>
<p>new Date(“month dd,yyyy hh:mm:ss”);  </p>
<p>new Date(“month dd,yyyy”);</p>
</li>
<li><p>用毫秒时间戳初始化日期对象</p>
<p>new Date(ms);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">JavaScript 将日期存储为自 1970 年 1 月 1 日 00:00:00 UTC（协调世界时）以来的毫秒数。</span><br><span class="line">零时间是 1970 年 1 月 1 日 00:00:00 UTC。</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="获取日期方法"><a href="#获取日期方法" class="headerlink" title="获取日期方法"></a>获取日期方法</h4><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getDate()</td>
<td align="left">以数值返回天（1-31）</td>
</tr>
<tr>
<td align="left">getDay()</td>
<td align="left">以数值获取周名（0-6）</td>
</tr>
<tr>
<td align="left">getFullYear()</td>
<td align="left">获取四位的年（yyyy）</td>
</tr>
<tr>
<td align="left">getHours()</td>
<td align="left">获取小时（0-23）</td>
</tr>
<tr>
<td align="left">getMilliseconds()</td>
<td align="left">获取毫秒（0-999）</td>
</tr>
<tr>
<td align="left">getMinutes()</td>
<td align="left">获取分（0-59）</td>
</tr>
<tr>
<td align="left">getMonth()</td>
<td align="left">获取月（0-11）</td>
</tr>
<tr>
<td align="left">getSeconds()</td>
<td align="left">获取秒（0-59）</td>
</tr>
<tr>
<td align="left">getTime()</td>
<td align="left">获取时间（从 1970 年 1 月 1 日至今）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">date.getFullYear()//获取完整的年份(4位,1970-????)</span><br><span class="line">date.getMonth() //获取当前月份(0-11,0代表1月)</span><br><span class="line">date.getDate()//获取几号   - 0 - 31 比如25</span><br><span class="line">date.getDay()//获取星期几 - 比如星期3的3</span><br><span class="line">date.getHours()//获取小时</span><br><span class="line">date.getTime()// 获取相对于1970-01-01的毫秒值</span><br></pre></td></tr></table></figure>

<h4 id="日期设置方法"><a href="#日期设置方法" class="headerlink" title="日期设置方法"></a>日期设置方法</h4><p>设置方法用于设置日期的某个部分。下面是最常用的方法（按照字母顺序排序）：</p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">setDate()</td>
<td align="left">以数值（1-31）设置日</td>
</tr>
<tr>
<td align="left">setFullYear()</td>
<td align="left">设置年（可选月和日）</td>
</tr>
<tr>
<td align="left">setHours()</td>
<td align="left">设置小时（0-23）</td>
</tr>
<tr>
<td align="left">setMilliseconds()</td>
<td align="left">设置毫秒（0-999）</td>
</tr>
<tr>
<td align="left">setMinutes()</td>
<td align="left">设置分（0-59）</td>
</tr>
<tr>
<td align="left">setMonth()</td>
<td align="left">设置月（0-11）</td>
</tr>
<tr>
<td align="left">setSeconds()</td>
<td align="left">设置秒（0-59）</td>
</tr>
<tr>
<td align="left">setTime()</td>
<td align="left">设置时间（从 1970 年 1 月 1 日至今的毫秒数）</td>
</tr>
</tbody></table>
<h4 id="时间戳转化为日期的方式"><a href="#时间戳转化为日期的方式" class="headerlink" title="时间戳转化为日期的方式"></a><strong>时间戳转化为日期的方式</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Mon May 28 2018</span><br><span class="line">console.log(newDate.toDateString());</span><br><span class="line"> </span><br><span class="line">// Mon, 28 May 2018 15:24:12 GMT</span><br><span class="line">console.log(newDate.toGMTString());</span><br><span class="line"> </span><br><span class="line">// 2018-05-28T15:24:12.000Z</span><br><span class="line">console.log(newDate.toISOString());</span><br><span class="line"> </span><br><span class="line">// 2018-05-28T15:24:12.000Z</span><br><span class="line">console.log(newDate.toJSON());</span><br><span class="line"></span><br><span class="line">// 2018/5/28</span><br><span class="line">console.log(newDate.toLocaleDateString());</span><br><span class="line"> </span><br><span class="line">// 2018/5/28 下午11:24:12</span><br><span class="line">console.log(newDate.toLocaleString());</span><br><span class="line"> </span><br><span class="line">// 下午11:24:12</span><br><span class="line">console.log(newDate.toLocaleTimeString());</span><br><span class="line"> </span><br><span class="line">// Mon May 28 2018 23:24:12 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(newDate.toString());</span><br><span class="line"> </span><br><span class="line">// 23:24:12 GMT+0800 (中国标准时间)</span><br><span class="line">console.log(newDate.toTimeString());</span><br><span class="line"> </span><br><span class="line">// Mon, 28 May 2018 15:24:12 GMT</span><br><span class="line">console.log(newDate.toUTCString());</span><br></pre></td></tr></table></figure>

<h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.console);<span class="comment">//打印信息</span></span><br><span class="line"><span class="built_in">console</span>.error(<span class="string">&#x27;报错信息&#x27;</span>);<span class="comment">//打印报错，但是不会影响代码继续执行</span></span><br><span class="line"><span class="built_in">console</span>.warn(<span class="string">&#x27;警告信息&#x27;</span>);<span class="comment">//警告信息</span></span><br><span class="line"><span class="keyword">let</span> isDebug = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.assert(isDebug, <span class="string">&#x27;打印报错信息&#x27;</span>)<span class="comment">//断言，判断当条件为false，会打印错误信息（不影响代码继续执行）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Myfn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.count(<span class="string">&#x27;My被执行的次数：&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line">Myfn()</span><br><span class="line">Myfn()</span><br><span class="line">Myfn()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10000</span>)</span><br><span class="line"><span class="keyword">let</span> obj;</span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="number">10000</span>; index++) &#123;</span><br><span class="line">  obj1[<span class="string">`obj_<span class="subst">$&#123;index&#125;</span>`</span>] = index</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 启动计时器</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;testForEach&#x27;</span>);</span><br><span class="line"><span class="comment">// (写一些测试用代码)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (index === <span class="number">9999</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(index);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 停止计时，输出时间</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;testForEach&#x27;</span>);</span><br><span class="line"><span class="comment">// 启动计时器</span></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;testForEach&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1[<span class="string">&#x27;obj_9999&#x27;</span>]);</span><br><span class="line"><span class="comment">// 停止计时，输出时间</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;testForEach&#x27;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">&#x27;for&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100000</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; array.length; index++) &#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">&#x27;for&#x27;</span>);<span class="comment">//循环执行需要多少时间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list = [&#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span> &#125;, &#123; <span class="attr">name</span>: <span class="string">&#x27;王美丽&#x27;</span>, <span class="attr">age</span>: <span class="number">19</span>, <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span> &#125;, &#123;&#125;]<span class="comment">//这里不知道为什么我的浏览器不显示最后一个，所以我就在数组后面加了一个空对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(list);<span class="comment">//让数组和对象数据更加直观的可以看到</span></span><br></pre></td></tr></table></figure>

<h3 id="defer和async"><a href="#defer和async" class="headerlink" title="defer和async"></a>defer和async</h3><p>页面的加载和渲染过程：</p>
<ol>
<li>浏览器通过HTTP协议请求服务器，获取HMTL文档并开始从上到下解析，构建DOM树；</li>
<li>在构建DOM过程中，如果遇到外联的样式声明和脚本声明，则暂停文档解析，创建新的网络连接，并开始下载样式文件和脚本文件；</li>
<li>样式文件下载完成后，构建样式表；脚本文件下载完成后，解释并执行，然后继续解析文档构建DOM</li>
<li>完成文档解析后，将DOM树和样式表进行关联和映射，最后将视图渲染到浏览器窗口</li>
</ol>
<blockquote>
<p>defer和async只对外部脚本有效（引入的js文件）</p>
</blockquote>
<ul>
<li><code>defer</code>script异步加载，html解析完,DomCOntentLoaded之前执行</li>
<li><code>async</code>script加载完后会立即执行,执行的过程仍会阻塞后续html的解析</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1237064/201902/1237064-20190225103106193-1835436522.jpg" alt="img"></p>
<ul>
<li>蓝色线代表网络读取，</li>
<li>红色线代表js执行时间</li>
<li>绿色线代表 HTML 解析。</li>
</ul>
<ol>
<li>通常情况下defer的使用频率较高,它能保证script之间的变量依赖。</li>
<li>需要注意的是:async script的资源请求时异步的,但script的执行仍然会阻塞后续渲染(单线程),defer是在html渲染完之后执行的所以不会阻塞后续html的解析。</li>
</ol>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>function</td>
<td>必需。要调用的函数后要执行的 JavaScript 代码串。</td>
</tr>
<tr>
<td>millisec</td>
<td>可选。执行或调用 code/function 需要等待的时间，以毫秒计。默认为 0。</td>
</tr>
<tr>
<td>param1, param2, …</td>
<td>可选。 传给执行函数的其他参数（IE9 及其更早版本不支持该参数）</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function show(x, y, z) &#123;</span><br><span class="line">  console.log(x, y, z)</span><br><span class="line">&#125;</span><br><span class="line">//第三个及以后的参数都可以作为show函数的参数</span><br><span class="line">setTimeout(show, 100, 1, 2, 3)</span><br></pre></td></tr></table></figure>

<p><strong>实例</strong></p>
<p>看以下例子可以知道，代码运行为6次打印了6。因为setTimeout因为是一个异步函数，var变量存在变量提升、无块级作用域等，等执行到setTimeout时，for循环已经遍历结束，i的值已经是6。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">//6,6,6,6,6,6</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法</p>
<p>1、闭包；使用闭包将i的值驻留在内存中，打印j的值（形成了自己的作用域），实际的外部函数的变量i</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)<span class="comment">// 0,1,2,3,4,5</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、setTimeout的第三个参数，该参数就是给setTimeout第一个函数的参数。每次传入setTimeout第一个函数的j值是for遍历的值，个人认为还是作用域的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function">(<span class="params">j</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)<span class="comment">// 0,1,2,3,4,5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MutationObserver"><a href="#MutationObserver" class="headerlink" title="MutationObserver"></a>MutationObserver</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver">https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver/MutationObserver</a></p>
<p>当父元素中的元素有删减，会调用该函数。</p>
<p>eg：点击按钮，table中添加tr，调用该函数，可以为tr中的input设置disabled</p>
<p>tip: 添加合理的判断条件，否则会执行死循环</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><strong>JS的基本数据类型和引用数据类型</strong></p>
<ul>
<li>基本数据类型：<code>undefined</code>、<code>null</code>、<code>boolean</code>、<code>number</code>、<code>string</code>、<code>symbol</code></li>
<li>引用数据类型：<code>object</code>、<code>array</code>、<code>function</code></li>
</ul>
<h3 id="number"><a href="#number" class="headerlink" title="number"></a>number</h3><h4 id="数值判断转换"><a href="#数值判断转换" class="headerlink" title="数值判断转换"></a><strong>数值判断转换</strong></h4><ul>
<li><p>NaN：not a number 该属性用于指示某个值不是数字。 </p>
<ul>
<li>NaN 与任何值都不相等，包括他本身</li>
</ul>
</li>
<li><p>isNaN: is not a number判断是否是数字，若是数字返回false</p>
</li>
<li><p>isFinite(number ) 函数用于检查其参数是否是无穷大。</p>
<p><strong>提示：</strong> 如果 number 是 NaN（非数字），或者是正、负无穷大的数，则返回 false。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined表示一个声明了没有初始化的变量，变量只声明的时候值默认是undefined</span><br><span class="line">null表示一个空，变量的值如果想为null，必须手动设置</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔类型的隐式转换：转换为true   非空字符串  非0数字  true 任何对象</span><br><span class="line">				转换成false  空字符串  0  false  null  undefined</span><br></pre></td></tr></table></figure>

<p>转换成字符串类型：</p>
<ul>
<li>toString() String() 拼接字符串方式</li>
</ul>
<p><strong>转换成数值类型：</strong></p>
<ul>
<li><p>1.Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN </p>
</li>
<li><p>2.parseInt() </p>
</li>
<li><p>3.parseFloat()</p>
</li>
</ul>
<h4 id="实战-1"><a href="#实战-1" class="headerlink" title="实战"></a>实战</h4><h5 id="判断字符串或者数字是否是正整数"><a href="#判断字符串或者数字是否是正整数" class="headerlink" title="判断字符串或者数字是否是正整数"></a>判断字符串或者数字是否是正整数</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isInteger = (s) =&gt; &#123;</span><br><span class="line">    var re = /^[0-9]+$/;</span><br><span class="line">    return re.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断字符串或者数字是否是小数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const isDecimal = (s) =&gt; &#123;</span><br><span class="line">	var re1 = /^[0-9]+$/;</span><br><span class="line">	var re2 = /^[0-9]+\.?[0-9]+?$/;</span><br><span class="line">    return !re.test(s) &amp;&amp; re2.test(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>不会改变原来的字符串</strong></p>
<h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt"></a>charAt</h4><p>charAt(index)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取指定位置处字符 myString.charAt(1)</span><br></pre></td></tr></table></figure>

<p>charCodeAt()      //获取指定位置处字符的ASCII码</p>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h4><p>indexOf(‘’,[index] )       </p>
<p>返回指定内容在元字符串中的位置，只找第一个匹配的，若没有则返回-1</p>
<p>indexOf(‘a’,2);从位置2开始找到a的位置<br>lastIndexOf()     //从后往前找，只找第一个匹配的</p>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf"></a>lastIndexOf</h4><p>lastIndexOf(‘’)</p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>拼接字符串，等效于+，+更常用</p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>提取字符串的一部分，并返回新的字符串</p>
<p>str.slice(start, end) </p>
<p>end 参数可选，start可取正值，也可取负值。</p>
<p>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）<br>取负值时表示从索引为 length+start 位置截取到end所在位置的字符</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ar str = &quot;It is our choices that show what we truly are, far more than our abilities.&quot;;</span><br><span class="line">console.log(str.slice(0,-30)); // It is our choices that show what we truly are</span><br><span class="line">console.log(str.slice(-30)); // , far more than our abilities.</span><br></pre></td></tr></table></figure>

<h4 id="substring"><a href="#substring" class="headerlink" title="substring"></a>substring</h4><p>str.slice(start, end)<br>取正值时表示从索引为start的位置截取到end的位置(不包括end所在位置的字符，如果end省略则截取到字符串末尾）<br>取负值时表示从索引为 length+start 位置截取到end所在位置的字符</p>
<h4 id="substr"><a href="#substr" class="headerlink" title="substr"></a>substr</h4><p>返回字符串指定位置开始的指定数量的字符。</p>
<p>substr(fromIndex,length)           </p>
<p>start 表示开始截取字符的位置，可取正值或负值。取正值时表示start位置的索引，取负值时表示 length+start位置的索引。</p>
<p>length 表示截取的字符长度。</p>
<h4 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h4><p>trim()去除空白<br>只能去除字符串前后的空白，字符之间的空格不能去掉</p>
<h4 id="toLocaleUpperCase"><a href="#toLocaleUpperCase" class="headerlink" title="toLocaleUpperCase"></a><strong>toLocaleUpperCase</strong></h4><p>toLocaleLowerCase() 方法返回调用该方法的字符串被转换成小写的值，转换规则根据本地化的大小写映射toLocaleUpperCase() 方法则是转换成大写的值。</p>
<p>语法：<em>str.toLocaleLowerCase()</em>, <em>str.toLocaleUpperCase()</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;ABCDEFG&#x27;.toLocaleLowerCase()); // abcdefg</span><br><span class="line">console.log(&#x27;abcdefg&#x27;.toLocaleUpperCase()); // ABCDEFG</span><br></pre></td></tr></table></figure>

<h4 id="split"><a href="#split" class="headerlink" title="split"></a>split</h4><p>split()字符转换为数组 split()还可以结合正则表达式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str=<span class="string">&#x27;a,b,c,d&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> arr=str.split(<span class="string">&#x27;,&#x27;</span>);<span class="comment">//以逗号为分割成数组</span></span><br><span class="line">arr.join(<span class="string">&#x27;&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="includes-ES6"><a href="#includes-ES6" class="headerlink" title="includes(ES6)"></a>includes(ES6)</h4><p>includes() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它用来判断一个字符串是否属于另一个字符。如果是，则返回true，否则返回false。</p>
<p>语法：<em>str.includes(subString [, position])</em></p>
<p>subString 表示要搜索的字符串，position 表示从当前字符串的哪个位置开始搜索字符串，默认值为0。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Practice makes perfect.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&quot;perfect&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">&quot;perfect&quot;</span>,<span class="number">100</span>)); </span><br></pre></td></tr></table></figure>

<h4 id="endsWith-ES6"><a href="#endsWith-ES6" class="headerlink" title="endsWith(ES6)"></a>endsWith(ES6)</h4><p>endsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它基本与 contains() 功能相同，不同的是，它用来判断一个字符串是否是原字符串的结尾。若是则返回true，否则返回false。</p>
<p>语法：<em>str.endsWith(substring [, position])</em></p>
<p>与contains 方法不同，position 参数的默认值为字符串长度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;Learn and live.&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;live.&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">&quot;Learn&quot;</span>,<span class="number">5</span>)); </span><br></pre></td></tr></table></figure>

<p>startsWith() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，它用来判断当前字符串是否是以给定字符串开始的，若是则返回true，否则返回false。</p>
<p>语法：<em>str.startsWith(subString [, position])</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &quot;Where there is a will, there is a way.&quot;;</span><br><span class="line">console.log(str.startsWith(&quot;Where&quot;)); // true</span><br><span class="line">console.log(str.startsWith(&quot;there&quot;,6)); </span><br></pre></td></tr></table></figure>

<h4 id="实战-2"><a href="#实战-2" class="headerlink" title="实战"></a>实战</h4><h5 id="找到第一个不重复的字符，并返回它的索引"><a href="#找到第一个不重复的字符，并返回它的索引" class="headerlink" title="找到第一个不重复的字符，并返回它的索引"></a>找到第一个不重复的字符，并返回它的索引</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> firstUniqChar = <span class="function">(<span class="params">s</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> position = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span> (position.has(i)) &#123;</span><br><span class="line">      position.set(i, position.get(i) + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      position.set(i, <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;  </span><br><span class="line">    <span class="keyword">if</span> (position.get(s[i]) === <span class="number">1</span>) </span><br><span class="line">      <span class="keyword">return</span> i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//s = &quot;leetcode&quot;</span></span><br><span class="line">返回 <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//s = &quot;loveleetcode&quot;</span></span><br><span class="line">返回 <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="会改变原来数组的有："><a href="#会改变原来数组的有：" class="headerlink" title="会改变原来数组的有："></a>会改变原来数组的有：</h4><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><p>删除数组的最后一个元素并返回删除的元素。</p>
<h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><p>向数组的末尾添加一个或更多元素，并返回新的长度。</p>
<h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><p>删除并返回数组的第一个元素。</p>
<h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><p>向数组的开头添加一个或更多元素，并返回新的长度。reverse()—反转数组的元素顺序。</p>
<h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p>翻转数组</p>
<h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><p><em>arr.sort([comparefn])</em></p>
<ul>
<li><p>comparefn是可选的，如果省略，数组元素将按照各自转换为字符串的Unicode(万国码)位点顺序排序</p>
</li>
<li><p>如果指明了comparefn，数组将按照调用该函数的返回值来排序。若 a 和 b 是两个将要比较的元素：</p>
<ul>
<li>若 comparefn(a, b) &lt; 0，那么a 将排到 b 前面；</li>
<li>若 comparefn(a, b) = 0，那么a 和 b 相对位置不变；</li>
<li>若 comparefn(a, b) &gt; 0，那么a , b 将调换位置；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//即使是数组sort也是根据字符，从小到大排序</span></span><br><span class="line"><span class="comment">//采用冒泡排序</span></span><br><span class="line">sort(<span class="function"><span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line"><span class="comment">// 升序</span></span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line"><span class="comment">// 倒序</span></span><br><span class="line"><span class="keyword">return</span> b - a;</span><br><span class="line">&#125;)</span><br><span class="line">fn（a,b）&#123;<span class="keyword">return</span> <span class="xml">&lt;0||&gt;0&#125;,返回小于0升序，大于0降序。</span></span><br><span class="line"><span class="xml"></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">0</span>].sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a,b)</span><br><span class="line">    <span class="keyword">return</span> a-b</span><br><span class="line">&#125;)</span><br><span class="line">:<span class="number">3</span> <span class="number">2</span></span><br><span class="line">:<span class="number">1</span> <span class="number">3</span> </span><br><span class="line">:<span class="number">1</span> <span class="number">3</span> </span><br><span class="line">:<span class="number">1</span> <span class="number">2</span> </span><br><span class="line">:<span class="number">0</span> <span class="number">2</span></span><br><span class="line">:<span class="number">0</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><strong>sort()方法的比较逻辑为：</strong><br>前一半的数组进行比较，并排好序，后一半数组再与前面排序好的数组的中间一个值比较（二分法，判断是与前面还是后面的数组比较，更快），并排序</p>
<h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">array.splice(index, howmany, item1, ....., itemX)</span><br></pre></td></tr></table></figure>

<p>参数值</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>index</em></td>
<td align="left">必需。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。</td>
</tr>
<tr>
<td align="left"><em>howmany</em></td>
<td align="left">可选。要删除的项目数。如果设置为 0，则不会删除任何项目。</td>
</tr>
<tr>
<td align="left"><em>item1, …, itemX</em></td>
<td align="left">可选。要添加到数组中的新项目。</td>
</tr>
</tbody></table>
<p>arr.splice(start,deleteCount[, item1[, item2[, …]]])</p>
<p><strong>删除</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;apple&quot;</span>,<span class="string">&quot;boy&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> splices = array.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&quot;apple&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(splices); <span class="comment">// [&quot;boy&quot;] ,可见是从数组下标为1的元素开始删除,并且删除一个元素,由于itemN缺省,故此时该方法只删除元素</span></span><br></pre></td></tr></table></figure>

<p><strong>插入</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;four&quot;</span>];</span><br><span class="line">array.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&quot;three&quot;</span>); <span class="comment">// </span></span><br><span class="line">array; <span class="comment">//[&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.insert = <span class="function"><span class="keyword">function</span> (<span class="params">index, item</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">this</span>.splice(index, <span class="number">0</span>, item);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> nums = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;four&quot;</span>];</span><br><span class="line">nums.insert(<span class="number">2</span>, <span class="string">&#x27;three&#x27;</span>); <span class="comment">// 注意数组索引, [0,1,2..]</span></span><br><span class="line">array <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;]</span></span><br></pre></td></tr></table></figure>

<h4 id="不会改变原来数组的有："><a href="#不会改变原来数组的有：" class="headerlink" title="不会改变原来数组的有："></a>不会改变原来数组的有：</h4><h5 id="indexOf和lastIndexOf"><a href="#indexOf和lastIndexOf" class="headerlink" title="indexOf和lastIndexOf"></a>indexOf和lastIndexOf</h5><p>indexOf(arr[i],[index] ) 从位置index查找arr[i]在数组中的位置，只找第一个匹配的，如果不存在，则返回-1。</p>
<h5 id="concat-1"><a href="#concat-1" class="headerlink" title="concat()"></a>concat()</h5><p>将传入的数组或者元素与原数组合并，组成一个新的数组并返回。</p>
<p>语法：<em><strong>arr.concat(value1, value2, …, valueN)</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [1, 2, 3];</span><br><span class="line">var array2 = array.concat(4,[5,6],[7,8,9]);</span><br><span class="line">console.log(array2); // [1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br><span class="line">console.log(array); // [1, 2, 3], 可见原数组并未被修改</span><br></pre></td></tr></table></figure>

<p>若concat方法中不传入参数，那么将基于原数组<strong>浅复制</strong>生成一个一模一样的新数组（指向新的地址空间）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">a</span>: <span class="number">1</span>&#125;];</span><br><span class="line"><span class="keyword">var</span> array3 = array.concat();</span><br><span class="line"><span class="built_in">console</span>.log(array3); <span class="comment">// [&#123;a: 1&#125;]</span></span><br><span class="line"><span class="built_in">console</span>.log(array3 === array); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(array[<span class="number">0</span>] === array3[<span class="number">0</span>]); <span class="comment">// true，新旧数组第一个元素依旧共用一个同一个对象的引用</span></span><br></pre></td></tr></table></figure>

<h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p>将数组中的所有元素连接成一个字符串。</p>
<p>语法：<em>arr.join([separator = ‘,’])</em> separator可选，缺省默认为逗号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [&#x27;We&#x27;, &#x27;are&#x27;, &#x27;Chinese&#x27;];</span><br><span class="line">console.log(array.join()); // &quot;We,are,Chinese&quot;</span><br><span class="line">console.log(array.join(&#x27;+&#x27;)); // &quot;We+are+Chinese&quot;</span><br><span class="line">console.log(array.join(&#x27;&#x27;)); // &quot;WeareChinese&quot;</span><br></pre></td></tr></table></figure>

<h5 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h5><p>将数组中一部分元素浅复制存入新的数组对象，并且返回这个数组对象。</p>
<p>语法：<em>arr.slice([start[, end]])</em></p>
<p>参数 start 指定复制开始位置的索引，end如果有值则表示复制结束位置的索引（不包括此位置）。</p>
<p>如果 start 的值为负数，假如数组长度为 length，则表示从 length+start 的位置开始复制，此时参数 end 如果有值，只能是比 start 大的负数，否则将返回空数组。</p>
<p>slice方法参数为空时，同concat方法一样，都是浅复制生成一个新数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>, <span class="string">&quot;five&quot;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(array.slice()); <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(array.slice(<span class="number">2</span>,<span class="number">3</span>)); <span class="comment">// [&quot;three&quot;]</span></span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;,&quot;four&quot;, &quot;five&quot;]</span></span><br></pre></td></tr></table></figure>

<p><strong>浅复制</strong> 是指当对象的被复制时，只是复制了对象的引用，指向的依然是同一个对象。下面来说明slice为什么是浅复制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123;<span class="attr">color</span>:<span class="string">&quot;yellow&quot;</span>&#125;, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> array2 = array.slice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array2); <span class="comment">// [&#123;color:&quot;yellow&quot;&#125;]</span></span><br><span class="line">array[<span class="number">0</span>][<span class="string">&quot;color&quot;</span>] = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(array2); <span class="comment">// [&#123;color:&quot;bule&quot;&#125;]</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>由于slice是浅复制，复制到的对象只是一个引用，改变原数组array的值，array2也随之改变。</p>
<h5 id="toString和toLocaleString"><a href="#toString和toLocaleString" class="headerlink" title="toString和toLocaleString"></a>toString和toLocaleString</h5><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><h5 id="from"><a href="#from" class="headerlink" title="from"></a>from</h5><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（<strong>iterable</strong>）的对象（包括ES6新增的数据结构Set和Map）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>
<p>只要是部署了<strong>Iterator</strong>接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c</span><br><span class="line">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span><br><span class="line"></span><br><span class="line">let namesSet = new Set([&#x27;a&#x27;, &#x27;b&#x27;])</span><br><span class="line">Array.from(namesSet) // [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></pre></td></tr></table></figure>

<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<p>下面的例子是取出一组DOM节点的文本内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span.name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent)</span><br></pre></td></tr></table></figure>

<h5 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h5><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="comment">//参数个数只有一个时，实际上是指定数组的长度。</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h5><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h5 id="find和findIndex"><a href="#find和findIndex" class="headerlink" title="find和findIndex"></a>find和findIndex</h5><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出<strong>第一个</strong>返回值为<code>true</code>的成员，然后<strong>返回该成员</strong>。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p>上面代码找出数组中第一个小于0的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，<strong>返回第一个符合条件的数组成员的位置</strong>，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>
<h5 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h5><p><code>fill</code>方法使用给定值，填充一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。</p>
<h5 id="entries和keys和values"><a href="#entries和keys和values" class="headerlink" title="entries和keys和values"></a>entries和keys和values</h5><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, &#x27;a&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但Babel转码器已经支持。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;a:1&#125;,2,3,&#123;b:2&#125;].includes(&#123;a:1&#125;)//false</span><br></pre></td></tr></table></figure>

<h5 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h5><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">&#x27;#&#x27;</span>) <span class="comment">// &quot;#a##&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// &quot;,a,,&quot;</span></span><br></pre></td></tr></table></figure>

<p>ES6则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure>

<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,&quot;a&quot;,,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>for...of</code>循环也会遍历空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].entries()] <span class="comment">// [[0,undefined], [1,&quot;a&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].values()] <span class="comment">// [undefined,&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h4 id="实战-3"><a href="#实战-3" class="headerlink" title="实战"></a>实战</h4><h5 id="根据数组长度创建一个一样长度的数组并初始化值为0"><a href="#根据数组长度创建一个一样长度的数组并初始化值为0" class="headerlink" title="根据数组长度创建一个一样长度的数组并初始化值为0"></a>根据数组长度创建一个一样长度的数组并初始化值为0</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = new Array(5).fill(0)</span><br></pre></td></tr></table></figure>

<h5 id="选择一个随机值"><a href="#选择一个随机值" class="headerlink" title="选择一个随机值"></a>选择一个随机值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const random = (arr) =&gt; arr[Math.floor(Math.random() * arr.length)]</span><br><span class="line">random([1, 2, 3, 4, 5, 6])</span><br></pre></td></tr></table></figure>

<h5 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h5><p><a href="https://zhuanlan.zhihu.com/p/90017508">https://zhuanlan.zhihu.com/p/90017508</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeDuplicate</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>]))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  indexOf：从左往右查找目标字符串，是否包含 Value;</span></span><br><span class="line"><span class="comment">           如果包含，返回第一次出现的索引;</span></span><br><span class="line"><span class="comment">           如果不包含，返回 -1</span></span><br><span class="line"><span class="comment">  indexOf 和 lastIndexOf() 方法一样</span></span><br><span class="line"><span class="comment">  步骤：</span></span><br><span class="line"><span class="comment">  1. 先声明一个空数组，用来存放去重后的数据</span></span><br><span class="line"><span class="comment">  2. 遍历数组，判断每一项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> indexArr = [];</span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">if</span>(indexArr.indexOf(item)===-<span class="number">1</span>)&#123;</span><br><span class="line">      indexArr.push(item);</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(indexArr); <span class="comment">// [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;,&#x27;four&#x27;];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> el = arr.filter(<span class="function">(<span class="params">item,index</span>)=&gt;</span>arr.indexOf(item)===index);</span><br><span class="line"><span class="built_in">console</span>.log(el); <span class="comment">// [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;,&#x27;four&#x27;];</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">   1. 和上面方法一致，只不过是使用了 forEach</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;one&#x27;</span>,<span class="string">&#x27;three&#x27;</span>,<span class="string">&#x27;two&#x27;</span>,<span class="string">&#x27;four&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index,arr</span>)</span>&#123;</span><br><span class="line">    obj[arr[index]] = arr[index];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> el =  <span class="built_in">Object</span>.keys(obj);</span><br><span class="line"><span class="built_in">console</span>.log(el) <span class="comment">// [&#x27;one&#x27;,&#x27;two&#x27;,&#x27;three&#x27;,&#x27;four&#x27;];</span></span><br></pre></td></tr></table></figure>

<h5 id="数组中最大元素的下标"><a href="#数组中最大元素的下标" class="headerlink" title="数组中最大元素的下标"></a>数组中最大元素的下标</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxValIndex</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> max=<span class="built_in">Math</span>.max(...arr);</span><br><span class="line">  <span class="keyword">var</span> index = arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item).indexOf(max);</span><br><span class="line">  <span class="keyword">return</span> index</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="找出数组中出现最多的元素和次数"><a href="#找出数组中出现最多的元素和次数" class="headerlink" title="找出数组中出现最多的元素和次数"></a>找出数组中出现最多的元素和次数</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMost</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> maxName, maxNum = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      res[item] ? res[item] += <span class="number">1</span> : res[item] = <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 遍历 res</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> r <span class="keyword">in</span> res) &#123;</span><br><span class="line">      <span class="keyword">if</span> (res[r] &gt; maxNum) &#123;</span><br><span class="line">        maxNum = res[r]</span><br><span class="line">        maxName = r</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;出现次数最多的元素为:&#x27;</span> + maxName + <span class="string">&#x27;, 出现次数为:&#x27;</span> + maxNum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMost</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> maxName, maxNum = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 遍历数组</span></span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    res[item] ? res[item] += <span class="number">1</span> : res[item] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (res[item] &gt; maxNum) &#123;</span><br><span class="line">      maxName = item</span><br><span class="line">      maxNum = res[item]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;出现次数最多的元素为:&#x27;</span> + maxName + <span class="string">&#x27;, 出现次数为:&#x27;</span> + maxNum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMost</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!arr.length) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> maxName, maxNum = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> res = arr.reduce(<span class="function">(<span class="params">res, currentNum</span>) =&gt;</span> &#123;</span><br><span class="line">    res[currentNum] ? res[currentNum] += <span class="number">1</span> : res[currentNum] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> (res[currentNum] &gt; maxNum) &#123;</span><br><span class="line">      maxNum = res[currentNum]</span><br><span class="line">      maxName = currentNum</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">  &#125;, &#123;&#125;)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;出现次数最多的元素为:&#x27;</span> + maxName + <span class="string">&#x27;, 出现次数为:&#x27;</span> + maxNum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> str = <span class="string">&#x27;jshdjsihh&#x27;</span>;</span><br><span class="line">     <span class="keyword">const</span> obj = str.split(<span class="string">&#x27;&#x27;</span>).reduce(<span class="function">(<span class="params">pre,item</span>) =&gt;</span> &#123;</span><br><span class="line">         pre[item] ? pre[item] ++ : pre[item] = <span class="number">1</span></span><br><span class="line">         <span class="keyword">return</span> pre</span><br><span class="line">     &#125;,&#123;&#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(obj) <span class="comment">// &#123;j: 2, s: 2, h: 3, d: 1, i: 1&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h5><h6 id="数组对象去重"><a href="#数组对象去重" class="headerlink" title="数组对象去重"></a>数组对象去重</h6><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tempArr1 = tempArr1.filter(<span class="function">(<span class="params">item,index</span>) =&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> tempArr1.findIndex(<span class="function"><span class="params">item1</span> =&gt;</span>item1.id==item.id) == index</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="判断两个数组对象是否相等"><a href="#判断两个数组对象是否相等" class="headerlink" title="判断两个数组对象是否相等"></a>判断两个数组对象是否相等</h6><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p><strong>迭代方法 不会修改原数组</strong></p>
<p>every()、filter()、forEach()、map()、some()</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>指定数组的每项元素都执行一次传入的函数，返回值为undefined。</p>
<p>语法：<strong>arr.forEach(fn, thisArg)</strong></p>
<p>fn 表示在数组每一项上执行的函数，接受三个参数：</p>
<ul>
<li>value 当前正在被处理的元素的值</li>
<li>index 当前元素的数组索引</li>
<li>array 数组本身</li>
</ul>
<p>thisArg 可选，用来当做fn函数内的this对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;cc&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> sReturn = array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, array</span>)</span>&#123;</span><br><span class="line">  array[index] = value * value;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// cc被打印了三次</span></span><br><span class="line">&#125;,obj);</span><br><span class="line"><span class="built_in">console</span>.log(array); <span class="comment">// [1, 9, 25], 可见原数组改变了</span></span><br><span class="line"><span class="built_in">console</span>.log(sReturn); <span class="comment">// undefined, 可见返回值为undefined</span></span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>使用传入函数处理每个元素，并返回函数的返回值组成的新数组。</p>
<p>语法：<strong>arr.map(fn, thisArg)</strong></p>
<p>参数介绍同 forEach 方法的参数介绍。</p>
<h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p>数组的每一项执行的函数都满足条件就返回true</p>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>对数组的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line">list.some(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">  <span class="keyword">if</span>(item===<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">输出结果为<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>es6中的some也可实现此功能。some循环中只要有一个符合条件则会跳出循环体</p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>执行函数过滤掉不符和条件的数组元素，返回复合条件的数组元素</p>
<p>语法：<strong>arr.filter(fn, thisArg)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [18, 9, 10, 35, 80];</span><br><span class="line">var array2 = array.filter(function(value, index, array)&#123;</span><br><span class="line">  return value &gt; 20;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(array2); // [35, 80]</span><br></pre></td></tr></table></figure>

<p><code>0</code>，<code>undefined</code>，<code>null</code>，<code>false</code>，<code>&quot;&quot;</code>，<code>&#39;&#39;</code>可以很容易地通过以下方法省略</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">&#x27;&#x27;</span>, <span class="literal">false</span>];</span><br><span class="line">array.filter(<span class="built_in">Boolean</span>);</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">(<span class="number">3</span>) [<span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure>

<p>删除重复值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const array  = [5,4,7,8,9,2,7,5];</span><br><span class="line">array.filter((item,idx,arr) =&gt; arr.indexOf(item) === idx);</span><br></pre></td></tr></table></figure>

<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>reduce() 方法接收一个方法作为累加器，数组中的每个值(从左至右) 开始合并，最终为一个值。</p>
<p>语法：<strong>array.reduce(function(total, currentValue, currentIndex, arr), initialValue)</strong></p>
<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>initialValue</em></td>
<td align="left">可选。<strong>传递给函数的初始值</strong></td>
</tr>
<tr>
<td align="left"><em>function(total,currentValue, index,arr)</em></td>
<td align="left">必需。用于执行每个数组元素的函数。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><em>total(累计器)</em></td>
<td align="left">必需。<em>初始值</em>, 或者计算结束后的返回值。</td>
</tr>
<tr>
<td align="left"><em>currentValue</em>(当前值)</td>
<td align="left">必需。当前元素</td>
</tr>
<tr>
<td align="left"><em>currentIndex(当前索引)</em></td>
<td align="left">可选。当前元素的索引</td>
</tr>
<tr>
<td align="left"><em>arr(源数组)</em></td>
<td align="left">可选。当前元素所属的数组对象。</td>
</tr>
</tbody></table>
<p><strong>代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123; <span class="comment">//不带初始值</span></span><br><span class="line">  <span class="keyword">return</span> acc + cur</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>].reduce(<span class="function">(<span class="params">acc, cur</span>) =&gt;</span> &#123; <span class="comment">//带初始值</span></span><br><span class="line">  <span class="keyword">return</span> acc + cur</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"><span class="comment">// 10 + 1 + 2 + 3 + 4</span></span><br><span class="line"><span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p> <strong>初始值 <code>initialValue</code> 可以是任意类型。如果没有提供 <code>initialValue</code>，<code>reduce</code> 会从索引 1 的地方开始执行 <code>callback</code> 方法，跳过第一个索引。如果提供 <code>initialValue</code>，从索引 0 开始</strong></p>
<h4 id="entries"><a href="#entries" class="headerlink" title="entries()"></a>entries()</h4><p>方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组迭代器对象，该对象包含数组中每个索引的键值对。</p>
<p>语法：<strong>arr.entries()</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;];</span><br><span class="line">var iterator = array.entries();</span><br><span class="line">console.log(iterator.next()); //&#123; value: [ 0, &#x27;a&#x27; ], done: false &#125; </span><br><span class="line">console.log(iterator.next().value); // [0, &quot;a&quot;]</span><br><span class="line">console.log(iterator.next().value); // [1, &quot;b&quot;]</span><br><span class="line">console.log(iterator.next().value); // [2, &quot;c&quot;]</span><br><span class="line">console.log(iterator.next().value); // undefined, 迭代器处于数组末尾时, 再迭代就会返回undefined</span><br></pre></td></tr></table></figure>

<h4 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h4><p>keys() 方法基于ECMAScript 2015（ES6）规范，返回一个数组索引的迭代器。（浏览器实际实现可能会有调整）</p>
<p>语法：<strong>arr.keys()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;xyz&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.keys();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 0, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: undefined, done: false&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="values"><a href="#values" class="headerlink" title="values()"></a>values()</h4><p>values() 方法基于<strong>ECMAScript 2015（ES6）规范</strong>，返回一个数组迭代器对象，该对象包含数组中每个索引的值。其用法基本与上述 entries 方法一致。</p>
<p>语法：<strong>arr.values()</strong></p>
<p>遗憾的是，现在没有浏览器实现了该方法，因此下面将就着看看吧。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;xyz&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> iterator = array.values();</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//abc</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next().value);<span class="comment">//xyz</span></span><br></pre></td></tr></table></figure>

<h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><p><strong>for…in循环</strong></p>
<p>精准的迭代，可以迭代对象的元素。也可以迭代数组。</p>
<p>【注意】使用<code>for ... in</code>，迭代的是元素（keys），对于数组来说，则为下标（0,1,2…,length-1）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(var key in arr) &#123;</span><br><span class="line">    //执行相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>for…of循环（ES6支持）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(let item of arr) &#123;</span><br><span class="line">    //执行相关操作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和<code>for...in</code>不同的是，<code>for...of</code>迭代出来的是值（value），对于数组来说，则是一个元素值。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h4><p><strong>for…in遍历</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">    <span class="attr">author</span>: <span class="string">&quot;ztyzz&quot;</span>,</span><br><span class="line">    <span class="attr">time</span>: <span class="string">&quot;2018.2.30&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> el <span class="keyword">in</span> book) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(book[el]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>for … of遍历</strong></p>
<p>此方法，<strong>不能遍历普通对象</strong>(因为能够被for…of正常遍历的，都需要实现一个遍历器Iterator。而数组、字符串、Set、Map结构，早就内置好了Iterator（迭代器），它们的原型中都有一个Symbol.iterator方法，而Object对象并没有实现这个接口（<strong>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。</strong>），使得它无法被for…of遍历。)，需要和<code>Object.keys()</code>搭配使用，先获取对象的所有key的数组 然后遍历：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var book = &#123;</span><br><span class="line">    name: &quot;hello&quot;,</span><br><span class="line">    id: &quot;2&quot;,</span><br><span class="line">    author: &quot;ztyzz&quot;,</span><br><span class="line">    time: &quot;2018.2.30&quot;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">for(var key of Object.keys(book)) &#123;</span><br><span class="line">    console.log(book[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【注意】<code>Object.values()</code>返回对象所有的键值组成的数组，但是由于无法获取到key值，功能会比较残缺。</p>
<p>同时，由于<code>Object.keys()</code>返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性).所以我们可以使用forEach()等上面的方法，来进行数组的遍历，再通过对象的访问来进行值的访问。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = People.bind(p1)</span><br><span class="line">Foo(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1);</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">&#x27;boo&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(foo.name);</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br></pre></td></tr></table></figure>

<h2 id="数据转化"><a href="#数据转化" class="headerlink" title="数据转化"></a>数据转化</h2><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><h6 id="不全等"><a href="#不全等" class="headerlink" title="不全等"></a>不全等</h6><p>null,NaN,undefined,0-0,+0,true,false</p>
<p><strong>基本数据类型有隐式转换</strong></p>
<ul>
<li><p>字符串与数字比较 （等号两侧转化为数字，再比较）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  　　100 == &quot;100&quot;　　==&gt;　　100 == 100　　//　true</span><br><span class="line">  　　100 == &quot;99&quot;　　==&gt;　　100 == 99　　//　false</span><br><span class="line">  　　100 == &quot;abc&quot;　　==&gt;　　100 == NaN　　//　false</span><br><span class="line">  　　1 == &quot;abc&quot;　　==&gt;　　1 == NaN　　//　false</span><br><span class="line">  　　1 == &quot;&quot;　　==&gt;　　1 == 0　　//　false</span><br></pre></td></tr></table></figure></li>
<li><p>字符串与布尔值比较（等号两侧转换为数字，再比较）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  　　&quot;abc&quot; == true　　==&gt;　　NaN == 1　　//　false</span><br><span class="line">  　　&quot;abc&quot; == false　　==&gt;　　NaN == 0　　//　false</span><br><span class="line">  　　&quot;&quot; == true　　==&gt;　　0 == 1　　//　false</span><br><span class="line">  　　&quot;&quot; == false　　==&gt;　　0 == 0　　//　true</span><br></pre></td></tr></table></figure></li>
<li><p>数字与布尔值比较（等号两侧转换为数字，再比较）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  　　1 == true　　==&gt;　　1 == 1　　//　true</span><br><span class="line">  　　0 == true　　==&gt;　　0 == 1　　//　false</span><br><span class="line">  　　100 == true　　==&gt;　　100 == 1　　//　false</span><br><span class="line">  　　1 == false　　==&gt;　　1 == 0　　//　false</span><br><span class="line">  　　0 == false　　==&gt;　　0 == 0　　//　true</span><br><span class="line">  　　100 == false　　==&gt;　　100 == 0　　//　false</span><br></pre></td></tr></table></figure></li>
<li><p>undefined 和 null</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined 与 null 比较特殊,比较相等性之前，不能将 null 和 undefined 转换成其他任何值。undefined 和 null 互相比较返回 true，和自身比较也返回 true，其他情况返回 false</span><br><span class="line">　　undefiend == undefined　　//　true</span><br><span class="line">　　undefined == null　　//　true</span><br><span class="line">　　null == null　　//　true</span><br><span class="line">　　undefined == 其他值　　//　false</span><br><span class="line">　　null == 其他值　　//　false</span><br></pre></td></tr></table></figure></li>
<li><p>NaN</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NaN（非数值）也很特殊，NaN 和任何值（包括自己）比较都是返回 false</span><br><span class="line">NaN == NaN　　//　false</span><br><span class="line">NaN == 其他值　　//　false</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>复杂数据类型</strong></p>
<p>由于引用类型保存的是对象（包括数组，函数）的地址值，所以地址值不同的，返回的都是 false</p>
<ul>
<li><p>等号两侧为不同的引用数据类型时</p>
</li>
<li><p>有且只有一侧为引用数据类型时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1，2] == 1 ==&gt; NaN == 1　　//　false</span><br><span class="line">[1，2] == true ==&gt; NaN == 1　　//　false</span><br><span class="line">[1] == 1 ==&gt; 1 == 1　　//　true</span><br><span class="line">[1] == &#x27;1&#x27; ==&gt; &#x27;1&#x27; == &#x27;1&#x27;　　//　true</span><br><span class="line"></span><br><span class="line">[] == 0 ==&gt; 0 == 0　　//　true</span><br><span class="line">[] == &#x27;0&#x27; ==&gt; &#x27;&#x27; == &#x27;0&#x27;　　//　false</span><br><span class="line">[] == &#x27;&#x27; ==&gt; &#x27;&#x27; == &#x27;&#x27;　　//　true</span><br></pre></td></tr></table></figure></li>
</ul>
<h6 id="全等"><a href="#全等" class="headerlink" title="全等"></a>全等</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+0 === -0 //true</span><br><span class="line">实际意义上的全等</span><br><span class="line">Object.is(+0, -0) // false</span><br><span class="line">Object.is(NaN, NaN) // true</span><br></pre></td></tr></table></figure>

<h5 id="自动转换布尔值"><a href="#自动转换布尔值" class="headerlink" title="自动转换布尔值"></a>自动转换布尔值</h5><p>除了以下五个值，其他都是自动转为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>+0</code>或<code>-0</code></li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<h5 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h5><p>具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串。</p>
<p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;5&#x27; + 1 // &#x27;51&#x27;</span><br><span class="line">&#x27;5&#x27; + true // &quot;5true&quot;</span><br><span class="line">&#x27;5&#x27; + false // &quot;5false&quot;</span><br><span class="line">&#x27;5&#x27; + &#123;&#125; // &quot;5[object Object]&quot;</span><br><span class="line">&#x27;5&#x27; + [] // &quot;5&quot;</span><br><span class="line">&#x27;5&#x27; + function ()&#123;&#125; // &quot;5function ()&#123;&#125;&quot;</span><br><span class="line">&#x27;5&#x27; + undefined // &quot;5undefined&quot;</span><br><span class="line">&#x27;5&#x27; + null // &quot;5null&quot;</span><br></pre></td></tr></table></figure>

<h5 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h5><p>JavaScript 遇到预期为数值的地方，就会将参数值自动转换为数值。系统内部会自动调用<code>Number()</code>函数。</p>
<p>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;5&#x27; - &#x27;2&#x27; // 3</span><br><span class="line">&#x27;5&#x27; * &#x27;2&#x27; // 10</span><br><span class="line">true - 1  // 0</span><br><span class="line">false - 1 // -1</span><br><span class="line">&#x27;1&#x27; - 1   // 0</span><br><span class="line">&#x27;5&#x27; * []    // 0</span><br><span class="line">false / &#x27;5&#x27; // 0</span><br><span class="line">&#x27;abc&#x27; - 1   // NaN</span><br><span class="line">null + 1 // 1</span><br><span class="line">undefined + 1 // NaN</span><br></pre></td></tr></table></figure>

<p>上面代码中，运算符两侧的运算子，都被转成了数值。</p>
<blockquote>
<p>注意：<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>。</p>
</blockquote>
<p>一元运算符也会把运算子转成数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+&#x27;abc&#x27; // NaN</span><br><span class="line">-&#x27;abc&#x27; // NaN</span><br><span class="line">+true // 1</span><br><span class="line">-false // 0</span><br></pre></td></tr></table></figure>

<h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><h5 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h5><ul>
<li><p>基本类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数值：转换后还是原来的值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">324</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324&#x27;</span>) <span class="comment">// 324</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串：如果不可以被解析为数值，返回 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;324abc&#x27;</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 空字符串转为0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;&#x27;</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔值：true 转成 1，false 转成 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined：转成 NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null：转成0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多。基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parseInt(&#x27;42 cats&#x27;) // 42</span><br><span class="line">Number(&#x27;42 cats&#x27;) // NaN</span><br></pre></td></tr></table></figure></li>
<li><p>引用类型</p>
<p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Number(&#123;a: 1&#125;) // NaN</span><br><span class="line">Number([1, 2, 3]) // NaN</span><br><span class="line">Number([5]) // 5</span><br></pre></td></tr></table></figure>

<p>第一步，调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤。</p>
<p>第二步，如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤。</p>
<p>第三步，<strong>如果<code>toString</code>方法返回的是对象</strong>，就报错。</p>
<p>请看下面的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123; x: 1 &#125;;</span><br><span class="line">console.log(Number(obj)); // NaN</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">if (typeof obj.valueOf() === &#x27;object&#x27;) &#123;</span><br><span class="line">  console.log(Number(obj.toString()));</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(Number(obj.valueOf()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用<code>Number</code>函数，得到<code>NaN</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Number(obj)</span><br><span class="line">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错。</p>
</li>
</ul>
<h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ul>
<li><p>基本类型</p>
<ul>
<li><strong>数值</strong>：转为相应的字符串。</li>
<li><strong>字符串</strong>：转换后还是原来的值。</li>
<li><strong>布尔值</strong>：<code>true</code>转为字符串<code>&quot;true&quot;</code>，<code>false</code>转为字符串<code>&quot;false&quot;</code>。</li>
<li><strong>undefined</strong>：转为字符串<code>&quot;undefined&quot;</code>。</li>
<li><strong>null</strong>：转为字符串<code>&quot;null&quot;</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String(123) // &quot;123&quot;</span><br><span class="line">String(&#x27;abc&#x27;) // &quot;abc&quot;</span><br><span class="line">String(true) // &quot;true&quot;</span><br><span class="line">String(undefined) // &quot;undefined&quot;</span><br><span class="line">String(null) // &quot;null&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>引用类型</p>
<p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String(&#123;a: 1&#125;) // &quot;[object Object]&quot;</span><br><span class="line">String([1, 2, 3]) // &quot;1,2,3&quot;</span><br></pre></td></tr></table></figure>

<p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序。</p>
<ol>
<li>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</li>
<li>如果<code>valueOf</code>方法返回的是对象，就报错。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  valueOf: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">String(obj)</span><br><span class="line">// TypeError: Cannot convert object to primitive value</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h5><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值。</p>
<p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean(undefined) // false</span><br><span class="line">Boolean(null) // false</span><br><span class="line">Boolean(0) // false</span><br><span class="line">Boolean(NaN) // false</span><br><span class="line">Boolean(&#x27;&#x27;) // false</span><br></pre></td></tr></table></figure>

<p>当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean(true) // true</span><br><span class="line">Boolean(false) // false</span><br></pre></td></tr></table></figure>

<p>注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>（详见《原始类型值的包装对象》一章）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Boolean(&#123;&#125;) // true</span><br><span class="line">Boolean([]) // true</span><br><span class="line">Boolean(new Boolean(false)) // true</span><br></pre></td></tr></table></figure>



<h2 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h2><h5 id="1、typeof"><a href="#1、typeof" class="headerlink" title="1、typeof"></a><strong>1、typeof</strong></h5><p>typeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：</p>
<ul>
<li>值类型(基本类型)：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</li>
<li>引用数据类型：对象(Object)、数组(Array)、函数(Function)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span><span class="string">&#x27;&#x27;</span>; <span class="comment">// string 有效</span></span><br><span class="line">typeof1; <span class="comment">// number 有效</span></span><br><span class="line">typeofSymbol(); <span class="comment">// symbol 有效</span></span><br><span class="line">typeoftrue; <span class="comment">//boolean 有效</span></span><br><span class="line">typeofundefined; <span class="comment">//undefined 有效</span></span><br><span class="line">typeofnull; <span class="comment">//object 无效</span></span><br><span class="line"><span class="keyword">typeof</span>[] ; <span class="comment">//object 无效</span></span><br><span class="line">typeofnewFunction(); <span class="comment">// function 有效</span></span><br><span class="line">typeofnewDate(); <span class="comment">//object 无效</span></span><br><span class="line">typeofnewRegExp(); <span class="comment">//object 无效</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>对于基本类型，除 null 以外，均可以返回正确的结果。</li>
<li>对于引用类型，除 function 以外，一律返回 object 类型。</li>
<li>对于 null ，返回 object 类型。因为在定义typeof时还没有null这种类型。</li>
</ul>
<p>其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，<strong>只返回了处于其原型链最顶端的 Object 类型</strong>，没有错，但不是我们想要的结果。</p>
<h5 id="2、instanceof"><a href="#2、instanceof" class="headerlink" title="2、instanceof"></a><strong>2、instanceof</strong></h5><p>instanceof 是用来<strong>判断 A 是否为 B 的实例</strong>(不能判断一个对象实例具体属于哪种类型)</p>
<p>表达式为：A instanceof B。如果 A 是 B 的实例，则返回 true,否则返回 false。 </p>
<p>在这里需要特别注意的是：<strong>instanceof 检测的是原型</strong>，我们用一段伪代码来模拟其内部执行过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">instanceof</span> (A,B) = &#123;</span><br><span class="line">    varL = A.__proto__;</span><br><span class="line">    varR = B.prototype;</span><br><span class="line">    <span class="keyword">if</span>(L === R) &#123;</span><br><span class="line">        <span class="comment">// A的内部属性 __proto__ 指向 B 的原型对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述过程可以看出，<strong>当 A 的 proto 指向 B 的 prototype 时，就认为 A 就是 B 的实例</strong>，我们再来看几个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line">newDate() <span class="keyword">instanceof</span> <span class="built_in">Date</span>;<span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">new</span> Person() <span class="keyword">instanceof</span> Person;</span><br><span class="line"> </span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">newDate() <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br><span class="line">newPerson <span class="keyword">instanceof</span> <span class="built_in">Object</span>;<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>虽然 instanceof 能够判断出 [ ] 是Array的实例，但它认为 [ ] 也是Object的实例</strong></p>
<p>我们来分析一下 [ ]、Array、Object 三者之间的关系：</p>
<p>从 instanceof 能够判断出 [ ].<strong>proto</strong>  指向 Array.prototype，而 Array.prototype.<strong>proto</strong> 又指向了Object.prototype，最终 Object.prototype.<strong>proto</strong> 指向了null，标志着原型链的结束。因此，[]、Array、Object 就在内部形成了一条原型链：</p>
<p><img src="https://images2015.cnblogs.com/blog/849589/201601/849589-20160112232510850-2003340583.png" alt="img"></p>
<p>从原型链可以看出，[] 的 <strong>proto</strong>  直接指向Array.prototype，间接指向 Object.prototype，所以按照 instanceof 的判断规则，[] 就是Object的实例。依次类推，类似的 new Date()、new Person() 也会形成一条对应的原型链 。因此，<strong>instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</strong></p>
<h5 id="3、constructor"><a href="#3、constructor" class="headerlink" title="3、constructor"></a><strong>3、constructor</strong></h5><p>当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后<strong>在 prototype上添加一个 constructor 属性，并让其指向 F 的引用</strong>。如下所示：</p>
<p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125250566-1896556617.png" alt="img"></p>
<p>当执行 var f = new F() 时，F 被当成了构造函数，f 是F的实例对象，此时 <strong>F 原型上的 constructor 传递到了 f 上</strong>，因此 f.constructor == F</p>
<p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508125714941-1649387639.png" alt="img"></p>
<p>可以看出，<strong>F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上</strong>， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。</p>
<p>同样，JavaScript 中的内置对象在内部构建时也是这样做的：</p>
<p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508131800457-2091987664.png" alt="img"></p>
<blockquote>
<ul>
<li><p>null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。</p>
</li>
<li><p>函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object</p>
</li>
</ul>
</blockquote>
<p><img src="https://images2015.cnblogs.com/blog/849589/201705/849589-20170508132757347-1999338357.png" alt="img"></p>
<p>为什么变成了 Object？</p>
<p>因为 <strong>prototype 被重新赋值的是一个 { }， { } 是 new Object() 的字面量，因此 new Object() 会将 Object 原型上的 constructor 传递给 { }，也就是 Object 本身。</strong></p>
<p><strong>因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改</strong>。</p>
<h5 id="4、toString"><a href="#4、toString" class="headerlink" title="4、toString"></a><strong>4、toString</strong></h5><p>toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格</p>
<p>式为 [object Xxx] ，其中 Xxx 就是对象的类型。</p>
<p>对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / </p>
<p>apply 来调用才能返回正确的类型信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.prototype.toString.call(&#x27;&#x27;) ;   // [object String]</span><br><span class="line">Object.prototype.toString.call(1) ;    // [object Number]</span><br><span class="line">Object.prototype.toString.call(true) ; // [object Boolean]</span><br><span class="line">Object.prototype.toString.call(Symbol()); //[object Symbol]</span><br><span class="line">Object.prototype.toString.call(undefined) ; // [object Undefined]</span><br><span class="line">Object.prototype.toString.call(null) ; // [object Null]</span><br><span class="line">Object.prototype.toString.call(newFunction()) ; // [object Function]</span><br><span class="line">Object.prototype.toString.call(newDate()) ; // [object Date]</span><br><span class="line">Object.prototype.toString.call([]) ; // [object Array]</span><br><span class="line">Object.prototype.toString.call(newRegExp()) ; // [object RegExp]</span><br><span class="line">Object.prototype.toString.call(newError()) ; // [object Error]</span><br><span class="line">Object.prototype.toString.call(document) ; // [object HTMLDocument]</span><br><span class="line">Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用</span><br></pre></td></tr></table></figure>



<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><p>webpak 引入autoprefixer，自动加上各种前缀让不同的浏览器得以支持</p>
<p>冒泡和捕获</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pauseEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.stopPropagation) e.stopPropagation();</span><br><span class="line">    e.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//防止冒泡和捕获</span></span><br><span class="line">w3c的方法是e.stopPropagation()，IE则是使用e.cancelBubble = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>取消默认事件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pauseEvent</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.preventDefault) e.preventDefault();</span><br><span class="line">    e.returnValue = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//取消默认事件</span></span><br><span class="line">w3c的方法是e.preventDefault()，IE则是使用e.returnValue = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//return false</span></span><br><span class="line">javascript的<span class="keyword">return</span> <span class="literal">false</span>只会阻止默认行为，而是用jQuery的话则既阻止默认行为又防止对象冒泡。</span><br></pre></td></tr></table></figure>

<p>event事件对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event </span><br><span class="line"><span class="built_in">document</span>.documentElement.clientWidth || <span class="built_in">document</span>.body.clientWidth </span><br><span class="line"><span class="keyword">var</span> target = ev.srcElement||ev.target</span><br></pre></td></tr></table></figure>

<p>设备像素比</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取设备像素比</span></span><br><span class="line"><span class="keyword">var</span> getPixelRatio = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> backingStore =</span><br><span class="line">context.backingStorePixelRatio ||</span><br><span class="line">context.webkitBackingStorePixelRatio ||</span><br><span class="line">context.mozBackingStorePixelRatio ||</span><br><span class="line">context.msBackingStorePixelRatio ||</span><br><span class="line">context.oBackingStorePixelRatio ||</span><br><span class="line">context.backingStorePixelRatio ||</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>) / backingStore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> pixelRatio = getPixelRatio(canvas);</span><br></pre></td></tr></table></figure>

<h2 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//图标固定</span></span><br><span class="line">  <span class="keyword">var</span> c = <span class="number">0</span>;</span><br><span class="line">  $(<span class="built_in">window</span>).scroll(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = $(<span class="built_in">document</span>).scrollTop() - $(<span class="string">&quot;.guide-box&quot;</span>).offset().top;</span><br><span class="line">    <span class="keyword">let</span> b = $(<span class="string">&quot;.guide-ico&quot;</span>).css(<span class="string">&quot;margin-top&quot;</span>);</span><br><span class="line">    b = b.substr(<span class="number">0</span>, b.length - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; a - c &gt; <span class="number">0</span> &amp;&amp; a &lt; $(<span class="string">&quot;.guide-box&quot;</span>).height() * <span class="number">0.8</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a  &gt; b) &#123;</span><br><span class="line">        $(<span class="string">&quot;.guide-ico&quot;</span>).css(&#123;</span><br><span class="line">          <span class="attr">top</span>: a - b,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; <span class="number">0</span> &amp;&amp; a - c &lt; <span class="number">0</span> &amp;&amp;a &lt; $(<span class="string">&quot;.guide-box&quot;</span>).height() * <span class="number">0.8</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        $(<span class="string">&quot;.guide-ico&quot;</span>).css(&#123;</span><br><span class="line">          <span class="attr">top</span>: a-b,</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    c = a;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><h3 id="纯js"><a href="#纯js" class="headerlink" title="纯js"></a>纯js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间差</span></span><br><span class="line"><span class="keyword">let</span> t1 = moment().locale(<span class="string">&quot;zh-cn&quot;</span>).format(<span class="string">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> t2 = moment(<span class="string">&quot;2021-07-02 14:33:33&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> t3 = t2.diff(t1, <span class="string">&quot;second&quot;</span>); <span class="comment">//计算相差的秒</span></span><br><span class="line"><span class="keyword">let</span> d = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.floor(t3 / <span class="number">60</span>) / <span class="number">60</span>) / <span class="number">24</span>); <span class="comment">//相差的天</span></span><br><span class="line"><span class="comment">//时</span></span><br><span class="line"><span class="keyword">let</span> t = t3 - d * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">t = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.floor(t / <span class="number">60</span>) / <span class="number">60</span>);</span><br><span class="line"><span class="comment">//分</span></span><br><span class="line"><span class="keyword">let</span> m = t3 - d * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> - t * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">m = <span class="built_in">Math</span>.floor(m / <span class="number">60</span>);</span><br><span class="line"><span class="comment">//秒</span></span><br><span class="line"><span class="keyword">let</span> s = t3 - d * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> - t * <span class="number">60</span> * <span class="number">60</span> - m * <span class="number">60</span>;</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较时间</span></span><br><span class="line">compareTime = <span class="function">(<span class="params">startTime, endTime</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> start_time = startTime.replace(<span class="regexp">/-|\s|:|\//g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> end_time = endTime.replace(<span class="regexp">/-|\s|:|\//g</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (start_time &lt; end_time) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="moment"><a href="#moment" class="headerlink" title="moment"></a>moment</h3><p>获取前一天的日期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">moment(new Date()).subtract(1, &quot;days&quot;).format(&quot;YYYY-MM-DD&quot;)</span><br></pre></td></tr></table></figure>

<p>比较时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">compareTime = (startTime, endTime) =&gt; &#123;</span><br><span class="line">	return moment(startTime).isBefore(endTime)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以什么格式获取当前时间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let now = moment().locale(&#x27;zh-cn&#x27;).format(&#x27;YYYY-MM-DD HH:mm:ss&#x27;);</span><br></pre></td></tr></table></figure>

<p>距离当前时间60天的moment对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">moment().subtract(60, &#x27;days&#x27;)</span><br></pre></td></tr></table></figure>

<p>传入年份和月份 获取该年对应月份的天数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getMonthDays(year,month)&#123;</span><br><span class="line"></span><br><span class="line"> var thisDate = new Date(year,month,0); //当天数为0 js自动处理为上一月的最后一天</span><br><span class="line"></span><br><span class="line"> return thisDate.getDate();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个时间相差多少天</p>
<p>分别获取两个日期的<a href="https://so.csdn.net/so/search?q=%E6%97%B6%E9%97%B4%E6%88%B3&spm=1001.2101.3001.7020">时间戳</a>，相减得到数值是毫秒，再换算成天（即除以1 * 24 * 60 * 60 * 1000）即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>startDate  开始日期 yyyy-MM-dd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>enDate  结束日期 yyyy-MM-dd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;number&#125;</span> </span>两日期相差的天数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">getDaysBetween</span>(<span class="params">startDate, enDate</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sDate = <span class="built_in">Date</span>.parse(startDate)</span><br><span class="line">  <span class="keyword">const</span> eDate = <span class="built_in">Date</span>.parse(enDate)</span><br><span class="line">  <span class="comment">// if (sDate &gt; eDate) &#123;</span></span><br><span class="line">  <span class="comment">//   return 0</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">  <span class="keyword">if</span> (sDate === eDate) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> days = (eDate - sDate) / (<span class="number">1</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.abs(days)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getDaysBetween(<span class="string">&#x27;2021-04-21&#x27;</span>, <span class="string">&#x27;2021-03-22&#x27;</span>)) <span class="comment">// 输出结果为44275</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取url的参数"><a href="#获取url的参数" class="headerlink" title="获取url的参数"></a>获取url的参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getQueryVariable(variable)&#123;</span><br><span class="line">    let a=window.location.href.split(&quot;?&quot;)[1];</span><br><span class="line">    var query = a;</span><br><span class="line">    var vars = query.split(&quot;&amp;&quot;);</span><br><span class="line">    for (var i=0;i&lt;vars.length;i++) &#123;</span><br><span class="line">    var pair = vars[i].split(&quot;=&quot;);</span><br><span class="line">    if(pair[0] == variable)&#123;return pair[1];&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return(false);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getUrl(href = &#x27;&#x27;) &#123;</span><br><span class="line">  var url =decodeURIComponent(href || window.location.href); //获取url中&quot;?&quot;符后的字串</span><br><span class="line">  var theRequest = new Object();</span><br><span class="line">  if (url.lastIndexOf(&quot;?&quot;) != -1) &#123;</span><br><span class="line">    var str =url.substring(url.lastIndexOf(&quot;?&quot;) + 1, url.length);</span><br><span class="line">    const strs = str.split(&quot;&amp;&quot;);</span><br><span class="line">    for (var i = 0; i &lt; strs.length; i++) &#123;</span><br><span class="line">      theRequest[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return theRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组转换为JSON数据"><a href="#数组转换为JSON数据" class="headerlink" title="数组转换为JSON数据"></a>数组转换为JSON数据</h2><p><strong>方法一：使用Object.assign()</strong></p>
<p>Object.assign()方法将<a href="https://so.csdn.net/so/search?q=%E6%9E%9A%E4%B8%BE&spm=1001.2101.3001.7020">枚举</a>的所有属性的值从源对象（一个或多个）复制到目标对象</p>
<p><strong>语法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(target, ...sources)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [34, 24, 31, 48];</span><br><span class="line">JSON.stringify(Object.assign(&#123;&#125;, array))</span><br><span class="line">//&#x27;&#123;&quot;0&quot;:34,&quot;1&quot;:24,&quot;2&quot;:31,&quot;3&quot;:48&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="setTimeout-1"><a href="#setTimeout-1" class="headerlink" title="setTimeout"></a>setTimeout</h2><p>看以下例子可以知道，代码运行为6次打印了6。因为setTimeout因为是一个异步函数，var变量存在变量提升、无块级作用域等，等执行到setTimeout时，for循环已经遍历结束，i的值已经是6。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">//6,6,6,6,6,6</span></span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决办法</p>
<p>1、闭包；使用闭包将i的值驻留在内存中，打印j的值（形成了自己的作用域），实际的外部函数的变量i</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)<span class="comment">// 0,1,2,3,4,5</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、setTimeout的第三个参数，该参数就是给setTimeout第一个函数的参数。每次传入setTimeout第一个函数的j值是for遍历的值，个人认为还是作用域的问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(</span><br><span class="line">    <span class="function">(<span class="params">j</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)<span class="comment">// 0,1,2,3,4,5</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">1000</span>,</span><br><span class="line">    i</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="数组循环中删除元素"><a href="#数组循环中删除元素" class="headerlink" title="数组循环中删除元素"></a>数组循环中删除元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var arr = [1, 2, 2, 3, 4, 5];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++)&#123;</span><br><span class="line">        // 打印数组中的情况，便于跟踪数组中数据的变化</span><br><span class="line">        console.log(i + &#x27; = &#x27; + arr[i]);</span><br><span class="line">        // 删除掉所有为2的元素</span><br><span class="line">        if(arr[i] === 2) &#123;</span><br><span class="line">            arr.splice(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(arr);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>产生这个结果的原因是因为，当删除掉了一个元素后，数组中元素的索引（下标）发生了实时变化，造成了程序的异常。</p>
<p>方案</p>
<ol>
<li><p>循环中索引添加递加判断,只有在不删除元素时才对索引递加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(var i=0; i&lt;arr.length;) &#123;</span><br><span class="line">  if(arr[i].gender === 2) &#123;</span><br><span class="line">    arr.splice(i,1);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>倒序删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">    var arr = [1, 2, 2, 3, 4, 5];</span><br><span class="line">    var i = arr.length;</span><br><span class="line">    while(i--) &#123;</span><br><span class="line">        console.log(i + &#x27; = &#x27; + arr[i]);</span><br><span class="line">        if(arr[i] === 2) &#123;</span><br><span class="line">            arr.splice(i, 1);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    console.log(arr);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h2 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h2><h3 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h3><p><a href="https://www.jianshu.com/p/c8b86b09daf0">https://www.jianshu.com/p/c8b86b09daf0</a></p>
<p>防抖和节流是针对<strong>响应跟不上触发频率</strong>这类问题的两种解决方案。 在给DOM绑定事件时，有些事件我们是无法控制触发频率的。 如鼠标移动事件onmousemove, 滚动滚动条事件onscroll，窗口大小改变事件onresize，瞬间的操作都会导致这些事件会被高频触发。 如果事件的回调函数较为复杂，就会导致响应跟不上触发，出现页面卡顿，假死现象。 在实时检查输入时，如果我们绑定onkeyup事件发请求去服务端检查，用户输入过程中，事件的触发频率也会很高，会导致大量的请求发出，响应速度会大大跟不上触发。</p>
<h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来<strong>之前</strong>，又一次触发了事件，就重新开始延时</p>
<p><img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144209623-862434090.jpg" alt="img"></p>
<h5 id="非立即执行版"><a href="#非立即执行版" class="headerlink" title="非立即执行版"></a><strong>非立即执行版</strong></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        </span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            func.apply(context, args)</span><br><span class="line">        &#125;, wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4842858-1f6389b9dd9e5ef9.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1134/format/webp" alt="img"></p>
<h5 id="立即执行版"><a href="#立即执行版" class="headerlink" title="立即执行版"></a><strong>立即执行版</strong></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> callNow = !timeout;</span><br><span class="line">        timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">        &#125;, wait)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/4842858-067785c056f182d8.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1140/format/webp" alt="img"></p>
<p>将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版的防抖函数。</p>
<h5 id="双剑合璧版"><a href="#双剑合璧版" class="headerlink" title="双剑合璧版"></a><strong>双剑合璧版</strong></h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@desc </span>函数防抖</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>func 函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>wait 延迟执行毫秒数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>immediate true 表立即执行，false 表非立即执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait,immediate</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout) <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">        <span class="keyword">if</span> (immediate) &#123;</span><br><span class="line">            <span class="keyword">var</span> callNow = !timeout;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">            &#125;, wait)</span><br><span class="line">            <span class="keyword">if</span> (callNow) func.apply(context, args)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p><strong>连续触发事件但是在 n 秒中只执行一次函数。节流会稀释函数的执行频率</strong></p>
<p><img src="https://images2018.cnblogs.com/blog/1022151/201806/1022151-20180613144342847-660853255.jpg" alt="img"></p>
<h5 id="时间戳版"><a href="#时间戳版" class="headerlink" title="时间戳版"></a>时间戳版</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">            func.apply(context, args);</span><br><span class="line">            previous = now;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4842858-80423b8898a27732.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1140/format/webp" alt="img"></p>
<p>可以看到，在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次。</p>
<h5 id="定时器版"><a href="#定时器版" class="headerlink" title="定时器版:"></a>定时器版:</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">func, wait</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> context = <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">if</span> (!timeout) &#123;</span><br><span class="line">            timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">                func.apply(context, args)</span><br><span class="line">            &#125;, wait)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/4842858-bf2ed4c8ed4f0ec0.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1136/format/webp" alt="img"></p>
<p>可以看到，在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次，在停止触发事件后，函数还会再执行一次。</p>
<h5 id="双剑合璧版-1"><a href="#双剑合璧版-1" class="headerlink" title="双剑合璧版"></a>双剑合璧版</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @desc 函数节流</span><br><span class="line"> * @param func 函数</span><br><span class="line"> * @param wait 延迟执行毫秒数</span><br><span class="line"> * @param type 1 表时间戳版，2 表定时器版</span><br><span class="line"> */</span><br><span class="line">function throttle(func, wait ,type) &#123;</span><br><span class="line">    if(type===1)&#123;</span><br><span class="line">        let previous = 0;</span><br><span class="line">    &#125;else if(type===2)&#123;</span><br><span class="line">        let timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    return function() &#123;</span><br><span class="line">        let context = this;</span><br><span class="line">        let args = arguments;</span><br><span class="line">        if(type===1)&#123;</span><br><span class="line">            let now = Date.now();</span><br><span class="line"></span><br><span class="line">            if (now - previous &gt; wait) &#123;</span><br><span class="line">                func.apply(context, args);</span><br><span class="line">                previous = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else if(type===2)&#123;</span><br><span class="line">            if (!timeout) &#123;</span><br><span class="line">                timeout = setTimeout(() =&gt; &#123;</span><br><span class="line">                    timeout = null;</span><br><span class="line">                    func.apply(context, args)</span><br><span class="line">                &#125;, wait)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Web-Notification桌面通知"><a href="#Web-Notification桌面通知" class="headerlink" title="Web Notification桌面通知"></a>Web Notification桌面通知</h3><p><a href="https://daotin.netlify.app/gc12ta.html#%E6%9C%80%E5%90%8E">https://daotin.netlify.app/gc12ta.html#%E6%9C%80%E5%90%8E</a></p>
<h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4><p>要创建一个消息通知，非常简单，直接使用 window 对象下面的<code>Notification</code>类即可，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var n = new Notification(&quot;桌面推送&quot;, &#123;</span><br><span class="line">   icon: &#x27;img/icon.png&#x27;,</span><br><span class="line">   body: &#x27;这是我的第一条桌面通知。&#x27;,</span><br><span class="line">   image:&#x27;img/1.jpg&#x27;</span><br><span class="line">&#125;); </span><br></pre></td></tr></table></figure>

<p>于是你就会看到系统桌面弹出我上面那张截图的通知。</p>
<blockquote>
<p>PS：消息通知只有通过<code>Web服务访问</code>该页面时才会生效，如果直接双击打开本地文件，是没有任何效果的。也就是说你的文件需要使用服务器的形式打开，而不是直接使用浏览器打开本地文件。</p>
</blockquote>
<p>当然也有可能你什么都没看到，别着急继续往下看。</p>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>当然在想要弹出上面通知之前，有必要了解一下一个通知的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myNotification = new Notification(title, options); </span><br></pre></td></tr></table></figure>

<p><code>title</code>：定义一个通知的标题，当它被触发时，它将显示在通知窗口的顶部。</p>
<p><code>options</code>（可选）对象包含应用于通知的任何自定义设置选项。</p>
<p>常用的选项有：</p>
<ul>
<li><p>body: 通知的正文，将显示在标题下方。</p>
</li>
<li><p>tag: 类似每个通知的ID，以便在必要的时候对通知进行刷新、替换或移除。</p>
</li>
<li><p>icon:  显示通知的图标</p>
</li>
<li><p>image: 在通知正文中显示的图像的URL。</p>
</li>
<li><p>data: 您想要与通知相关联的任意数据。这可以是任何数据类型。</p>
</li>
<li><p>renotify: 一个 Boolean 指定在新通知替换旧通知后是否应通知用户。默认值为false，这意味着它们不会被通知。</p>
</li>
<li><p>requireInteraction: 表示通知应保持有效，直到用户点击或关闭它，而不是自动关闭。默认值为false。</p>
</li>
</ul>
<p>当这段代码执行时，浏览器会询问用户，是否允许该站点显示消息通知，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155108.png" alt="img"></p>
<p>只有用户点击了<code>允许</code>，授权了通知，通知才会被显示出来。</p>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><p><em>如何获取到用户点击的是“允许”还是“阻止”呢？</em></p>
<p>window的 Notification实例有一个 <code>requestPermission</code> 函数用来获取用户的授权状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 首先，我们检查是否具有权限显示通知</span><br><span class="line"> // 如果没有，我们就申请权限</span><br><span class="line"> if (window.Notification &amp;&amp; Notification.permission !== &quot;granted&quot;) &#123;</span><br><span class="line">     Notification.requestPermission(function (status) &#123;</span><br><span class="line">     //status是授权状态。</span><br><span class="line">     //如果用户点击的允许，则status为&#x27;granted&#x27;</span><br><span class="line">     // 如果用户点击的禁止，则status为&#x27;denied&#x27;</span><br><span class="line">    </span><br><span class="line">     // 这将使我们能在 Chrome/Safari 中使用 Notification.permission</span><br><span class="line">     if (Notification.permission !== status) &#123;</span><br><span class="line">       Notification.permission = status;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果用户点击了授权右上角的关闭按钮，则status的值为default。</p>
</blockquote>
<p>之后，我们只需要判断 status 的值是否为<code>granted</code>，来决定是否显示通知。</p>
<h4 id="通知事件"><a href="#通知事件" class="headerlink" title="通知事件"></a>通知事件</h4><p>但是单纯的显示一个消息框是没有任何吸引力的，所以消息通知应该具有一定的交互性，在显示消息的前前后后都应该有事件的参与。</p>
<p>Notification一开始就制定好了一系列事件函数，开发者可以很方面的使用这些函数处理用户交互：</p>
<p>有：<code>onshow</code>,<code>onclick</code>,<code>onerror</code>,<code>onclose</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var n = new Notification(&quot;桌面推送&quot;, &#123;</span><br><span class="line">   icon: &#x27;img/icon.png&#x27;,</span><br><span class="line">   body: &#x27;这是我的第一条桌面通知。&#x27;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//onshow函数在消息框显示时触发</span><br><span class="line">//可以做一些数据记录及定时关闭消息框等</span><br><span class="line">n.onshow = function() &#123;</span><br><span class="line">   console.log(&#x27;显示消息框&#x27;);</span><br><span class="line">   //5秒后关闭消息框</span><br><span class="line">   setTimeout(function() &#123;</span><br><span class="line">       n.close();</span><br><span class="line">   &#125;, 3000);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//消息框被点击时被调用</span><br><span class="line">//可以打开相关的视图，同时关闭该消息框等操作</span><br><span class="line">n.onclick = function() &#123;</span><br><span class="line">   console.log(&#x27;点击消息框&#x27;);</span><br><span class="line">   // 打开相关的视图</span><br><span class="line">   n.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//当有错误发生时会onerror函数会被调用</span><br><span class="line">//如果没有granted授权，创建Notification对象实例时，也会执行onerror函数</span><br><span class="line">n.onerror = function() &#123;</span><br><span class="line">   console.log(&#x27;消息框错误&#x27;);</span><br><span class="line">   // 做些其他的事</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//一个消息框关闭时onclose函数会被调用</span><br><span class="line">n.onclose = function() &#123;</span><br><span class="line">   console.log(&#x27;关闭消息框&#x27;);</span><br><span class="line">   //做些其他的事</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;button&gt;点击发起通知&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  window.addEventListener(&quot;load&quot;, function() &#123;</span><br><span class="line">    // 首先，让我们检查我们是否有权限发出通知</span><br><span class="line">    // 如果没有，我们就请求获得权限</span><br><span class="line">    if (window.Notification &amp;&amp; Notification.permission !== &quot;granted&quot;) &#123;</span><br><span class="line">      Notification.requestPermission(function(status) &#123;</span><br><span class="line">        if (Notification.permission !== status) &#123;</span><br><span class="line">          Notification.permission = status;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    var button = document.getElementsByTagName(&quot;button&quot;)[0];</span><br><span class="line">   </span><br><span class="line">    button.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">      // 如果用户同意就创建一个通知</span><br><span class="line">      if (window.Notification &amp;&amp; Notification.permission === &quot;granted&quot;) &#123;</span><br><span class="line">        var n = new Notification(&quot;Hi！&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      // 如果用户没有选择是否显示通知</span><br><span class="line">      // 注：因为在 Chrome 中我们无法确定 permission 属性是否有值，因此</span><br><span class="line">      // 检查该属性的值是否是 &quot;default&quot; 是不安全的。</span><br><span class="line">      else if (window.Notification &amp;&amp; Notification.permission !== &quot;denied&quot;) &#123;</span><br><span class="line">        Notification.requestPermission(function(status) &#123;</span><br><span class="line">          if (Notification.permission !== status) &#123;</span><br><span class="line">            Notification.permission = status;</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          // 如果用户同意了</span><br><span class="line">          if (status === &quot;granted&quot;) &#123;</span><br><span class="line">            var n = new Notification(&quot;Hi!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">   </span><br><span class="line">          // 否则，我们可以让步的使用常规模态的 alert</span><br><span class="line">          else &#123;</span><br><span class="line">            alert(&quot;Hi!&quot;);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">   </span><br><span class="line">      // 如果用户拒绝接受通知</span><br><span class="line">      else &#123;</span><br><span class="line">        // 我们可以让步的使用常规模态的 alert</span><br><span class="line">        alert(&quot;Hi!&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当我们打开界面的时候，就会弹出授权申请，如果我们点击<code>允许</code>，然后点击按钮，就可以发送一条通知到桌面，我们就可以在桌面右下角看到这条通知。</p>
<p><img src="https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155403.png" alt="img"></p>
<p>上面我们只是显示一条消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (status === &quot;granted&quot;) &#123;</span><br><span class="line"> var n = new Notification(&quot;Hi&quot;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>如果我们有很多消息的话，比如我是用个for循环来模拟大量通知的情况。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(var i=0; i&lt;10; i++) &#123;</span><br><span class="line">   var n = new Notification(&quot;Hi,&quot;+i);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>可以看到有10条通知都显示出来。但是某些情况下对于用户来说，显示大量通知是件令人痛苦的事情。</p>
<p><img src="https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155632.png" alt="img"></p>
<p>比如，如果一个即时通信应用向用户提示每一条传入的消息。为了避免数以百计的不必要通知铺满用户的桌面，可能需要接管一个挂起消息的队列。</p>
<p>因此，需要为新建的通知添加一个<code>标记</code>。</p>
<p>如果有一条新通知和上一条通知具有相同的标记，那么这条新通知将会替换上一条通知，最后桌面上只会显示最新的通知。</p>
<p>还是上面的例子，只需要在触发通知加个<code>tag</code>属性即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (var i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">  // 最后只看到内容为 &quot;Hi! 9&quot; 的通知</span><br><span class="line">   var n = new Notification(&quot;Hi! &quot; + i, &#123;tag: &#x27;soManyNotification&#x27;&#125;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>消息通知是个不错的特性，可是也不排除有些站点恶意的使用这个功能，一旦用户授权之后，不时的推送一些不太友好的消息，打扰用户的工作，这个时候我们可以移除该站点的权限，禁用其消息通知功能。</p>
<p><img src="https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155205.png" alt="img"></p>
<p>我们可以点击浏览器地址输入框左边的叹号就有一个通知的选项，我们可以修改授权。或者在通知页面也有修改通知的选项，可以根据具体情况进行修改授权通知。</p>
<p><img src="https://raw.githubusercontent.com/Daotin/pic/master/img/20190727155225.png" alt="img"></p>
<p>于是最基本的 Web Notification 就实现了。</p>
</li>
</ol>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><h3 id="async"><a href="#async" class="headerlink" title="async"></a><strong>async</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在async中将异步的代码同步执行</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">await</span> fn()</span><br><span class="line">  <span class="comment">// await的Promise会同步执行完</span></span><br><span class="line">  <span class="keyword">await</span>的 <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolved(<span class="number">3</span>);</span><br><span class="line">  &#125;).then(<span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(v);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ​​​​​at ​quokka.js:2:2​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​quokka.js:10:4​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​v​​​ ​quokka.js:13:4​</span><br><span class="line"></span><br><span class="line">4 ​​​​​at ​quokka.js:16:2​</span><br><span class="line"></span><br><span class="line">5 ​​​​​at ​quokka.js:5:8​</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> f2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">8</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">f1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">  resolved(<span class="number">7</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">很多人以为<span class="keyword">await</span>会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上<span class="keyword">await</span>会产生一个微任务(<span class="built_in">Promise</span>.then是微任务)。<span class="keyword">await</span>后面的函数会执行一遍，然后就会跳出整个<span class="keyword">async</span>函数来执行后面js栈的代码。等本轮事件循环执行完了之后又会跳回到<span class="keyword">async</span>函数中执行剩下的代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ​​​​​at ​​​​​​quokka.js:9:1​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​​​​​​quokka.js:2:3​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​​​​quokka.js:7:3​</span><br><span class="line"></span><br><span class="line">4 ​​​​​at ​​​​​​quokka.js:15:3​</span><br><span class="line"></span><br><span class="line">5 ​​​​​at ​​​​​​quokka.js:20:1​</span><br><span class="line"></span><br><span class="line">6 ​​​​​at ​​​​​​quokka.js:4:3​</span><br><span class="line"></span><br><span class="line">7 ​​​​​at ​​​​​​​​res​​​ ​quokka.js:18:3​</span><br><span class="line"></span><br><span class="line">8 ​​​​​at ​​​​​​quokka.js:11:3​</span><br></pre></td></tr></table></figure>

<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a><strong>promise</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">a.then(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ​​​​​at ​​​​​​quokka.js:2:3​</span><br><span class="line"></span><br><span class="line">Promise &#123; &lt;pending&gt; &#125;</span><br><span class="line">  ​​​​​at ​​​​​​​​a​​​ ​quokka.js:11:1​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​​​​​​quokka.js:4:5​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​​​​​​index​​​ ​quokka.js:9:3​</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolved(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  resolved(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  reject(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">JavaScript具有<span class="string">&quot;从头到尾&quot;</span>的概念。 除非抛出错误/<span class="keyword">return</span>，否则函数将一直执行直到<span class="keyword">return</span>语句或其结尾。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 ​​​​​at ​​​​​​quokka.js:2:3​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​​​​quokka.js:4:3​</span><br><span class="line"></span><br><span class="line">5 ​​​​​at ​​​​​​quokka.js:6:3​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​​​​​​​​res​​​ ​quokka.js:9:3​</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Error: x 必须为正数] ​​​​​at ​​​​​​​​res​​​ ​quokka.js:6:3​</span><br></pre></td></tr></table></figure>

<h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="时间空间复杂度"><a href="#时间空间复杂度" class="headerlink" title="时间空间复杂度"></a>时间空间复杂度</h2><p>log：<a href="https://blog.csdn.net/weixin_39888180/article/details/111268391">https://blog.csdn.net/weixin_39888180/article/details/111268391</a></p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>其实就是一个函数，用大 O 表示， 比如 O(1)、 O(n)…</p>
<p>它的作用就是用来<code>定义描述算法的运行时间</code></p>
<ul>
<li><strong>O(1)</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    let i = 0</span><br><span class="line">    i += 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n)：</strong> 如果是 O(1) + O(n) 则还是 O(n)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n^2)：</strong> O(n) * O(n), 也就是双层循环，自此类推：O(n^3)…</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">      for (let j = 0; j &lt; n; j += 1) &#123;</span><br><span class="line">        console.log(i, j)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(logn)：</strong> 就是求 log 以 2 为底的多少次方等于 n</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    // 这个例子就是求2的多少次方会大于i，然后就会结束循环。 这就是一个典型的 O(logn)</span><br><span class="line">    let i = 1</span><br><span class="line">    while (i &lt; n) &#123;</span><br><span class="line">      console.log(i)</span><br><span class="line">      i *= 2</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>和时间复杂度一样，空间复杂度也是用大 O 表示，比如 O(1)、 O(n)…</p>
<p>它用来<code>定义描述算法运行过程中临时占用的存储空间大小</code></p>
<blockquote>
<p>占用越少 代码写的就越好</p>
</blockquote>
<ul>
<li><strong>O(1)：</strong> 单个变量，所以占用永远是 O(1)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    let i = 0</span><br><span class="line">    i += 1</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n)：</strong> 声明一个数组， 添加 n 个值， 相当于占用了 n 个空间单元</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    const arr = []</span><br><span class="line">    for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">      arr.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>O(n^2)：</strong> 类似一个矩阵的概念，就是二维数组的意思</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">for (let i = 0; i &lt; n; i += 1) &#123;</span><br><span class="line">  arr.push([])</span><br><span class="line">  for (let j = 0; j &lt; n; j += 1) &#123;</span><br><span class="line">    arr[i].push(j)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><p>二分法查找是一种速度非常快的算法，但是它有固定的应用范围。仅当列表是有序的时候，二分查找才管用。</p>
<blockquote>
<p>采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边</p>
</blockquote>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ul>
<li>（1）在数据集之中，找一个基准点</li>
<li>（2）建立两个数组，分别存储左边和右边的数组</li>
<li>（3）利用递归进行下次比较</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> [];    <span class="comment">// 返回空数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> cIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">var</span> c = arr.splice(cIndex, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> l = [];</span><br><span class="line">    <span class="keyword">var</span> r = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; c) &#123;</span><br><span class="line">            l.push(arr[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> quickSort(l).concat(c, quickSort(r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure>

<h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p><a href="https://mp.weixin.qq.com/s/BQ3_RJQcCZiXphMoyMRaTg">https://mp.weixin.qq.com/s/BQ3_RJQcCZiXphMoyMRaTg</a></p>
<p>基本数据类型的特点：直接存储在栈(stack)中的数据<br>引用数据类型的特点：存储的是该对象在栈中引用地址，真实的数据存放在堆内存里。引用数据类型在栈中存储了指针，指针指向堆中该实体的起始地址</p>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</p>
<h4 id="实现浅拷贝"><a href="#实现浅拷贝" class="headerlink" title="实现浅拷贝"></a>实现浅拷贝</h4><p>浅拷贝只拷贝基本数据的内容，引用数据虽然栈不同但会共用一个堆</p>
<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p><img src="https://segmentfault.com/img/bVbrl7t?w=541&h=138" alt="图片描述"></p>
<p>注意：当object只有一层的时候，是深拷贝</p>
<h5 id="展开运算符…"><a href="#展开运算符…" class="headerlink" title="展开运算符…"></a>展开运算符…</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; name: &#x27;Kobe&#x27;, address:&#123;x:100,y:100&#125;&#125;</span><br><span class="line">let obj2= &#123;... obj1&#125;</span><br><span class="line">obj1.address.x = 200;</span><br><span class="line">obj1.name = &#x27;wade&#x27;</span><br><span class="line">console.log(&#x27;obj2&#x27;,obj2) // obj2 &#123; name: &#x27;Kobe&#x27;, address: &#123; x: 200, y: 100 &#125; &#125;</span><br></pre></td></tr></table></figure>

<h5 id="concat-2"><a href="#concat-2" class="headerlink" title="concat()"></a>concat()</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let arr = [1, 3, &#123;</span><br><span class="line">    username: &#x27;kobe&#x27;</span><br><span class="line">    &#125;];</span><br><span class="line">let arr2 = arr.concat();    </span><br><span class="line">arr2[2].username = &#x27;wade&#x27;;</span><br><span class="line">console.log(arr); //[ 1, 3, &#123; username: &#x27;wade&#x27; &#125; ]</span><br></pre></td></tr></table></figure>

<h5 id="slice-2"><a href="#slice-2" class="headerlink" title="slice()"></a>slice()</h5><p><img src="https://segmentfault.com/img/bVbrmbB?w=424&h=185" alt="图片描述"></p>
<h4 id="实现深拷贝"><a href="#实现深拷贝" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h4><p><img src="https://image-static.segmentfault.com/809/484/809484289-5cb44d922e659_fix732" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, newObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = newObj || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj[key]);<span class="comment">//判断是否数组</span></span><br><span class="line">      newObj[key] = (isArray == <span class="literal">true</span> ? [] : &#123;&#125;)</span><br><span class="line">      deepClone(obj[key], newObj[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(newObj);</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> a2 = deepClone(a1);</span><br><span class="line">a1.a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a2.a);</span><br></pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = deepClone(source[key])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target = source</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a =&#123;<span class="attr">name</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],<span class="attr">age</span>:[<span class="number">10</span>,<span class="number">15</span>],<span class="attr">book</span>:&#123;<span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>,k]&#125;&#125;</span><br><span class="line">  <span class="keyword">let</span> b = deepClone(a)</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(a == b)</span><br><span class="line">  <span class="keyword">let</span> c = a</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="built_in">console</span>.log(c == a)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(xxx))</span><br><span class="line"></span><br><span class="line">我们在使⽤ <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(xxx))时应该注意⼀下⼏点：</span><br><span class="line"><span class="number">1</span>、如果obj⾥⾯存在时间对象，<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))之后，时间对象变成了字符串。</span><br><span class="line"><span class="number">2</span>、如果obj⾥有<span class="built_in">RegExp</span>、<span class="built_in">Error</span>对象，则序列化的结果将只得到空对象。</span><br><span class="line"><span class="number">3</span>、如果obj⾥有函数，<span class="literal">undefined</span>，则序列化的结果会把函数， <span class="literal">undefined</span>丢失。</span><br><span class="line"><span class="number">4</span>、如果obj⾥有<span class="literal">NaN</span>、<span class="literal">Infinity</span>和-<span class="literal">Infinity</span>，则序列化的结果会变成<span class="literal">null</span>。</span><br><span class="line"><span class="number">5</span>、<span class="built_in">JSON</span>.stringify()只能序列化对象的可枚举的⾃有属性。如果obj中的对象是有构造函数⽣成的，则使⽤<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">深拷贝后，会丢弃对象的<span class="title">constructor</span>。</span><br><span class="line">6、如果对象中存在循环引⽤的情况也⽆法正确实现深拷贝。</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> factorial = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>f(6) = n * f(5)，所以 f(6) 需要拆解成 f(5) 子问题进行求解，以此类推 f(5) = n * f(4) ，也需要进一步拆分 … 直到 f(1)，「这是递的过程。」 f(1) 解决后，依次可以解决f(2)…. f(n)最后也被解决，「这是归的过程。」</p>
<p>归无非就是把问题拆解成具有相同解决思路的子问题，直到最后被拆解的子问题不能够拆分，这个过程是“递”。当解决了最小粒度可求解的子问题后，在“归”的过程中顺其自然的解决了最开始的问题。</p>
<p>  <strong>复杂度分析</strong></p>
<ul>
<li>空间复杂度为 O(n)</li>
<li>时间复杂度 O(2^n)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">总时间 = 子问题个数 * 解决一个子问题需要的时间</span><br></pre></td></tr></table></figure>

<ul>
<li>子问题个数即递归树中的节点总数 2^n</li>
<li>解决一个子问题需要的时间，因为只有一个加法操作 <code>fib(n-1) + fib(n-2)</code> ，所以解决一个子问题的时间为 <code>O(1)</code></li>
</ul>
<p>  二者相乘，得出算法的时间复杂度为 <code>O(2^n)</code></p>
<h3 id="实现深拷贝-1"><a href="#实现深拷贝-1" class="headerlink" title="实现深拷贝"></a>实现深拷贝</h3><p><img src="https://image-static.segmentfault.com/809/484/809484289-5cb44d922e659_fix732" alt="img"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj, newObj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newObj = newObj || &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj[key] == <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> isArray = <span class="built_in">Array</span>.isArray(obj[key]);<span class="comment">//判断是否数组</span></span><br><span class="line">      newObj[key] = (isArray == <span class="literal">true</span> ? [] : &#123;&#125;)</span><br><span class="line">      deepClone(obj[key], newObj[key]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newObj[key] = obj[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(newObj);</span><br><span class="line">  <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a1 = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;</span><br><span class="line"><span class="keyword">let</span> a2 = deepClone(a1);</span><br><span class="line">a1.a.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a2.a);</span><br></pre></td></tr></table></figure>




<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> target;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> source === <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">      target = <span class="built_in">Array</span>.isArray(source) ? [] : &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> source) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.hasOwnProperty(key)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">typeof</span> source[key] !== <span class="string">&#x27;object&#x27;</span>) &#123;</span><br><span class="line">            target[key] = source[key]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            target[key] = deepClone(source[key])</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      target = source</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a =&#123;<span class="attr">name</span>:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>],<span class="attr">age</span>:[<span class="number">10</span>,<span class="number">15</span>],<span class="attr">book</span>:&#123;<span class="number">1</span>:[<span class="number">2</span>,<span class="number">3</span>,k]&#125;&#125;</span><br><span class="line">  <span class="keyword">let</span> b = deepClone(a)</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">  <span class="built_in">console</span>.log(a == b)</span><br><span class="line">  <span class="keyword">let</span> c = a</span><br><span class="line">  <span class="built_in">console</span>.log(c)</span><br><span class="line">  <span class="built_in">console</span>.log(c == a)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(xxx))</span><br><span class="line"></span><br><span class="line">我们在使⽤ <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(xxx))时应该注意⼀下⼏点：</span><br><span class="line"><span class="number">1</span>、如果obj⾥⾯存在时间对象，<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))之后，时间对象变成了字符串。</span><br><span class="line"><span class="number">2</span>、如果obj⾥有<span class="built_in">RegExp</span>、<span class="built_in">Error</span>对象，则序列化的结果将只得到空对象。</span><br><span class="line"><span class="number">3</span>、如果obj⾥有函数，<span class="literal">undefined</span>，则序列化的结果会把函数， <span class="literal">undefined</span>丢失。</span><br><span class="line"><span class="number">4</span>、如果obj⾥有<span class="literal">NaN</span>、<span class="literal">Infinity</span>和-<span class="literal">Infinity</span>，则序列化的结果会变成<span class="literal">null</span>。</span><br><span class="line"><span class="number">5</span>、<span class="built_in">JSON</span>.stringify()只能序列化对象的可枚举的⾃有属性。如果obj中的对象是有构造函数⽣成的，则使⽤<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br><span class="line">深拷贝后，会丢弃对象的<span class="title">constructor</span>。</span><br><span class="line">6、如果对象中存在循环引⽤的情况也⽆法正确实现深拷贝。</span><br></pre></td></tr></table></figure>

<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;浙江&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;余杭区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;上城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;下城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;西湖区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;拱墅区&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;绍兴&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;柯桥区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;越城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;上虞区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;新昌县&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;武汉&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;江岸区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;江汉区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;硚口区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;汉阳区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;武昌区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;青山区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;洪山区&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="获取树的叶子节点并赋值到树结构中"><a href="#获取树的叶子节点并赋值到树结构中" class="headerlink" title="获取树的叶子节点并赋值到树结构中"></a>获取树的叶子节点并赋值到树结构中</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> input = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;浙江&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;余杭区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;上城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;下城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;西湖区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;拱墅区&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;绍兴&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;柯桥区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;越城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;上虞区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;新昌县&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;武汉&quot;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;江岸区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;江汉区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;硚口区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;汉阳区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;武昌区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;青山区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;洪山区&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getLeafCountTree</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.children) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr.leafCount = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.children.length; i++) &#123;</span><br><span class="line">        arr.leafCount = arr.leafCount + getLeafCountTree(arr.children[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//需要将次层的叶子节点return给父级</span></span><br><span class="line">      <span class="keyword">return</span> arr.leafCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">finalQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//因为是数组，不是树形结构，需要以树形结构处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> r = <span class="number">0</span>; r &lt; input.length; r++) &#123;</span><br><span class="line">      getLeafCountTree(input[r]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  finalQuery();</span><br><span class="line">  <span class="keyword">return</span> input</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(process(input));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> output = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;浙江&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;浙江&quot;</span>,</span><br><span class="line">    <span class="attr">leafCount</span>: <span class="number">9</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;杭州&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;浙江-杭州&quot;</span>,</span><br><span class="line">        <span class="attr">leafCount</span>: <span class="number">5</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;余杭区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-杭州-余杭区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;上城区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-杭州-上城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;下城区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-杭州-下城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;西湖区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-杭州-西湖区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;拱墅区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-杭州-拱墅区&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;绍兴&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;浙江-绍兴&quot;</span>,</span><br><span class="line">        <span class="attr">leafCount</span>: <span class="number">4</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;柯桥区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-绍兴-柯桥区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;越城区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-绍兴-越城区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;上虞区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-绍兴-上虞区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;新昌县&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;浙江-绍兴-新昌县&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;湖北&quot;</span>,</span><br><span class="line">    <span class="attr">leafCount</span>: <span class="number">7</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;武汉&quot;</span>,</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&quot;湖北-武汉&quot;</span>,</span><br><span class="line">        <span class="attr">leafCount</span>: <span class="number">7</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;江岸区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-江岸区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;江汉区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-江汉区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;硚口区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-硚口区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;汉阳区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-汉阳区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;武昌区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-武昌区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;青山区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-青山区&quot;</span> &#125;,</span><br><span class="line">          &#123; <span class="attr">name</span>: <span class="string">&quot;洪山区&quot;</span>, <span class="attr">path</span>: <span class="string">&quot;湖北-武汉-洪山区&quot;</span> &#125;,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="根据id，拿到id数组"><a href="#根据id，拿到id数组" class="headerlink" title="根据id，拿到id数组"></a>根据id，拿到id数组</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// (tree为目标树，targetId为目标节点id)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNodeRoute</span>(<span class="params">tree, targetId</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodePathArray = []</span><br><span class="line">  <span class="keyword">let</span> fn = <span class="function">(<span class="params">tree, targetId</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; tree.length; index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tree[index].children) &#123;</span><br><span class="line">        <span class="keyword">let</span> endRecursiveLoop = fn(tree[index].children, targetId)</span><br><span class="line">        <span class="keyword">if</span> (endRecursiveLoop) &#123;</span><br><span class="line">          nodePathArray.push(tree[index].name)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (tree[index].name === targetId) &#123;</span><br><span class="line">        nodePathArray.push(tree[index].name)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fn(tree, targetId)</span><br><span class="line">  <span class="keyword">return</span> nodePathArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getNodeRoute(input, <span class="string">&#x27;余杭区&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(getNodeRoute(input, <span class="string">&#x27;余杭区&#x27;</span>).reverse());</span><br><span class="line"><span class="comment">//[ &#x27;浙江&#x27;, &#x27;杭州&#x27;, &#x27;余杭区&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><ul>
<li><p>使用递归实现<code>getElementsByClassName</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">byClass</span>(<span class="params">node, className, arr</span>)</span>&#123;</span><br><span class="line">       <span class="comment">//得到传入节点的所有子节点</span></span><br><span class="line">       <span class="keyword">var</span> lists = node.childNodes;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt; lists.length;i++)&#123;</span><br><span class="line">           <span class="comment">//判断是否有相同className元素</span></span><br><span class="line">           <span class="keyword">if</span>(arr[i],className == className)&#123;</span><br><span class="line">               arr.push(arr[i]);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//判断子节点是否还有子节点</span></span><br><span class="line">           <span class="keyword">if</span>(arr[i].childNodes.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">               byClass(arr[i],className,arr);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li>
<li><p>有一堆桃子，每天吃掉一半，挑出一个坏的扔掉，第6天的时候发现还剩1个桃子，问原来有多少个桃子。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> a = (fn(n - <span class="number">1</span>) + <span class="number">1</span>) * <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn(<span class="number">2</span>)) <span class="comment">//190</span></span><br></pre></td></tr></table></figure>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><p>将浏览器的前进按钮禁止</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将浏览器的前进按钮禁止</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">&quot;jquery&quot;</span>;</span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.history &amp;&amp; <span class="built_in">window</span>.history.pushState) &#123;</span><br><span class="line">    $(<span class="built_in">window</span>).on(<span class="string">&#x27;popstate&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// console.log(window.location.href)</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.location.href.indexOf(<span class="built_in">window</span>.location.origin + <span class="string">&quot;/wechatpub/surveyOne&quot;</span>)&gt;-<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// console.log(window.location.href,&quot;==========================&quot;)</span></span><br><span class="line">        <span class="built_in">window</span>.history.pushState(<span class="string">&#x27;forward&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">        <span class="built_in">window</span>.history.forward(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// window.history.pushState(&#x27;forward&#x27;, null, &#x27;#&#x27;); //在IE中必须得有这两行</span></span><br><span class="line">  <span class="comment">// window.history.forward(1);</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="业务问题"><a href="#业务问题" class="headerlink" title="业务问题"></a>业务问题</h1><h2 id="AntD"><a href="#AntD" class="headerlink" title="AntD"></a>AntD</h2><h3 id="Form"><a href="#Form" class="headerlink" title="Form"></a>Form</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rules=&#123;[</span><br><span class="line">    (&#123; getFieldValue &#125;) =&gt; (&#123;</span><br><span class="line">        validator(_, value) &#123;</span><br><span class="line">        if (value.valueOf() &gt; getFieldValue(&#x27;onlineTime&#x27;).valueOf() 					|| !value) &#123;</span><br><span class="line">        	return Promise.resolve();</span><br><span class="line">        &#125;</span><br><span class="line">        return Promise.reject(new Error(&#x27;上线时间大于当前时间&#x27;));</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const formRef = useRef&lt;any&gt;();</span><br><span class="line">formRef.current.setFieldsValue(&#123;</span><br><span class="line">    putNum: state.crowdData.putNum,</span><br><span class="line">    putPhone: state.crowdData.putPhone,</span><br><span class="line">    putEmail: state.crowdData.putEmail</span><br><span class="line">&#125;)</span><br><span class="line">&lt;Form ref=&#123;formRef&#125; initialValues=&#123;initialValues&#125; &#123;...Formlayout&#125;&gt;&lt;Form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="upload"><a href="#upload" class="headerlink" title="upload"></a>upload</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> uploadProps = &#123;</span><br><span class="line">  <span class="comment">// name: &quot;file&quot;,</span></span><br><span class="line">  <span class="attr">action</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">accept</span>: <span class="string">&quot;.doc, .docx&quot;</span>,</span><br><span class="line">  <span class="attr">multiple</span>: <span class="literal">false</span>, <span class="comment">//是否支持多选文件</span></span><br><span class="line">  <span class="attr">fileList</span>: uploadTypeList,</span><br><span class="line">  <span class="attr">showUploadList</span>: &#123;</span><br><span class="line">    <span class="attr">showDownloadIcon</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">downloadIcon</span>: <span class="string">&#x27;download &#x27;</span>,</span><br><span class="line">    <span class="attr">showRemoveIcon</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">removeIcon</span>: <span class="xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">className</span>=<span class="string">&#x27;iconfont iconshanchu3&#x27;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> removeIcon()&#125;/&gt;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">iconRender</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">PUBLIC_CDN_URL</span>&#125;/<span class="attr">images</span>/<span class="attr">dashboard</span>/<span class="attr">upload_file.png</span>`&#125; <span class="attr">alt</span>=<span class="string">&#x27;&#x27;</span> 			<span class="attr">className</span>=<span class="string">&#123;styles.upload_file&#125;/</span>&gt;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">onRemove</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    setUploadTypeList([])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">onChange</span>(<span class="params">info</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info, uploadTypeList)</span><br><span class="line">    <span class="keyword">let</span> ext = info.file.name ? info.file.name.split(<span class="string">&#x27;.&#x27;</span>)[<span class="number">1</span>] : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="regexp">/[*&amp;&lt;&gt;%?:;\\/|&quot;]/im</span></span><br><span class="line">    <span class="keyword">if</span> (ext) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!(ext === <span class="string">&#x27;doc&#x27;</span> || ext === <span class="string">&#x27;docx&#x27;</span>)) &#123;</span><br><span class="line">        message.error(<span class="string">&#x27;您只能上传doc，docx 文件!&#x27;</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (reg.test(info.file.name)) &#123;</span><br><span class="line">        message.error(<span class="string">&#x27;文件名不能包含下列任何字符串：* &amp; &lt; &gt; % ? : ; \\ / | &quot;&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        message.loading(&#123; <span class="attr">content</span>: <span class="string">&#x27;文件上传中...&#x27;</span>, <span class="attr">key</span>: <span class="string">&#x27;export&#x27;</span> &#125;);</span><br><span class="line">        <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">        formData.append(<span class="string">&#x27;file_upload&#x27;</span>, info.file);</span><br><span class="line">        <span class="built_in">console</span>.log(info, uploadTypeList)</span><br><span class="line">        <span class="comment">// setUploadLocalList([info.file])</span></span><br><span class="line">        <span class="comment">// uploadTopic.run(formData);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>实战</category>
      </categories>
      <tags>
        <tag>实战</tag>
        <tag>代码片段</tag>
      </tags>
  </entry>
  <entry>
    <title>vue</title>
    <url>/2020/09/25/06-vue/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="标签数据"><a href="#标签数据" class="headerlink" title="标签数据"></a>标签数据</h2><ul>
<li> , msg也可以是js表达式，但只能包含**单个**表达式

<blockquote>
<p>一个表达式会产生一个值,它可以放在任何需要一个值的地方<br>语句可以理解成一个行为.循环语句和if语句就是典型的语句<br>需要语句的地方,你可以使用一个表达式来代替.这样的语句称之为表达式语句</p>
</blockquote>
</li>
<li><p>v-model=”msg”建立双向绑定     </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;name&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;name = $event.target.value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>v-once指令： 执行一次性地插值，当数据改变时，插值处的内容不会更新 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span v-once&gt;这个将不会改变: &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编译html元素       v-html    </p>
</li>
<li><p>v-text</p>
</li>
</ul>
<h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;&#123;&#123;url&#125;&#125;&quot; alt=&quot;&quot; /&gt;</span><br><span class="line">&lt;img v-bind:src=&quot;url&quot; /&gt;</span><br><span class="line">//缩写</span><br><span class="line">&lt;img :src=&quot;url&quot; alt=&quot;&quot; &gt;</span><br><span class="line">//动态参数的缩写 </span><br><span class="line">// 可以用方括号括起来的 JavaScript 表达式作为一个指令的参数 </span><br><span class="line">&lt;img v-bind:[]=&quot;url&quot;  &gt;</span><br></pre></td></tr></table></figure>

<p><strong>内联样式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img v-bind:style=&quot;&#123;color:&#x27;&#x27;,fontsize:data+&#x27;px&#x27;&#125;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>class</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:&#x27;red&#x27;,</span><br><span class="line">b:&#x27;blue&#x27;,</span><br><span class="line">json:&#123;</span><br><span class="line">    red:true,</span><br><span class="line">    blue:false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;strong :class=&quot;[条件?a:b]&quot;&gt;文字。。&lt;/strong&gt;//可以用三元表达式  </span><br><span class="line">&lt;strong :class=&quot;[a,b]&quot;&gt;文字。。&lt;/strong&gt;</span><br><span class="line">&lt;strong :class=&quot;&#123;red:true,blue:false&#125;&quot;&gt;文字。。&lt;/strong&gt;</span><br><span class="line">&lt;strong :class=&quot;json&quot;&gt;文字。。&lt;/strong&gt;</span><br><span class="line"></span><br><span class="line">//添加动态class</span><br><span class="line">&lt;strong :class=&quot;[条件?&#x27;className&#x27;:&#x27;className&#x27;,条件?&#x27;className&#x27;:&#x27;className&#x27;,]&quot;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>组件内部引入第三方的css文件只在当前组件生效的办法</p>
<style src="" scoped></style></li>
<li><p>vue样式穿透 ::v-deep   <a href="https://www.jb51.net/article/188038.htm">https://www.jb51.net/article/188038.htm</a></p>
<p>修改vantUI样式，直接在 <style lang="scss" scoped> …. </style> 中编写的话只会影响当前组件内的样式，但如果去掉scoped话又会影响全局样式。</p>
<p>如果你希望 scoped 样式中的一个选择器能够作用得“更深”，例如影响子组件，你可以使用 &gt;&gt;&gt; 操作符：</p>
<style scoped> .a >>> .b { /* ... */ } </style> 上述代码将会编译成：.a[data-v-f3f3eg9] .b { /* … */ }
<p>可以使用 /deep/ 或 ::v-deep 操作符取而代之——两者都是 &gt;&gt;&gt; 的别名，同样可以正常工作。</p>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-for和虚拟DOM"><a href="#v-for和虚拟DOM" class="headerlink" title="v-for和虚拟DOM"></a>v-for和虚拟DOM</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">for</span>=<span class="string">&quot;(val,index) in array&quot;</span></span><br><span class="line"><span class="comment">//:key=&quot;index&quot;</span></span><br><span class="line"><span class="comment">//每次更改数组数据，全部的数据都会重新渲染，添加key值，从而只渲染更改的数据.这是因为每一个列表渲染的元素加上了唯一标识符，编译器通过标识符渲染指定列表，高效渲染虚拟DOM树</span></span><br></pre></td></tr></table></figure>

<p> 打个🌰。把F元素插入到A B C D E中。 </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80OTI3MDM1LTRkNzg2M2I2MTI0YzVjYjkuanBn?x-oss-process=image/format,png" alt="img"></p>
<p>其实是这么插的：新的dom和旧的dom比较， 第一个原来是A，更新之后还是A，所以就不变，第二个是B，更新之后还是B，所以还是不变，第三个是C，更新之后变成了F。  然后后面的都变化了 </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80OTI3MDM1LWM3N2I2YWQ4MWZkNDM1YzMuanBn?x-oss-process=image/format,png" alt="img"></p>
<p>但是如果给每一个列表渲染的元素加上了唯一标识符。列表更新之后，编译器通过标识符知道第一个元素是A。第三个是C，就不会更新成F。就像下图。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy80OTI3MDM1LTk2MGYyZDg1NmI1ZWM5YzMuanBn?x-oss-process=image/format,png" alt="img"></p>
<p>vue和react的虚拟DOM的Diff算法大致相同</p>
<img src="https://upload-images.jianshu.io/upload_images/3973616-cbe6ef9bad920f51.png?imageMogr2/auto-orient/strip|imageView2/2/w/576/format/webp" alt="img" style="zoom:50%;" />

<ul>
<li><p>如果dom树有三层，在没加ID的情况下。</p>
<p>先比较第一层。比较一次</p>
<p>再比较第二层。比较第一层第一个节点和第二层第一个节点，第一层第一个节点和第二层第二个节点，比较第一层第二个节点和第二层两个节点。比较了四次。</p>
<p>算法复杂度，2的n次方。</p>
</li>
<li><p>如果加上ID。</p>
<p>比较第一个节点。再比较第二个节点。再比较第三个节点。再比较第四个节点。再比较第五个节点。一直比到第n个节点。</p>
<p>算法复杂度为n。</p>
</li>
</ul>
<h3 id="v-if和v-show"><a href="#v-if和v-show" class="headerlink" title="v-if和v-show"></a>v-if和v-show</h3><p><a href="https://blog.csdn.net/zg0601/article/details/123632608">https://blog.csdn.net/zg0601/article/details/123632608</a></p>
<h4 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">v-<span class="keyword">if</span> 指令用于条件性地渲染一块内容。这块内容只会在指令的表达式返回 <span class="literal">true</span> 值的时候被渲染。</span><br><span class="line">&lt;h1 v-<span class="keyword">if</span>=<span class="string">&quot;awesome&quot;</span>&gt;Vue is awesome!&lt;/h1&gt;</span><br><span class="line">也可以用 v-<span class="keyword">else</span> 添加一个“<span class="keyword">else</span> 块”：	</span><br><span class="line">&lt;h1 v-<span class="keyword">else</span>&gt;Oh no 😢&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">在 &lt;template&gt; 元素上使用 v-<span class="keyword">if</span> 条件渲染分组</span><br><span class="line">&lt;template v-<span class="keyword">if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>当它们处于同一节点，<code>v-for</code> 的优先级比 <code>v-if</code> 更高，这意味着 <code>v-if</code> 将分别重复运行于每个 <code>v-for</code> 循环中。当你只想为<em>部分</em>项渲染节点时，这种优先级的机制会十分有用，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;li v-<span class="keyword">for</span>=<span class="string">&quot;todo in todos&quot;</span> v-<span class="keyword">if</span>=<span class="string">&quot;!todo.isComplete&quot;</span>&gt;</span><br><span class="line">  &#123;&#123; todo &#125;&#125;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>

<h4 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> &lt;div v-show=<span class="string">&quot;a&quot;</span>&gt; </span><br><span class="line"> v-show=<span class="string">&quot;a&quot;</span><span class="comment">//a是布尔值， 切换元素的 CSS property `display`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vue2.+ 中data数据对象是通过Object.defineProerty来进行数据的双向数据绑定，</span></span><br><span class="line"><span class="comment">//而数组则是监听数组的push和pop等操作数组的方法进行双向绑定的，</span></span><br><span class="line"><span class="comment">//因此当是通过下标来修改时便不能更新视图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用数组中的值来控制展示</span></span><br><span class="line"> &lt;div v-show=<span class="string">&quot;arr[index]&quot;</span>&gt; </span><br><span class="line"><span class="built_in">this</span>.$set(<span class="built_in">this</span>.arr,index,!<span class="built_in">this</span>.arr[index]);</span><br><span class="line"><span class="comment">//第一个参数为数组，第二个参数为数组下标，第三个参数为设置的值，</span></span><br></pre></td></tr></table></figure>

<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>既然 v-show 和 v-if 这两个指令都可以控制DOM元素的行为，那么它们有什么区别呢？</p>
<p>1、控制手段不同</p>
<p>v-show指令设置隐藏是给绑定的DOM元素添加CSS样式：display:none，但是DOM元素仍然存在；<br>v-if指令设置隐藏是将DOM元素整个删除，此时DOM元素不再存在。<br>2、编译过程不同</p>
<p>v-if  切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；而 v-show 只是简单的基于CSS切换，不管初始条件是什么，元素总是会被渲染。</p>
<p>3、编译条件不同</p>
<p>v-show是在任何条件下（首次条件是否为真）都被编译，然后被缓存，而且DOM元素保留；</p>
<p>v-if 由false变为true时，触发组件的beforeCreate、create、beforeMount、mounter钩子，由true变为false时，触发组件的</p>
<p>beforeDestory、destoryed方法。v-if 是真正的条件渲染，它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；</p>
<p>v-if 也是惰性的，如果初始渲染时条件为假，则什么也不做——直到为真时才开始渲染条件块。</p>
<p>4、性能消耗不同</p>
<p> v-show 由更高的初始渲染消耗， v-if 有更高的切换消耗。</p>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>如果需要非常频繁地切换，则使用v-show较好；</p>
<p>如果在运行时条件很少改变，则使用v-if较好。</p>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><pre><code>Vue.directive(指令名称,function(参数)&#123;
    this.el    -&gt; 原生DOM元素
&#125;);

&lt;div v-red=&quot;参数&quot;&gt;&lt;/div&gt;
</code></pre>
<p>指令定义函数提供了几个钩子函数（可选）：</p>
<ul>
<li>bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。</li>
<li>inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。</li>
<li>update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。</li>
<li>componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。</li>
<li>unbind: 只调用一次， 指令与元素解绑时调用。</li>
</ul>
<p>例子：<a href="https://juejin.cn/post/6906028995133833230#heading-5">https://juejin.cn/post/6906028995133833230#heading-5</a></p>
<h2 id="computed和watch"><a href="#computed和watch" class="headerlink" title="computed和watch"></a>computed和watch</h2><p>如果一个值依赖多个属性（多对一），用computed肯定是更加方便的。如果一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一对多），用watch更加方便一些</p>
<h3 id="计算属性computed"><a href="#计算属性computed" class="headerlink" title="计算属性computed"></a><strong>计算属性computed</strong></h3><ul>
<li>computed是计算属性，用来计算一个属性的值。<ol>
<li>调用的时候不需要加括号，可以直接当属性来用</li>
<li>根据依赖自动缓存，依赖不变的时候，值不会重新计算</li>
</ol>
</li>
<li>computed的getter和setter<ul>
<li>computed的属性可以读取和设值。因此，在computed中可以分为getter(读取)和setter(设值).</li>
<li>一般情况下没有setter，computed只预设了getter，只能读取，不能设值。所以，computed默认格式（是不表明getter函数的）.</li>
<li>当赋值给计算属性的时候，将调用setter函数。</li>
</ul>
</li>
</ul>
<p>计算属性是为了模板中的表达式简洁，易维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;p id=&quot;app&quot;&gt;&#123;&#123; myname.substring(0,1).toUpperCase() + myname.substring(1) &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>运算过于复杂，冗长，且不好维护，因此我们对于复杂的运算应该 使用计算属性的方式去书写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &#123;&#123; changewords &#125;&#125;</span><br><span class="line">    //通过在表达式中调用方法来达到同样的效果 //&#123;&#123; changewords() &#125;&#125;</span><br><span class="line">    //不同的是计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。这就意味着只要message</span><br><span class="line">    还没有发生改变，多次访问 reversedMessage,计算属性会立即返回之前的计算结果，而不必再次执行函数。</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;&#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  method: &#123;</span><br><span class="line">    changewords() &#123;</span><br><span class="line">      return;</span><br><span class="line">      //this.myname.substring(0, 1).toUpperCase() + this.myname.substring(1);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    changewords() &#123;</span><br><span class="line">      return 0;</span><br><span class="line">      //this.myname.substring(0, 1).toUpperCase() + this.myname.substring(1);</span><br><span class="line">    &#125;,</span><br><span class="line">    //完整写法</span><br><span class="line">    changewords: &#123;</span><br><span class="line">      get: function () &#123;</span><br><span class="line">        return; //一定要return</span><br><span class="line">      &#125;,</span><br><span class="line">      set: function (newVal) &#123; &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>变量不在 data中定义，而是定义在computed中</p>
</li>
<li><p><strong>计算属性基于响应式依赖进行缓存。</strong>如其中的任意一个值未发生变化，它调用的就是上一次 计算缓存的数据，而不是从新计算。因此提高了程序的性能。而methods中每调用一次就会重新计算一次，为了进行不必要的资源消耗，选择用计算属性</p>
</li>
<li><p><strong>支持缓存</strong>，只有依赖数据发生改变，才会重新进行计算</p>
</li>
<li><p>不支持异步，当computed内有异步操作时无效，无法监听数据的变化</p>
</li>
</ul>
<h3 id="侦听器-watch"><a href="#侦听器-watch" class="headerlink" title="侦听器 watch"></a>侦听器 <strong>watch</strong></h3><p>watch的意思是监听，当发生变化时，监听并且执行。</p>
<ol>
<li>immediat：ture表示让值最初时候watch就执行</li>
<li>deep表示对对象里面的变化进行深度监听</li>
<li>不支持缓存，数据变，直接会触发相应的操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">question</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">answer</span>: <span class="string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span><br><span class="line"> 	 &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="line">    <span class="attr">question</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.answer = <span class="string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="line">      <span class="built_in">this</span>.debouncedGetAnswer()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$watch(name,fnCb);  <span class="comment">//浅度</span></span><br><span class="line">vm.$watch(name,fnCb,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;);  <span class="comment">//深度监视 </span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>不支持缓存，数据变，直接会触发相应的操作；</p>
</li>
<li><p><strong>watch支持异步</strong>；</p>
</li>
<li><p>监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；</p>
</li>
<li><p>当一个属性发生变化时，需要执行对应的操作；一对多；</p>
</li>
<li><p>监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数</p>
<ul>
<li>immediate：组件加载立即触发回调函数执行，</li>
<li>deep: 深度监听，为了发现<strong>对象内部值</strong>的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增</li>
</ul>
</li>
<li><p><strong>不应该使用箭头函数来定义 watcher 函数</strong>，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</p>
</li>
</ul>
<h3 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h3><ul>
<li>功能上：computed是计算属性，watch是监听一个值的变化，然后执行对应的回调。</li>
<li>是否调用缓存：computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调。</li>
<li>是否调用return：computed中的函数必须要用return返回，watch中的函数不是必须要用return。</li>
<li>computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）</li>
<li>使用场景：computed—-当一个属性受多个属性影响的时候，使用computed—–购物车商品结算。watch–当一条数据影响多条数据的时候，使用watch—–搜索框.</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3>  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> @<span class="attr">click</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- 动态参数的缩写 --&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">a</span> @[<span class="attr">event</span>]=<span class="string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用原生的事件</span></span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//不能直接定义事件，需要从methods中引入this.handleScroll</span></span><br><span class="line">    <span class="comment">//TODO,是否是this指向的问题</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;scroll&#x27;</span>, <span class="built_in">this</span>.handleScroll, <span class="literal">true</span>)</span><br><span class="line">    <span class="built_in">this</span>.boxTop = <span class="built_in">this</span>.$refs.tabList.offsetTop;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="键盘"><a href="#键盘" class="headerlink" title="键盘"></a>键盘</h3><p>@keydown    $event    ev.keyCode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">常用键:</span><br><span class="line">回车</span><br><span class="line">a). @keyup.13</span><br><span class="line">b). @keyup.enter</span><br><span class="line">上、下、左、右</span><br><span class="line">@keyup/keydown.left</span><br><span class="line">@keyup/keydown.right</span><br><span class="line">@keyup/keydown.up</span><br><span class="line">@keyup/keydown.down</span><br><span class="line">自定义键盘信息:</span><br><span class="line">Vue.directive(&#x27;on&#x27;).keyCodes.ctrl=17;</span><br><span class="line">//vue2.0	</span><br><span class="line">通过全局 config.keyCodes 对象自定义按键修饰符别名：</span><br><span class="line">Vue.config.keyCodes.ctrl=17;</span><br><span class="line">@keyup.ctrl=&quot;fn()&quot;</span><br></pre></td></tr></table></figure>

<p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><h3 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h3><p>在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件_之后_进行同步。<br>意思是什么呢，就是说当我们在input输入框输入数据时，v-model绑定的值不会发发生变化，但是当我们停止输入，输入框失去焦点或者按下回车时，v-model绑定的值才会发生变化，即在“change”时而非“input”时更新</p>
<h3 id="trim"><a href="#trim" class="headerlink" title="trim"></a><strong>trim</strong></h3><p> <strong>用户输入的前后的空格去掉</strong></p>
<h3 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h3><p>stop防止事件冒泡  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@click.stop=&quot;show()&quot;   </span><br><span class="line">阻止冒泡:  </span><br><span class="line">a). ev.cancelBubble=true;</span><br><span class="line">b). @click.stop	推荐</span><br><span class="line">c). event.stopPropagation();</span><br></pre></td></tr></table></figure>

<h3 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 阻止默认行为，提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>修饰符可以串联</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="capture"><a href="#capture" class="headerlink" title="capture"></a>capture</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="self"><a href="#self" class="headerlink" title="self"></a>self</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="once"><a href="#once" class="headerlink" title="once"></a>once</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="passive"><a href="#passive" class="headerlink" title="passive"></a>passive</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 而不会等待 `onScroll` 完成  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:scroll.passive</span>=<span class="string">&quot;onScroll&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="exact"><a href="#exact" class="headerlink" title="exact"></a>exact</h4><p><code>.exact</code> 修饰符允许你控制由精确的系统修饰符组合触发的事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.ctrl.exact=&quot;onCtrlClick&quot;&gt;A&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span><br><span class="line">&lt;button v-on:click.exact=&quot;onClick&quot;&gt;A&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h4 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h4><p>日常开发时，我们总会遇到需要父子组件双向绑定的问题，但是考虑到组件的可维护性，vue中是不允许子组件改变父组件传的props值的。那么同时，vue中也提供了一种解决方案.<a href="https://so.csdn.net/so/search?q=sync&spm=1001.2101.3001.7020">sync</a>修饰符。sync修饰符，与我们平常使用$emit实现子组件向父组件通信没有区别，只不过是写法上方便一些。</p>
<ul>
<li><p>$emit</p>
<p>子组件使用$emit向父组件发送事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(&#x27;update:title&#x27;, newTitle)</span><br></pre></td></tr></table></figure>

<p>父组件监听这个事件并更新一个本地的数据title：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;text-document</span><br><span class="line">  :title=&quot;title&quot;</span><br><span class="line">  @update:title=&quot;val =&gt; title = val&quot;</span><br><span class="line">&gt;&lt;/text-document&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>.sync修饰符</p>
<p>只需要修两个地方：</p>
<ol>
<li>子组件内触发的事件名称以“update:title”命名</li>
<li>父组件v-bind:title 加上.sync修饰符，即 v-bind:title.sync</li>
</ol>
<p>这样父组件就不用再手动绑定@update:title事件了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">    onInput(e) &#123;</span><br><span class="line">        this.$emit(&quot;update:title&quot;, e.target.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// index.vue组件</span><br><span class="line">&lt;info :title.sync=&quot;title&quot;&gt;&lt;/info&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;<span class="number">1.</span>msg|filterA&lt;/p&gt;</span><br><span class="line">&#123;&#123;<span class="string">&#x27;welcome&#x27;</span>|uppercase&#125;&#125;  </span><br><span class="line">&lt;p&gt;<span class="number">2.</span>msg|filterA&lt;/p&gt;</span><br><span class="line">&#123;&#123;<span class="string">&#x27;WELCOME&#x27;</span>|lowercase|capitalize&#125;&#125;</span><br></pre></td></tr></table></figure>

<p> 数据配合使用过滤器:<br>        limitBy    限制几个<br>        limitBy   参数(取几个)<br>        limitBy 取几个  从哪开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	filterBy	过滤数据</span><br><span class="line">	filterBy ‘谁’</span><br><span class="line"></span><br><span class="line">	orderBy	排序</span><br><span class="line">	orderBy 谁 1/-1</span><br><span class="line">		1  -&gt; 正序</span><br><span class="line">		2  -&gt; 倒序</span><br><span class="line"></span><br><span class="line">自定义过滤器:  model -&gt;过滤 -&gt; view</span><br><span class="line">	Vue.filter(name,function(msg,[a,b])&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">&#123;&#123;msg | name([a,b])&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过渡动画"><a href="#过渡动画" class="headerlink" title="过渡动画"></a>过渡动画</h2><p><a href="https://cn.vuejs.org/v2/guide/transitions.html">https://cn.vuejs.org/v2/guide/transitions.html</a></p>
<h3 id="过渡条件"><a href="#过渡条件" class="headerlink" title="过渡条件"></a>过渡条件</h3><p>Vue 提供了 <code>transition</code> 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡</p>
<ul>
<li>条件渲染 (使用 <code>v-if</code>)</li>
<li>条件展示 (使用 <code>v-show</code>)</li>
<li>动态组件</li>
<li>组件根节点</li>
</ul>
<h3 id="过渡的类名"><a href="#过渡的类名" class="headerlink" title="过渡的类名"></a>过渡的类名</h3><p>在进入/离开的过渡中，会有 6 个 class 切换。</p>
<ol>
<li><code>v-enter</code>：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。</li>
<li><code>v-enter-active</code>：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-enter-to</code>：<strong>2.1.8 版及以上</strong>定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 <code>v-enter</code> 被移除)，在过渡/动画完成之后移除。</li>
<li><code>v-leave</code>：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。</li>
<li><code>v-leave-active</code>：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。</li>
<li><code>v-leave-to</code>：<strong>2.1.8 版及以上</strong>定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 <code>v-leave</code> 被删除)，在过渡/动画完成之后移除。</li>
</ol>
<p><strong>实例</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;demo&quot;&gt;</span><br><span class="line">  &lt;button v-on:click=&quot;show = !show&quot;&gt;</span><br><span class="line">    Toggle</span><br><span class="line">  &lt;/button&gt;</span><br><span class="line">  &lt;transition name=&quot;fade&quot;&gt;</span><br><span class="line">    &lt;p v-if=&quot;show&quot;&gt;hello&lt;/p&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#x27;#demo&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    show: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.fade-enter-active, .fade-leave-active &#123;</span><br><span class="line">  transition: opacity .5s;</span><br><span class="line">&#125;</span><br><span class="line">.fade-enter, .fade-leave-to /* .fade-leave-active below version 2.1.8 */ &#123;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="过渡组件transition"><a href="#过渡组件transition" class="headerlink" title="过渡组件transition"></a>过渡组件transition</h3><p><a href="https://cn.vuejs.org/v2/api/#transition">https://cn.vuejs.org/v2/api/#transition</a></p>
<h4 id="Prop"><a href="#Prop" class="headerlink" title="Prop"></a><strong>Prop</strong></h4><ul>
<li><code>name</code> - string，用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为 <code>.fade-enter</code>，<code>.fade-enter-active</code> 等。默认类名为 <code>&quot;v&quot;</code></li>
<li><code>appear</code> - boolean，是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>
<li><code>css</code> - boolean，是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>
<li><code>type</code> - string，指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>
<li><code>mode</code> - string，控制离开/进入过渡的时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时进行。</li>
<li><code>duration</code> - number | { <code>enter</code>: number, <code>leave</code>: number } 指定过渡的持续时间。默认情况下，Vue 会等待过渡所在根元素的第一个 <code>transitionend</code> 或 <code>animationend</code> 事件。</li>
<li><code>enter-class</code> - string</li>
<li><code>leave-class</code> - string</li>
<li><code>appear-class</code> - string</li>
<li><code>enter-to-class</code> - string</li>
<li><code>leave-to-class</code> - string</li>
<li><code>appear-to-class</code> - string</li>
<li><code>enter-active-class</code> - string</li>
<li><code>leave-active-class</code> - string</li>
<li><code>appear-active-class</code> - string</li>
</ul>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><ul>
<li><code>before-enter</code></li>
<li><code>before-leave</code></li>
<li><code>before-appear</code></li>
<li><code>enter</code></li>
<li><code>leave</code></li>
<li><code>appear</code></li>
<li><code>after-enter</code></li>
<li><code>after-leave</code></li>
<li><code>after-appear</code></li>
<li><code>enter-cancelled</code></li>
<li><code>leave-cancelled</code> (<code>v-show</code> only)</li>
<li><code>appear-cancelled</code></li>
</ul>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p><code>&lt;transition&gt;</code> 元素作为<strong>单个</strong>元素/组件的过渡效果。<code>&lt;transition&gt;</code> 只会把过渡效果应用到其包裹的内容上，而不会额外渲染 DOM 元素，也不会出现在可被检查的组件层级中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 简单元素 --&gt;</span><br><span class="line">&lt;transition&gt;</span><br><span class="line">  &lt;div v-if=&quot;ok&quot;&gt;toggled content&lt;/div&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 动态组件 --&gt;</span><br><span class="line">&lt;transition name=&quot;fade&quot; mode=&quot;out-in&quot; appear&gt;</span><br><span class="line">  &lt;component :is=&quot;view&quot;&gt;&lt;/component&gt;</span><br><span class="line">&lt;/transition&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 事件钩子 --&gt;</span><br><span class="line">&lt;div id=&quot;transition-demo&quot;&gt;</span><br><span class="line">  &lt;transition @after-enter=&quot;transitionComplete&quot;&gt;</span><br><span class="line">    &lt;div v-show=&quot;ok&quot;&gt;toggled content&lt;/div&gt;</span><br><span class="line">  &lt;/transition&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new Vue(&#123;</span><br><span class="line">  ...</span><br><span class="line">  methods: &#123;</span><br><span class="line">    transitionComplete: function (el) &#123;</span><br><span class="line">      // 传入 &#x27;el&#x27; 这个 DOM 元素作为参数。</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;).$mount(&#x27;#transition-demo&#x27;)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参考</strong>：<a href="https://cn.vuejs.org/v2/guide/transitions.html">过渡：进入，离开和列表</a></li>
</ul>
<h2 id="混入mixin"><a href="#混入mixin" class="headerlink" title="混入mixin"></a>混入mixin</h2><p><a href="https://cn.vuejs.org/v2/guide/mixins.html">https://cn.vuejs.org/v2/guide/mixins.html</a></p>
<p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</p>
<p>与组件的区别</p>
<p>组件：在父组件中引入组件，相当于在父组件中给出一片独立的空间供子组件使用，然后根据props来传值，但本质上两者是相对独立的。<br>Mixins：则是在引入组件之后与组件中的对象和方法进行合并，相当于扩展了父组件的对象与方法，可以理解为形成了一个新的组件。</p>
<p>特点<br>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。</p>
<p>选项为data ：在发生冲突时以组件数据优先。<br>值为函数的选项，如生命周期钩子函数created,mounted等，就会被合并调用，混合对象里的钩子函数在组件里的钩子函数之前调用<br>值为对象的选项，例如 methods、components和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。<br>方法和参数在各组件中不共享</p>
<h1 id="vm实例"><a href="#vm实例" class="headerlink" title="vm实例"></a>vm实例</h1><p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#box&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; <span class="comment">//局部组件</span></span><br><span class="line">    <span class="string">&#x27;aaa&#x27;</span>: Aaa</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: data</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span> &#123; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="comment">//设置 property 也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br></pre></td></tr></table></figure>

<p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的。也就是说如果你添加一个新的 property，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm.b = &#x27;hi&#x27;</span><br></pre></td></tr></table></figure>

<p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。</p>
<h2 id="全局Api"><a href="#全局Api" class="headerlink" title="全局Api"></a>全局Api</h2><h3 id="Vue-component"><a href="#Vue-component" class="headerlink" title="Vue.component"></a>Vue.component</h3><h3 id="Vue-use-plugin"><a href="#Vue-use-plugin" class="headerlink" title="Vue.use( plugin )"></a>Vue.use( plugin )</h3><p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法调用时，会将 Vue 作为参数传入。</p>
<p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p>
<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>
<h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm=<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// el:&#x27;#box&#x27;,</span></span><br><span class="line">    <span class="attr">aa</span>:<span class="number">11</span>,<span class="comment">//自定义属性</span></span><br><span class="line">    <span class="attr">show</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>:&#123;</span><br><span class="line">        <span class="attr">a</span>:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(vm.$options.aa);<span class="comment">//获取自定义属性</span></span><br><span class="line">vm.$options.show();</span><br></pre></td></tr></table></figure>

<h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象 property 的访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="vm-props"><a href="#vm-props" class="headerlink" title="vm.$props"></a>vm.$props</h3><p>当前组件接收到的 props 对象。Vue 实例代理了对其 props 对象 property 的访问。</p>
<h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><p>获取Vue实例挂载的元素节点</p>
<h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><p>一个对象，持有注册过 <a href="https://cn.vuejs.org/v2/api/#ref"><code>ref</code> attribute</a> 的所有 DOM 元素和组件实例。</p>
<h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><p>父实例，如果当前实例有的话。子组件可以通过<code>this.$parent.fn</code>(父组件的函数)去调用父组件的函数</p>
<h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3><p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>
<h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自己。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="vm-watch"><a href="#vm-watch" class="headerlink" title="vm.$watch"></a>vm.$watch</h3><p>vm.$watch( expOrFn, callback, [options] )</p>
<p>观察 Vue 实例上的一个表达式或者一个函数计算结果的变化。回调函数得到的参数为新值和旧值。</p>
<h3 id="vm-set"><a href="#vm-set" class="headerlink" title="vm.$set"></a>vm.$set</h3><p>vm.$set( target, propertyName/index, value )</p>
<p>🌹调用方法：this.$set( target, key, value )</p>
<p>🌹 target：要更改的数据源(可以是对象或者数组)</p>
<p>🌹 key：要更改的具体数据</p>
<p>🌹 value ：重新赋的值</p>
<p><strong>当你发现你给对象加了一个属性，在控制台能打印出来，但是却没有更新到视图上时，也许这个时候就需要用到this.$set（）这个方法了</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/17600821-0ab6b6711bdbf0e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>给data定义的对象<code>新增属性</code>,同时<code>又要视图实时更新</code>,除了用<code>Vue.$set()</code>方法,也可以通过<code>Object.assign()</code>实现</p>
<h3 id="vm-once"><a href="#vm-once" class="headerlink" title="vm.$once"></a>vm.$once</h3><p>$once有两个参数，第一个参数为字符串类型，用来指定绑定的事件名称，第二个参数设置事件的回调函数</p>
<p>自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button @click=&quot;$emit(&#x27;onceHander&#x27;)&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.$once(&#x27;onceHander&#x27;, () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;该事件只能够被触发一次，触发后立刻被移除11&#x27;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>生命周期</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let timer = setInterval(()=&gt;&#123;</span><br><span class="line">    // to do</span><br><span class="line">    console.log(&quot;定时器打印111&quot;);</span><br><span class="line">&#125;,1000);</span><br><span class="line">this.$once(&#x27;hook:beforeDestroy&#x27;,()=&gt;&#123;</span><br><span class="line">    clearInterval(timer);</span><br><span class="line">    timer = null;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="vm-mount"><a href="#vm-mount" class="headerlink" title="vm.$mount"></a>vm.$mount</h3><p>挂载,将数据转化为dom</p>
<h3 id="vm-forceUpdate"><a href="#vm-forceUpdate" class="headerlink" title="vm.$forceUpdate()"></a>vm.$forceUpdate()</h3><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p><a href="https://www.jianshu.com/p/a7550c0e164f">https://www.jianshu.com/p/a7550c0e164f</a></p>
<p><a href="https://mp.weixin.qq.com/s/lf9uKtTAKNplJeSwFSM_Uw">https://mp.weixin.qq.com/s/lf9uKtTAKNplJeSwFSM_Uw</a></p>
<p>在下次 DOM 更新循环结束之后执行延迟回调。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// DOM 更新了</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="组件命名"><a href="#组件命名" class="headerlink" title="组件命名"></a><strong>组件命名</strong></h2><ul>
<li><h4 id="kebab-case-短横线分隔命名"><a href="#kebab-case-短横线分隔命名" class="headerlink" title="kebab-case(短横线分隔命名)"></a>kebab-case(短横线分隔命名)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;my-component-name&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure></li>
<li><h4 id="PascalCase-首字母大写命名"><a href="#PascalCase-首字母大写命名" class="headerlink" title="PascalCase  (首字母大写命名)"></a>PascalCase  (首字母大写命名)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;MyComponentName&#x27;, &#123; /* ... */ &#125;)</span><br></pre></td></tr></table></figure>

<p>当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。也就是说 <code>&lt;my-component-name&gt;</code> 和 <code>&lt;MyComponentName&gt;</code> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。</p>
</li>
</ul>
<h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><ul>
<li><strong>定义组件</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//vue2.0组件定义</span></span><br><span class="line">&lt;template id=<span class="string">&quot;Aaa&quot;</span>&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> @<span class="attr">click</span>=<span class="string">&quot;change&quot;</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&lt;/template &gt;</span><br><span class="line"><span class="keyword">var</span> Aaa = &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">isCollapse</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//导出组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Aaa</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>组件使用</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入组件</span></span><br><span class="line"><span class="keyword">import</span> Aaa <span class="keyword">from</span> <span class="string">&#x27;./Aaa&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    Aaa,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;component-a&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line">Vue.component(&#x27;component-b&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line">Vue.component(&#x27;component-c&#x27;, &#123; /* ... */ &#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123; el: &#x27;#app&#x27; &#125;)</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">  &lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">  &lt;component-c&gt;&lt;/component-c&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>如果你恰好使用了 webpack (或在内部使用了 webpack 的 <a href="https://github.com/vuejs/vue-cli">Vue CLI 3+</a>)，那么就可以使用 <code>require.context</code> 只全局注册这些非常通用的基础组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> upperFirst <span class="keyword">from</span> <span class="string">&#x27;lodash/upperFirst&#x27;</span></span><br><span class="line"><span class="keyword">import</span> camelCase <span class="keyword">from</span> <span class="string">&#x27;lodash/camelCase&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requireComponent = <span class="built_in">require</span>.context(</span><br><span class="line">  <span class="comment">// 其组件目录的相对路径</span></span><br><span class="line">  <span class="string">&#x27;./components&#x27;</span>,</span><br><span class="line">  <span class="comment">// 是否查询其子目录</span></span><br><span class="line">  <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 匹配基础组件文件名的正则表达式</span></span><br><span class="line">  <span class="regexp">/Base[A-Z]\w+\.(vue|js)$/</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">requireComponent.keys().forEach(<span class="function"><span class="params">fileName</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 获取组件配置</span></span><br><span class="line">  <span class="keyword">const</span> componentConfig = requireComponent(fileName)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取组件的 PascalCase 命名</span></span><br><span class="line">  <span class="keyword">const</span> componentName = upperFirst(</span><br><span class="line">    camelCase(</span><br><span class="line">      <span class="comment">// 获取和目录深度无关的文件名</span></span><br><span class="line">      fileName</span><br><span class="line">        .split(<span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">        .pop()</span><br><span class="line">        .replace(<span class="regexp">/\.\w+$/</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局注册组件</span></span><br><span class="line">  Vue.component(</span><br><span class="line">    componentName,</span><br><span class="line">    <span class="comment">// 如果这个组件选项是通过 `export default` 导出的，</span></span><br><span class="line">    <span class="comment">// 那么就会优先使用 `.default`，</span></span><br><span class="line">    <span class="comment">// 否则回退到使用模块的根。</span></span><br><span class="line">    componentConfig.default || componentConfig</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>全局注册的行为必须在根 Vue 实例 (通过 <code>new Vue</code>) 创建之前发生</strong>。<a href="https://github.com/chrisvfritz/vue-enterprise-boilerplate/blob/master/src/components/_globals.js">这里</a>有一个真实项目情景下的示例。</p>
<h2 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h2><h3 id="插槽：slot"><a href="#插槽：slot" class="headerlink" title="插槽：slot"></a>插槽：slot</h3><p><a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html">https://v2.cn.vuejs.org/v2/guide/components-slots.html</a></p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components 规范草案</a>，将 <code>&lt;slot&gt;</code> 元素作为承载分发内容的出口。</p>
<h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a>编译作用域</h4><p><strong>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;navigation-link url=&quot;/profile&quot;&gt;</span><br><span class="line">  Clicking here will send you to: &#123;&#123; url &#125;&#125;</span><br><span class="line">  &lt;!--</span><br><span class="line">  这里的 `url` 会是 undefined，因为其 (指该插槽的) 内容是</span><br><span class="line">  _传递给_ &lt;navigation-link&gt; 的而不是</span><br><span class="line">  在 &lt;navigation-link&gt; 组件*内部*定义的。</span><br><span class="line">  --&gt;</span><br><span class="line">&lt;/navigation-link&gt;</span><br></pre></td></tr></table></figure>

<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><blockquote>
<p>自 2.6.0 起有所更新。已废弃的使用 <code>slot</code> attribute 的语法在<a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">这里</a>。</p>
</blockquote>
<p>有时我们需要多个插槽。例如对于一个带有如下模板的 <code>&lt;base-layout&gt;</code> 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;!-- 我们希望把页头放这里 --&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;!-- 我们希望把主要内容放这里 --&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;!-- 我们希望把页脚放这里 --&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>对于这样的情况，<code>&lt;slot&gt;</code> 元素有一个特殊的 attribute：<code>name</code>。这个 attribute 可以用来定义额外的插槽：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;slot&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>一个不带 <code>name</code> 的 <code>&lt;slot&gt;</code> 出口会带有隐含的名字“default”。</p>
<p>在向具名插槽提供内容的时候，我们可以在一个 <code>&lt;template&gt;</code> 元素上使用 <code>v-slot</code> 指令，并以 <code>v-slot</code> 的参数的形式提供其名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure>

<p>现在 <code>&lt;template&gt;</code> 元素中的所有内容都将会被传入相应的插槽。<strong>任何没有被包裹在带有 <code>v-slot</code> 的 <code>&lt;template&gt;</code> 中的内容都会被视为默认插槽的内容</strong>。</p>
<p>然而，如果你希望更明确一些，仍然可以在一个 <code>&lt;template&gt;</code> 中包裹默认插槽的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:default&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line"></span><br><span class="line">  &lt;template v-slot:footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure>

<p>任何一种写法都会渲染出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;container&quot;&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1&gt;Here might be a page title&lt;/h1&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  &lt;main&gt;</span><br><span class="line">    &lt;p&gt;A paragraph for the main content.&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;And another one.&lt;/p&gt;</span><br><span class="line">  &lt;/main&gt;</span><br><span class="line">  &lt;footer&gt;</span><br><span class="line">    &lt;p&gt;Here&#x27;s some contact info&lt;/p&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>注意 <strong><code>v-slot</code> 只能添加在 <code>&lt;template&gt;</code> 上</strong> (只有<a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E7%8B%AC%E5%8D%A0%E9%BB%98%E8%AE%A4%E6%8F%92%E6%A7%BD%E7%9A%84%E7%BC%A9%E5%86%99%E8%AF%AD%E6%B3%95">一种例外情况</a>)，这一点和已经废弃的 <a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95"><code>slot</code> attribute</a> 不同。</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><blockquote>
<p>自 2.6.0 起有所更新。已废弃的使用 <code>slot-scope</code> attribute 的语法在<a href="https://v2.cn.vuejs.org/v2/guide/components-slots.html#%E5%BA%9F%E5%BC%83%E4%BA%86%E7%9A%84%E8%AF%AD%E6%B3%95">这里</a>。</p>
</blockquote>
<p><strong>让插槽内容能够访问子组件中才有的数据是很有用的</strong>。例如，设想一个带有如下模板的 <code>&lt;current-user&gt;</code> 组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot&gt;&#123;&#123; user.lastName &#125;&#125;&lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>我们可能想换掉备用内容，用名而非姓来显示。如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user&gt;</span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>

<p>然而上述代码不会正常工作，因为只有 <code>&lt;current-user&gt;</code> 组件可以访问到 <code>user</code>，而我们提供的内容是在父级渲染的。</p>
<p>为了让 <code>user</code> 在父级的插槽内容中可用，我们可以将 <code>user</code> 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">  &lt;slot v-bind:user=&quot;user&quot;&gt;</span><br><span class="line">    &#123;&#123; user.lastName &#125;&#125;</span><br><span class="line">  &lt;/slot&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure>

<p>绑定在 <code>&lt;slot&gt;</code> 元素上的 attribute 被称为<strong>插槽 prop</strong>。现在在父级作用域中，我们可以使用带值的 <code>v-slot</code> 来定义我们提供的插槽 prop 的名字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;current-user&gt;</span><br><span class="line">  &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="line">    &#123;&#123; slotProps.user.firstName &#125;&#125;</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/current-user&gt;</span><br><span class="line"></span><br><span class="line">解构插槽 Prop</span><br><span class="line">&lt;current-user v-slot=&quot;&#123; user &#125;&quot;&gt;</span><br><span class="line">  &#123;&#123; user.firstName &#125;&#125;</span><br><span class="line">&lt;/current-user&gt;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 <code>slotProps</code>，但你也可以使用任意你喜欢的名字。</p>
<h4 id="动态插槽"><a href="#动态插槽" class="headerlink" title="动态插槽"></a>动态插槽</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-layout&gt;</span><br><span class="line">  &lt;template v-slot:[dynamicSlotName]&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/template&gt;</span><br><span class="line">&lt;/base-layout&gt;</span><br></pre></td></tr></table></figure>



<h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a><strong>动态组件</strong></h3><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a><strong>keep-alive</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<p>如果你选择了一篇文章，切换到 <em>Archive</em> 标签，然后再切换回 <em>Posts</em>，是不会继续展示你之前选择的文章的。这是因为你每次切换新标签的时候，Vue 都创建了一个新的 <code>currentTabComponent</code> 实例。</p>
<p>当在这些组件之间切换的时候，你有时会想保持这些组件的状态，以避免反复重渲染导致的性能问题。<br>用一个 <keep-alive> 元素将其动态组件包裹起来，<strong>组件将会被缓存</strong></p>
<ul>
<li><p><strong>Props</strong>：</p>
<ul>
<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>
<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>
<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>
<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>
<ul>
<li>页面第一次进入，钩子的触发顺序created-&gt; mounted-&gt; activated</li>
<li>退出时触发deactivated</li>
<li>当再次进入（前进或者后退）时，只触发activated。</li>
</ul>
</li>
</ul>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 在 HTML 中是 kebab-case(短横线分隔命名)  的 --&gt;</span><br><span class="line">&lt;blog-post post-title=&quot;hello!&quot;&gt;&lt;/blog-post&gt;</span><br><span class="line">&lt;!-- 在 HTML 中是 的 camelCase (小驼峰)--&gt;</span><br><span class="line">&lt;blog-post postTitle=&quot;hello!&quot;&gt;&lt;/blog-post&gt;、</span><br><span class="line">//都可以用postTitle来获取</span><br><span class="line">Vue.component(&#x27;blog-post&#x27;, &#123;T</span><br><span class="line">  // 在 JavaScript 中是 camelCase 的</span><br><span class="line">  props: [&#x27;postTitle&#x27;],</span><br><span class="line">  template: &#x27;&lt;h3&gt;&#123;&#123; postTitle &#125;&#125;&lt;/h3&gt;&#x27;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>每个 prop 都可以指定的值类型</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">    <span class="comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span></span><br><span class="line">    propA: Number,</span><br><span class="line">    <span class="comment">// 多个可能的类型</span></span><br><span class="line">    propB: [String, Number],</span><br><span class="line">    <span class="comment">// 必填的字符串</span></span><br><span class="line">    propC: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      required: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的数字</span></span><br><span class="line">    propD: &#123;</span><br><span class="line">      type: Number,</span><br><span class="line">      default: <span class="number">100</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 带有默认值的对象</span></span><br><span class="line">    propE: &#123;</span><br><span class="line">      type: Object,</span><br><span class="line">      <span class="comment">// 对象或数组默认值必须从一个工厂函数获取</span></span><br><span class="line">      default: function () &#123;</span><br><span class="line">        return &#123; message: &#x27;hello&#x27; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义验证函数</span></span><br><span class="line">    propF: &#123;</span><br><span class="line">      validator: function (value) &#123;</span><br><span class="line">        <span class="comment">//使用 prop 定义中的 validator 选项，可以将一个 prop 类型限制在一组特定的值中。</span></span><br><span class="line">        <span class="comment">// 这个值必须匹配下列字符串中的一个</span></span><br><span class="line">        return [&#x27;success&#x27;, &#x27;warning&#x27;, &#x27;danger&#x27;].indexOf(value) !== -1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    propG: Promise, <span class="comment">// or any other constructor</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>所有的 prop 都使得其父子 prop 之间形成了一个<strong>单向下行绑定</strong>：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。</p>
<h2 id="组件手动更新"><a href="#组件手动更新" class="headerlink" title="组件手动更新"></a>组件手动更新</h2><ul>
<li><p>v-if</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;isUpdate&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">// 移除组件</span><br><span class="line">this.isUpdate = false;</span><br><span class="line">//在组件移除后，重新渲染组件</span><br><span class="line">//this.$nextTick可实现在DOM 状态更新后，执行传入的方法。</span><br><span class="line">this.$nextTick(() =&gt; &#123;</span><br><span class="line">this.isUpdate = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>:key</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div v-if=&quot;isUpdate&quot; :key=&quot;test || Math.random() || new Data()&quot;&gt;&lt;/div&gt;</span><br><span class="line">this.test++</span><br></pre></td></tr></table></figure></li>
<li><p>调用强制更新方法this.$forceUpdate()会更新视图和数据，强制触发vue的update方法</p>
</li>
<li><p>this.$set</p>
</li>
</ul>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><p><a href="https://segmentfault.com/a/1190000019208626">https://segmentfault.com/a/1190000019208626</a></p>
<h3 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。</span><br><span class="line">子组件中使用mounted编译完成，将父组件数据赋值给子组件的数据，而直接不使用父组件数据</span><br><span class="line"><span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.msg)</span><br><span class="line">    <span class="built_in">this</span>.b=<span class="built_in">this</span>.msg;</span><br><span class="line">    <span class="comment">//   vue2.0不允许直接给父级的数据做赋值操作</span></span><br><span class="line">    <span class="comment">//若父组件每次传一个对象给子组件，则可以赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h3><h4 id="emit"><a href="#emit" class="headerlink" title="emit"></a>emit</h4><p>emit用于子组件调用父组件的方法并传递数据；子组件可以使用“$emit”触发父组件的自定义事件，触发事件后附加参数都会传给监听器回调，语法为“vm.$emit(事件, arg )”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;box&quot;&gt;</span><br><span class="line">    &lt;aaa&gt;</span><br><span class="line">    &lt;/aaa&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;aaa&quot;&gt;</span><br><span class="line">  &lt;span&gt;我是父级 -&gt; &#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">  &lt;bbb @child-msg=&quot;get&quot;&gt;&lt;/bbb&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;template id=&quot;bbb&quot;&gt;</span><br><span class="line">  &lt;h3&gt;子组件-&gt; &#123;&#123; a &#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;input type=&quot;button&quot; value=&quot;send&quot; @click=&quot;send&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: &quot;#box&quot;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: &quot;aaa&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    aaa: &#123;</span><br><span class="line">      data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          msg: &quot;我是父组件的数据&quot;,</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;,</span><br><span class="line">      template: &quot;#aaa&quot;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        get(msg) &#123;</span><br><span class="line">          alert(msg);</span><br><span class="line">          this.msg = msg;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        bbb: &#123;</span><br><span class="line">          data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">              a: &quot;我是子组件的数据&quot;,</span><br><span class="line">            &#125;;</span><br><span class="line">          &#125;,</span><br><span class="line">          template: &quot;#bbb&quot;,</span><br><span class="line">          methods: &#123;</span><br><span class="line">            send() &#123;</span><br><span class="line">              //将子组件的数据传递给父组件</span><br><span class="line">              this.$emit(&quot;child-msg&quot;, this.a);</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title="sync修饰符"></a>sync修饰符</h4><h4 id="自定义组件的v-model"><a href="#自定义组件的v-model" class="headerlink" title="自定义组件的v-model"></a>自定义组件的v-model</h4><p><a href="https://blog.csdn.net/weixin_47232046/article/details/109738816">https://blog.csdn.net/weixin_47232046/article/details/109738816</a></p>
<p>一个组件上的 <code>v-model</code> 默认会利用名为 <code>value</code> 的 prop 和名为 <code>input</code> 的事件，但是像单选框、复选框等类型的输入控件可能会将 <code>value</code> attribute 用于<a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Value">不同的目的</a>。<code>model</code> 选项可以用来避免这样的冲突：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;base-checkbox&#x27;, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: &#x27;checked&#x27;,</span><br><span class="line">    event: &#x27;change&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: Boolean</span><br><span class="line">  &#125;,</span><br><span class="line">  template: `</span><br><span class="line">    &lt;input</span><br><span class="line">      type=&quot;checkbox&quot;</span><br><span class="line">      v-bind:checked=&quot;checked&quot;</span><br><span class="line">      v-on:change=&quot;$emit(&#x27;change&#x27;, $event.target.checked)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在在这个组件上使用 <code>v-model</code> 的时候：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;base-checkbox v-model=&quot;lovingVue&quot;&gt;&lt;/base-checkbox&gt;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>lovingVue</code> 的值将会传入这个名为 <code>checked</code> 的 prop。同时当 <code>&lt;base-checkbox&gt;</code> 触发一个 <code>change</code> 事件并附带一个新的值的时候，这个 <code>lovingVue</code> 的 property 将会被更新。</p>
<h3 id="中央事件总线"><a href="#中央事件总线" class="headerlink" title="中央事件总线"></a>中央事件总线</h3><p><strong>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Event = new Vue();　　　　　　相当于又new了一个vue实例，Event中含有vue的全部方法；</span><br><span class="line"></span><br><span class="line">Event.$emit(&#x27;msg&#x27;,this.msg);　　 发送数据，第一个参数是发送数据的名称，接收时还用这个名字接收，第二个参数是这个数据现在的位置；</span><br><span class="line"></span><br><span class="line">Event.$on(&#x27;msg&#x27;,function(msg)&#123;　 接收数据，第一个参数是数据的名字，与发送时的名字对应，第二个参数是一个方法，要对数据的操作</span><br><span class="line"></span><br><span class="line">事件总线eventBus主要是在要相互通信的两个Vue页面之中，都引入一个新的vue实例，然后通过分别调用这个实例的事件触发和监听来实现通信和参数传递。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//准备一个空的实例对象</span></span><br><span class="line"><span class="keyword">var</span> Event=<span class="keyword">new</span> Vue();</span><br><span class="line"><span class="keyword">var</span> A=&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">                    &lt;div&gt;</span></span><br><span class="line"><span class="string">                        &lt;span&gt;我是A组件&lt;/span&gt; -&gt; &#123;&#123;a&#125;&#125;</span></span><br><span class="line"><span class="string">                        &lt;input type=&quot;button&quot; value=&quot;把A数据给C&quot; @click=&quot;send&quot;&gt;</span></span><br><span class="line"><span class="string">                    &lt;/div&gt;</span></span><br><span class="line"><span class="string">            `</span>,</span><br><span class="line">    <span class="attr">methods</span>:&#123;</span><br><span class="line">        <span class="function"><span class="title">send</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            Event.$emit(<span class="string">&#x27;a-msg&#x27;</span>,<span class="built_in">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">a</span>:<span class="string">&#x27;我是a数据&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> C=&#123;</span><br><span class="line">    <span class="attr">template</span>:<span class="string">`</span></span><br><span class="line"><span class="string">                &lt;div&gt;</span></span><br><span class="line"><span class="string">                    &lt;h3&gt;我是C组件&lt;/h3&gt;</span></span><br><span class="line"><span class="string">                    &lt;span&gt;接收过来的A的数据为: &#123;&#123;a&#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">                &lt;/div&gt;</span></span><br><span class="line"><span class="string">            `</span>,</span><br><span class="line">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">a</span>:<span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//var _this=this;</span></span><br><span class="line">        Event.$on(<span class="string">&#x27;a-msg&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.a=a;</span><br><span class="line">        &#125;.bind(<span class="built_in">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide/inject"></a>provide/inject</h3><p><strong>允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。</p>
<p>一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。</p>
<p><strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p>
<h3 id="parent-children与-ref"><a href="#parent-children与-ref" class="headerlink" title="$parent / $children与 ref"></a><code>$parent</code> / <code>$children</code>与 <code>ref</code></h3><ul>
<li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li>
<li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li>
<li><strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// component-a 子组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Vue.js&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      <span class="built_in">window</span>.alert(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">component-a</span> <span class="attr">ref</span>=<span class="string">&quot;comA&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component-a</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    mounted () &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="keyword">const</span> comA = <span class="built_in">this</span>.$refs.comA;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      <span class="built_in">console</span>.log(comA.title);  <span class="comment">// Vue.js</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">      comA.sayHello();  <span class="comment">// 弹窗</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li>父子通信：</li>
</ul>
<p>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></p>
<ul>
<li>兄弟通信：</li>
</ul>
<p>Bus；Vuex</p>
<ul>
<li>跨级通信：</li>
</ul>
<p>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></p>
<h2 id="组件懒加载"><a href="#组件懒加载" class="headerlink" title="组件懒加载"></a>组件懒加载</h2><ul>
<li><p>异步方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">components:&#123;</span><br><span class="line">   &quot;One-com&quot;:resolve=&gt;([&#x27;./one&#x27;],resolve)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>const方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const One = ()=&gt;import(&quot;./one&quot;);</span><br><span class="line">components:&#123;</span><br><span class="line">     &quot;One-com&quot;:One</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h1><p><code>Vue.use</code>和<code>Vue.prototype</code>没有本质区别，<code>Vue.use</code>就是在<code>Vue.prototype</code>基础上又封装了一层而已，他们实现的原理都是在<code>Vue.prototype</code>上添加了一个方法，<code>Vue.prototype</code>适合于注册Vue生态外的插件，<code>Vue.use</code>适合于注册Vue生态内的插件。</p>
<h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;google-map&gt;</span><br><span class="line">  &lt;google-map-region v-bind:shape=&quot;cityBoundaries&quot;&gt;</span><br><span class="line">    &lt;google-map-markers v-bind:places=&quot;iceCreamShops&quot;&gt;&lt;/google-map-markers&gt;</span><br><span class="line">  &lt;/google-map-region&gt;</span><br><span class="line">&lt;/google-map&gt;</span><br></pre></td></tr></table></figure>

<p>在这个组件里，所有 <code>&lt;google-map&gt;</code> 的后代都需要访问一个 <code>getMap</code> 方法，以便知道要跟哪个地图进行交互。不幸的是，使用 <code>$parent</code> property 无法很好的扩展到更深层级的嵌套组件上。这也是依赖注入的用武之地，它用到了两个新的实例选项：<code>provide</code> 和 <code>inject</code>。</p>
<p><code>provide</code> 选项允许我们指定我们想要<strong>提供</strong>给后代组件的数据/方法。在这个例子中，就是 <code>&lt;google-map&gt;</code> 内部的 <code>getMap</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">provide: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    getMap: this.getMap</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在任何后代组件里，我们都可以使用 <code>inject</code> 选项来接收指定的我们想要添加在这个实例上的 property：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inject: [&#x27;getMap&#x27;]</span><br></pre></td></tr></table></figure>

<h2 id="Vue-use"><a href="#Vue-use" class="headerlink" title="Vue.use"></a>Vue.use</h2><p>Vue.use(Object | Function)</p>
<ul>
<li><p>Object ,必须提供 install 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>Function,它会被作为 install 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import moment from &quot;moment&quot;;</span><br><span class="line">const momentPlugin = &#123;</span><br><span class="line">  install: function (Vue: any) &#123;</span><br><span class="line">    Object.defineProperty(Vue.prototype, &quot;$moment&quot;, &#123; value: moment &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export default momentPlugin;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>install 方法调用时，会将 Vue 作为参数传入。 该方法需要在调用 new Vue() <strong>之前</strong>被调用。当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>
<p>还是看代码比较直接，新建plugin文件夹，文件夹下新建plugin.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(Vue.prototype, &#123;</span><br><span class="line">        <span class="attr">$Plugin</span>: &#123;</span><br><span class="line">            <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">&#x27;I am a plugin&#x27;</span>) &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = install</span><br></pre></td></tr></table></figure>

<p> main.js导入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 测试插件</span></span><br><span class="line"><span class="keyword">import</span> Plugin <span class="keyword">from</span> <span class="string">&quot;./plugin/plugin&quot;</span></span><br><span class="line">Vue.use(Plugin)</span><br></pre></td></tr></table></figure>

<p>使用插件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$Plugin()</span><br></pre></td></tr></table></figure>

<p>总结：</p>
<p>Vue.use主要是执行install方法，而install主要也是执行Vue.prototype方法。所以，其实Vue.use()方法的核心就是Vue.prototype，只不过又封装了一层,更加的灵活，扩展性更好</p>
<h3 id="饿了么"><a href="#饿了么" class="headerlink" title="饿了么"></a>饿了么</h3><blockquote>
<p>用饿了么UI举例</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line">Vue.use(Element)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>饿了么部分源码</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//types/element-ui.d.ts</span><br><span class="line">export interface InstallationOptions &#123;</span><br><span class="line">  locale: any,</span><br><span class="line">  i18n: any,</span><br><span class="line">  size: string</span><br><span class="line">&#125;</span><br><span class="line">export function install (vue: typeof Vue, options: InstallationOptions): void</span><br><span class="line"></span><br><span class="line">//src/index.js</span><br><span class="line">const install = function(Vue, opts = &#123;&#125;) &#123;</span><br><span class="line">  locale.use(opts.locale);</span><br><span class="line">  locale.i18n(opts.i18n);</span><br><span class="line"></span><br><span class="line">  components.forEach(component =&gt; &#123;</span><br><span class="line">    Vue.component(component.name, component);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  Vue.use(InfiniteScroll);</span><br><span class="line">  Vue.use(Loading.directive);</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$ELEMENT = &#123;</span><br><span class="line">    size: opts.size || &#x27;&#x27;,</span><br><span class="line">    zIndex: opts.zIndex || 2000</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  Vue.prototype.$loading = Loading.service;</span><br><span class="line">  Vue.prototype.$msgbox = MessageBox;</span><br><span class="line">  Vue.prototype.$alert = MessageBox.alert;</span><br><span class="line">  Vue.prototype.$confirm = MessageBox.confirm;</span><br><span class="line">  Vue.prototype.$prompt = MessageBox.prompt;</span><br><span class="line">  Vue.prototype.$notify = Notification;</span><br><span class="line">  Vue.prototype.$message = Message;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">/* istanbul ignore if */</span><br><span class="line">if (typeof window !== &#x27;undefined&#x27; &amp;&amp; window.Vue) &#123;</span><br><span class="line">  install(window.Vue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>ue.use</code>就是要运行这个<code>install</code>对应的函数 </p>
<p><strong>总结</strong></p>
<ol>
<li>Vue的插件是一个<strong>对象</strong>, 就像<code>Element</code>.</li>
<li>插件<strong>对象</strong>必须有<code>install</code>字段.</li>
<li><code>install</code>字段是一个函数.</li>
<li>初始化插件<strong>对象</strong>需要通过<code>Vue.use()</code></li>
</ol>
<h2 id="Vue-prototype-xxx"><a href="#Vue-prototype-xxx" class="headerlink" title="Vue.prototype.$xxx"></a>Vue.prototype.$xxx</h2><p>如果需要设置全局变量，在main.js中，Vue实例化的代码里添加。 不想污染全局作用域。这种情况下，你可以通过在 原型 上定义它们使其在每个Vue实例中可用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue.prototype.$echarts = echarts</span><br></pre></td></tr></table></figure>

<p>这样<code>$echarts</code>就在所有Vue实例中可用了,变量前加上$，是防止被组件中的变量意外覆盖。</p>
<h1 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h1><p>Vue 实例在被创建时都要经过一系列的初始化过程 ， 编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等 。 在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">beforeCreate	</span><br><span class="line">组件实例刚刚被创建，组件的el（Vue实例挂载的元素节点，简单来说el的作用就是将当前vue组件生成的实例插入到页面元素中）和data，methods都未被初始化，调用不了</span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &#x27;#app&#x27;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">created			     </span><br><span class="line">实例已经创建完成，data，methods都已经被初始化，可以被调用但是el还处于未被创建状态。如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作</span><br><span class="line"></span><br><span class="line">beforeMount		</span><br><span class="line">template模板已经编译完成，el已经创建完成，但是还没有挂载到页面上，而只是放在内存中</span><br><span class="line"></span><br><span class="line">mounted			</span><br><span class="line">页面渲染完成初始化完毕。可以在 mounted 内部使用 vm.$nextTick。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行</span><br><span class="line"></span><br><span class="line">beforeUpdate	组件更新之前</span><br><span class="line">updated			组件更新完毕	</span><br><span class="line">更新前/后：当data变化时，会触发beforeUpdate和updated方法。</span><br><span class="line"></span><br><span class="line">beforeDestroy	组件销毁前</span><br><span class="line">destroyed		组件销毁后</span><br><span class="line">销毁前/后：在执行destroy方法后，对data的改变不会再触发周期函数，说明此时vue实例已经解除了事件监听以及和dom的绑定，但是dom结构依然存在。</span><br><span class="line"></span><br><span class="line">activated	keep-alive 组件激活时调用。</span><br><span class="line">deactivated	keep-alive 组件停用时调用。</span><br></pre></td></tr></table></figure>

<p>不要在生命周期函数或者回调上使用箭头函数， 因为箭头函数并没有 <code>this</code> ,this指向调用它的VUE实例</p>
<p> 比如 <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code> </p>
<h1 id="vue-router路由"><a href="#vue-router路由" class="headerlink" title="vue-router路由"></a>vue-router路由</h1><h2 id="hash和history"><a href="#hash和history" class="headerlink" title="hash和history"></a><strong>hash和history</strong></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">routes</span>: [...]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p><strong>hash</strong></p>
<p>hash模式下，它指 # 号之后的所有字符，但是他虽然包含在url中，但是不包含在http请求中，所以<strong>改变hash值不会重新加载页面</strong>，对传给后端的url没有任何影响，因此不会重新加载页面。它每次改变都会触发hashchange事件，可以通过给window加上hashchange事件进行监听。它是单页面的标配。</p>
<p><strong>history</strong></p>
<p>利用了HTML5 History Interface中新增的pushState和replaceState方法。这两个方法应用于浏览器的历史记录栈， <strong>而不会引起页面的刷新</strong> ，在当前已有的 back、forward、go 的基础之上，它们提供了对<strong>历史记录进行修改</strong>的功能。 history模式下有一个问题，就是当页面刷新时，他会实实在在的发送请求，把url给传送过去，因此，如果后端没有做处理的话，就会因找不到资源而报404错误，因此使用history模式时可以跟后端进行配合。</p>
<p>下面阐述几种 <code>HTML5</code> 新增的 <code>history API</code> 。<strong>具体如下表：</strong></p>
<table>
<thead>
<tr>
<th>API</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>history.pushState(data, title [, url])</td>
<td>pushState主要用于<strong>往历史记录堆栈顶部添加一条记录</strong>。各参数解析如下：<strong>①data</strong>会在onpopstate事件触发时作为参数传递过去；<strong>②title</strong>为页面标题，当前所有浏览器都会忽略此参数；③<strong>url</strong>为页面地址，可选，缺少时表示为当前页地址</td>
</tr>
<tr>
<td>history.replaceState(data, title [, url])</td>
<td>更改当前的历史记录，参数同上； 上面的pushState是添加，这个更改</td>
</tr>
<tr>
<td>history.state</td>
<td>用于存储以上方法的data数据（即state对象），如果当前URL不是通过pushState或者replaceState产生的，那么history.state是null。</td>
</tr>
<tr>
<td>window.onpopstate</td>
<td>响应pushState或者replaceState的调用。</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>hash</strong></p>
<ul>
<li>url中有#</li>
<li>原理是onhashchange事件</li>
<li><strong>仅 hash 符号之前的内容会被包含在请求中</strong></li>
<li>hash修改的url是同文档的url</li>
<li>hash不会修改浏览器历史记录栈</li>
<li>生成二维码、微信分享页面的时候都会自动过滤掉#后面的参数</li>
</ul>
<p><strong>history</strong></p>
<ul>
<li><p>url中没有#，美观</p>
</li>
<li><p>原理是popstate事件,浏览历史（即history对象）出现变化时，就会触发popstate事件。history.pushState用于在浏览历史中添加历史记录，history.replaceState修改浏览历史中当前纪录，但是并不触发页面刷新</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history.pushState(&#123;color:&#x27;red&#x27;&#125;, &#x27;red&#x27;, &#x27;red&#x27;&#125;)</span><br><span class="line">window.onpopstate = function(event)&#123;</span><br><span class="line">  console.log(event.state)</span><br><span class="line">  if(event.state &amp;&amp; event.state.color === &#x27;red&#x27;)&#123;</span><br><span class="line">    document.body.style.color = &#x27;red&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>全路径内容会被包含在请求中</strong></p>
</li>
<li><p>history修改的url可以是同域的任意url</p>
</li>
<li><p>history会修改浏览器历史记录栈</p>
</li>
<li><p>history模式往往需要后端支持，如果后端nginx没有覆盖路由地址，就会返回404</p>
</li>
</ul>
<h2 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h2><h3 id="手动配置路由"><a href="#手动配置路由" class="headerlink" title="手动配置路由"></a>手动配置路由</h3><p>直接<code>vue add router</code>,或者</p>
<ol>
<li><p>下载vue-router模块  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure></li>
<li><p>创建文件夹，存放路由配置</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> login <span class="keyword">from</span> <span class="string">&quot;../components/login.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> register <span class="keyword">from</span> <span class="string">&quot;../components/register.vue&quot;</span></span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: login,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/register&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: register,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;history&quot;</span>,</span><br><span class="line">  <span class="attr">base</span>: process.env.BASE_URL,</span><br><span class="line">  routes,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.0</span></span><br><span class="line"><span class="comment">// 1. 定义路由组件.</span></span><br><span class="line"><span class="comment">// 也可以从其他文件导入</span></span><br><span class="line"><span class="keyword">const</span> Home = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;Home&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">const</span> About = &#123; <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;About&lt;/div&gt;&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 定义一些路由</span></span><br><span class="line"><span class="comment">// 每个路由都需要映射到一个组件。</span></span><br><span class="line"><span class="comment">// 我们后面再讨论嵌套路由。</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">  &#123; <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: About &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由实例并传递 `routes` 配置</span></span><br><span class="line"><span class="comment">// 你可以在这里输入更多的配置，但我们在这里</span></span><br><span class="line"><span class="comment">// 暂时保持简单</span></span><br><span class="line"><span class="keyword">const</span> router = VueRouter.createRouter(&#123;</span><br><span class="line">  <span class="comment">// 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。</span></span><br><span class="line">  <span class="attr">history</span>: VueRouter.createWebHashHistory(),</span><br><span class="line">  routes, <span class="comment">// `routes: routes` 的缩写</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>main.js文件中引入router</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router/index&quot;</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">router</span>: router,</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5. 创建并挂载根实例</span></span><br><span class="line"><span class="keyword">const</span> app = Vue.createApp(&#123;&#125;)</span><br><span class="line"><span class="comment">//确保 _use_ 路由实例使</span></span><br><span class="line"><span class="comment">//整个应用支持路由。</span></span><br><span class="line">app.use(router)</span><br><span class="line"></span><br><span class="line">app.mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在，应用已经启动了！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="自动配置路由"><a href="#自动配置路由" class="headerlink" title="自动配置路由"></a>自动配置路由</h3><p>根据文件夹自动配置路由</p>
<p><img src="img/vue/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1.png" alt="自动配置路由"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> routes = []</span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span></span><br><span class="line"><span class="keyword">const</span> routerContext = <span class="built_in">require</span>.context(<span class="string">&#x27;./&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/index\.js$/</span>)</span><br><span class="line"></span><br><span class="line">routerContext.keys().forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// route就是路径</span></span><br><span class="line">  <span class="comment">// 如果是根目录的index不做处理</span></span><br><span class="line">  <span class="keyword">if</span> (route.startsWith(<span class="string">&#x27;./index&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> routerModule = routerContext(route)</span><br><span class="line">  routes = [...routes, ...(routerModule.default || routerModule)]</span><br><span class="line">  <span class="built_in">console</span>.log(routes)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(process.env.BASE_URL)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: isProd &amp;&amp; process.env.VUE_APP_PREVIEW !== <span class="string">&#x27;true&#x27;</span> ? <span class="string">&#x27;/wechatpub/&#x27;</span> : process.env.BASE_URL,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//activity/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 活动路由配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/activity/smashedEgg/:id&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;SmashedEgg&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: &quot;survey&quot; */</span> 					<span class="string">&#x27;@/views/activity/SmashedEgg.vue&#x27;</span>),</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><h3 id="router-view"><a href="#router-view" class="headerlink" title="router-view"></a>router-view</h3><p><code>router-view</code> 将显示与 url 对应的组件。你可以把它放在任何地方，以适应你的布局。<code>&lt;router-view&gt;</code> 渲染的组件还可以内嵌自己的 <code>&lt;router-view&gt;</code>，<strong>根据嵌套路径，渲染嵌套组件</strong>。</p>
<p>因为它也是个组件，所以可以配合 <code>&lt;transition&gt;</code> 和 <code>&lt;keep-alive&gt;</code> 使用。如果两个结合一起用，要确保在内层使用 <code>&lt;keep-alive&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="router-link"><a href="#router-link" class="headerlink" title="router-link"></a>router-link</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!-- 使用 router-link 组件来导航. --&gt;</span><br><span class="line">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span><br><span class="line">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span><br><span class="line">&lt;router-link to=&quot;/foo&quot;&gt;Go to Foo&lt;/router-link&gt;</span><br><span class="line">&lt;router-link to=&quot;/bar&quot;&gt;Go to Bar&lt;/router-link&gt;</span><br></pre></td></tr></table></figure>

<p>要注意，当 <code>&lt;router-link&gt;</code> 对应的路由匹配成功，将自动设置 class 属性值 <code>.router-link-active</code></p>
<p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这跟代码调用 <code>router.push()</code> 是一回事：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>

<h2 id="路由用法"><a href="#路由用法" class="headerlink" title="路由用法"></a>路由用法</h2><h3 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h3><table>
<thead>
<tr>
<th>模式</th>
<th>匹配路径</th>
<th>$route.params</th>
</tr>
</thead>
<tbody><tr>
<td>/user/:username</td>
<td>/user/evan</td>
<td><code>&#123; username: &#39;evan&#39; &#125;</code></td>
</tr>
<tr>
<td>/user/:username/post/:post_id</td>
<td>/user/evan/post/123</td>
<td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td>
</tr>
</tbody></table>
<p>除了 <code>$route.params</code> 外，<a href="https://router.vuejs.org/zh/api/#%E8%B7%AF%E7%94%B1%E5%AF%B9%E8%B1%A1">API 文档</a></p>
<p>当使用路由参数时，例如从 <code>/user/foo</code> 导航到 <code>/user/bar</code>，<strong>原来的组件实例会被复用</strong>。因为两个路由都渲染同个组件，比起销毁再创建，复用则显得更加高效。<strong>不过，这也意味着组件的生命周期钩子不会再被调用</strong>。</p>
<p>复用组件时，想对路由参数的变化作出响应的话，你可以简单地 watch (监测变化) <code>$route</code> 对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    $route(to, <span class="keyword">from</span>) &#123;</span><br><span class="line">      <span class="comment">// 对路由变化作出响应...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者，使用 <code>beforeRouteUpdate</code> <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>，它也可以取消导航：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> User = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// react to route changes...</span></span><br><span class="line">    <span class="comment">// don&#x27;t forget to call next()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="捕获所有路由"><a href="#捕获所有路由" class="headerlink" title="捕获所有路由"></a>捕获所有路由</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当使用通配符路由时，请确保路由的顺序是正确的，也就是说含有通配符的路由应该放在最后</span></span><br><span class="line"><span class="comment">//路由 &#123; path: &#x27;*&#x27; &#125; 通常用于客户端 404 错误。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 会匹配所有路径</span></span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 会匹配以 `/user-` 开头的任意路径</span></span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/user-*&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用一个<em>通配符</em>时，<code>$route.params</code> 内会自动添加一个名为 <code>pathMatch</code> 参数。它包含了 URL 通过<em>通配符</em>被匹配的部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 给出一个路由 &#123; path: &#x27;/user-*&#x27; &#125;</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/user-admin&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$route.params.pathMatch <span class="comment">// &#x27;admin&#x27;</span></span><br><span class="line"><span class="comment">// 给出一个路由 &#123; path: &#x27;*&#x27; &#125;</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&#x27;/non-existing&#x27;</span>)</span><br><span class="line"><span class="built_in">this</span>.$route.params.pathMatch <span class="comment">// &#x27;/non-existing&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p><router-view> 是最顶层的出口，渲染最高级路由匹配到的组件。同样地，一个被渲染组件同样可以包含自己的嵌套 <router-view></p>
<p>嵌套路由的现象：点击了路由跳转之后父路由组件的内容一直呈现；子路由的内容进行切换，地址栏的路径也随之改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 嵌套路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/travel&#x27;</span>, <span class="attr">component</span>: TravelPage,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/travel/america&#x27;</span>, <span class="attr">component</span>: TravelAmericaPage &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/travel/china&#x27;</span>, <span class="attr">component</span>: TravelChinaPage&#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>, <span class="attr">component</span>: AboutPage</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//TravelPage.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;travel&quot;&gt;</span><br><span class="line">    &lt;h2&gt;Travels&lt;/h2&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      //这里展示子组件的内容</span><br><span class="line">      &lt;router-link to=&quot;/travel/america&quot;&gt;America&lt;/router-link&gt;</span><br><span class="line">      &lt;router-link to=&quot;/travel/china&quot;&gt;China&lt;/router-link&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h3 id="命名路由"><a href="#命名路由" class="headerlink" title="命名路由"></a>命名路由</h3><p>有时候，通过一个名称来标识一个路由显得更方便一些（有些路径很长，直接写太麻烦），特别是在链接一个路由，或者是执行一些跳转的时候。你可以在创建 Router 实例的时候，在 <code>routes</code> 配置中给某个路由设置名称。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;/user/:userId&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: User</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>要链接到一个命名路由，可以给 <code>router-link</code> 的 <code>to</code> 属性传一个对象：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;user&#x27;, params: &#123; userId: 123 &#125;&#125;&quot;</span>&gt;</span>User<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这跟代码调用 <code>router.push()</code> 是一回事：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="number">123</span> &#125; &#125;)</span><br></pre></td></tr></table></figure>

<p>这两种方式都会把路由导航到 <code>/user/123</code> 路径。</p>
<h3 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h3><p>命名视图只需两步：第一在router-view添加name属性，第二在路由中用<code>components。</code></p>
<p>有时候想同时（同级）展示多个视图，而不是嵌套展示，例如创建一个布局，有 <code>sidebar</code>（侧导航） 和 <code>main</code>（主内容） 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 <code>router-view</code> 没有设置名字，那么默认为 <code>default</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;router-view class=&quot;view one&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view class=&quot;view two&quot; name=&quot;a&quot;&gt;&lt;/router-view&gt;</span><br><span class="line">&lt;router-view class=&quot;view three&quot; name=&quot;b&quot;&gt;&lt;/router-view&gt;</span><br></pre></td></tr></table></figure>

<p>一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 <strong><code>components</code> 配置（带上 s）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const router = new VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: &#x27;/&#x27;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        default: Foo,</span><br><span class="line">        a: Bar,</span><br><span class="line">        b: Baz</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="重定向和别名"><a href="#重定向和别名" class="headerlink" title="重定向和别名"></a>重定向和别名</h3><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><p>重定向也是通过 <code>routes</code> 配置来完成，下面例子是从 <code>/a</code> 重定向到 <code>/b</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/b&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>重定向的目标也可以是一个命名的路由：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>甚至是一个方法，动态返回重定向目标：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">redirect</span>: <span class="function"><span class="params">to</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 方法接收 目标路由 作为参数</span></span><br><span class="line">      <span class="comment">// return 重定向的 字符串路径/路径对象</span></span><br><span class="line">    &#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h4><p>“重定向”的意思是，<strong>当用户访问 <code>/a</code>时</strong>，URL 将会被替换成 <code>/b</code>，然后匹配路由为 <code>/b</code>，那么“别名”又是什么呢？</p>
<p><code>/a</code> 的别名是 <code>/b</code>，意味着，<strong>当用户访问 <code>/b</code> 时</strong>，URL 会保持为 <code>/b</code>，但是路由匹配则为 <code>/a</code>，就像用户访问 <code>/a</code> 一样。</p>
<p>上面对应的路由配置为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/a&#x27;</span>, <span class="attr">component</span>: A, <span class="attr">alias</span>: <span class="string">&#x27;/b&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>“别名”的功能让你可以自由地将 UI 结构映射到任意的 URL，而不是受限于配置的嵌套路由结构。</p>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p><strong>方式一：通过 params 传参</strong></p>
<ul>
<li><p>编程式：</p>
<ul>
<li>```<br>data:{<br>  username: ‘’<br>},<br>login() {<br>  …<br>  this.$router.push({<pre><code>name: &#39;home&#39;, //注意使用 params 时一定不能使用 path
params: &#123; username: this.username &#125;,
</code></pre>
  })<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 声明式：</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;router-link :to=&quot;&#123; name: &#x27;home&#x27;, params: &#123; username: username &#125; &#125;&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>取值：<code>this.$route.params.username</code></p>
</li>
</ul>
<p><strong>方式二：通过 query 传参</strong></p>
<ul>
<li><p>编程式：</p>
<ul>
<li>```<br>data:{<br>  username: ‘’<br>},<br>login() {<br>  …<br>  this.$router.push({<pre><code>path: &#39;/home&#39;,
query: &#123; username: this.username &#125;,
</code></pre>
  })<br>}<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 声明式：</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    &lt;router-link :to=&quot;&#123; path: &#x27;/home&#x27;, query: &#123; username: username &#125; &#125;&quot;&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>取值：<code>this.$route.query.username</code></p>
</li>
</ul>
<p><strong>params 传参后，刷新页面会失去拿到的参数。所以路由参数要修改为 <code>&#39;/login/:username&#39;</code>（官方称为动态路由）</strong></p>
<h2 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h2><p>路由守卫就是路由跳转过程中的一些<a href="https://so.csdn.net/so/search?q=%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">钩子函数</a> ，在路由跳转的时候，做一些判断或其它的操作。 类似于组件生命周期钩子函数 。</p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>全局路由守卫(全局路由守卫，就是小区大门，整个小区就这一个大门)</p>
<p>beforeEach(to, from, next) 全局前置守卫，路由跳转前触发<br>beforeResolve(to, from, next) 全局解析守卫 在所有组件内守卫和异步路由组件被解析之后触发<br>afterEach(to, from) 全局后置守卫，路由跳转完成后触发</p>
</li>
<li><p>路由独享守卫</p>
<p>beforeEnter(to,from,next) 路由对象单个路由配置 ，单个路由进入前触发</p>
</li>
<li><p>组件路由守卫(跟 methods: {}等同级别书写，组件路由守卫是写在每个单独的 vue 文件里面的路由守卫)</p>
<p>beforeRouteEnter(to,from,next) 在组件生命周期beforeCreate阶段触发<br>beforeRouteUpdadte(to,from,next) 当前路由改变时触发<br>beforeRouteLeave(to,from,next) 导航离开该组件的对应路由时触发</p>
</li>
</ul>
<p><strong>参数</strong><br>to： 即将要进入的目标路由对象</p>
<p>from： 即将要离开的路由对象</p>
<p>next：一定要调用该方法来 <strong>resolve</strong> 这个钩子。执行效果依赖 <code>next</code> 方法的调用参数。</p>
<ul>
<li><code>next()</code> : 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 <code>confirmed</code> (确认的)。</li>
<li><code>next(false)</code> : 中断当前的导航。如果浏览器的 <code>URL</code> 改变了 (可能是用户手动或者浏览器后退按钮)，那么 <code>URL</code> 地址会重置到 <code>from</code> 路由对应的地址。</li>
<li><code>next(&#39;/&#39;)</code> 或者 <code>next(&#123; path: &#39;/&#39; &#125;)</code> : 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向 <code>next</code> 传递任意位置对象，且允许设置诸如 <code>replace: true</code>、<code>name: &#39;home&#39;</code> 之类的选项以及任何用在 <a href="https://link.juejin.cn/?target=https://router.vuejs.org/zh/api/%23to"><code>router-link</code> 的 <code>to</code> prop</a> 或 <a href="https://link.juejin.cn/?target=https://router.vuejs.org/zh/api/%23router-push"><code>router.push</code></a> 中的选项。</li>
<li><strong><code>next(error)</code></strong> : (2.4.0+) 如果传入 <code>next</code> 的参数是一个 <code>Error</code> 实例，则导航会被终止且该错误会被传递给 <a href="https://link.juejin.cn/?target=https://router.vuejs.org/zh/api/%23router-onerror"><code>router.onError()</code></a> 注册过的回调。。</li>
</ul>
<h3 id="路由前置守卫"><a href="#路由前置守卫" class="headerlink" title="路由前置守卫"></a>路由前置守卫</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123; ... &#125;)</span><br><span class="line"></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>确保 <code>next</code> 函数在任何给定的导航守卫中都被严格调用一次。它可以出现多于一次，但是只能在所有的逻辑路径都不重叠的情况下，否则钩子永远都不会被解析或报错</strong></p>
<p>以一个简单的例子来解释router.beforeEach<br>假设我们现在做一个这样的需求，用户在未登录的时候进入任意页面，我们就让用户跳转到登录页面，在已登录的时候让用户正常跳转到点击的页面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BAD</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="comment">// 如果用户未能验证身份，则 `next` 会被调用两次</span></span><br><span class="line">  next()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// GOOD</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.name !== <span class="string">&#x27;Login&#x27;</span> &amp;&amp; !isAuthenticated) next(&#123; <span class="attr">name</span>: <span class="string">&#x27;Login&#x27;</span> &#125;)</span><br><span class="line">  <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="组件内的守卫"><a href="#组件内的守卫" class="headerlink" title="组件内的守卫"></a>组件内的守卫</h3><ul>
<li><code>beforeRouteEnter</code></li>
<li><code>beforeRouteUpdate</code> (2.2 新增)</li>
<li><code>beforeRouteLeave</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 在渲染该组件的对应路由被验证前调用</span></span><br><span class="line">   <span class="comment">// 不能获取组件实例 `this` ！</span></span><br><span class="line">   <span class="comment">// 因为当守卫执行时，组件实例还没被创建！</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">   <span class="comment">// 举例来说，对于一个带有动态参数的路径 `/users/:id`，在 `/users/1` 和 `/users/2` 之间跳转的时候，</span></span><br><span class="line">   <span class="comment">// 由于会渲染同样的 `UserDetails` 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">   <span class="comment">// 因为在这种情况发生的时候，组件已经挂载好了，导航守卫可以访问组件实例 `this`</span></span><br><span class="line"> &#125;,</span><br><span class="line"> <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span></span>)</span> &#123;</span><br><span class="line">   <span class="comment">// 在导航离开渲染该组件的对应路由时调用</span></span><br><span class="line">   <span class="comment">// 与 `beforeRouteUpdate` 一样，它可以访问组件实例 `this`</span></span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>



<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="router-push"><a href="#router-push" class="headerlink" title="router.push"></a>router.push</h3><p><strong>注意：在 Vue 实例内部，你可以通过 <code>$router</code> 访问路由实例。因此你可以调用 <code>this.$router.push</code>。</strong></p>
<p><code>router.push</code> 这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，则回到之前的 URL。</p>
<p>当你点击 <code>&lt;router-link&gt;</code> 时，这个方法会在内部调用，所以说，点击 <code>&lt;router-link :to=&quot;...&quot;&gt;</code> 等同于调用 <code>router.push(...)</code></p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot;&gt;</code></td>
<td><code>router.push(...)</code></td>
</tr>
</tbody></table>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">router.push(<span class="string">&#x27;home&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;home&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名的路由</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; <span class="attr">userId</span>: <span class="string">&#x27;123&#x27;</span> &#125;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带查询参数，变成 /register?plan=private</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;register&#x27;</span>, <span class="attr">query</span>: &#123; <span class="attr">plan</span>: <span class="string">&#x27;private&#x27;</span> &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：如果提供了 <code>path</code>，<code>params</code> 会被忽略，上述例子中的 <code>query</code> 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 <code>name</code> 或手写完整的带有参数的 <code>path</code>：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> userId = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">router.push(&#123; <span class="attr">name</span>: <span class="string">&#x27;user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">`/user/<span class="subst">$&#123;userId&#125;</span>`</span> &#125;) <span class="comment">// -&gt; /user/123</span></span><br><span class="line"><span class="comment">// 这里的 params 不生效</span></span><br><span class="line">router.push(&#123; <span class="attr">path</span>: <span class="string">&#x27;/user&#x27;</span>, <span class="attr">params</span>: &#123; userId &#125;&#125;) <span class="comment">// -&gt; /user</span></span><br></pre></td></tr></table></figure>

<h3 id="router-replace"><a href="#router-replace" class="headerlink" title="router.replace"></a>router.replace</h3><p>跟 <code>router.push</code> 很像，唯一的不同就是，它不会向 history 添加新记录，而是跟它的方法名一样 —— 替换掉当前的 history 记录。</p>
<table>
<thead>
<tr>
<th>声明式</th>
<th>编程式</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;router-link :to=&quot;...&quot; replace&gt;</code></td>
<td><code>router.replace(...)</code></td>
</tr>
</tbody></table>
<h3 id="router-go"><a href="#router-go" class="headerlink" title="router.go"></a>router.go</h3><p>这个方法的参数是一个整数，意思是在 history 记录中向前或者后退多少步，类似 <code>window.history.go(n)</code>。</p>
<p>例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在浏览器记录中前进一步，等同于 history.forward()</span></span><br><span class="line">router.go(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后退一步记录，等同于 history.back()</span></span><br><span class="line">router.go(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前进 3 步记录</span></span><br><span class="line">router.go(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 history 记录不够用，那就默默地失败呗</span></span><br><span class="line">router.go(-<span class="number">100</span>)</span><br><span class="line">router.go(<span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h1 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h1><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="comment">// 创建一个新的 store 实例</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(store.state.count) <span class="comment">// -&gt; 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Vuex 通过store选项，提供了一种机制将状态从根组件“注入”到每一个子组件中</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">store</span>: store,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.$store.state.count)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>由于 Vuex 的状态存储是响应式的，从 store 实例中读取状态最简单的方法就是在<a href="https://cn.vuejs.org/guide/computed.html">计算属性</a>中返回某个状态</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 创建和挂载根实例。</span></span><br><span class="line">  <span class="comment">// 记得要通过 router 配置参数注入路由，</span></span><br><span class="line">  <span class="comment">// 从而让整个应用都有路由功能</span></span><br><span class="line">  <span class="attr">router</span>: router,</span><br><span class="line">  store,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&#x27;#app&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到</span></span><br><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class="line">  <span class="comment">//从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当一个组件需要获取多个状态的时候，将这些状态都声明为计算属性会有些重复和冗余。为了解决这个问题，我们可以使用 mapState 辅助函数帮助我们生成计算属性</span></span><br><span class="line"><span class="comment">// 在单独构建的版本中辅助函数为 Vuex.mapState</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: mapState(&#123;</span><br><span class="line">    <span class="comment">// 箭头函数可使代码更简练</span></span><br><span class="line">    <span class="attr">count</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传字符串参数 &#x27;count&#x27; 等同于 `state =&gt; state.count`</span></span><br><span class="line">    <span class="attr">countAlias</span>: <span class="string">&#x27;count&#x27;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class="line">    countPlusLocalState (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + <span class="built_in">this</span>.localCount</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当映射的计算属性的名称与 state 的子节点名称相同时，我们也可以给 <code>mapState</code> 传一个字符串数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">&#x27;count&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">todos</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;...&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneTodos</span>: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  doneTodosCount () &#123;</span><br><span class="line">    <span class="comment">//Getter 会暴露为 store.getters 对象，你可以以属性的形式访问这些值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.doneTodosCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mapGetters</code> 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">&#x27;doneTodosCount&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;anotherGetter&#x27;</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...mapGetters(&#123;</span><br><span class="line">  <span class="comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span></span><br><span class="line">  <span class="attr">doneCount</span>: <span class="string">&#x27;doneTodosCount&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state,n) &#123;</span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count+=n</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>你可以向 <code>store.commit</code> 传入额外的参数，即 mutation 的<strong>载荷（payload）</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种方式提交</span></span><br><span class="line">store.commit(<span class="string">&quot;increment&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">mount</span>: n,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">store.commit(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;increment&quot;</span>,</span><br><span class="line">  <span class="attr">mount</span>: n,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Mutation 必须是同步函数</p>
</blockquote>
<h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Action 类似于 mutation，不同在于：</p>
<ul>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
<li>Action 可以包含任意<strong>异步操作</strong>(请求在这里操作)。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Action 函数接受一个与 <strong>store 实例</strong>具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实践中，我们会经常用到 ES2015 的 参数解构 (opens new window)来简化代码</span></span><br><span class="line"><span class="attr">actions</span>: &#123;</span><br><span class="line">    increment (&#123; commit &#125;) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Action 通过 <code>store.dispatch</code> 方法触发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">store.dispatch(<span class="string">&#x27;increment&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>Actions 支持同样的载荷方式和对象方式进行分发：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">&#x27;incrementAsync&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;incrementAsync&#x27;</span>,</span><br><span class="line">  <span class="attr">amount</span>: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以在 action 内部执行<strong>异步</strong>操作</p>
</blockquote>
<h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  <span class="attr">state</span>: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  <span class="attr">mutations</span>: &#123; ... &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: moduleA,</span><br><span class="line">    <span class="attr">b</span>: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<h2 id="vuex项目"><a href="#vuex项目" class="headerlink" title="vuex项目"></a>vuex项目</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">├── api</span><br><span class="line">│   └── ... # 抽取出API请求</span><br><span class="line">├── components</span><br><span class="line">│   ├── App.vue</span><br><span class="line">│   └── ...</span><br><span class="line">└── store</span><br><span class="line">    ├── index.js          # 我们组装模块并导出 store 的地方</span><br><span class="line">    ├── getters.js        # 根级别的 action</span><br><span class="line">    ├── mutations.js      # 根级别的 mutation</span><br><span class="line">    └── modules</span><br><span class="line">        ├── user.js       # </span><br><span class="line">        └── market.js     # </span><br></pre></td></tr></table></figure>

<h3 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="keyword">import</span> getters <span class="keyword">from</span> <span class="string">&#x27;./getters&#x27;</span></span><br><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./modules/user&#x27;</span></span><br><span class="line"><span class="keyword">import</span> market <span class="keyword">from</span> <span class="string">&#x27;./modules/market&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    user,</span><br><span class="line">    market</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="getters-js"><a href="#getters-js" class="headerlink" title="getters.js"></a>getters.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">userInfo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.userInfo,</span><br><span class="line">  <span class="attr">fullInfo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.fullInfo,</span><br><span class="line">  <span class="attr">areaList</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.user.areaList,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> market = &#123;</span><br><span class="line">  <span class="attr">homePage</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.market.homePage,</span><br><span class="line">  <span class="attr">goodsInfo</span>: <span class="function"><span class="params">state</span> =&gt;</span> state.market.goodsInfo,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">  ...user,</span><br><span class="line">  ...market</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> getters</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="user-js"><a href="#user-js" class="headerlink" title="user.js"></a>user.js</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable no-unused-vars */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化，向后端请求用户信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  getUserCoreInfo,</span><br><span class="line">  getUserFullInfo,</span><br><span class="line">  getCityDropDown,</span><br><span class="line"> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/api/user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">userInfo</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">fullInfo</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">areaList</span>: &#123;&#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">SET_CORE_INFO</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.userInfo = data</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">SET_FULL_INFO</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.fullInfo = data</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">SET_AREA_LIST</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.areaList = data</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="keyword">async</span> GetUserCoreInfo (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> getUserCoreInfo()</span><br><span class="line">      commit(<span class="string">&#x27;SET_CORE_INFO&#x27;</span>, result.data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> GetUserFullInfo (&#123; commit &#125;) &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> getUserFullInfo()</span><br><span class="line">      commit(<span class="string">&#x27;SET_FULL_INFO&#x27;</span>, result.data)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">async</span> EditUserFullInfo (&#123; commit &#125;, params) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">await</span> editUserFullInfo(params)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> user</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    userCoreInfo () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$store.getters.userInfo</span><br><span class="line">   &#125;</span><br><span class="line">&#125;,</span><br><span class="line">created () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; dispatch &#125; = <span class="built_in">this</span>.$store</span><br><span class="line">    dispatch(<span class="string">&#x27;GetUserCoreInfo&#x27;</span>)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h1 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h1><h2 id="路由权限"><a href="#路由权限" class="headerlink" title="路由权限"></a>路由权限</h2><ul>
<li>静态路由：固定的路由，没有权限。如login页面</li>
<li>动态路由：根据不同的角色，后端返回不同的路由接口。通过meta中的roles去做筛选</li>
</ul>
<h3 id="store存储路由"><a href="#store存储路由" class="headerlink" title="store存储路由"></a>store存储路由</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址：store/modules/permission</span></span><br><span class="line"><span class="keyword">import</span> &#123; routes <span class="keyword">as</span> constantRoutes &#125; <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据meta.roles去判断该角色是否有路由权限</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPermission</span>(<span class="params">roles, route</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (route.meta &amp;&amp; route.meta.roles) &#123;</span><br><span class="line">    <span class="keyword">return</span> route.meta.roles.some(<span class="function"><span class="params">val</span> =&gt;</span> val === roles)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归动态路由</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>routes 动态路由</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>roles 角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">filterAsyncRoutes</span>(<span class="params">routes, roles</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  routes.forEach(<span class="function"><span class="params">route</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tmp = &#123; ...route &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasPermission(roles, tmp)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (tmp.children) &#123;</span><br><span class="line">        <span class="comment">//后台传来的路由字符串，转换为组件对象</span></span><br><span class="line">        <span class="comment">//       let a = `../views/$&#123;route.component&#125;`;</span></span><br><span class="line">        <span class="comment">//       route.component = () =&gt; import(a); // 导入组件</span></span><br><span class="line">        tmp.children = filterAsyncRoutes(tmp.children, roles)</span><br><span class="line">      &#125;</span><br><span class="line">      res.push(tmp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模拟后端传过来的路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> asyncRoutes = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">redirect</span>: <span class="string">&#x27;/PickupTask&#x27;</span>,</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;首页&#x27;</span>,</span><br><span class="line">      <span class="comment">//纯前端去做动态路由</span></span><br><span class="line">      <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/HomeView.vue&#x27;</span>),</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;PickupTask&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;PickupTask&#x27;</span>,</span><br><span class="line">        <span class="attr">meta</span>: &#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;PickupTask&#x27;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/Sd/PickupTask.vue&#x27;</span>),</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;access&#x27;</span>,</span><br><span class="line">        <span class="attr">hidden</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/demo/Access.vue&#x27;</span>),</span><br><span class="line">        <span class="attr">meta</span>: &#123;</span><br><span class="line">          <span class="attr">title</span>: <span class="string">&#x27;access&#x27;</span>,</span><br><span class="line">          <span class="attr">roles</span>: [<span class="string">&#x27;admin&#x27;</span>],</span><br><span class="line">          <span class="comment">//按钮权限标识</span></span><br><span class="line">          <span class="attr">button</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;btn:access:createUser&#x27;</span>: <span class="string">&#x27;hidden&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;btn:access:editUser&#x27;</span>: <span class="string">&#x27;disable&#x27;</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> permisssion = &#123;</span><br><span class="line">  <span class="comment">// namespaced: true, -&gt; store.dispatch(&#x27;permisssion/generateRoutes&#x27;, &#x27;admin&#x27;);</span></span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="comment">//静态路由+动态路由</span></span><br><span class="line">    <span class="attr">routes</span>: [],</span><br><span class="line">    <span class="comment">//动态路由</span></span><br><span class="line">    <span class="attr">addRoutes</span>: []</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">SET_ROUTES</span>: <span class="function">(<span class="params">state, routes</span>) =&gt;</span> &#123;</span><br><span class="line">      state.addRoutes = routes</span><br><span class="line">      state.routes = constantRoutes.concat(routes)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">generateRoutes</span>(<span class="params">&#123; commit &#125;, roles</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> accessedRoutes = filterAsyncRoutes(asyncRoutes, roles)</span><br><span class="line">        commit(<span class="string">&#x27;SET_ROUTES&#x27;</span>, accessedRoutes)</span><br><span class="line">        resolve(accessedRoutes)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> permisssion</span><br></pre></td></tr></table></figure>

<h3 id="router添加路由"><a href="#router添加路由" class="headerlink" title="router添加路由"></a>router添加路由</h3><p>将store中的动态路由使用addRoute添加(<strong>最新版本去掉了addRoutes只能使用addRoute添加路由</strong>)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址：router/index</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter, &#123; RouteConfig &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isProd = process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> routerContext = <span class="built_in">require</span>.context(<span class="string">&#x27;./&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/index\.js$/</span>);</span><br><span class="line"><span class="comment">//静态路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> routes: any = [];</span><br><span class="line"></span><br><span class="line">routerContext.keys().forEach(<span class="function">(<span class="params">route</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// route就是路径</span></span><br><span class="line">  <span class="comment">// 如果是根目录的index不做处理</span></span><br><span class="line">  <span class="keyword">if</span> (route.startsWith(<span class="string">&#x27;./index&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> routerModule = routerContext(route);</span><br><span class="line">  routes = [...routes, ...(routerModule.default || routerModule)];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 router 实例，然后传 `routes` 配置</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="attr">base</span>: isProd ? <span class="string">&#x27;/vue-demo/&#x27;</span> : process.env.BASE_URL,</span><br><span class="line">  routes,</span><br><span class="line">  <span class="function"><span class="title">scrollBehavior</span>(<span class="params">to, <span class="keyword">from</span>, savedPosition</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (to.hash) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">selector</span>: to.hash,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> registerRouteFresh = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局全局前置守卫</span></span><br><span class="line"><span class="comment"> * to : 将要进入的目标路由对象</span></span><br><span class="line"><span class="comment"> * from : 即将离开的目标路由对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">router.beforeEach(<span class="keyword">async</span> (to: any, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">//设置当前页的title</span></span><br><span class="line">  <span class="built_in">document</span>.title = to.meta.title;</span><br><span class="line">  <span class="keyword">if</span> (to.path === <span class="string">&#x27;/login&#x27;</span> &amp;&amp; <span class="built_in">localStorage</span>.getItem(<span class="string">&#x27;token&#x27;</span>)) &#123;</span><br><span class="line">    next(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(registerRouteFresh);</span><br><span class="line">  <span class="comment">//如果首次或者刷新界面，next(...to, replace: true)会循环遍历路由，</span></span><br><span class="line">  <span class="comment">//如果to找不到对应的路由那么他会再执行一次beforeEach((to, from, next))直到找到对应的路由，</span></span><br><span class="line">  <span class="comment">//我们的问题在于页面刷新以后异步获取数据，直接执行next()感觉路由添加了但是在next()之后执行的，</span></span><br><span class="line">  <span class="comment">//所以我们没法导航到相应的界面。这里使用变量registerRouteFresh变量做记录，直到找到相应的路由以后，把值设置为false然后走else执行next(),整个流程就走完了，路由也就添加完了。</span></span><br><span class="line">  <span class="keyword">if</span> (registerRouteFresh) &#123;</span><br><span class="line">    <span class="comment">//设置路由</span></span><br><span class="line">    <span class="keyword">const</span> accessRoutes = <span class="keyword">await</span> store.dispatch(<span class="string">&#x27;generateRoutes&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>);</span><br><span class="line">    <span class="keyword">let</span> errorPage = &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;404&#x27;</span>,</span><br><span class="line">      <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/404.vue&#x27;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 将404添加进去</span></span><br><span class="line">    <span class="comment">// 现在才添加的原因是：作为一级路由，当刷新，动态路由还未加载，路由就已经做了匹配，找不到就跳到了404</span></span><br><span class="line">    router.addRoute(&#123; ...errorPage &#125;);</span><br><span class="line">    accessRoutes.forEach(<span class="function">(<span class="params">item: RouteConfig</span>) =&gt;</span> &#123;</span><br><span class="line">      router.addRoute(item);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//获取路由配置</span></span><br><span class="line">    <span class="built_in">console</span>.log(router.getRoutes());</span><br><span class="line">    <span class="comment">//通过next(&#123;...to, replace&#125;)解决刷新后路由失效的问题</span></span><br><span class="line">    next(&#123; ...to, <span class="attr">replace</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    registerRouteFresh = <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure>

<h2 id="菜单权限"><a href="#菜单权限" class="headerlink" title="菜单权限"></a>菜单权限</h2><p>路由遍历，通过store路由权限中的permission.state.routes去做处理</p>
<h2 id="按钮权限"><a href="#按钮权限" class="headerlink" title="按钮权限"></a>按钮权限</h2><h3 id="准备：存储按钮标识"><a href="#准备：存储按钮标识" class="headerlink" title="准备：存储按钮标识"></a>准备：存储按钮标识</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址：store/modules/user</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  userInfo,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;@/api&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">role</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">    <span class="attr">mockButton</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;btn:access:createUser&#x27;</span>: <span class="string">&#x27;show&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;btn:access:editUser&#x27;</span>: <span class="string">&#x27;show&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//更改 Vuex 的 store 中的状态的唯一方法是提交 mutation</span></span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="attr">change_role</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.role = data.role</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">change_btn</span>: <span class="function">(<span class="params">state, data</span>) =&gt;</span> &#123;</span><br><span class="line">      state.mockButton = data.mockButton</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> user</span><br></pre></td></tr></table></figure>

<h3 id="指令-1"><a href="#指令-1" class="headerlink" title="指令"></a>指令</h3><p>通过模拟传入按钮标识的属性，去判断按钮是否隐藏或者禁用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址：directive/permission/index</span></span><br><span class="line"><span class="keyword">import</span> permission <span class="keyword">from</span> <span class="string">&#x27;./permissionBtn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  Vue.directive(<span class="string">&#x27;permission&#x27;</span>, permission)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.Vue) &#123;</span><br><span class="line">  <span class="built_in">window</span>[<span class="string">&#x27;permission&#x27;</span>] = permission</span><br><span class="line">  Vue.use(install); <span class="comment">// eslint-disable-line</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">permission.install = install</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> permission</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//地址：directive/permission/permissionBtn</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkPermission</span>(<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; value &#125; = binding</span><br><span class="line">  <span class="keyword">const</span> roles = store.getters &amp;&amp; store.getters.role</span><br><span class="line">  <span class="comment">// 获取模拟权限按钮标识</span></span><br><span class="line">  <span class="keyword">const</span> mockButton = store.getters &amp;&amp; store.getters.mockButton</span><br><span class="line">  <span class="comment">// 设置按钮属性</span></span><br><span class="line">  <span class="keyword">if</span> (mockButton[value] === <span class="string">&#x27;disabled&#x27;</span>) &#123;</span><br><span class="line">    el.disabled = <span class="literal">true</span></span><br><span class="line">    el.setAttribute(<span class="string">&#x27;disabled&#x27;</span>, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mockButton[value] === <span class="string">&#x27;hidden&#x27;</span>) &#123;</span><br><span class="line">    el.style.display = <span class="string">&#x27;none&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (mockButton[value] === <span class="string">&#x27;show&#x27;</span>) &#123;</span><br><span class="line">    el.style.display = <span class="string">&#x27;block&#x27;</span></span><br><span class="line">    el.disabled = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// throw new Error(`need roles! Like v-permission=&quot;[&#x27;admin&#x27;,&#x27;editor&#x27;]&quot;`)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">inserted</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">    checkPermission(el, binding)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">el, binding</span>)</span> &#123;</span><br><span class="line">    checkPermission(el, binding)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>//应用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;a-button @click=&quot;changeRole&quot;&gt;切换角色&lt;/a-button&gt;</span><br><span class="line">    &lt;span&gt;当前角色：&#123;&#123; role &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;!-- 注意一定要加disabled属性，才能设置它的disabled值 --&gt;</span><br><span class="line">    &lt;a-button :disabled=&quot;false&quot; v-permission=&quot;&#x27;btn:access:createUser&#x27;&quot;&gt;</span><br><span class="line">      新建用户</span><br><span class="line">    &lt;/a-button&gt;</span><br><span class="line">    &lt;a-button :disabled=&quot;false&quot; v-permission=&quot;&#x27;btn:access:editUser&#x27;&quot;&gt;</span><br><span class="line">      编辑用户</span><br><span class="line">    &lt;/a-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123; Vue, Component, Watch &#125; from &quot;vue-property-decorator&quot;;</span><br><span class="line">import permission from &quot;@/directive/permission/index.js&quot;; // 权限判断指令</span><br><span class="line">// import checkPermission from &#x27;@/utils/permission&#x27; // 权限判断函数</span><br><span class="line">@Component(&#123;</span><br><span class="line">  directives: &#123;</span><br><span class="line">    permission,</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    role() &#123;</span><br><span class="line">      return this.$store.getters.role;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br><span class="line">export default class Access extends Vue &#123;</span><br><span class="line">  get role() &#123;</span><br><span class="line">    return this.$store.getters.role;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeRole() &#123;</span><br><span class="line">    //设置按钮权限</span><br><span class="line">    this.$store.commit(&quot;change_btn&quot;, &#123;</span><br><span class="line">      mockButton:</span><br><span class="line">        this.role === &quot;admin&quot;</span><br><span class="line">          ? &#123;</span><br><span class="line">              &quot;btn:access:createUser&quot;: &quot;hidden&quot;,</span><br><span class="line">              &quot;btn:access:editUser&quot;: &quot;disabled&quot;,</span><br><span class="line">            &#125;</span><br><span class="line">          : &#123;</span><br><span class="line">              &quot;btn:access:createUser&quot;: &quot;show&quot;,</span><br><span class="line">              &quot;btn:access:editUser&quot;: &quot;show&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    //设置角色</span><br><span class="line">    this.$store.commit(&quot;change_role&quot;, &#123;</span><br><span class="line">      role: this.role === &quot;admin&quot; ? &quot;edit&quot; : &quot;admin&quot;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Array&#125;</span> <span class="variable">value</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Boolean&#125;</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@example </span>see @/views/permission/directive.vue</span></span><br><span class="line"><span class="comment"> * 除了使用指令，也可以使用函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPermission</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value &amp;&amp; value <span class="keyword">instanceof</span> <span class="built_in">Array</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> roles = store.getters &amp;&amp; store.getters.roles</span><br><span class="line">    <span class="keyword">const</span> permissionRoles = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> hasPermission = roles.some(<span class="function"><span class="params">role</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> permissionRoles.includes(role)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> hasPermission</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">`need roles! Like v-permission=&quot;[&#x27;admin&#x27;,&#x27;editor&#x27;]&quot;`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;a-button</span><br><span class="line">      v-if=&quot;hasPerms(&#x27;btn:access:createUser&#x27;)&quot;</span><br><span class="line">      :disable=&quot;hasPerms(&#x27;btn:access:createUser&#x27;)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      新建用户</span><br><span class="line">    &lt;/a-button&gt;</span><br><span class="line">    &lt;a-button</span><br><span class="line">      v-if=&quot;hasPerms(&#x27;btn:access:editUser&#x27;)&quot;</span><br><span class="line">      :disable=&quot;hasPerms(&#x27;btn:access:editUser&#x27;)&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      编辑用户</span><br><span class="line">    &lt;/a-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script lang=&#x27;ts&#x27;&gt;</span><br><span class="line">import &#123; Vue, Component, Watch &#125; from &quot;vue-property-decorator&quot;;</span><br><span class="line">import checkPermission from &quot;@/utils/permission&quot;; // 权限判断函数</span><br><span class="line">@Component</span><br><span class="line">export default class Access extends Vue &#123;</span><br><span class="line">  hasPerms(params) &#123;</span><br><span class="line">    return checkPermission(params);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="vue-class-component"><a href="#vue-class-component" class="headerlink" title="vue-class-component"></a>vue-class-component</h1><p>vue2.x 对 TS 的支持并不友好，所以 vue2.x 跟 TS 的整合，通常需要基于 vue-class-component 来用基于 class（类） 的组件书写方式。</p>
<p>然后现在 vue3.x 已出，对 TS 很友好的支持，所以使用 vue3.x 的话暂时就不需要这种写法了。</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p><a href="https://www.jianshu.com/p/adfe275b731e">https://www.jianshu.com/p/adfe275b731e</a></p>
<h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>Vue Class Component 是一个可以让你使用Class风格语法编写Vue组件的库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;button v-on:click=&quot;decrement&quot;&gt;-&lt;/button&gt;</span><br><span class="line">    &#123;&#123; count &#125;&#125;</span><br><span class="line">    &lt;button v-on:click=&quot;increment&quot;&gt;+&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Vue from &#x27;vue&#x27;</span><br><span class="line">import Component from &#x27;vue-class-component&#x27;</span><br><span class="line"></span><br><span class="line">// 使用Class风格定义组件</span><br><span class="line">@Component</span><br><span class="line">export default class Counter extends Vue &#123;</span><br><span class="line">  // Class的属性将是组件的data</span><br><span class="line">  count = 0</span><br><span class="line"></span><br><span class="line">  // Methods will be component methods</span><br><span class="line">  increment() &#123;</span><br><span class="line">    this.count++</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  decrement() &#123;</span><br><span class="line">    this.count--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>可以使用通过<code>@Component</code>装饰器标注Class, 来用直观和标准的Class语法定义组件的data和方法. 你可以简单地使用Class风格的组件代替组件定义, 因为它等价于普通的使用对象定义的组件.</p>
<p>通过使用Class风格定义的组件, 你不但要改变语法, 还要利用一些ECMAScript语法特性, 比如Class继承和装饰器. Vue Class Component 也提供了一个<a href="https://links.jianshu.com/go?to=guide/extend-and-mixins.md%23Mixins"><code>mixins</code> 帮助</a> 来继承mixin, 以及一个 <a href="https://links.jianshu.com/go?to=guide/custom-decorators.md"><code>createDecorator</code> 方法</a>来简单地创建你自己的修饰器.你或许也需要使用  <a href="https://links.jianshu.com/go?to=https://github.com/kaorun343/vue-property-decorator">Vue Property Decorator</a> 提供的 <code>@Prop</code> 和 <code>@Watch</code> 装饰器.</p>
<h3 id="Class-组件"><a href="#Class-组件" class="headerlink" title="Class 组件"></a>Class 组件</h3><p><code>@Componen</code>装饰器使你的类成为一个Vue组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HelloWorld class will be a Vue component</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>使用Class属性来初始化 <code>data</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">@Component</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义 component 的 data</span></span></span><br><span class="line"><span class="javascript">  message = <span class="string">&#x27;Hello World!&#x27;</span></span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>The above component renders 上面的组件会在<code>&lt;div&gt;</code>中的组件data <code>message</code>中渲染<code>Hello World!</code></p>
<p><strong>注意如果初始化的值是 <code>undefined</code>,</strong> Class属性将不是响应式的, 意思就是当其发生修改后, 将不会被侦测到:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// `message` 将不是响应式数据</span></span><br><span class="line">  message = <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止这种情况, 你需要使用 <code>null</code> 来赋值, 或者使用 <code>data</code> 钩子来代替:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// `message` 将是响应式</span></span><br><span class="line">  message = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// `hello` 将是响应式的, 因为在data钩子里</span></span><br><span class="line">      <span class="attr">hello</span>: <span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h3><p>组件 <code>methods</code> 将直接定义在Class方法属性中:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;hello&quot;</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">@Component</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义一个组件方法</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">&#x27;Hello World!&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Computed计算属性"><a href="#Computed计算属性" class="headerlink" title="Computed计算属性"></a>Computed计算属性</h3><p>计算属性可以通过Class属性的 getter / setter 定义:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">@Component</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">  firstName = <span class="string">&#x27;John&#x27;</span></span></span><br><span class="line"><span class="javascript">  lastName = <span class="string">&#x27;Doe&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义计算属性的 getter</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 定义计算属性的 setter</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> splitted = value.split(<span class="string">&#x27; &#x27;</span>)</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.firstName = splitted[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.lastName = splitted[<span class="number">1</span>] || <span class="string">&#x27;&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">&#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="额外的钩子"><a href="#额外的钩子" class="headerlink" title="额外的钩子"></a>额外的钩子</h3><p>如果你使用Vue的插件, 比如<a href="https://links.jianshu.com/go?to=https://router.vuejs.org/">Vue Router</a>, 你或许需要Class组件来解决它们提供的钩子. 在这个例子中, <code>Component.registerHooks</code>允许你注册这些钩子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// class-component-hooks.js</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由钩子函数的名字注册</span></span><br><span class="line">Component.registerHooks([</span><br><span class="line">  <span class="string">&#x27;beforeRouteEnter&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeRouteLeave&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeRouteUpdate&#x27;</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>在注册完这些钩子后, 就可以在Class组件中把它们当作Class属性方法来使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeRouteEnter&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeRouteUpdate&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;beforeRouteLeave&#x27;</span>)</span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐在单独的文件中写注册钩子的代码, 因为你需要在其他组件定义前注册它们. 你可以在文件顶部使用 <code>import</code> 引入:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定在引入其他组件前注册</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./class-component-hooks&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="扩展-和-Mixins"><a href="#扩展-和-Mixins" class="headerlink" title="扩展 和 Mixins"></a>扩展 和 Mixins</h3><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>你可以扩展一个存在的Class组件, 类似于原生的Class继承. 想象你有下面的名为Super的Class组件:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// super.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个叫super的Class组件</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  superValue = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以扩展他, 通过使用原生的Class继承语法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Super <span class="keyword">from</span> <span class="string">&#x27;./super&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展  名为Super的Class组件</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.superValue) <span class="comment">// -&gt; Hello</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 名为Super的Class组件必须是一个Class组件. 换句话说, 它需要继承作为原本的<code>Vue</code>构造器以及被 <code>@Component</code> 装饰器装饰.</p>
<h4 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h4><p>Vue Class Component 提供 <code>mixins</code> 助手函数来在Class风格中使用 <a href="https://links.jianshu.com/go?to=https://vuejs.org/v2/guide/mixins.html">mixins</a>. 通过使用<code>mixins</code>助手, TypeScript 可以推断mixin类型以及在组件类型中继承它们.</p>
<p>例子中定义了名为<code>Hello</code> 和 <code>World</code> 的 mixins :</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以定义和组件风格一样的 mixins .</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  hello = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">World</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  world = <span class="string">&#x27;World&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Class组件中使用它们:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Component, &#123; mixins &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Hello, World &#125; <span class="keyword">from</span> <span class="string">&#x27;./mixins&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `mixins` 助手函数代替 `Vue`.</span></span><br><span class="line"><span class="comment">// `mixins` 可以接收任何数量的参数.</span></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> <span class="keyword">extends</span> <span class="title">mixins</span>(<span class="title">Hello</span>, <span class="title">World</span>) </span>&#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.hello + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.world + <span class="string">&#x27;!&#x27;</span>) <span class="comment">// -&gt; Hello World!</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和名为Super的Class组件一样, 所有的mixins 必须被定义为一个 Class 组件.</p>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p><a href="https://github.com/kaorun343/vue-property-decorator#readme">https://github.com/kaorun343/vue-property-decorator#readme</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/191443950">https://zhuanlan.zhihu.com/p/191443950</a></p>
<p><a href="https://blog.csdn.net/yusirxiaer/article/details/112364800">https://blog.csdn.net/yusirxiaer/article/details/112364800</a></p>
<p>vue-property-decorator 是在 <code>vue-class-component</code> 上增强了更多的结合 <code>Vue</code> 特性的装饰器</p>
<h3 id="Prop-1"><a href="#Prop-1" class="headerlink" title="Prop"></a>Prop</h3><p><strong>@Prop(options: (PropOptions | Constructor[] | Constructor) = {})</strong></p>
<p><code>@Prop</code>装饰器接收一个参数，这个参数可以有三种写法：</p>
<ul>
<li><code>Constructor</code>，例如<code>String，Number，Boolean</code>等，指定 <code>prop</code> 的类型；</li>
<li><code>Constructor[]</code>，指定 <code>prop</code> 的可选类型；</li>
<li><code>PropOptions</code>，可以使用以下选项：<code>type，default，required，validator</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Prop &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @Prop(<span class="built_in">String</span>) public propA: string | <span class="literal">undefined</span></span><br><span class="line">  @Prop([<span class="built_in">String</span>, <span class="built_in">Number</span>]) public propB!: string | number</span><br><span class="line">  @Prop(&#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">default</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  public readonly propC!: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于下面的js写法 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">propA</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propB</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">propC</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">      <span class="attr">defalut</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PropSync"><a href="#PropSync" class="headerlink" title="PropSync"></a><strong>PropSync</strong></h3><p><code>@PropSync</code>装饰器与<code>@prop</code>用法类似，二者的区别在于：</p>
<ul>
<li><p><code>@PropSync</code> 装饰器接收两个参数：</p>
<ul>
<li> <code>propName: string</code> 表示父组件传递过来的属性名；</li>
<li> <code>options: Constructor | Constructor[] | PropOptions</code> 与<code>@Prop</code>的第一个参数一致；</li>
</ul>
</li>
<li><p><code>@PropSync</code> 会生成一个新的计算属性。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, PropSync &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">@PropSync(<span class="string">&#x27;propA&#x27;</span>, &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="string">&#x27;abc&#x27;</span> &#125;) public syncedPropA!: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于下面的js写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">propA</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">syncedPropA</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.propA</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;update:propA&#x27;</span>, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意： @PropSync 需要配合父组件的 .sync 修饰符使用</strong></p>
<p><comp :propA.sync="bar"></comp><br>会被扩展为：</p>
<p>&lt;comp :propA=”bar” @update:propA=”val =&gt; bar = val”&gt;</comp><br>当子组件需要更新 propA的值时，它需要显式地触发一个更新事件：</p>
<p>this.$emit(‘update:propA’, newValue)</p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a><strong>Model</strong></h3><p><a href="https://blog.csdn.net/weixin_47232046/article/details/109738816">https://blog.csdn.net/weixin_47232046/article/details/109738816</a></p>
<p><strong>@Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = {})</strong></p>
<p><code>@Model</code>装饰器允许我们在一个组件上自定义<code>v-model</code>，接收两个参数：</p>
<ul>
<li><code>event: string</code> 事件名。</li>
<li><code>options: Constructor | Constructor[] | PropOptions</code> 与<code>@Prop</code>的第一个参数一致。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Model &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @Model(<span class="string">&#x27;change&#x27;</span>, &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">default</span>: <span class="string">&#x27;123&#x27;</span> &#125;) public value!: string</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于下面的js写法</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面例子中指定的是<code>change</code>事件，所以我们还需要在<code>template</code>中加上相应的事件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">:value</span>=<span class="string">&quot;value&quot;</span></span></span><br><span class="line"><span class="tag">    @<span class="attr">change</span>=<span class="string">&quot;$emit(&#x27;change&#x27;, $event.target.value)&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p><strong>@Watch(path: string, options: WatchOptions = {})</strong></p>
<p><code>@Watch</code> 装饰器接收两个参数：</p>
<ul>
<li><code>path: string</code> 被侦听的属性名；</li>
<li>options可以包含两个属性 ：<br><code>immediate?:boolean</code> 侦听开始之后是否立即调用该回调函数； <code>deep?:boolean</code> 被侦听的对象的属性被改变时，是否调用该回调函数；</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Watch &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @Watch(<span class="string">&#x27;msg&#x27;</span>)</span><br><span class="line">  public <span class="function"><span class="title">onMsgChanged</span>(<span class="params">newValue: string, oldValue: string</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Watch(<span class="string">&#x27;arr&#x27;</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  public <span class="function"><span class="title">onArrChanged1</span>(<span class="params">newValue: number[], oldValue: number[]</span>)</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  @Watch(<span class="string">&#x27;arr&#x27;</span>)</span><br><span class="line">  public <span class="function"><span class="title">onArrChanged2</span>(<span class="params">newValue: number[], oldValue: number[]</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于下面的js写法 </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line"><span class="attr">watch</span>: &#123;</span><br><span class="line">  <span class="attr">msg</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&#x27;onMsgChanged&#x27;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">arr</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&#x27;onArrChanged1&#x27;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">handler</span>: <span class="string">&#x27;onArrChanged2&#x27;</span>,</span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br><span class="line"><span class="attr">methods</span>: &#123;</span><br><span class="line">  <span class="function"><span class="title">onMsgVhanged</span>(<span class="params">newValue, oldValue</span>)</span> &#123; &#125;,</span><br><span class="line">  <span class="function"><span class="title">onArrChange1</span>(<span class="params">newValue, oldValue</span>)</span> &#123; &#125;,</span><br><span class="line">  <span class="function"><span class="title">onArrChange2</span>(<span class="params">newValue, oldValue</span>)</span> &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Emit"><a href="#Emit" class="headerlink" title="Emit"></a>Emit</h3><p><strong>@Emit(event?: string)</strong></p>
<ul>
<li><code>@Emit</code> 装饰器接收一个可选参数，该参数是<code>$Emit</code>的第一个参数，充当事件名。如果没有提供这个参数，<code>$Emit</code>会将回调函数名的<code>camelCase</code>转为<code>kebab-case</code>，并将其作为事件名；</li>
<li><code>@Emit</code>会将回调函数的返回值作为第二个参数，如果返回值是一个<code>Promise</code>对象，<code>$emit</code>会在<code>Promise</code>对象被标记为<code>resolved</code>之后触发；</li>
<li><code>@Emit</code>的回调函数的参数，会放在其返回值之后，一起被<code>$emit</code>当做参数使用。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Emit &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"> @Component</span><br><span class="line"> <span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">   count = <span class="number">0</span></span><br><span class="line">   @Emit()</span><br><span class="line">   public <span class="function"><span class="title">addToCount</span>(<span class="params">n: number</span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.count += n</span><br><span class="line">   &#125;</span><br><span class="line">   @Emit(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">   public <span class="function"><span class="title">resetCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="built_in">this</span>.count = <span class="number">0</span></span><br><span class="line">   &#125;</span><br><span class="line">   @Emit()</span><br><span class="line">   public <span class="function"><span class="title">returnValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">10</span></span><br><span class="line">   &#125;</span><br><span class="line">   @Emit()</span><br><span class="line">   public <span class="function"><span class="title">onInputChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> e.target.value</span><br><span class="line">   &#125;</span><br><span class="line">   @Emit()</span><br><span class="line">   public <span class="function"><span class="title">promise</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">         resolve(<span class="number">20</span>)</span><br><span class="line">       &#125;, <span class="number">0</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">等同于下面的js写法 </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">   <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">       <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">methods</span>: &#123;</span><br><span class="line">     <span class="function"><span class="title">addToCount</span>(<span class="params">n</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.count += n</span><br><span class="line">       <span class="built_in">this</span>.$emit(<span class="string">&#x27;add-to-count&#x27;</span>, n)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">resetCount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.count = <span class="number">0</span></span><br><span class="line">       <span class="built_in">this</span>.$emit(<span class="string">&#x27;reset&#x27;</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">returnValue</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.$emit(<span class="string">&#x27;return-value&#x27;</span>, <span class="number">10</span>)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">onInputChange</span>(<span class="params">e</span>)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.$emit(<span class="string">&#x27;on-input-change&#x27;</span>, e.target.value, e)</span><br><span class="line">     &#125;,</span><br><span class="line">     <span class="function"><span class="title">promise</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">       <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">           resolve(<span class="number">20</span>)</span><br><span class="line">         &#125;, <span class="number">0</span>)</span><br><span class="line">       &#125;)</span><br><span class="line">       promise.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">         <span class="built_in">this</span>.$emit(<span class="string">&#x27;promise&#x27;</span>, value)</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><strong>@Ref(refKey?: string)</strong></p>
<p><code>@Ref</code> 装饰器接收一个可选参数，用来指向元素或子组件的引用信息。如果没有提供这个参数，会使用装饰器后面的属性名充当参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Vue, Component, Ref &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Form &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line">@Componentexport <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  @Ref() readonly loginForm!: Form</span><br><span class="line">  @Ref(<span class="string">&#x27;changePasswordForm&#x27;</span>) readonly passwordForm!: Form</span><br><span class="line">  public <span class="function"><span class="title">handleLogin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loginForm.validate(<span class="function"><span class="params">valide</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (valide) &#123;</span><br><span class="line">        <span class="comment">// login...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// error tips</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于下面的js写法 export default &#123;</span></span><br><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="attr">loginForm</span>: &#123;</span><br><span class="line">    <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$refs.loginForm</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">passwordForm</span>: &#123;</span><br><span class="line">    <span class="attr">cache</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.$refs.changePasswordForm</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="自定义装饰器"><a href="#自定义装饰器" class="headerlink" title="自定义装饰器"></a>自定义装饰器</h3><p>Vue Class Component 提供 <code>createDecorator</code> 帮助创建自定义装饰器. <code>createDecorator</code> 接受一个回调函数作为第一个参数, 回调将接受下面的参数:</p>
<ul>
<li><code>options</code>: Vue 组件选项. 改变这个对象将影响所提供的组件.</li>
<li><code>key</code>: 装饰器所需要的属性或方法的键.</li>
<li><code>parameterIndex</code>: 如果自定义装饰器用于参数，则装饰参数的索引.</li>
</ul>
<p>下面例子是创建一个 <code>Log</code> 装饰器, 当修饰器方法被调用时, 打印log信息, 包括方法名和参数:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decorators.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createDecorator &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义 Log 装饰器.</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Log = createDecorator(<span class="function">(<span class="params">options, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 保存原始方法.</span></span><br><span class="line">  <span class="keyword">const</span> originalMethod = options.methods[key]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 覆盖方法.</span></span><br><span class="line">  options.methods[key] = <span class="function"><span class="keyword">function</span> <span class="title">wrapperMethod</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 打印一个 log.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Invoked: <span class="subst">$&#123;key&#125;</span>(`</span>, ...args, <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用原始方法</span></span><br><span class="line">    originalMethod.apply(<span class="built_in">this</span>, args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>作为方法修饰器使用它:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Log &#125; <span class="keyword">from</span> <span class="string">&#x27;./decorators&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 当`hello`方法被调用, 打印一个log</span></span><br><span class="line">  @Log</span><br><span class="line">  <span class="function"><span class="title">hello</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面代码中, 当 <code>hello</code> 被调用, 并传入 <code>42</code>, 将会打印处下面的log:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Invoked: hello( 42 )</span><br></pre></td></tr></table></figure>

<h2 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h2><h3 id="在属性中初始化this的值"><a href="#在属性中初始化this的值" class="headerlink" title="在属性中初始化this的值"></a>在属性中初始化<code>this</code>的值</h3><p>如果你在类的属性中定义一个箭头函数, 箭头函数中访问 <code>this</code> 时, 将无法获取实例. 这是因为当初始化Class属性时, <code>this</code>仅仅时Vue实例的代理:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComp</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  foo = <span class="number">123</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不要这么做</span></span><br><span class="line">  bar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 不能这样更新属性</span></span><br><span class="line">    <span class="comment">// 事实上`this` 不是Vue实例.</span></span><br><span class="line">    <span class="built_in">this</span>.foo = <span class="number">456</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="通常使用生命周期函数代替constructor"><a href="#通常使用生命周期函数代替constructor" class="headerlink" title="通常使用生命周期函数代替constructor"></a>通常使用生命周期函数代替constructor</h3><p>由于原始构造函数被调用来收集初始组件数据, 建议不要自己声明 <code>constructor</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Posts</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  posts = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不要这么做</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    fetch(<span class="string">&#x27;/posts.json&#x27;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(<span class="function"><span class="params">posts</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.posts = posts</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面的代码打算在组件初始化的时候用fetch来获取post列表, 但是fetch将会被调用两次, 因为Vue Class Component的运作</strong></p>
<p>所以推荐写在生命周期函数里, 比如用<code>created</code> 代替 <code>constructor</code>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Component <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span></span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Posts</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  posts = []</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这样做才对哦</span></span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    fetch(<span class="string">&#x27;/posts.json&#x27;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(<span class="function"><span class="params">posts</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.posts = posts</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Vue3快速上手"><a href="#Vue3快速上手" class="headerlink" title="Vue3快速上手"></a>Vue3快速上手</h1><p>深度剖析 Vue3 响应式：<a href="https://mp.weixin.qq.com/s/W5mc4Lb15ve-oJFiCKQKug">https://mp.weixin.qq.com/s/W5mc4Lb15ve-oJFiCKQKug</a></p>
<h2 id="Vue3带来了什么"><a href="#Vue3带来了什么" class="headerlink" title="Vue3带来了什么"></a>Vue3带来了什么</h2><h3 id="性能的提升"><a href="#性能的提升" class="headerlink" title="性能的提升"></a>性能的提升</h3><ul>
<li><p>打包大小减少41%</p>
</li>
<li><p>初次渲染快55%, 更新渲染快133%</p>
</li>
<li><p>内存减少54%</p>
<p>……</p>
</li>
</ul>
<h3 id="源码的升级"><a href="#源码的升级" class="headerlink" title="源码的升级"></a>源码的升级</h3><ul>
<li><p>使用Proxy代替defineProperty实现响应式</p>
</li>
<li><p>重写虚拟DOM的实现和Tree-Shaking</p>
<p>……</p>
</li>
</ul>
<h3 id="拥抱TypeScript"><a href="#拥抱TypeScript" class="headerlink" title="拥抱TypeScript"></a>拥抱TypeScript</h3><ul>
<li>Vue3可以更好的支持TypeScript</li>
</ul>
<h3 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h3><ol>
<li><p>Composition API（组合API）</p>
<ul>
<li>setup配置</li>
<li>ref与reactive</li>
<li>watch与watchEffect</li>
<li>provide与inject</li>
<li>……</li>
</ul>
</li>
<li><p>新的内置组件</p>
<ul>
<li>Fragment </li>
<li>Teleport</li>
<li>Suspense</li>
</ul>
</li>
<li><p>其他改变</p>
<ul>
<li>新的生命周期钩子</li>
<li>data 选项应始终被声明为一个函数</li>
<li>移除keyCode支持作为 v-on 的修饰符</li>
<li>……</li>
</ul>
</li>
</ol>
<h2 id="常用-Composition-API"><a href="#常用-Composition-API" class="headerlink" title="常用 Composition API"></a>常用 Composition API</h2><p>官方文档: <a href="https://v3.cn.vuejs.org/guide/composition-api-introduction.html">https://v3.cn.vuejs.org/guide/composition-api-introduction.html</a></p>
<h3 id="拉开序幕的setup"><a href="#拉开序幕的setup" class="headerlink" title="拉开序幕的setup"></a>拉开序幕的setup</h3><ol>
<li>理解：Vue3.0中一个新的配置项，值为一个函数。</li>
<li>setup是所有<strong style="color:#DD5145">Composition API（组合API）</strong><i style="color:gray;font-weight:bold">“ 表演的舞台 ”</i>。</li>
<li>组件中所用到的：数据、方法等等，均要配置在setup中。</li>
<li>setup函数的两种返回值：<ol>
<li>若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！）</li>
<li><span style="color:#aad">若返回一个渲染函数：则可以自定义渲染内容。（了解）</span></li>
</ol>
</li>
<li>注意点：<ol>
<li>尽量不要与Vue2.x配置混用<ul>
<li>Vue2.x配置（data、methos、computed…）中<strong style="color:#DD5145">可以访问到</strong>setup中的属性、方法。</li>
<li>但在setup中<strong style="color:#DD5145">不能访问到</strong>Vue2.x配置（data、methos、computed…）。</li>
<li>如果有重名, setup优先。</li>
</ul>
</li>
<li>setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合）</li>
</ol>
</li>
</ol>
<h3 id="setup的两个注意点"><a href="#setup的两个注意点" class="headerlink" title="setup的两个注意点"></a>setup的两个注意点</h3><ul>
<li><p>setup执行的时机</p>
<ul>
<li>在beforeCreate之前执行一次，this是undefined。</li>
</ul>
</li>
<li><p>setup的参数</p>
<ul>
<li>props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。</li>
<li>context：上下文对象<ul>
<li>attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 <code>this.$attrs</code>。</li>
<li>slots: 收到的插槽内容, 相当于 <code>this.$slots</code>。</li>
<li>emit: 分发自定义事件的函数, 相当于 <code>this.$emit</code>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ref函数"><a href="#ref函数" class="headerlink" title="ref函数"></a>ref函数</h3><ul>
<li>作用: <strong>定义一个响应式的数据</strong></li>
<li>语法: <code>const xxx = ref(initValue)</code> <ul>
<li>创建一个包含响应式数据的<strong style="color:#DD5145">引用对象（reference对象，简称ref对象）</strong>。</li>
<li>JS中操作数据： <code>xxx.value</code></li>
<li>模板中读取数据: 不需要.value，直接：<code>&lt;div&gt;&#123;&#123;xxx&#125;&#125;&lt;/div&gt;</code></li>
</ul>
</li>
<li>备注：<ul>
<li>接收的数据可以是：基本类型、也可以是对象类型。</li>
<li>基本类型的数据：响应式依然是靠<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>完成的。</li>
<li>对象类型的数据：内部 <i style="color:gray;font-weight:bold">“ 求助 ”</i> 了Vue3.0中的一个新函数—— <code>reactive</code>函数。</li>
</ul>
</li>
</ul>
<h3 id="reactive函数"><a href="#reactive函数" class="headerlink" title="reactive函数"></a>reactive函数</h3><ul>
<li>作用: 定义一个<strong style="color:#DD5145">对象类型</strong>的响应式数据（基本类型不要用它，要用<code>ref</code>函数）</li>
<li>语法：<code>const 代理对象= reactive(源对象)</code>接收一个对象（或数组），返回一个<strong style="color:#DD5145">代理对象（Proxy的实例对象，简称proxy对象）</strong></li>
<li>reactive定义的响应式数据是“深层次的”。</li>
<li>内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。</li>
</ul>
<h3 id="Vue3-0中的响应式原理"><a href="#Vue3-0中的响应式原理" class="headerlink" title="Vue3.0中的响应式原理"></a>Vue3.0中的响应式原理</h3><h4 id="vue2-x的响应式"><a href="#vue2-x的响应式" class="headerlink" title="vue2.x的响应式"></a>vue2.x的响应式</h4><ul>
<li><p>实现原理：</p>
<ul>
<li><p>对象类型：通过<code>Object.defineProperty()</code>对属性的读取、修改进行拦截（数据劫持）。</p>
</li>
<li><p>数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(data, <span class="string">&#x27;count&#x27;</span>, &#123;</span><br><span class="line">    get () &#123;&#125;, </span><br><span class="line">    set () &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>存在问题：</p>
<ul>
<li>新增属性、删除属性, 界面不会更新。</li>
<li>直接通过下标修改数组, 界面不会自动更新。</li>
</ul>
</li>
</ul>
<h4 id="Vue3-0的响应式"><a href="#Vue3-0的响应式" class="headerlink" title="Vue3.0的响应式"></a>Vue3.0的响应式</h4><ul>
<li><p>实现原理: </p>
<ul>
<li><p>通过Proxy（代理）:  拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。</p>
</li>
<li><p>通过Reflect（反射）:  对源对象的属性进行操作。</p>
</li>
<li><p>MDN文档中描述的Proxy与Reflect：</p>
<ul>
<li><p>Proxy：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy</a></p>
</li>
<li><p>Reflect：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">	<span class="comment">// 拦截读取属性值</span></span><br><span class="line">    get (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, prop)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截设置属性值或添加新属性</span></span><br><span class="line">    set (target, prop, value) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, prop, value)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 拦截删除属性</span></span><br><span class="line">    deleteProperty (target, prop) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="built_in">Reflect</span>.deleteProperty(target, prop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">proxy.name = <span class="string">&#x27;tom&#x27;</span>   </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="reactive对比ref"><a href="#reactive对比ref" class="headerlink" title="reactive对比ref"></a>reactive对比ref</h3><ul>
<li>从定义数据角度对比：<ul>
<li> ref用来定义：<strong style="color:#DD5145">基本类型数据</strong>。</li>
<li> reactive用来定义：<strong style="color:#DD5145">对象（或数组）类型数据</strong>。</li>
<li> 备注：ref也可以用来定义<strong style="color:#DD5145">对象（或数组）类型数据</strong>, 它内部会自动通过<code>reactive</code>转为<strong style="color:#DD5145">代理对象</strong>。</li>
</ul>
</li>
<li>从原理角度对比：<ul>
<li> ref通过<code>Object.defineProperty()</code>的<code>get</code>与<code>set</code>来实现响应式（数据劫持）。</li>
<li> reactive通过使用<strong style="color:#DD5145">Proxy</strong>来实现响应式（数据劫持）, 并通过<strong style="color:#DD5145">Reflect</strong>操作<strong style="color:orange">源对象</strong>内部的数据。</li>
</ul>
</li>
<li>从使用角度对比：<ul>
<li> ref定义的数据：操作数据<strong style="color:#DD5145">需要</strong><code>.value</code>，读取数据时模板中直接读取<strong style="color:#DD5145">不需要</strong><code>.value</code>。</li>
<li> reactive定义的数据：操作数据与读取数据：<strong style="color:#DD5145">均不需要</strong><code>.value</code>。</li>
</ul>
</li>
</ul>
<h3 id="计算属性与监视"><a href="#计算属性与监视" class="headerlink" title="计算属性与监视"></a>计算属性与监视</h3><h4 id="computed函数"><a href="#computed函数" class="headerlink" title="computed函数"></a>computed函数</h4><ul>
<li><p>与Vue2.x中computed配置功能一致</p>
</li>
<li><p>写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;computed&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">	<span class="comment">//计算属性——简写</span></span><br><span class="line">    <span class="keyword">let</span> fullName = computed(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> person.firstName + <span class="string">&#x27;-&#x27;</span> + person.lastName</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//计算属性——完整</span></span><br><span class="line">    <span class="keyword">let</span> fullName = computed(&#123;</span><br><span class="line">        <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> person.firstName + <span class="string">&#x27;-&#x27;</span> + person.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="title">set</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> nameArr = value.split(<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            person.firstName = nameArr[<span class="number">0</span>]</span><br><span class="line">            person.lastName = nameArr[<span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="watch函数"><a href="#watch函数" class="headerlink" title="watch函数"></a>watch函数</h4><ul>
<li><p>与Vue2.x中watch配置功能一致</p>
</li>
<li><p>两个小“坑”：</p>
<ul>
<li>监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。</li>
<li>监视reactive定义的响应式数据中某个属性时：deep配置有效。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//情况一：监视ref定义的响应式数据</span></span><br><span class="line">watch(sum,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;sum变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：监视多个ref定义的响应式数据</span></span><br><span class="line">watch([sum,msg],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;sum或msg变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 情况三：监视reactive定义的响应式数据</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！</span></span><br><span class="line"><span class="comment">			若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">watch(person,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;person变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">false</span>&#125;) <span class="comment">//此处的deep配置不再奏效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况四：监视reactive定义的响应式数据中的某个属性</span></span><br><span class="line">watch(<span class="function">()=&gt;</span>person.job,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//情况五：监视reactive定义的响应式数据中的某些属性</span></span><br><span class="line">watch([<span class="function">()=&gt;</span>person.job,<span class="function">()=&gt;</span>person.name],<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">immediate</span>:<span class="literal">true</span>,<span class="attr">deep</span>:<span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//特殊情况</span></span><br><span class="line">watch(<span class="function">()=&gt;</span>person.job,<span class="function">(<span class="params">newValue,oldValue</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;person的job变化了&#x27;</span>,newValue,oldValue)</span><br><span class="line">&#125;,&#123;<span class="attr">deep</span>:<span class="literal">true</span>&#125;) <span class="comment">//此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>watch监听 props 中的基本类型数据，需要通过 getter 函数返回值的形式（()=&gt;props.xxx）才能监听</p>
</li>
<li><p>watch监听 props 中的引用类型数据，且父组件中没有改变地址指向时，可以直接监听</p>
</li>
<li><p>watch监听 props 中的引用类型数据，且父组件中改变了地址指向时，需要通过 getter 函数返回值的形式（()=&gt;props.xxx）才能监听</p>
</li>
</ol>
<h4 id="watchEffect函数"><a href="#watchEffect函数" class="headerlink" title="watchEffect函数"></a>watchEffect函数</h4><ul>
<li><p>watch的套路是：既要指明监视的属性，也要指明监视的回调。</p>
</li>
<li><p>watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。</p>
</li>
<li><p>watchEffect有点像computed：</p>
<ul>
<li>但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。</li>
<li>而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。</span></span><br><span class="line">watchEffect(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x1 = sum.value</span><br><span class="line">    <span class="keyword">const</span> x2 = person.age</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;watchEffect配置的回调执行了&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h3><ul>
<li>Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名：<ul>
<li><code>beforeDestroy</code>改名为 <code>beforeUnmount</code></li>
<li><code>destroyed</code>改名为 <code>unmounted</code></li>
</ul>
</li>
<li>Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下：<ul>
<li><code>beforeCreate</code>===&gt;<code>setup()</code></li>
<li><code>created</code>=======&gt;<code>setup()</code></li>
<li><code>beforeMount</code> ===&gt;<code>onBeforeMount</code></li>
<li><code>mounted</code>=======&gt;<code>onMounted</code></li>
<li><code>beforeUpdate</code>===&gt;<code>onBeforeUpdate</code></li>
<li><code>updated</code> =======&gt;<code>onUpdated</code></li>
<li><code>beforeUnmount</code> ==&gt;<code>onBeforeUnmount</code></li>
<li><code>unmounted</code> =====&gt;<code>onUnmounted</code></li>
</ul>
</li>
</ul>
<h3 id="自定义hook函数"><a href="#自定义hook函数" class="headerlink" title="自定义hook函数"></a>自定义hook函数</h3><ul>
<li><p>什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。</p>
</li>
<li><p>类似于vue2.x中的mixin。</p>
</li>
<li><p>自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。</p>
</li>
</ul>
<h3 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h3><ul>
<li>作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。</li>
<li>语法：<code>const name = toRef(person,&#39;name&#39;)</code></li>
<li>应用:   要将响应式对象中的某个属性单独提供给外部使用时。</li>
</ul>
<ul>
<li>扩展：<code>toRefs</code> 与<code>toRef</code>功能一致，但可以批量创建多个 ref 对象，语法：<code>toRefs(person)</code></li>
</ul>
<h2 id="其它-Composition-API"><a href="#其它-Composition-API" class="headerlink" title="其它 Composition API"></a>其它 Composition API</h2><h4 id="1-shallowReactive-与-shallowRef"><a href="#1-shallowReactive-与-shallowRef" class="headerlink" title="1.shallowReactive 与 shallowRef"></a>1.shallowReactive 与 shallowRef</h4><ul>
<li><p>shallowReactive：只处理对象最外层属性的响应式（浅响应式）。</p>
</li>
<li><p>shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。</p>
</li>
<li><p>什么时候使用?</p>
<ul>
<li> 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。</li>
<li> 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。</li>
</ul>
</li>
</ul>
<h4 id="2-readonly-与-shallowReadonly"><a href="#2-readonly-与-shallowReadonly" class="headerlink" title="2.readonly 与 shallowReadonly"></a>2.readonly 与 shallowReadonly</h4><ul>
<li>readonly: 让一个响应式数据变为只读的（深只读）。</li>
<li>shallowReadonly：让一个响应式数据变为只读的（浅只读）。</li>
<li>应用场景: 不希望数据被修改时。</li>
</ul>
<h4 id="3-toRaw-与-markRaw"><a href="#3-toRaw-与-markRaw" class="headerlink" title="3.toRaw 与 markRaw"></a>3.toRaw 与 markRaw</h4><ul>
<li>toRaw：<ul>
<li>作用：将一个由<code>reactive</code>生成的<strong style="color:orange">响应式对象</strong>转为<strong style="color:orange">普通对象</strong>。</li>
<li>使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。</li>
</ul>
</li>
<li>markRaw：<ul>
<li>作用：标记一个对象，使其永远不会再成为响应式对象。</li>
<li>应用场景:<ol>
<li>有些值不应被设置为响应式的，例如复杂的第三方类库等。</li>
<li>当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="4-customRef"><a href="#4-customRef" class="headerlink" title="4.customRef"></a>4.customRef</h4><ul>
<li><p>作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。</p>
</li>
<li><p>实现防抖效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;input type=&quot;text&quot; v-model=&quot;keyword&quot;&gt;</span><br><span class="line">	&lt;h3&gt;&#123;&#123;keyword&#125;&#125;&lt;/h3&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	import &#123;ref,customRef&#125; from &#x27;vue&#x27;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name:&#x27;Demo&#x27;,</span><br><span class="line">		setup()&#123;</span><br><span class="line">			// let keyword = ref(&#x27;hello&#x27;) //使用Vue准备好的内置ref</span><br><span class="line">			//自定义一个myRef</span><br><span class="line">			function myRef(value,delay)&#123;</span><br><span class="line">				let timer</span><br><span class="line">				//通过customRef去实现自定义</span><br><span class="line">				return customRef((track,trigger)=&gt;&#123;</span><br><span class="line">					return&#123;</span><br><span class="line">						get()&#123;</span><br><span class="line">							track() //告诉Vue这个value值是需要被“追踪”的</span><br><span class="line">							return value</span><br><span class="line">						&#125;,</span><br><span class="line">						set(newValue)&#123;</span><br><span class="line">							clearTimeout(timer)</span><br><span class="line">							timer = setTimeout(()=&gt;&#123;</span><br><span class="line">								value = newValue</span><br><span class="line">								trigger() //告诉Vue去更新界面</span><br><span class="line">							&#125;,delay)</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">			let keyword = myRef(&#x27;hello&#x27;,500) //使用程序员自定义的ref</span><br><span class="line">			return &#123;</span><br><span class="line">				keyword</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="5-provide-与-inject"><a href="#5-provide-与-inject" class="headerlink" title="5.provide 与 inject"></a>5.provide 与 inject</h4><img src="https://v3.cn.vuejs.org/images/components_provide.png" style="width:300px" />

<ul>
<li><p>作用：实现<strong style="color:#DD5145">祖与后代组件间</strong>通信</p>
</li>
<li><p>套路：父组件有一个 <code>provide</code> 选项来提供数据，后代组件有一个 <code>inject</code> 选项来开始使用这些数据</p>
</li>
<li><p>具体写法：</p>
<ol>
<li><p>祖组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">let</span> car = reactive(&#123;<span class="attr">name</span>:<span class="string">&#x27;奔驰&#x27;</span>,<span class="attr">price</span>:<span class="string">&#x27;40万&#x27;</span>&#125;)</span><br><span class="line">    provide(<span class="string">&#x27;car&#x27;</span>,car)</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>后代组件中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">setup</span>(<span class="params">props,context</span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">    <span class="keyword">const</span> car = inject(<span class="string">&#x27;car&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;car&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h4 id="6-响应式数据的判断"><a href="#6-响应式数据的判断" class="headerlink" title="6.响应式数据的判断"></a>6.响应式数据的判断</h4><ul>
<li>isRef: 检查一个值是否为一个 ref 对象</li>
<li>isReactive: 检查一个对象是否是由 <code>reactive</code> 创建的响应式代理</li>
<li>isReadonly: 检查一个对象是否是由 <code>readonly</code> 创建的只读代理</li>
<li>isProxy: 检查一个对象是否是由 <code>reactive</code> 或者 <code>readonly</code> 方法创建的代理</li>
</ul>
<h2 id="Composition-API-的优势"><a href="#Composition-API-的优势" class="headerlink" title="Composition API 的优势"></a>Composition API 的优势</h2><h3 id="Options-API-存在的问题"><a href="#Options-API-存在的问题" class="headerlink" title="Options API 存在的问题"></a>Options API 存在的问题</h3><p>使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f84e4e2c02424d9a99862ade0a2e4114~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:50%;" />



<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5ac7e20d1784887a826f6360768a368~tplv-k3u1fbpfcp-watermark.image" alt="img" style="zoom:50%;" />



<h2 id="组件-1"><a href="#组件-1" class="headerlink" title="组件"></a>组件</h2><h3 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h3><p><a href="https://blog.csdn.net/qq_26018335/article/details/124986459">https://blog.csdn.net/qq_26018335/article/details/124986459</a></p>
<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; createApp &#125; from &#x27;vue&#x27;</span><br><span class="line">import MyComponent from &#x27;./App.vue&#x27;</span><br><span class="line"></span><br><span class="line">const app = createApp(&#123;&#125;)</span><br><span class="line">app.component(&#x27;MyComponent&#x27;, MyComponent)</span><br></pre></td></tr></table></figure>

<p><code>app.component()</code> 方法可以被链式调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">  .component(&#x27;ComponentA&#x27;, ComponentA)</span><br><span class="line">  .component(&#x27;ComponentB&#x27;, ComponentB)</span><br><span class="line">  .component(&#x27;ComponentC&#x27;, ComponentC)</span><br></pre></td></tr></table></figure>

<h3 id="Props-声明"><a href="#Props-声明" class="headerlink" title="Props 声明"></a>Props 声明</h3><p>在使用 <code>&lt;script setup&gt;</code> 的单文件组件中，props 可以使用 <code>defineProps()</code> 宏来声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps([&#x27;foo&#x27;])</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="新的组件"><a href="#新的组件" class="headerlink" title="新的组件"></a>新的组件</h3><h4 id="1-Fragment"><a href="#1-Fragment" class="headerlink" title="1.Fragment"></a>1.Fragment</h4><ul>
<li>在Vue2中: 组件必须有一个根标签</li>
<li>在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中</li>
<li>好处: 减少标签层级, 减小内存占用</li>
</ul>
<h4 id="2-Teleport"><a href="#2-Teleport" class="headerlink" title="2.Teleport"></a>2.Teleport</h4><ul>
<li><p>什么是Teleport？—— <code>Teleport</code> 是一种能够将我们的<strong style="color:#DD5145">组件html结构</strong>移动到指定位置的技术。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;teleport to=&quot;移动位置&quot;&gt;</span><br><span class="line">	&lt;div v-if=&quot;isShow&quot; class=&quot;mask&quot;&gt;</span><br><span class="line">		&lt;div class=&quot;dialog&quot;&gt;</span><br><span class="line">			&lt;h3&gt;我是一个弹窗&lt;/h3&gt;</span><br><span class="line">			&lt;button @click=&quot;isShow = false&quot;&gt;关闭弹窗&lt;/button&gt;</span><br><span class="line">		&lt;/div&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/teleport&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-Suspense"><a href="#3-Suspense" class="headerlink" title="3.Suspense"></a>3.Suspense</h4><ul>
<li><p>等待异步组件时渲染一些额外内容，让应用有更好的用户体验</p>
</li>
<li><p>使用步骤：</p>
<ul>
<li><p>异步引入组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;defineAsyncComponent&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">const</span> Child = defineAsyncComponent(<span class="function">()=&gt;</span><span class="keyword">import</span>(<span class="string">&#x27;./components/Child.vue&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>Suspense</code>包裹组件，并配置好<code>default</code> 与 <code>fallback</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">		&lt;h3&gt;我是App组件&lt;/h3&gt;</span><br><span class="line">		&lt;Suspense&gt;</span><br><span class="line">			&lt;template v-slot:default&gt;</span><br><span class="line">				&lt;Child/&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">			&lt;template v-slot:fallback&gt;</span><br><span class="line">				&lt;h3&gt;加载中.....&lt;/h3&gt;</span><br><span class="line">			&lt;/template&gt;</span><br><span class="line">		&lt;/Suspense&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="HOOK"><a href="#HOOK" class="headerlink" title="HOOK"></a>HOOK</h2><p><a href="https://juejin.cn/post/7181712900094951483">https://juejin.cn/post/7181712900094951483</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="1-全局API的转移"><a href="#1-全局API的转移" class="headerlink" title="1.全局API的转移"></a>1.全局API的转移</h3><ul>
<li><p>Vue 2.x 有许多全局 API 和配置。</p>
<ul>
<li><p>例如：注册全局组件、注册全局指令等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册全局组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;MyButton&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">data</span>: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;Clicked &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册全局指令</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">inserted</span>: <span class="function"><span class="params">el</span> =&gt;</span> el.focus()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vue3.0中对这些API做出了调整：</p>
<ul>
<li><p>将全局的API，即：<code>Vue.xxx</code>调整到应用实例（<code>app</code>）上</p>
<table>
<thead>
<tr>
<th>2.x 全局 API（<code>Vue</code>）</th>
<th>3.x 实例 API (<code>app</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>Vue.config.xxxx</td>
<td>app.config.xxxx</td>
</tr>
<tr>
<td>Vue.config.productionTip</td>
<td><strong style="color:#DD5145">移除</strong></td>
</tr>
<tr>
<td>Vue.component</td>
<td>app.component</td>
</tr>
<tr>
<td>Vue.directive</td>
<td>app.directive</td>
</tr>
<tr>
<td>Vue.mixin</td>
<td>app.mixin</td>
</tr>
<tr>
<td>Vue.use</td>
<td>app.use</td>
</tr>
<tr>
<td>Vue.prototype</td>
<td>app.config.globalProperties</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h3 id="2-其他改变"><a href="#2-其他改变" class="headerlink" title="2.其他改变"></a>2.其他改变</h3><ul>
<li><p>data选项应始终被声明为一个函数。</p>
</li>
<li><p>过度类名的更改：</p>
<ul>
<li><p>Vue2.x写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-leave</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Vue3.x写法</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-enter-from</span>,</span><br><span class="line"><span class="selector-class">.v-leave-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.v-leave-from</span>,</span><br><span class="line"><span class="selector-class">.v-enter-to</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>keyCode作为 v-on 的修饰符，同时也不再支持<code>config.keyCodes</code></p>
</li>
<li><p><strong style="color:#DD5145">移除</strong><code>v-on.native</code>修饰符</p>
<ul>
<li><p>父组件中绑定事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;my-component</span><br><span class="line">  v-on:close=&quot;handleComponentEvent&quot;</span><br><span class="line">  v-on:click=&quot;handleNativeClickEvent&quot;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>子组件中声明自定义事件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    emits: [&#x27;close&#x27;]</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong style="color:#DD5145">移除</strong>过滤器（filter）</p>
<blockquote>
<p>过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。</p>
</blockquote>
</li>
<li><p>……</p>
</li>
</ul>
<h1 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h1><p>采用了空对象初始化的形式，来初始化对象，这样对象中的字段在赋值的时候是<strong>不存在响应式的</strong></p>
<p><a href="http://e.betheme.net/article/show-90795.html?action=onClick">http://e.betheme.net/article/show-90795.html?action=onClick</a></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>router</tag>
        <tag>vuex</tag>
        <tag>vue搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>react技术栈</title>
    <url>/2020/09/25/05-react/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React的特点和优势"><a href="#React的特点和优势" class="headerlink" title="React的特点和优势"></a>React的特点和优势</h1><ol>
<li>虚拟DOM<br>之前操作dom的⽅式是通过document.getElementById()的⽅式，这样的过程实际上是先去读取html的dom结构，将结构转换成变量，再进⾏操作<br>⽽reactjs定义了⼀套变量形式的dom模型，⼀切操作和换算直接在变量中，这样减少了操作真实dom，性能真实相当的⾼，和主流MVC框架有本质的区别，并不和dom打交道</li>
<li>组件系统<br>react最核⼼的思想是将⻚⾯中任何⼀个区域或者元素都可以看做⼀个组件 component<br>那么什么是组件呢？<br>组件指的就是同时包含了html、css、js、image元素的聚合体<br>使⽤react开发的核⼼就是将⻚⾯拆分成若⼲个组件，并且react⼀个组件中同时耦合了css、js、<br>image，这种模式整个颠覆了过去的传统的⽅式</li>
<li>单向数据流<br>其实reactjs的核⼼内容就是数据绑定，所谓数据绑定指的是只要将⼀些服务端的数据和前端⻚⾯绑定<br>好，开发者只关注实现业务就⾏了</li>
<li>JSX 语法<br>在vue中，我们使⽤render函数来构建组件的dom结构性能较⾼，因为省去了查找和编译模板的过程，<br>但是在render中利⽤createElement创建结构的时候代码可读性较低，较为复杂，此时可以利⽤jsx语法<br>来在render中创建dom，解决这个问题，但是前提是需要使⽤⼯具来编译jsx</li>
</ol>
<h1 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h1><h2 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h2><p>全局定义将组件App放置在<code>id=&#39;App&#39;</code>的容器里</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDom from &#x27;react-dom&#x27;</span><br><span class="line">import App from &#x27;./app.jsx&#x27;</span><br><span class="line">// ReactDOM.render(&#x27;要渲染的虚拟DOM元素&#x27;, &#x27;要渲染到页面上的哪个位置中&#x27;)</span><br><span class="line">// 注意： ReactDOM.render() 方法的第二个参数，和vue不一样，不接受 &quot;#app&quot; 这样的字符串，而是需要传递一个 原生的 DOM 对象</span><br><span class="line">ReactDom.render(</span><br><span class="line">    &lt;App/&gt;,</span><br><span class="line">    document.getElementById(&#x27;App&#x27;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="APP-jsx"><a href="#APP-jsx" class="headerlink" title="APP.jsx"></a>APP.jsx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 在 react 中，如要要创建 DOM 元素了，只能使用 React 提供的 JS API 来创建，不能【直接】像 Vue 中那样，手写 HTML 元素</span><br><span class="line">// React.createElement() 方法，用于创建 虚拟DOM 对象，它接收 3个及以上的参数</span><br><span class="line">// 参数1： 是个字符串类型的参数，表示要创建的元素类型</span><br><span class="line">// 参数2： 是一个属性对象，表示 创建的这个元素上，有哪些属性</span><br><span class="line">// 参数3： 从第三个参数的位置开始，后面可以放好多的虚拟DOM对象，这写参数，表示当前元素的子节点</span><br><span class="line"> var myDiv = React.createElement(&#x27;div&#x27;, &#123; title: &#x27;this is a div&#x27;, id: &#x27;mydiv&#x27; &#125;, &#x27;这是一个div&#x27;, myH1)</span><br><span class="line">//&lt;div title=&quot;this is a div&quot; id=&quot;mydiv&quot;&gt;这是一个div&lt;/div&gt;</span><br><span class="line"> </span><br><span class="line">// 由于，React官方，发现，如果直接让用户手写 JS 代码创建元素，用户会疯掉的，然后，用户就开始寻找新的前端框架了，于是，React 官方，就提出了一套 JSX 语法规范，能够让我们在 JS 文件中，书写类似于 HTML 那样的代码，快速定义虚拟DOM结构；</span><br><span class="line">// 问题： JSX（符合 XML 规范的 JS 语法）的原理是什么？</span><br><span class="line">// JSX内部在运行的时候，也是先把 类似于HTML 这样的标签代码，转换为了 React.createElement 的形式；（JSX是一个对程序员友好的语法糖）</span><br><span class="line">//在JSX创建DOM的时候，所有的节点，必须有唯一的根元素进行包裹；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 在React中，构造函数，就是一个最基本的组件</span><br><span class="line">// 如果想要把组件放到页面中，可以把 构造函数的名称，当作 组件的名称，以 HTML标签形式引入页面中即可</span><br><span class="line">// 注意：React在解析所有的标签的时候，是以标签的首字母来区分的，如果标签的首字母是小写，那么就按照 普通的 HTML 标签来解析，如果 首字母是大写，则按照 组件的形式去解析渲染</span><br><span class="line">// 结论：组件的首字母必须是大写</span><br><span class="line">export default function Hello(props) &#123;</span><br><span class="line">  // 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；</span><br><span class="line">  // 通过 props 得到的任何数据都是只读的，不能从新赋值</span><br><span class="line">  return (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;这是在Hello组件中定义的元素 --- &#123;props.name&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/div&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h1><p><a href="https://react.docschina.org/docs/react-component.html">https://react.docschina.org/docs/react-component.html</a></p>
<p><a href="https://m.html.cn/qa/react/14367.html">https://m.html.cn/qa/react/14367.html</a></p>
<p>从出生到成长，最后到死亡，这个过程的时间可以理解为生命周期。React的生命周期同理也是这么一个过程。<br>React的生命周期分为三个阶段：挂载期（也叫实例化期）、更新期（也叫存在期）、卸载期（也叫销毁期）。在每个周期中React都提供了一些钩子函数。<br>生命周期的描述如下：<br>挂载期：一个组件实例初次北创建的过程。<br>更新期：组件在创建后再次渲染的过程。<br>卸载期：组件在使用完后被销毁的过程。</p>
<h2 id="组件初始化阶段"><a href="#组件初始化阶段" class="headerlink" title="组件初始化阶段"></a>组件初始化阶段</h2><p><strong>组件实例创建阶段的生命周期函数，在组件的一辈子中，只执行一次</strong>；</p>
<ul>
<li><p>constructor(props)</p>
<p>仅用于以下两种情况：</p>
<ul>
<li>通过给 <code>this.state</code> 赋值对象来初始化<a href="https://zh-hans.reactjs.org/docs/state-and-lifecycle.html">内部 state</a>。</li>
<li>为<a href="https://zh-hans.reactjs.org/docs/handling-events.html">事件处理函数</a>绑定实例</li>
</ul>
<p>在为 React.Component 子类实现构造函数时，通过 super(props)调用父类React Component的构造函数，⽤来将⽗组件传来的 props 绑定到这个类中。否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p>
</li>
<li><p>componentWillMount<strong>（17后已经过时</strong>）: 组件将要被挂载，此时还没有开始渲染虚拟DOM，无法获取到页面上的任何元素，因为虚拟DOM和页面都还没有开始渲染呢。</p>
<ul>
<li><p>进⾏ajax请求，作者一开始也喜欢在React的willMount函数中进行异步获取数据（认为这可以减少白屏的时间），后来发现其实应该在didMount中进行。</p>
</li>
<li><p>可以修改state</p>
</li>
</ul>
</li>
<li><p>render： <code>render()</code> 方法是 class 组件中唯一必须实现的方法。 第一次开始渲染，创建虚拟dom，当render执行完，内存中就有了完整的虚拟DOM了。但是，页面上尚未真正显示DOM元素</p>
</li>
<li><p>componentDidMount:  <code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。依赖于 DOM 节点的初始化应该放在这里。</p>
<ul>
<li>网络请求获取数据</li>
<li>对DOM进行操作</li>
<li>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅  </li>
</ul>
</li>
</ul>
<h2 id="组件更新阶段"><a href="#组件更新阶段" class="headerlink" title="组件更新阶段"></a><strong>组件更新阶段</strong></h2><p>更新根据组件的state和props的改变，有选择性的触发0次或多次；</p>
<ul>
<li><p>componentWillReceiveProps（<strong>17后已经过时）</strong>:<br>组件将要接收新属性props，此时，只要这个方法被触发，就证明父组件为当前子组件传递了新的属性值；<br>如果我们使用 this.props 来获取属性值，这个属性值，不是最新的，是上一次的旧属性值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">componentWillReceiveProps</span>(<span class="params">nextProps</span>)</span>&#123;    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.props.pmsg + <span class="string">&#x27; ---- &#x27;</span> + nextProps.pmsg</span><br><span class="line">);&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>shouldComponentUpdate: 组件是否需要被更新，此时，组件尚未被更新，但是，state 和 props 肯定是最新的。 首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shouldComponentUpdate(nextProps, nextState)</span><br></pre></td></tr></table></figure></li>
<li><p>componentWillUpdate（<strong>17已经过时</strong>）: 组件将要被更新，此时，尚未开始更新，内存中的虚拟DOM树还是旧的，页面上的 DOM 元素 也是旧的</p>
</li>
<li><p>render: 根据最新的 state 和 props 重新渲染一棵内存中的 虚拟DOM树，当 render 调用完毕，内存中的旧DOM树，已经被新DOM树替换了！<strong>此时页面还是旧的</strong></p>
</li>
<li><p>componentDidUpdate: 此时，页面又被重新渲染了，state 和 虚拟DOM 和 页面已经完全保持同步</p>
</li>
</ul>
<h2 id="组件销毁阶段"><a href="#组件销毁阶段" class="headerlink" title="组件销毁阶段"></a>组件销毁阶段</h2><p><strong>也有一个显著的特点，一辈子只执行一次</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentWillUnmount: 组件将要被卸载，此时组件还可以正常使用；</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fb3cd2923f04e4c8dc58243522ff666~tplv-k3u1fbpfcp-zoom-1.image" alt="image.png"></p>
<h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/13/172acf9ceebe696c~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="image-20200528113856923"></p>
<p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p>
<ul>
<li>constructor()</li>
<li>static getDerivedStateFromProps()</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
<p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li>static getDerivedStateFromProps()</li>
<li>shouldComponentUpdate()</li>
<li>render()</li>
<li>getSnapshotBeforeUpdate()</li>
<li>componentDidUpdate()</li>
</ul>
<p>错误处理<br>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p>
<ul>
<li>static getDerivedStateFromError()</li>
<li>componentDidCatch()</li>
</ul>
<h3 id="废弃的生命周期"><a href="#废弃的生命周期" class="headerlink" title="废弃的生命周期"></a>废弃的生命周期</h3><p><strong>被废弃的三个函数都是在render之前</strong></p>
<h4 id="为什么废弃"><a href="#为什么废弃" class="headerlink" title="为什么废弃"></a>为什么废弃</h4><p>由于<code>React</code>未来会推出新的渲染方式–异步渲染，一种生命周期可被打断的渲染方式<strong>（因为fiber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次）</strong>，具体是在<code>render()</code>生成虚拟 <code>dom</code> 阶段可以打断重来， 这就会导致在dom挂载之前或是被更新之前的所有任务都会重复操作，所以<code>componentWillMount()</code>、·<code>componentWillReceiveProps()</code> <code>componentWIllUpdate()</code>方法可能会执行多次。（<strong>函数内部逻辑多次调用</strong>）</p>
<h4 id="componentWillMount"><a href="#componentWillMount" class="headerlink" title="componentWillMount"></a><strong>componentWillMount</strong></h4><p><strong>新版本中官方推荐将初始化的操作放在<code>constructor()</code>中， 将请求异步数据、订阅事件源、监听事件的操作放在<code>componentDidMount()</code></strong></p>
<h4 id="componentWillReceiveProps"><a href="#componentWillReceiveProps" class="headerlink" title="componentWillReceiveProps"></a><strong>componentWillReceiveProps</strong></h4><p>在老版本的<code>React</code>中，如果组件自身的state与其props密切相关的话，我们就会用到<code>componentWillReceiveProps(nextProps)</code>。常见的业务场景比如，tabs的激活状态，一般我们会在组件自身内通过state维持，但是当我们从其他页面返回时，想要保持离开之前时的tabs状态，这时我们可以通过props来传递，（<strong>破坏了数据源的单一性</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//previous </span><br><span class="line">componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">   if(nextProps.activeIndex !== this.state.activeIndex) &#123;</span><br><span class="line">     this.setState(&#123;activeIndex: nextProps.activeIndex&#125;)</span><br><span class="line">     this.fetchData() //因异步中断，可能会重复操作</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">/** next </span><br><span class="line">*将更新state与触发逻辑的操作分成两部分来执行，state更新部分在getDerivedStateFromProps中完成， 逻辑部分操作</span><br><span class="line">*在componentDidUpdate()中完成</span><br><span class="line">*/</span><br><span class="line">static getDerivedStateFromProps(nextProps, prevState) &#123; //此方法不能获取组件实例</span><br><span class="line">   if(nextProps.activeIndex !== prevState.activeIndex) &#123;</span><br><span class="line">     return &#123;activeIndex: nextProps.activeIndex&#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">componentDidUpdate() &#123;</span><br><span class="line">  this.fetchData() //可以确保只执行一次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该生命周期函数按照上面图谱中应该是在props属性改变之后调用，但其实只要父组件重新渲染，无论子组件的props有没有更新，子组件都会调用<code>componentWillReceiveProps</code> <strong>注意这里可能会造成死循环，即当子组件在该方法中调用了父组件通过props传递过来的函数时， 恰巧该函数中有能让父组件重新渲染的逻辑，就会造成死循环</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Parent extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">          			&#123;/* 迫使父组件更新, 子组件就会调用componentWillReceiveProps */&#125;</span><br><span class="line">                &lt;div onClick=&#123;() =&gt; this.forceUpdate()&#125;&gt; re-render &lt;/div&gt; </span><br><span class="line">                &lt;Child parentFun=&#123;() =&gt; this.setState(&#123;&#125;)&#125; /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Child extends Component &#123;</span><br><span class="line">    componentWillReceiveProps(nextProps, nextContext) &#123;</span><br><span class="line">      &#123;/*  子组件调用了父组件通过props传递过来的函数，该函数会使父组件重新渲染，造成死循环 */&#125;</span><br><span class="line">        nextProps.parentFun()</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt; child component &lt;/div&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="componentWillUpdate"><a href="#componentWillUpdate" class="headerlink" title="componentWillUpdate"></a><strong>componentWillUpdate</strong></h4><h3 id="getDerivedStateFromProps"><a href="#getDerivedStateFromProps" class="headerlink" title="getDerivedStateFromProps"></a>getDerivedStateFromProps</h3><p><strong>使用getDerivedStateFromProps代替了旧的componentWillReceiveProps及componentWillMount</strong></p>
<p>getDerivedStateFromProps是一个静态方法，在挂载和更新阶段时调用，可以返回一个对象来更新状态或者返回null不更新。</p>
<p>优点</p>
<ol>
<li><p>getDSFP是静态方法，在这里不能使用this，也就是一个纯函数，开发者不能写出副作用的代码</p>
</li>
<li><p>开发者只能通过prevState而不是prevProps来做对比，保证了state和props之间的简单关系以及不需要处理第一次渲染时prevProps为空的情况</p>
</li>
</ol>
<h3 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h3><p>getSnapshotBeforeUpdate代替了旧的componentWillUpdate。</p>
<p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ScrollingList extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.listRef = React.createRef();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getSnapshotBeforeUpdate(prevProps, prevState) &#123;</span><br><span class="line">    // 我们是否在 list 中添加新的 items ？</span><br><span class="line">    // 捕获滚动​​位置以便我们稍后调整滚动位置。</span><br><span class="line">    if (prevProps.list.length &lt; this.props.list.length) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      return list.scrollHeight - list.scrollTop;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState, snapshot) &#123;</span><br><span class="line">    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span><br><span class="line">    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span><br><span class="line">    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span><br><span class="line">    if (snapshot !== null) &#123;</span><br><span class="line">      const list = this.listRef.current;</span><br><span class="line">      list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getDerivedStateFromError"><a href="#getDerivedStateFromError" class="headerlink" title="getDerivedStateFromError"></a>getDerivedStateFromError</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static getDerivedStateFromError(error)</span><br></pre></td></tr></table></figure>

<p>此生命周期会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class ErrorBoundary extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123; hasError: false &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  static getDerivedStateFromError(error) &#123;    // 更新 state 使下一次渲染可以显降级 UI    return &#123; hasError: true &#125;;  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    if (this.state.hasError) &#123;      // 你可以渲染任何自定义的降级  UI      return &lt;h1&gt;Something went wrong.&lt;/h1&gt;;    &#125;</span><br><span class="line">    return this.props.children; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate"></a>forceUpdate</h3><p>默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。如果 <code>render()</code> 方法依赖于其他数据，则可以调用 <code>forceUpdate()</code> 强制让组件重新渲染。</p>
<p>调用 <code>forceUpdate()</code> 将致使组件调用 <code>render()</code> 方法，此操作会跳过该组件的 <code>shouldComponentUpdate()</code>。但其<strong>子组件</strong>会触发正常的生命周期方法，包括 <code>shouldComponentUpdate()</code> 方法。如果标记发生变化，React 仍将只更新 DOM。</p>
<h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><h2 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h2><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">if</span> (isLoggedIn) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Greeting</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLoggedIn = props.isLoggedIn;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">  	&#123;isLoggedIn?<span class="xml"><span class="tag">&lt;<span class="name">UserGreeting</span> /&gt;</span></span>:<span class="xml"><span class="tag">&lt;<span class="name">GuestGreeting</span> /&gt;</span></span>&#125;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="comment">// Try changing to isLoggedIn=&#123;true&#125;:</span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">isLoggedIn</span>=<span class="string">&#123;false&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="列表-amp-Key"><a href="#列表-amp-Key" class="headerlink" title="列表 &amp; Key"></a>列表 &amp; Key</h3><p>key为每个元素加上唯一的标识，这样在执行diff的时候会加快位置的确定</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">const</span> listItems = numbers.map(<span class="function">(<span class="params">number</span>) =&gt;</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;number&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>&#123;listItems&#125;<span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">NumberList</span> <span class="attr">numbers</span>=<span class="string">&#123;numbers&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> <strong>在 JSX 中嵌入 map()</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberList</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = props.numbers;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;numbers.map((number) =&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ListItem</span> <span class="attr">key</span>=<span class="string">&#123;number.toString()&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                  <span class="attr">value</span>=<span class="string">&#123;number&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。</p>
<p><strong>如果使用数组索引，那么在对dom进行添加或删除，会出问题</strong>：</p>
<img src="img/react/arr-delete-start.png" style="zoom: 50%;" />

<img src="img/react/arr-delete-end.png" style="zoom:50%;" />

<p>页面渲染好了之后，3 个 input 输入框依次输入随机内容，当我们用 index 作为 key 的时候，点击删除第一项按钮会发现，左侧文字正确改变，input 输入框最后一项没了，这不是我们希望的样子。 因为当我们使用 index 作为 key 时，此时 key 为 0、1、2，删掉第一项后 key 变为 0、1，此时 react 在执行 diff 算法过程中，任务 key=0 存在，只需要更新子节点的值，所以左侧的 name 成功改变，而 input 的值非受控，不会更新。同时在对比计算中少了 key=2 这项，删除了最后一项。</p>
<h3 id="添加样式的方式"><a href="#添加样式的方式" class="headerlink" title="添加样式的方式"></a>添加样式的方式</h3><p><strong>第一种：行内样式</strong></p>
<p>想给虚拟dom添加行内样式，需要使用表达式传入样式对象的方式来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意这里的两个括号，第一个表示我们在要JSX里插入JS了，第二个是对象的括号</span></span><br><span class="line"> &lt;p style=&#123;&#123;<span class="attr">color</span>:<span class="string">&#x27;red&#x27;</span>, <span class="attr">fontSize</span>:<span class="string">&#x27;14px&#x27;</span>&#125;&#125;&gt;Hello world&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p><strong>动态添加样式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div style=&#123;&#123;<span class="attr">display</span>: (index===<span class="built_in">this</span>.state.currentIndex) ? <span class="string">&quot;block&quot;</span> : <span class="string">&quot;none&quot;</span>&#125;&#125;&gt;此标签是否隐藏&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div className=&#123;index===<span class="built_in">this</span>.state.currentIndex?<span class="string">&quot;active&quot;</span>:<span class="literal">null</span>&#125;&gt;此标签是否选中&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第二种：内嵌样式</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;&#123;<span class="string">`.operafor4&#123;margin-top:42px !important&#125;`</span>&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p><strong>第三种：css modules</strong></p>
<p><a href="https://www.ruanyifeng.com/blog/2016/06/css_modules.html">https://www.ruanyifeng.com/blog/2016/06/css_modules.html</a></p>
<p>CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效。例如：父组件和子组件使用相同的class，父组件的class会覆盖子组件的样式</p>
<p>产生局部作用域的唯一方法，就是使用一个独一无二的<code>class</code>的名字，不会与其他选择器重名。这就是 CSS Modules 的做法。</p>
<p>css Modules 添加多个className</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> className=&#123;`$&#123;styles<span class="selector-class">.sAll</span>&#125; $&#123;styles<span class="selector-class">.s1</span>&#125;`&#125;&gt;aaaaaa&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<p>CSS Modules 允许使用<code>:global(.className)</code>的语法，声明一个全局规则。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:<span class="built_in">global</span>(.title) &#123;</span><br><span class="line">  color: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第四种：样式组件（styled-components）</strong></p>
<p>styled-components是针对React写的一套css-in-js框架，简单来讲就是在js中写css。<br>styled-components是一个第三方包，要安装。<strong>Material框架</strong>中的样式也是如此</p>
<h2 id="表单和受控组件"><a href="#表单和受控组件" class="headerlink" title="表单和受控组件"></a>表单和受控组件</h2><p>在 HTML 中，表单元素（如<code>&lt;input&gt;</code>、 <code>&lt;textarea&gt;</code> 和 <code>&lt;select&gt;</code>）之类的表单元素通常自己维护 state，并根据用户输入进行更新。而在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 <a href="https://react.docschina.org/docs/react-component.html#setstate"><code>setState()</code></a>来更新。</p>
<p>我们可以把两者结合起来，使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“<strong>受控组件</strong>”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class NameForm extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;value: &#x27;&#x27;&#125;;</span><br><span class="line">    this.handleChange = this.handleChange.bind(this);</span><br><span class="line">    this.handleSubmit = this.handleSubmit.bind(this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleChange(event) &#123;    this.setState(&#123;value: event.target.value&#125;);  &#125;</span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    alert(&#x27;提交的名字: &#x27; + this.state.value);</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;</span><br><span class="line">        &lt;label&gt;</span><br><span class="line">          名字:</span><br><span class="line">          &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt;        </span><br><span class="line">        &lt;/label&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;</span><br><span class="line">      &lt;/form&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>handlechange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>
<p><strong>对于受控组件来说，输入的值始终由 React 的 state 驱动</strong></p>
<h2 id="props"><a href="#props" class="headerlink" title="props"></a>props</h2><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">&quot;Sara&quot;</span> /&gt;</span></span>;ReactDOM.render(</span><br><span class="line">  element,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p>无论是函数组件还是 class 组件，都拥有 <code>defaultProps</code> 属性。可以通过配置特定的 <code>defaultProps</code> 属性来定义 <code>props</code> 的默认值</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 props 的默认值：</span></span><br><span class="line">Greeting.defaultProps = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Stranger&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染出 &quot;Hello, Stranger&quot;：</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="PropTypes类型检查"><a href="#PropTypes类型检查" class="headerlink" title="PropTypes类型检查"></a>PropTypes类型检查</h3><p>PropTypes 进行类型检查,可用于确保组件接收到的props数据类型是有效的</p>
<p>导入包</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>编写组件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greeting</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增类型检查</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Greeting.propTypes = &#123;</span><br><span class="line"><span class="comment">// 你可以将属性声明为 JS 原生类型，默认情况下</span></span><br><span class="line">  <span class="comment">// 这些属性都是可选的。</span></span><br><span class="line">  optionalArray: PropTypes.array,</span><br><span class="line">  optionalBool: PropTypes.<span class="keyword">bool</span>,</span><br><span class="line">  optionalFunc: PropTypes.func,</span><br><span class="line">  optionalNumber: PropTypes.number,</span><br><span class="line">  optionalObject: PropTypes.object,</span><br><span class="line">  optionalString: PropTypes.string,</span><br><span class="line">  optionalSymbol: PropTypes.symbol,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任何可被渲染的元素（包括数字、字符串、元素或数组）</span></span><br><span class="line">  <span class="comment">// (或 Fragment) 也包含这些类型。</span></span><br><span class="line">  optionalNode: PropTypes.node,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素。</span></span><br><span class="line">  optionalElement: PropTypes.element,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个 React 元素类型（即，MyComponent）。</span></span><br><span class="line">  optionalElementType: PropTypes.elementType,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以声明 prop 为类的实例，这里使用</span></span><br><span class="line">  <span class="comment">// JS 的 instanceof 操作符。</span></span><br><span class="line">  optionalMessage: PropTypes.<span class="built_in">instanceOf</span>(Message),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以让你的 prop 只能是特定的值，指定它为</span></span><br><span class="line">  <span class="comment">// 枚举类型。</span></span><br><span class="line">  optionalEnum: PropTypes.<span class="built_in">oneOf</span>([<span class="string">&#x27;News&#x27;</span>, <span class="string">&#x27;Photos&#x27;</span>]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个对象可以是几种类型中的任意一个类型</span></span><br><span class="line">  optionalUnion: PropTypes.<span class="built_in">oneOfType</span>([</span><br><span class="line">    PropTypes.string,</span><br><span class="line">    PropTypes.number,</span><br><span class="line">    PropTypes.<span class="built_in">instanceOf</span>(Message)</span><br><span class="line">  ]),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个数组由某一类型的元素组成</span></span><br><span class="line">  optionalArrayOf: PropTypes.<span class="built_in">arrayOf</span>(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由某一类型的值组成</span></span><br><span class="line">  optionalObjectOf: PropTypes.<span class="built_in">objectOf</span>(PropTypes.number),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以指定一个对象由特定的类型值组成</span></span><br><span class="line">  optionalObjectWithShape: PropTypes.<span class="built_in">shape</span>(&#123;</span><br><span class="line">    color: PropTypes.string,</span><br><span class="line">    fontSize: PropTypes.number</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// An object with warnings on extra properties</span></span><br><span class="line">  optionalObjectWithStrictShape: PropTypes.<span class="built_in">exact</span>(&#123;</span><br><span class="line">    name: PropTypes.string,</span><br><span class="line">    quantity: PropTypes.number</span><br><span class="line">  &#125;),   </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以在任何 PropTypes 属性后面加上 `isRequired` ，确保</span></span><br><span class="line">  <span class="comment">// 这个 prop 没有被提供时，会打印警告信息。</span></span><br><span class="line">  requiredFunc: PropTypes.func.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 任意类型的数据</span></span><br><span class="line">  requiredAny: PropTypes.any.isRequired,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你可以指定一个自定义验证器。它在验证失败时应返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 请不要使用 `console.warn` 或抛出异常，因为这在 `onOfType` 中不会起作用。</span></span><br><span class="line">  customProp: <span class="built_in">function</span>(props, propName, componentName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!/matchme/.<span class="built_in">test</span>(props[propName])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 你也可以提供一个自定义的 `arrayOf` 或 `objectOf` 验证器。</span></span><br><span class="line">  <span class="comment">// 它应该在验证失败时返回一个 Error 对象。</span></span><br><span class="line">  <span class="comment">// 验证器将验证数组或对象中的每个值。验证器的前两个参数</span></span><br><span class="line">  <span class="comment">// 第一个是数组或对象本身</span></span><br><span class="line">  <span class="comment">// 第二个是他们当前的键。</span></span><br><span class="line">  customArrayProp: PropTypes.<span class="built_in">arrayOf</span>(<span class="built_in">function</span>(propValue, key, componentName, location, propFullName) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!/matchme/.<span class="built_in">test</span>(propValue[key])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">        <span class="string">&#x27;Invalid prop `&#x27;</span> + propFullName + <span class="string">&#x27;` supplied to&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27; `&#x27;</span> + componentName + <span class="string">&#x27;`. Validation failed.&#x27;</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="this-props-children"><a href="#this-props-children" class="headerlink" title="this.props.children"></a><strong>this.props.children</strong></h3><p>将一个组件写在另一个组件的内容中，然后在外层组件中通过 this.props.children来接收内容中的组件</p>
<p>如果当前组件没有子节点，它就是 undefined ;<br>如果有一个子节点，数据类型是 Object；<br>如果有多个子节点，数据类型就是 Array。</p>
<h2 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h2><p><a href="https://juejin.cn/post/6850418109636050958">https://juejin.cn/post/6850418109636050958</a></p>
<p><a href="https://juejin.cn/post/6959885030063603743#heading-0">https://juejin.cn/post/6959885030063603743#heading-0</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    number:1</span><br><span class="line">&#125;;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;number:3&#125;)</span><br><span class="line">    console.log(this.state.number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/11/1733ca3cdf9d950d~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p>setState是一个异步方法，如果每次调用setState都会触发更新，那么性能消耗就大，异步操作是为了提高性能，将多个状态更新合并一起进行<strong>批量更新</strong>，减少re-render调用。 <strong>将 <code>setState()</code> 视为<em>请求</em>而不是立即更新组件的命令。</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for ( let i = 0; i &lt; 100; i++ ) &#123;</span><br><span class="line">    this.setState( &#123; num: this.state.num + 1 &#125; );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果setState是一个同步执行的机制，那么这个状态会被重新渲染100次，这对性能是一个相当大的消耗。</p>
<blockquote>
<p>React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新</p>
</blockquote>
<p><strong>回调函数</strong></p>
<p>setState提供了一个回调函数供开发者使用，在回调函数中，我们可以实时的获取到更新之后的数据。还是以刚才的例子做示范：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">state = &#123;</span><br><span class="line">    number:1</span><br><span class="line">&#125;;</span><br><span class="line">componentDidMount()&#123;</span><br><span class="line">    this.setState(&#123;number:3&#125;,()=&gt;&#123;</span><br><span class="line">        console.log(this.state.number)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/7/11/1733ca3cdfc5be38~tplv-t2oaga2asx-watermark.awebp" alt="img"></p>
<p><strong>总结：</strong></p>
<ul>
<li><p>setState本身并不是异步（不会立即更新state的结果），只是因为react的性能优化机制体现为异步。在react的生命周期函数或者作用域下为异步，在原生的环境下为同步。</p>
</li>
<li><p>React18之前，react 无法对 setTimeout 的代码前后加上事务逻辑（除非 react 重写 setTimeout）。</p>
<p>所以当遇到 <code>setTimeout/setInterval/Promise.then(fn)/fetch 回调/xhr 网络回调</code>时，react 都是无法控制的<strong>（可以使用手动批处理）</strong>。</p>
<ul>
<li>在setTimeout，Promise.then等异步事件中。setState和useState是同步执行的（立即更新state的结果）</li>
</ul>
</li>
</ul>
<h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p>react的核心思想是虚拟DOM。react包含了生成虚拟DOM的函数react.createElement，及Component类。而react-dom包的核心功能就是把这些虚拟DOM渲染到文档中变成实际DOM。</p>
<h3 id="原生JS获取Dom"><a href="#原生JS获取Dom" class="headerlink" title="原生JS获取Dom"></a>原生JS获取Dom</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Component&#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义获取Dom的函数</span></span><br><span class="line">    <span class="function"><span class="title">handleGetDom</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> title = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#title&#x27;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(title);</span><br><span class="line">        title.style.background = <span class="string">&#x27;skyblue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span>测试节点<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleGetDom&#125;</span>&gt;</span>点击操作Dom<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a><strong>Ref</strong></h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a><strong>使用场景</strong></h4><ul>
<li>对Dom元素的焦点控制、内容选择、控制</li>
<li>对Dom元素的内容设置及媒体播放</li>
<li>对Dom元素的操作和对组件实例的操作</li>
<li>集成第三方 DOM 库</li>
</ul>
<h4 id="回调-Ref"><a href="#回调-Ref" class="headerlink" title="回调 Ref"></a>回调 Ref</h4><blockquote>
<p>支持在函数组件和类组件内部使用</p>
</blockquote>
<p>使用<strong>回调 refs</strong>需要将<strong>回调函数</strong>赋值给 React元素 的 ref 属性。这个函数接受 React 组件 或 HTML 元素作为参数，将其挂载到实例属性上</p>
<p>React 会在组件挂载时，调用 <code>ref</code> 回调函数并传入 DOM元素，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，React 会保证 Refs 一定是最新的。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类组件</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.inputRef = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.setTextInputRef = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.inputRef = ele;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.setSonRef = <span class="function">(<span class="params">ele</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.sonInfo = ele;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.inputRef &amp;&amp; <span class="built_in">this</span>.inputRef.focus();<span class="comment">//获取input DOM</span></span><br><span class="line">    <span class="built_in">this</span>.sonInfo.getSonInfo()<span class="comment">//父组件执行子组件函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.setTextInputRef&#125;/</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;this.setSonRef&#125;/</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyInput</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">info</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">getSonInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>, state.info)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;props.inputRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//函数组件</span><br><span class="line">let tooltipRefs: any = &#123;&#125;;</span><br><span class="line">const Emotion: FC&lt;OnlyProps&gt; = (props) =&gt; &#123;</span><br><span class="line">  const DraggableBox = (&#123; id, index &#125;) =&gt; &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;Tooltip</span><br><span class="line">          ref=&#123;ref =&gt; tooltipRefs[key] = ref&#125;</span><br><span class="line">        &gt;</span><br><span class="line">      &lt;/div &gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><blockquote>
<p><strong>支持在类组件中使用</strong></p>
</blockquote>
<h5 id="Refs-API使用"><a href="#Refs-API使用" class="headerlink" title="Refs API使用"></a>Refs API使用</h5><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(props);</span><br><span class="line">        <span class="comment">//分配给实例属性</span></span><br><span class="line">        <span class="built_in">this</span>.inputRef = React.createRef(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//通过 this.inputRef.current 获取对该节点的引用</span></span><br><span class="line">        <span class="built_in">this</span>.inputRef &amp;&amp; <span class="built_in">this</span>.inputRef.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">//把 &lt;input&gt; ref 关联到构造函数中创建的 `inputRef` 上</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.inputRef&#125;/</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ref 的值根据节点的类型而有所不同：</strong></p>
<p>一、当 ref 属性用于 HTML 元素时，构造函数中使用 React.createRef() 创建的 ref 接收<strong>底层 DOM 元素</strong>作为其 current 属性。</p>
<p>二、当 ref 属性用于自定义 class 组件时，ref 对象接收组件的 <strong>挂载实例</strong> 作为其 current 属性。</p>
<p>三、<strong>不能挂载到函数组件上，因为函数组件没有实例（instance）</strong></p>
<p>但是，你可以在函数式组件中使用ref属性，就像你引用DOM元素和类组件一样。</p>
<h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><p><strong>只能在函数组件中使用</strong></p>
<blockquote>
<p>区别：<a href="https://zhuanlan.zhihu.com/p/105276393">https://zhuanlan.zhihu.com/p/105276393</a></p>
<p>useRef 用法类似于React.createRef()，区别：</p>
<p><strong>createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。</strong><code>useRef</code> 返回的 ref 对象在组件的<strong>整个生命周期内保持不变</strong>。useRef 不仅仅是用来管理 DOM ref 的，它还相当于 this , 可以存放任何变量。useRef 可以很好的解决闭包带来的不方便性</p>
</blockquote>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">UseRefHookExample</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> inputRef = useRef(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    inputRef.current.focus();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      使用 useRef() hook:</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        Click</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useImperativeHandle(ref, createHandle, [deps])</span><br></pre></td></tr></table></figure>

<ul>
<li>通过useImperativeHandle可以<strong>只暴露特定的操作</strong><ul>
<li>通过useImperativeHandle的Hook, 将父组件传入的ref和useImperativeHandle第二个参数返回的对象绑定到了一起</li>
<li>所以在父组件中, 调用inputRef.current时, 实际上是返<strong>回的对象</strong></li>
</ul>
</li>
<li>useImperativeHandle使用简单总结:<ul>
<li>作用: 减少暴露给父组件获取的DOM元素属性, 只暴露给父组件需要用到的DOM方法</li>
<li>参数1: 父组件传递的ref属性</li>
<li>参数2: 返回一个对象, 以供给父组件中通过ref.current调用该对象中的方法</li>
</ul>
</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useRef, forwardRef, useImperativeHandle &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> JMInput = forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef()</span><br><span class="line">  <span class="comment">// 作用: 减少父组件获取的DOM元素属性,只暴露给父组件需要用到的DOM方法</span></span><br><span class="line">  <span class="comment">// 参数1: 父组件传递的ref属性</span></span><br><span class="line">  <span class="comment">// 参数2: 返回一个对象,父组件通过ref.current调用对象中方法</span></span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">focus</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      inputRef.current.focus()</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ImperativeHandleDemo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// useImperativeHandle 主要作用:用于减少父组件中通过forward+useRef获取子组件DOM元素暴露的属性过多</span></span><br><span class="line">  <span class="comment">// 为什么使用: 因为使用forward+useRef获取子函数式组件DOM时,获取到的dom属性暴露的太多了</span></span><br><span class="line">  <span class="comment">// 解决: 使用uesImperativeHandle解决,在子函数式组件中定义父组件需要进行DOM操作,减少获取DOM暴露的属性过多</span></span><br><span class="line">  <span class="keyword">const</span> inputRef = useRef()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> inputRef.current.focus()&#125;&gt;聚焦<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">JMInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; forwardRef, useImperativeHandle, useEffect, useRef &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TestRef = forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="function"><span class="title">open</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;open&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">const</span> TestRef = (<span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; ref &#125; = props;</span><br><span class="line">  useImperativeHandle(ref, <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    <span class="function"><span class="title">open</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;open&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = useRef()</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    ref.current.open()</span><br><span class="line">  &#125;,[])</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>石小阳<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">TestRef</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">TestRef</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<h4 id="forwardRef-转发-传递"><a href="#forwardRef-转发-传递" class="headerlink" title="forwardRef 转发/传递"></a>forwardRef 转发/传递</h4><p>React.forwardRef是转发ref 获取组件内的DOM节点 ，</p>
<p>以下两种场景中特别有用：</p>
<ul>
<li><p><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components">转发 refs 到 DOM 组件</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyInput = React.forwardRef(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line">	)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = React.useRef(<span class="literal">null</span>);<span class="comment">//class组件用createRef</span></span><br><span class="line">    React.useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(inputRef.current);<span class="comment">//input节点</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">MyInput</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> /&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>调用 <code>React.useRef</code> 创建了一个 <code>React ref</code> 并将其赋值给 <code>ref</code> 变量。</li>
<li>指定 <code>ref</code> 为JSX属性，并向下传递 <code>&lt;MyInput ref=&#123;inputRef&#125;&gt;</code></li>
<li>React 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code> 作为其第二个参数。</li>
<li>向下转发该 <code>ref</code> 参数到 <code>&lt;button ref=&#123;ref&#125;&gt;</code>，将其指定为JSX属性</li>
<li>当 <code>ref</code> 挂载完成，<code>inputRef.current</code> 指向 <code>input</code> DOM节点</li>
</ol>
</li>
<li><p><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html#forwarding-refs-in-higher-order-components">在高阶组件中转发 refs</a></p>
</li>
</ul>
<h3 id="findDOMNode"><a href="#findDOMNode" class="headerlink" title="findDOMNode()"></a>findDOMNode()</h3><p>当组件加载到页面上之后（mounted），你都可以通过 <code>react-dom</code> 提供的 <code>findDOMNode()</code> 方法拿到组件对应的 DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; findDOMNode &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Inside Component class</span></span><br><span class="line"><span class="function"><span class="title">componentDidMound</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = findDOMNode(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>findDOMNode()</code> 不能用在无状态组件上。</p>
<h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><ul>
<li><p>react 事件的命名采用小驼峰式（camelCase），而不是纯小写。</p>
</li>
<li><p>使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串。</p>
</li>
<li><p>不能通过返回 <code>false</code> 的方式阻止默认行为。你必须显式的使用 <code>preventDefault</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;<span class="attr">isToggleOn</span>: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了在回调中使用 `this`，这个绑定是必不可少的</span></span><br><span class="line">    <span class="built_in">this</span>.handleClick = <span class="built_in">this</span>.handleClick.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">      <span class="attr">isToggleOn</span>: !state.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;this.state.isToggleOn ? &#x27;ON&#x27; : &#x27;OFF&#x27;&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Toggle</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在 JavaScript 中，class 的方法默认不会<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind">绑定</a> <code>this</code>。如果你忘记绑定 <code>this.handleClick</code> 并把它传入了 <code>onClick</code>，当你调用这个函数的时候 <code>this</code> 的值为 <code>undefined</code>。</p>
<p><strong>绑定this：</strong></p>
<ul>
<li><p>在constructor中用bind绑定</p>
</li>
<li><p>箭头函数</p>
</li>
<li><p>回调中使用箭头函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class LoggingButton extends React.Component &#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(&#x27;this is:&#x27;, this);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    // 此语法确保 `handleClick` 内的 `this` 已被绑定。</span><br><span class="line">    return (</span><br><span class="line">      &lt;button onClick=&#123;() =&gt; this.handleClick()&#125;&gt;</span><br><span class="line">        Click me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="组件渲染机制"><a href="#组件渲染机制" class="headerlink" title="组件渲染机制"></a>组件渲染机制</h3><p><code>Component</code>在 <code>state</code>改变,<code>props</code>改变,调用<code>this.setState(&#123;...&#125;)</code>，的时候都会进行渲染</p>
<ul>
<li><p>强制React组件重新渲染</p>
<p><strong>使用React的<code>forceUpdate</code>函数</strong></p>
<p>这是一个最明显的方式。在React类组件中，你可以通过调用这个方法，强制重渲染一个组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.forceUpdate();</span><br></pre></td></tr></table></figure>

<p><strong>在React hooks中强制更新组件</strong></p>
<p>在React hooks中，<code>forceUpdate</code>函数是无法使用的。你可以使用如下方式强制更新组件，并且不更改组件的state：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [state, updateState] = React.useState();</span><br><span class="line"><span class="keyword">const</span> forceUpdate = React.useCallback(<span class="function">() =&gt;</span> updateState(&#123;&#125;), []);</span><br></pre></td></tr></table></figure></li>
<li><p><code>shouldComponentUpdate</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">this</span>.state.name === nextState.name) &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>    </span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过memo来判断指定的参数变化更新组件</p>
</li>
<li><p><strong>componentWillReciveProps</strong></p>
</li>
</ul>
<h3 id="状态组件"><a href="#状态组件" class="headerlink" title="状态组件"></a>状态组件</h3><h4 id="状态组件对比"><a href="#状态组件对比" class="headerlink" title="状态组件对比"></a>状态组件对比</h4><p>使用 function 创建的组件，叫做【无状态组件】；使用 class 创建的组件，叫做【有状态组件】</p>
<ul>
<li>使用 function 构造函数创建的组件，内部没有 state 私有数据，只有一个props来接收外界传递过来的数据</li>
<li>使用 class创建的组件，内部，除了有 this.props 这个只读属性之外，还有一个 专门用于 存放自己私有数据的this.state 属性，这个 state 是可读可写的！</li>
</ul>
<p>有状态组件和无状态组件，最本质的区别：</p>
<ul>
<li><p>有无 state 属性；</p>
</li>
<li><p>class 创建的组件，有自己的生命周期函数，但是，function 创建的 组件，没有自己的生命周期函数；</p>
</li>
</ul>
<p>问题来了：什么时候使用 有状态组件，什么时候使用无状态组件呢？？？</p>
<ol>
<li>如果一个组件需要存放自己的私有数据，或者需要在组件的不同阶段执行不同的业务逻辑，此时，非常适合用 class 创建出来的有状态组件；</li>
<li>如果一个组件，只需要根据外界传递过来的 props，渲染固定的 页面结构就完事儿了，此时，非常适合使用 function 创建出来的 无状态组件；（使用无状态组件的小小好处： 由于剔除了组件的生命周期，所以，运行速度会相对快一丢丢）</li>
</ol>
<h4 id="class组件"><a href="#class组件" class="headerlink" title="class组件"></a>class组件</h4><p><strong>用class关键字创建出来的组件：“有状态组件”</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 class 创建的类，通过 extends 关键字，继承了 React.Component 之后，这个类，就是一个组件的模板了</span></span><br><span class="line"><span class="comment">// 如果想要引用这个组件，可以把 类的名称， 以标签形式，导入到 JSX 中使用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello2</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 注意： 如果使用 extends 实现了继承，那么在 constructor 的第一行，一定要显示调用一下 super()</span></span><br><span class="line">    <span class="comment">//  super() 表示父类的构造函数</span></span><br><span class="line">    <span class="built_in">super</span>(props)</span><br><span class="line">    <span class="comment">// 在 constructor 中，如果想要访问 props 属性，不能直接使用 this.props， 而是需要在 constructor 的构造器参数列表中，显示的定义 props 参数来接收，才能正常使用；</span></span><br><span class="line">    <span class="comment">// 注意： 这是固定写法，this.state 表示 当前组件实例的私有数据对象，就好比 vue 中，组件实例身上的 data()&#123; return &#123;&#125; &#125; 函数  </span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;这是 Hello2 组件的私有msg数据&#x27;</span>,</span><br><span class="line">      <span class="attr">info</span>: <span class="string">&#x27;瓦塔西***&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 保存信息1： No `render` method found on the returned component instance: you may have forgotten to define `render`.</span></span><br><span class="line">  <span class="comment">// 通过分析以上报错，发现，提示我们说，在 class 实现的组件内部，必须定义一个 render 函数</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 报错信息2： Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.</span></span><br><span class="line">    <span class="comment">// 通过分析以上报错，发现，在 render 函数中，还必须 return 一个东西，如果没有什么需要被return 的，则需要 return null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虽然在 React dev tools 中，并没有显示说 class 组件中的 props 是只读的，但是，经过测试得知，其实 只要是 组件的 props，都是只读的；</span></span><br><span class="line">    <span class="comment">// this.props.address = &#x27;123&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是 使用 class 类创建的组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>外界传递过来的数据是： &#123;this.props.address&#125; --- &#123;this.props.info&#125;<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">h5</span>&gt;</span>&#123;this.state.msg&#125;<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      //React中，提供的事件绑定机制，使用的 都是驼峰命名</span></span><br><span class="line"><span class="xml">      //     在为 React 事件绑定 处理函数的时候，需要通过 this.函数名， 来把 函数的引用交给 事件 </span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;修改 msg&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btnChangeMsg&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeMsg&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeMsg = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注意： 这里不是传统网页，所以 React 已经帮我们规定死了，在 方法中，默认this 指向 undefined，并不是指向方法的调用者</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用 this.state.msg = &#x27;123&#x27; 为 state 上的数据重新赋值，可以修改 state 中的数据值，但是，页面不会被更新；</span></span><br><span class="line">    <span class="comment">// 所以这种方式，React 不推荐，以后尽量少用；</span></span><br><span class="line">    <span class="comment">// 如果要为 this.state 上的数据重新赋值，那么，React 推荐使用 this.setState(&#123;配置对象&#125;) 来重新为 state 赋值</span></span><br><span class="line">    <span class="comment">// 注意： this.setState 方法，只会重新覆盖那些 显示定义的属性值，如果没有提供最全的属性，则没有提供的属性值，不会被覆盖；</span></span><br><span class="line">    <span class="comment">/* this.setState(&#123;</span></span><br><span class="line"><span class="comment">      msg: &#x27;123&#x27;</span></span><br><span class="line"><span class="comment">    &#125;) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// this.setState 方法，也支持传递一个 function，如果传递的是 function，则在 function 内部，必须return 一个 对象；</span></span><br><span class="line">    <span class="comment">// 在 function 的参数中，支持传递两个参数，其中，第一个参数是 prevState，表示为修改之前的 老的 state 数据</span></span><br><span class="line">    <span class="comment">// 第二个参数，是 外界传递给当前组件的 props 数据</span></span><br><span class="line">    <span class="built_in">this</span>.setState(<span class="function"><span class="keyword">function</span> (<span class="params">prevState, props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;123&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 由于 this.setState 是异步执行的，所以，如果想要立即拿到最新的修改结果，最保险的方式， 在回调函数中去操作最新的数据</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.state.msg)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h4><p>函数/无状态组件是一个纯函数，它可接受接受参数，并返回react元素。这些都是没有任何副作用的纯函数。这些组件没有状态或生命周期方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件的首字母必须是大写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在组件中，如果想要使用外部传递过来的数据，必须，显示的在 构造函数参数列表中，定义 props 属性来接收；</span></span><br><span class="line">  <span class="comment">// 通过 props 得到的任何数据都是只读的，不能从新赋值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>这是在Hello组件中定义的元素 --- &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="内置组件"><a href="#内置组件" class="headerlink" title="内置组件"></a>内置组件</h3><h4 id="PureComponent"><a href="#PureComponent" class="headerlink" title="PureComponent"></a>PureComponent</h4><h5 id="shouldComponentUpdate模拟"><a href="#shouldComponentUpdate模拟" class="headerlink" title="shouldComponentUpdate模拟"></a>shouldComponentUpdate模拟</h5><p><a href="https://blog.csdn.net/deng1456694385/article/details/88746797">https://blog.csdn.net/deng1456694385/article/details/88746797</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> <span class="title">extent</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;render&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>haha<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的组件会在<code>this.setState</code>调用后就会重新传染一次,但是我们可以看出<code>name</code>状态并没有没被我们用到,也没有改变,这种渲染就是无效渲染,所以为了优化我们通常会使用钩子函数<code>shouldComponentUpdate</code>来做一些逻辑判断,来确定是否要重新<code>render</code>一次</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo</span> <span class="title">extent</span> <span class="title">Component</span> </span>&#123;    </span><br><span class="line">    state = &#123;        </span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;	</span><br><span class="line">        <span class="built_in">this</span>.setState(&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">shouldComponentUpdate</span>(<span class="params">nextProps,nextState</span>)</span> &#123;    </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.state.name === nextState.name) &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>    </span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;        </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	render &lt;div&gt;haha&lt;/div&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以避免无效渲染,优化性能,但是如果这种判断逻辑多到一定程度,光判断逻辑就很复杂,而且每次都要判断也会影响性能,所以才有了 <code>PureComponent</code>，**<code>PureComponent</code>的区别在于相当于自己写了一个<code>shouldComponentUpdate</code>钩子函数处理, 对<code>props</code>和<code>state</code>进行浅比较,所谓浅比较就是之比较内部第一层的各个属性的值是否相同,像对象和数组这种数据类型,如果只改变内部的元素,就不会造成渲染**</p>
<h5 id="PureComponent的浅比较"><a href="#PureComponent的浅比较" class="headerlink" title="PureComponent的浅比较"></a><strong>PureComponent的浅比较</strong></h5><p>浅比较通过一个<code>shallowEqual</code>函数来完成：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowEqual</span>(<span class="params">objA: mixed, objB: mixed</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 首先对基本数据类型的比较</span></span><br><span class="line">  <span class="comment">// !! 若是同引用便会返回 true</span></span><br><span class="line">  <span class="comment">//其中is函数是自己实现的一个Object.is的功能，排除了===两种不符合预期的情况：</span></span><br><span class="line">  <span class="comment">// +0 === -0  // true</span></span><br><span class="line">  <span class="comment">// NaN === NaN // false</span></span><br><span class="line">  <span class="keyword">if</span> (is(objA, objB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 只有一种情况是误判的，那就是object,所以在判断两个对象都不是object</span></span><br><span class="line">  <span class="comment">// 之后，就可以返回false了</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> objA !== <span class="string">&#x27;object&#x27;</span> || objA === <span class="literal">null</span> || <span class="keyword">typeof</span> objB !== <span class="string">&#x27;object&#x27;</span> || objB === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 过滤掉基本数据类型之后，就是对对象的比较了</span></span><br><span class="line">  <span class="keyword">const</span> keysA = <span class="built_in">Object</span>.keys(objA);</span><br><span class="line">  <span class="keyword">const</span> keysB = <span class="built_in">Object</span>.keys(objB);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先拿出key值，对key的长度进行对比</span></span><br><span class="line">  <span class="keyword">if</span> (keysA.length !== keysB.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// key相等的情况下，在去循环比较</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keysA.length; i++) &#123;</span><br><span class="line">    <span class="comment">// key值相等的时候</span></span><br><span class="line">    <span class="comment">// 借用原型链上真正的 hasOwnProperty 方法，判断ObjB里面是否有A的key的key值</span></span><br><span class="line">    <span class="comment">// 属性的顺序不影响结果也就是&#123;name:&#x27;daisy&#x27;, age:&#x27;24&#x27;&#125; 跟&#123;age:&#x27;24&#x27;，name:&#x27;daisy&#x27; &#125;是一样的</span></span><br><span class="line">    <span class="comment">// 最后，对对象的value进行一个基本数据类型的比较，返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Component-vs-PureComponent-总结"><a href="#Component-vs-PureComponent-总结" class="headerlink" title="Component vs PureComponent 总结"></a><strong>Component vs PureComponent 总结</strong></h5><p>PureComponent相较于Component区别就是,对props和state默认进行判断来确定是否渲染,从而减少无效渲染次数. 大部分情况下直接用PureComponent比较好可以提高性能,但是如果遇到需要频繁修改值重新渲染的组件,用Component比较好,因为PureComponent频繁的判断也会影响性能.</p>
<h4 id="memo"><a href="#memo" class="headerlink" title="memo"></a>memo</h4><p><strong>针对函数组件的</strong>,减少组件的不必要更新。 <code>React.memo</code> 仅检查 props 变更。如果函数组件被 <code>React.memo</code> 包裹，且其实现中拥有 <a href="https://zh-hans.reactjs.org/docs/hooks-state.html"><code>useState</code></a>，<a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usereducer"><code>useReducer</code></a> 或 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext"><code>useContext</code></a> 的 Hook，当 state 或 context 发生变化时，它仍会重新渲染。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextCell = memo(<span class="function"><span class="keyword">function</span>(<span class="params">props:any</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我重新渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;props.click&#125;</span>&gt;</span>ffff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> fatherComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line"> <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      模块&#123;number&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">TextCell</span>/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setNumber(number =&gt; number + 1)&#125;&gt;加加加<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里如果没有用到memo 每次父组件重新setNumber,子组件都会重新渲染一次,加上了后<strong>只会在初始化的时候渲染(useMemo会在页面初始化的时候执行一次,并把执行的结果缓存一份)</strong>,减少了子组件渲染的次数</p>
<p>默认情况下其只会对复杂对象做<strong>浅层对比</strong>，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* 使用 props 渲染 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areEqual</span>(<span class="params">prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  如果把 nextProps 传入 render 方法的返回结果与</span></span><br><span class="line"><span class="comment">  将 prevProps 传入 render 方法的返回结果一致则返回 true，</span></span><br><span class="line"><span class="comment">  否则返回 false</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(MyComponent, areEqual);</span><br></pre></td></tr></table></figure>

<h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><p>无论是函数组件还是类组件，return 的 React 元素的语法必须是由一个标签包裹起来的所有虚拟 DOM 内容</p>
<p>一种是使用一个 div 标签将其包裹起来，另外一种方式就是使用 React 提供的 <code>&lt;React.Fragment&gt;</code> 将其包裹起来。但是我们不期望，增加额外的<code>dom</code>节点，所以<code>react</code>提供<code>Fragment</code>碎片概念，能够让一个组件返回多个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;React.Fragment&gt;</span><br><span class="line">      Some text.</span><br><span class="line">      &lt;h2&gt;A heading&lt;/h2&gt;</span><br><span class="line">    &lt;/React.Fragment&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="props-1"><a href="#props-1" class="headerlink" title="props"></a>props</h4><p>适用于父子组件通信</p>
<h5 id="父组件-gt-子组件"><a href="#父组件-gt-子组件" class="headerlink" title="父组件-&gt;子组件"></a>父组件-&gt;子组件</h5><p>父组件将需要传递的参数通过<code>key=&#123;xxx&#125;</code>方式传递至子组件，子组件通过<code>this.props.key</code>获取参数.</p>
<h5 id="子组件-gt-父组件"><a href="#子组件-gt-父组件" class="headerlink" title="子组件-&gt;父组件"></a>子组件-&gt;父组件</h5><p>利用 props callback 通信，父组件传递一个 callback 到子组件，当事件触发时将参数放置到 callback 带回给父组件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import Son from &#x27;./son&#x27;</span><br><span class="line">class Father extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    info: &#x27;&#x27;,</span><br><span class="line">  &#125;</span><br><span class="line">  callback = (value) =&gt; &#123;</span><br><span class="line">    // 此处的value便是子组件带回</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      info: value,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;&#123;this.state.info&#125;&lt;/p&gt;</span><br><span class="line">        &lt;Son callback=&#123;this.callback&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Father</span><br><span class="line"></span><br><span class="line">// 子组件</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">interface IProps &#123;</span><br><span class="line">  callback: (string) =&gt; void</span><br><span class="line">&#125;</span><br><span class="line">class Son extends React.Component&lt;IProps&gt; &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props)</span><br><span class="line">    this.handleChange = this.handleChange.bind(this)</span><br><span class="line">  &#125;</span><br><span class="line">  handleChange = (e) =&gt; &#123;</span><br><span class="line">    // 在此处将参数带回</span><br><span class="line">    this.props.callback(e.target.value)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;input type=&#x27;text&#x27; onChange=&#123;this.handleChange&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Son</span><br></pre></td></tr></table></figure>

<h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><p><a href="https://zh-hans.reactjs.org/docs/context.html">https://zh-hans.reactjs.org/docs/context.html</a></p>
<p>数据是通过 props 属性自上而下（由父及子）进行传递的 ，需要显式地通过组件树的逐层传递 props。Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// context.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="comment">//创建一个 Context 对象，并暴露Consumer和Provide</span></span><br><span class="line"><span class="keyword">const</span> &#123; Consumer, Provider &#125; = React.createContext(<span class="literal">null</span>) </span><br><span class="line"><span class="keyword">export</span> &#123; Consumer, Provider &#125;</span><br><span class="line"><span class="comment">//Father</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Son <span class="keyword">from</span> <span class="string">&#x27;./son&#x27;</span></span><br><span class="line">&lt;Provider value=&#123;<span class="built_in">this</span>.state.info&#125;&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.info&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Son</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/Provider&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//Son</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> GrandSon <span class="keyword">from</span> <span class="string">&#x27;./grandson&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">&#x27;./context&#x27;</span></span><br><span class="line">&lt;Consumer&gt;</span><br><span class="line">&#123;<span class="function">(<span class="params">info</span>) =&gt;</span> (</span><br><span class="line"><span class="comment">// 通过Consumer直接获取父组件的值</span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>父组件的值:&#123;info&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">GrandSon</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )&#125;</span><br><span class="line">&lt;/Consumer&gt;</span><br></pre></td></tr></table></figure>

<p>当 Provider 的 <code>value</code> 值发生变化时，它内部的所有消费组件都会重新渲染。从 Provider 到其内部 consumer 组件（包括 <a href="https://zh-hans.reactjs.org/docs/context.html#classcontexttype">.contextType</a> 和 <a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usecontext">useContext</a>）的传播不受制于  <code>shouldComponentUpdate</code> 函数，因此当 consumer 组件在其祖先组件跳过更新的情况下也能更新。 </p>
<h2 id="高阶函数与组件"><a href="#高阶函数与组件" class="headerlink" title="高阶函数与组件"></a>高阶函数与组件</h2><p>高阶组件即<code>高阶函数</code>，前面我们讲到，React遵循函数式开发，而高阶组件这个概念其实是React社区繁衍出来的概念。</p>
<p>在这里我们要谨记这一句话，<strong>组件 = 函数</strong>。</p>
<blockquote>
<p>高阶函数，通俗的讲，就是把函数当作参数，传入另外一个函数当中，再返回一个函数。</p>
</blockquote>
<h3 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a><strong>实际应用场景</strong></h3><h4 id="权限按钮"><a href="#权限按钮" class="headerlink" title="权限按钮"></a>权限按钮</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; useAccess &#125; from &#x27;../../../hooks/useAccess&#x27;;</span><br><span class="line">import &#123; message &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 权限高阶组件，使用示例：</span><br><span class="line"> * </span><br><span class="line"> * import WithAccess from &#x27;@components/WithAccess&#x27;;</span><br><span class="line"> * </span><br><span class="line"> * const WithAccessBtn = WithAccess(你的组件, 可选&#x27;button&#x27; | &#x27;menu&#x27; 默认为button);</span><br><span class="line"> * </span><br><span class="line"> * &lt;WithAccessBtn permission=&#x27;permission&#x27; /&gt;</span><br><span class="line"> * </span><br><span class="line"> * @param Comp 组件</span><br><span class="line"> * @param type 鉴权类型 按钮：button，菜单：menu</span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">const WithAccess = (Comp, type = &#x27;button&#x27;) =&gt; &#123;</span><br><span class="line">  const Access = props =&gt; &#123;</span><br><span class="line">    const &#123; getPermission &#125; = useAccess();</span><br><span class="line">    const &#123; permission, name, icon, onClick &#125; = props;</span><br><span class="line">    //showVisible是否展示, available是否有权限</span><br><span class="line">    const &#123; showVisible, available &#125; = getPermission(permission, type) || &#123;&#125;;</span><br><span class="line">    let initProps = props</span><br><span class="line">    console.log(props);</span><br><span class="line">    const config = () =&gt; &#123;</span><br><span class="line">      if (available === 0) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          onClick: () =&gt; &#123;</span><br><span class="line">            message.info(&#x27;按钮没有权限&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return showVisible ? &lt;Comp &#123;...initProps&#125; &#123;...config()&#125;&gt;&#123;name&#125;&lt;/Comp&gt; : null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Access;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default WithAccess;</span><br></pre></td></tr></table></figure>

<p>使用高阶组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import usePermissionModel from &quot;../../hox/access&quot;;</span><br><span class="line">import WithAccess from &#x27;./components&#x27;</span><br><span class="line">import &#123; Button, message &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; LaptopOutlined &#125; from &quot;@ant-design/icons&quot;;</span><br><span class="line"></span><br><span class="line">const WithAccessBtnYes = WithAccess(Button)</span><br><span class="line">const WithAccessBtnNo = WithAccess(Button)</span><br><span class="line">export default function AHooks(props) &#123;</span><br><span class="line">  const &#123; menus, set &#125; = usePermissionModel();</span><br><span class="line">  console.log(menus, set)</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;WithAccessBtnYes permission=&#x27;account:authorization:yes&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnYes&gt;</span><br><span class="line">    &lt;WithAccessBtnNo permission=&#x27;account:authorization:no&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnNo&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Hooks函数"><a href="#Hooks函数" class="headerlink" title="Hooks函数"></a>Hooks函数</h1><p><a href="http://www.ruanyifeng.com/blog/2019/09/react-hooks.html">http://www.ruanyifeng.com/blog/2019/09/react-hooks.html</a></p>
<ul>
<li>纯函数组件<strong>没有状态</strong></li>
<li>纯函数组件<strong>没有生命周期</strong></li>
<li>纯函数组件没有<code>this</code></li>
</ul>
<p>这就注定，我们所推崇的函数组件，只能做UI展示的功能，涉及到状态的管理与切换，我们不得不用类组件或者redux，但我们知道类组件的也是有缺点的，比如，遇到简单的页面，你的代码会显得很重，并且每创建一个类组件，都要去继承一个React实例，至于Redux,更不用多说，很久之前Redux的作者就说过，“能用React解决的问题就不用Redux”,等等一系列的话。关于<strong>React类组件r</strong>edux的作者又有话说</p>
<blockquote>
<ul>
<li>大型组件很难拆分和重构，也很难测试。</li>
<li>业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。</li>
<li>组件类引入了复杂的编程模式，比如 render props 和高阶组件。</li>
</ul>
</blockquote>
<p><strong>Hooks 优势</strong></p>
<ol>
<li>能优化类组件的三大问题</li>
<li>能在无需修改组件结构的情况下复用状态逻辑（自定义 Hooks ）</li>
<li>能将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据）</li>
</ol>
<p><strong>React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码”钩”进来。</strong>而React Hooks 就是我们所说的“钩子”。</p>
<h2 id="useState-状态钩子"><a href="#useState-状态钩子" class="headerlink" title="useState():状态钩子"></a>useState():状态钩子</h2><p>用于为函数组件引入状态（state）。纯函数不能有状态，所以把状态放在钩子里面。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//useState模拟1.0</span></span><br><span class="line"><span class="comment">//因为每次调用myUseState时会重置state的值。经过改进，必须将state写在函数的外面。</span></span><br><span class="line"><span class="keyword">let</span> _state;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myUseState</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  _state = _state===<span class="literal">undefined</span>? initialValue:_state;</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    _state = newValue; <span class="comment">//更新state值，</span></span><br><span class="line">    render(); <span class="comment">//触发重新渲染</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> [_state, setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 粗糙的渲染 */</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用myUseState</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = myUseState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">classNam</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		 <span class="tag">&lt;<span class="name">p</span>&gt;</span>n:&#123;n&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">		 <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setN(n+1)&#125;&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="xml">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	  );</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个组件用了两个useState怎么办？useState模拟2.0</span></span><br><span class="line"><span class="keyword">let</span> _state=[];</span><br><span class="line"><span class="keyword">let</span> index=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myUseState</span>(<span class="params">initialValue</span>) </span>&#123;</span><br><span class="line">  int currentIndex=index;	<span class="comment">//引入中间变量currentIndex就是为了保存当前操作的下标index。</span></span><br><span class="line">  _state[currentIndex] = _state[currentIndex]===<span class="literal">undefined</span>? initialValue:_state[currentIndex];</span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function">(<span class="params">newValue</span>) =&gt;</span> &#123;</span><br><span class="line">    _state[currentIndex] = newValue; </span><br><span class="line">    render(); </span><br><span class="line">  &#125;;</span><br><span class="line">  index+=<span class="number">1</span>;<span class="comment">// 每次更新完state值后，index值+1</span></span><br><span class="line">  <span class="keyword">return</span> [_state[currentIndex], setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  index=<span class="number">0</span>;	<span class="comment">//重要的一步，必须在渲染前后将index值重置为0，不然index会一种增加1</span></span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用myUseState</span></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = myUseState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [m, setM] = myUseState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">	  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">classNam</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">		 <span class="tag">&lt;<span class="name">p</span>&gt;</span>n:&#123;n&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">		 <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setN(n+1)&#125;&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="xml">		 <span class="tag">&lt;<span class="name">p</span>&gt;</span>m:&#123;m&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">		 <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>&#123;setM(m+1)&#125;&#125;&gt;n+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="xml">	  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">	  );</span><br><span class="line">&#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在正常的react的事件流里（如onClick等）</p>
<ul>
<li><p>setState和useState是<strong>异步执行</strong>的（不会立即更新state的结果，所以console数据没有更新）</p>
</li>
<li><p>多次执行setState和useState，只会调用一次重新渲染render</p>
</li>
<li><p>不同的是，setState会进行state的合并，而useState会进行state的覆盖</p>
</li>
</ul>
</li>
<li><p>在setTimeout，Promise.then等异步事件中</p>
<ul>
<li><p>setState和useState是<strong>同步执行</strong>的（立即更新state的结果，<strong>react17之后还是会批处理</strong>）</p>
</li>
<li><p>多次执行setState和useState，每一次的执行setState和useState，都会调用一次render</p>
</li>
</ul>
</li>
</ul>
<h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a><strong>批处理</strong></h3><p>batch批量处理：在每次执行 useState 的时候，组件都要重新 render 一次，会造成无效渲染，浪费时间（因为最后一次渲染会覆盖掉前面所有的渲染效果）。 所以 react 会把一些可以一起更新的 useState/setState 放在一起，只渲染一次。</p>
<p>在React16版本及以前，React 会对所有React内部触发的事件监听函数中的更新（比如onClick函数）做批处理，如果是绕过react组件，如addEventListenr，或者异步调用如异步请求或者setTimeout等，不会进行批处理。在React17版本及之后，React会对所有的更新做批处理。</p>
<p><strong>unstable_batchedUpdates手动批处理</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleClick3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 手动批处理</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    unstable_batchedUpdates(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setCount1(count1 + <span class="number">1</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(count1);</span><br><span class="line">      setFlag(<span class="function">(<span class="params">f</span>) =&gt;</span> !f);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;, <span class="number">10</span>);</span><br><span class="line">  <span class="comment">// React 只会在最后重新渲染一次（这是批处理！）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h3><ul>
<li><p>react中useState更新了组件，但是页面上的组件没有刷新</p>
<p>原因：useState更新的数据，是一个多层次的数据，<a href="https://so.csdn.net/so/search?q=react">react</a>监听的时候，是浅层监听(默认开启 类 Object.is 的浅层比较，所以指向的地址不变)，所以不一定及时刷新页面</p>
<p>解决办法:深拷贝，把需要更新的数据深拷贝一份，再使用useState 存储，就能实现每次都及时更新页面</p>
</li>
</ul>
<h2 id="useContext-共享状态钩子"><a href="#useContext-共享状态钩子" class="headerlink" title="useContext():共享状态钩子"></a>useContext():共享状态钩子</h2><p>如果需要在层层组件之间共享状态，可以使用<code>useContext()</code>。</p>
<p>第一步就是使用 React Context API，在组件外部建立一个 Context。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> AppContext = React.createContext(&#123;&#125;);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>组件封装代码如下。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line"><span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">&lt;AppContext.Provider value=&#123;&#123;</span><br><span class="line"><span class="attr">username</span>: <span class="string">&#x27;superawesome&#x27;</span></span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">Navbar</span>/&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">Messages</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/AppContext.Provider&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>AppContext.Provider</code>提供了一个 Context 对象，这个对象可以被子组件共享。</p>
<p>Navbar 组件的代码如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Navbar = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; username &#125; = useContext(AppContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;navbar&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>AwesomeSite<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;username&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="useReducer-钩子"><a href="#useReducer-钩子" class="headerlink" title="useReducer()钩子"></a>useReducer()钩子</h2><p><strong>useReducer适用于引用类型，而useState适合值类型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const [state, dispatch] = useReducer(reducer, initialArg, init)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>useReducer 接收三个参数，<strong>第一个参数为一个 reducer 函数，第二个参数是reducer的初始值，第三个参数为可选参数，值为一个函数，可以用来惰性提供初始状态。</strong></p>
<p>reducer 接受两个参数一个是 state 另一个是 action ，用法原理和 redux 中的 reducer 一致</p>
</li>
<li><p>useReducer 返回一个数组，数组中包含一个 state 和 dispath，state 是返回状态中的值，而 dispatch 是一个可以发布事件来更新 state 的函数。</p>
</li>
</ul>
<h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a><strong>原理</strong></h3><p><strong>useReucer 也是 useState 的内部实现</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> memoizedState</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, initialArg, init</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> initState = <span class="keyword">void</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> init === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        initState = init(initialArg)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        initState = initialArg</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">        memoizedState = reducer(memoizedState, action)</span><br><span class="line">        <span class="comment">// React的渲染</span></span><br><span class="line">        <span class="comment">// render()</span></span><br><span class="line">    &#125;</span><br><span class="line">    memoizedState = memoizedState || initState</span><br><span class="line">    <span class="keyword">return</span> [memoizedState, dispatch]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initState</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> useReducer(<span class="function">(<span class="params">oldState, newState</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> newState === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> newState(oldState)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newState</span><br><span class="line">    &#125;, initState)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>: <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;increment&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;decrement&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, dispatch] = useReducer(reducer, initialState);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">      Count: &#123;state.count&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;decrement&#x27;&#125;)&#125;&gt;-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> dispatch(&#123;type: &#x27;increment&#x27;&#125;)&#125;&gt;+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="useEffect-：副作用钩子"><a href="#useEffect-：副作用钩子" class="headerlink" title="useEffect()：副作用钩子"></a>useEffect()：副作用钩子</h2><p>纯函数只能进行数据计算，那些不涉及计算的操作（比如ajax 请求、访问原生dom 元素、本地持久化缓存、绑定/解绑事件、添加订阅、设置定时器、记录日志）应该写在哪里呢？</p>
<p>函数式编程将那些跟数据计算无关的操作，都称为 “<strong>副效应</strong>“ <strong>（side effect）</strong> 。</p>
<p><code>useEffect()</code>用来引入具有副作用的操作，最常见的就是向服务器请求数据。可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</p>
<p><strong><code>useEffect()</code>的用法如下：</strong></p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">useEffect(<span class="function">()  =&gt;</span>  &#123;</span><br><span class="line">    <span class="comment">// Async Action</span></span><br><span class="line">    <span class="comment">//return 则是在页面被卸载时调用.返回一个函数来指定如何“清除”副作用</span></span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;, [dependencies])</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面用法中，<code>useEffect()</code>接受两个参数。第一个参数是一个函数，异步操作的代码放在里面。第二个参数是一个数组，用于给出 Effect 的依赖项，只要这个数组发生变化，<code>useEffect()</code>就会执行。第二个参数可以省略，这时每次组件渲染时，就会执行<code>useEffect()</code>。</p>
<p><strong>它的常见用途有下面几种：</strong></p>
<ul>
<li>获取数据（data fetching）</li>
<li>事件监听或订阅（setting up a subscription）</li>
<li>改变 DOM（changing the DOM）</li>
<li>输出日志（logging）</li>
</ul>
<p><strong>tips</strong></p>
<ul>
<li><p><strong>它在第一次渲染之后<em>和</em>每次更新之后都会执行</strong></p>
</li>
<li><p>使用<code>useEffect()</code>时，有一点需要注意。如果有多个副效应，应该调用多个<code>useEffect()</code>，而不应该合并写在一起。</p>
</li>
<li><p>在useEffect中，不仅会请求后端的数据，还会通过调用setData来更新本地的状态，这样会触发view的更新。</p>
<p>但是，运行这个程序的时候，会出现无限循环的情况。useEffect在组件<strong>mount</strong>时执行，但也会在组件<strong>更新</strong>时执行。因为我们在每次请求数据之后都会设置本地的状态，所以组件会更新，因此useEffect会再次执行，因此出现了无限循环的情况。<strong>我们只想在组件mount时请求数据。</strong>我们可以传递一个空数组作为useEffect的第二个参数，这样就能避免在组件更新执行useEffect，只会在组件mount时执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> axios(</span><br><span class="line">      <span class="string">&#x27;http://localhost/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    setData(result.data);</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      ))&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<p>升级加载loading </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment, useState, useEffect &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = useState(&#123; <span class="attr">hits</span>: [] &#125;);</span><br><span class="line">  <span class="keyword">const</span> [query, setQuery] = useState(<span class="string">&#x27;redux&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [url, setUrl] = useState(</span><br><span class="line">    <span class="string">&#x27;http://hn.algolia.com/api/v1/search?query=redux&#x27;</span>,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">const</span> [isLoading, setIsLoading] = useState(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> fetchData = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      setIsLoading(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> axios(url);</span><br><span class="line"></span><br><span class="line">      setData(result.data);</span><br><span class="line">      setIsLoading(<span class="literal">false</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fetchData();</span><br><span class="line">  &#125;, [url]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">value</span>=<span class="string">&#123;query&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onChange</span>=<span class="string">&#123;event</span> =&gt;</span> setQuery(event.target.value)&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span></span></span><br><span class="line"><span class="xml">          setUrl(`http://localhost/api/v1/search?query=$&#123;query&#125;`)</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &gt;</span></span><br><span class="line"><span class="xml">        Search</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      &#123;isLoading ? (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>Loading ...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      ) : (</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;data.hits.map(item =&gt; (</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item.objectID&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;item.url&#125;</span>&gt;</span>&#123;item.title&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          ))&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="useCallback和useMemo"><a href="#useCallback和useMemo" class="headerlink" title="useCallback和useMemo"></a>useCallback和useMemo</h2><p><a href="https://www.xiaye0.com/?p=113">https://www.xiaye0.com/?p=113</a></p>
<p><a href="https://www.jianshu.com/p/014ee0ebe959">https://www.jianshu.com/p/014ee0ebe959</a></p>
<p><strong>useCallback和useMemo</strong>都会在组件第一次渲染的时候执行，之后会在其<strong>依赖的变量</strong>发生改变时再次执行；并且这两个hooks都返回<strong>缓存</strong>，<strong>useMemo返回缓存的变量，useCallback返回缓存的函数。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type DependencyList = ReadonlyArray&lt;any&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>&lt;<span class="title">T</span> <span class="title">extends</span> (<span class="params">...args: any[]</span>) =&gt; <span class="title">any</span>&gt;(<span class="params">callback: T, deps: DependencyList</span>): <span class="title">T</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMemo</span>&lt;<span class="title">T</span>&gt;(<span class="params">factory: () =&gt; T, deps: DependencyList | <span class="literal">undefined</span></span>): <span class="title">T</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>React 中当组件的 props 或 state 变化时，会重新渲染视图</strong></p>
</blockquote>
<h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>父组件给子组件传递属性（<strong>函数</strong>），父组件重新渲染，会重新创建函数，对应函数地址改变，即传给子组件的属性发生了变化，导致子组件渲染。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TextCell = memo(<span class="function"><span class="keyword">function</span>(<span class="params">props:any</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;我重新渲染了&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;props.click&#125;</span>&gt;</span>ffff<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> fatherComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> [number,setNumber] = useState(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> handleClick = useCallback(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="number">33</span>)</span><br><span class="line">&#125;,[])</span><br><span class="line"> <span class="keyword">return</span>(</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      模块&#123;number&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">TextCell</span> <span class="attr">click</span>=<span class="string">&#123;handleClick&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span>setNumber(number =&gt; number + 1)&#125;&gt;加加加<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里如果不使用useCallback,哪怕子组件用memo包裹了 也还是会更新子组件,因为子组件的绑定的函数click在父组件更新的时候也会更新<strong>引用地址</strong>,导致子组件的更新,但是这个其实是没必要的更新,绑定的函数并不需要子组件更新,useCallback就是阻止这类没必要的更新而存在的</p>
<p>这里需要注意的是 如果是有参数需要传递,则需要这样写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;TextCell click=&#123;useCallback(<span class="function">()=&gt;</span>handleClick(‘传递的参数’),[])&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong></p>
<ul>
<li><p>防止死循环</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于记录 getData 调用次数</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [val, setVal] = useState(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      setVal(<span class="string">&quot;new data &quot;</span> + count);</span><br><span class="line">      count++;</span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">val</span>=<span class="string">&#123;val&#125;</span> <span class="attr">getData</span>=<span class="string">&#123;getData&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">&#123;val, getData&#125;</span>) </span>&#123;</span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    getData();</span><br><span class="line">  &#125;, [getData]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;val&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<ol>
<li><code>App</code>渲染<code>Child</code>，将<code>val</code>和<code>getData</code>传进去</li>
<li><code>Child</code>使用<code>useEffect</code>获取数据。因为对<code>getData</code>有依赖，于是将其加入依赖列表</li>
<li><code>getData</code>执行时，调用<code>setVal</code>，导致<code>App</code>重新渲染</li>
<li><code>App</code>重新渲染时生成新的<code>getData</code>方法，传给<code>Child</code></li>
<li><code>Child</code>发现<code>getData</code>的引用变了，又会执行<code>getData</code></li>
<li>3 -&gt; 5 是一个死循环</li>
</ol>
</li>
</ul>
<h3 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h3><h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>useEventListener</p>
<p>如果你发现自己使用useEffect添加了许多事件监听，那你可能需要考虑将这些逻辑封装成一个通用的hook。</p>
<p>useWhyDidYouUpdate</p>
<p>这个hook让你更加容易观察到是哪一个prop的改变导致了一个组件的重新渲染。</p>
<p>useLockBodyScroll</p>
<p>有时候当一些特别的组件在你们的页面中展示时，你想要阻止用户滑动你的页面（想一想modal框或者移动端的全屏菜单）。</p>
<h1 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h1><p>路由是一种向用户显示不同页面的能力。 这意味着用户可以通过输入 URL 或单击页面元素在 WEB 应用的不同部分之间切换</p>
<p>这里需要说明一下 React Router 库中几个不同的 npm 依赖包，每个包都有不同的用途</p>
<table>
<thead>
<tr>
<th>相关组件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>react-router</td>
<td>实现了路由的核心功能，用作下面几个包的运行时依赖项(peer dependency)。</td>
</tr>
<tr>
<td>react-router-dom</td>
<td>基于 <code>react-router</code> 添加了浏览器运行环境的一些组件和功能。</td>
</tr>
<tr>
<td>react-router-native</td>
<td>适用于 <code>React Native</code></td>
</tr>
<tr>
<td>react-router-redux</td>
<td>React Router 和 Redux 的集成。</td>
</tr>
<tr>
<td>eact-router-config</td>
<td>提供可配置化的路由</td>
</tr>
</tbody></table>
<h2 id="React-Routers三类组件"><a href="#React-Routers三类组件" class="headerlink" title="React Routers三类组件"></a>React Routers三类组件</h2><h3 id="路由器Router"><a href="#路由器Router" class="headerlink" title="路由器Router"></a>路由器Router</h3><p><code>&lt;BrowserRouter&gt;</code>和<code>&lt;HashRouter&gt;</code>，两者之间的主要区别是它们存储URL和与Web服务器通信的方式。</p>
<h4 id="BrowserRouter"><a href="#BrowserRouter" class="headerlink" title="BrowserRouter"></a>BrowserRouter</h4><p><code>&lt;BrowserRouter&gt;</code>使用常规的URL路径。但它们要求正确配置服务器。具体来说，您的Web服务器需要在所有由React Router客户端管理的URL上提供相同的页面</p>
<p>BrowserRouter提供了如下属性</p>
<ul>
<li><code>basename (string)</code> 当前位置的基准 URL。当应用程序放置于服务器上子目录中时，可以设置，比如 <code>/public</code> 。</li>
<li><code>forceRefresh (boolean)</code>，在导航的过程中整个页面是否刷新</li>
<li><code>getUserConfirmation (func)</code>，当导航需要确认时执行的函数。默认是：window.confirm</li>
<li><code>keyLength (number)</code>  location.key 的长度。默认是 6</li>
<li><code>children (node)</code> 要渲染的子节点</li>
</ul>
<h4 id="HashRouter"><a href="#HashRouter" class="headerlink" title="HashRouter"></a>HashRouter</h4><p><code>&lt;HashRouter&gt;</code>将当前位置存储在<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">URL</a><a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/hash">的<code>hash</code>一部分中</a>，因此URL看起来像<code>http://example.com/#/your/page</code>。由于哈希从不发送到服务器，因此这意味着不需要特殊的服务器配置(<strong>在任意的路由进行页面的刷新都不会是 404</strong>)。</p>
<p>HashRouter提供了如下属性</p>
<ul>
<li><code>basename: string</code>, 同 <code>&lt;BrowserRouter&gt;</code> 的 <code>basename</code>。</li>
<li><code>getUserConfirmation: function</code>, 同 <code>&lt;BrowserRouter&gt;</code> 的 <code>getUserConfirmation</code>。</li>
<li><code>hashType: string</code>, Hash 编码类型，可选值 <code>&#39;slash&#39;(默认) | &#39;noslash&#39; | &#39;hashbang&#39;</code> 。<ul>
<li><code>slash</code>, 创建像 <code>#/</code>, <code>#/user/1</code> 这样的 hash 地址，默认值。</li>
<li><code>noslash</code>, 创建像 <code>#</code>, <code>#user/1</code> 这样的 hash 地址</li>
<li><code>hashbang</code>, 创建像 <code>#!/</code>, <code>#!/user/1</code> 这样的 ajax crawlable(已被 Google 遗弃) 的 hash 地址</li>
</ul>
</li>
<li><code>children: node</code>, 同 <code>&lt;BrowserRouter&gt;</code> 的 <code>children: node</code>。</li>
</ul>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><p>HashRouter：使用 URL 的哈希值实现</p>
<p>原理：监听 window 的 <code>hashchange</code> 事件来实现的</p>
<p>BrowserRouter（推荐）：使用 H5 的 history.pushState() API 实现</p>
<p>原理：监听 window 的 <code>popstate</code> 事件来实现的</p>
<p>BrowserRouter组件都会创建一个 <code>history</code> 实例对象，它记录了当前的位置，还记录了堆栈中以前的位置。在当前位置发生变化时，页面会被重新渲染，于是你就有一种导航跳转的感觉。</p>
<p>那么如何改变当前的位置呢？也就是说如何做到<strong>导航跳转</strong>呢？这时候 <code>history</code> 的作用就来了，这个对象暴露了一些方法，比如 <code>history.push</code> 和 <code>history.replace</code> ，它们就可以拿来处理上面的问题。</p>
<p>当你点击一个 <code>&lt;Link&gt;</code> 组件时，<code>history.push</code> 就会被调用，而当你使用一个 <code>&lt;Redirect&gt;</code> 组件时，<code>history.replace</code> 就会被调用。其它的方法比如 <code>history.Back</code> 和 <code>history.Forward</code> 可以用来在历史堆栈中回溯或前进。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ul>
<li><p><strong>basename: string</strong></p>
<p>原因是：ngix服务器上面要放不止一个网站 根目录下面已经有一个网站，这个网站需单独建一个文件夹。</p>
<p>作用：为所有位置添加一个基准URL<br>使用场景：假如你需要把页面部署到服务器的二级目录，你可以使用 <code>basename</code> 设置到此目录。</p>
</li>
</ul>
<h3 id="路线匹配器Route"><a href="#路线匹配器Route" class="headerlink" title="路线匹配器Route"></a>路线匹配器Route</h3><h4 id="Route"><a href="#Route" class="headerlink" title="Route"></a>Route</h4><h5 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h5><p><a href="https://www.jianshu.com/p/76ee90125e9f">https://www.jianshu.com/p/76ee90125e9f</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;span&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> onRemoveItem(item)&#125;&gt;Dismiss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/span&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">	<span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;handleRemoveItem&#125;</span>&gt;</span>Dismiss<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>如果我们使用内联函数，则每次调用“render”函数时都会创建一个新的函数实例。</p>
<p>当 React 进行虚拟 DOM diffing 时，它每次都会找到一个新的函数实例；因此在渲染阶段它会会绑定新函数并将旧实例扔给垃圾回收。</p>
<p>因此直接绑定内联函数就需要额外做垃圾回收和绑定到 DOM 的新函数的工作。</p>
<h5 id="三种渲染方式"><a href="#三种渲染方式" class="headerlink" title="三种渲染方式"></a><strong>三种渲染方式</strong></h5><p><a href="https://www.cnblogs.com/ypSharing/p/15587340.html">https://www.cnblogs.com/ypSharing/p/15587340.html</a></p>
<p><strong>优先级是 children &gt; component &gt; render。</strong> </p>
<ul>
<li><p><code>&lt;Route component&gt;</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route exact path=<span class="string">&quot;/home&quot;</span> component=&#123;Home&#125; /&gt;   <span class="comment">//推荐</span></span><br><span class="line">或</span><br><span class="line">&lt;Route exact path=<span class="string">&quot;/home&quot;</span> component=&#123;<span class="function">()=&gt;</span><span class="xml"><span class="tag">&lt;<span class="name">Home</span> /&gt;</span></span>&#125; /&gt; <span class="comment">// 内联函数</span></span><br></pre></td></tr></table></figure>

<p>参数：对象<code>&lt;Route path=&#39;/home&#39; component=&#123;home&#125;/&gt;</code></p>
<ul>
<li>直接使用组件类–使用最多的方式</li>
<li>缺点：不能把父组件中的数据通过props传递给路由组件中</li>
</ul>
<p>参数：函数<code>&lt;Route path=&#39;/home&#39; component=&#123;()=&gt;&lt;home/&gt;&#125; /&gt;</code></p>
<ul>
<li><p>使用函数，可以写条件判断，根据条件来渲染不同的组件</p>
</li>
<li><p>可以通过props来完成父组件中的数据向路由渲染组件传递</p>
</li>
<li><p>缺点：每次匹配路由成功都会从新创建组件—效率低下，不建议使用</p>
<p>路由会使用<code>React.createElement</code>从指定的组件中创建一个新的React元素。这意味着，如果你向组件属性提供内置函数，则将在每个渲染中创建一个新组件。这将导致现有组件的卸载和新组件的安装，而不是仅更新现有组件。使用内置函数进行内联渲染时，应使用<code>render</code>或<code>children</code>属性。</p>
</li>
</ul>
</li>
<li><p><code>&lt;Route render=&#123;(props)=&gt;&#123;return &lt;component/&gt;&#125;&#125;&gt;</code></p>
<ul>
<li><p>render方式渲染，使用函数方式</p>
</li>
<li><p>如果匹配相同，则不重新创建，效率高</p>
</li>
<li><p>建议如果组件对象方式渲染（函数方式）推荐使用render</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> render=&#123;(props)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.state.count==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> &lt;Home1 count=&#123;<span class="keyword">this</span>.state.count&#125;/&gt;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        retutn &lt;Home2/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><code>&lt;Route children&gt;</code></p>
<ul>
<li><p>组件对象方式：必须匹配到path的路由规则才渲染和render与component一样<br><code>&lt;Route path=&quot;/about&quot; children=&#123;&lt;About /&gt;&#125; /&gt;</code></p>
</li>
<li><p>函数方式：不管是否和path匹配都渲染</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在匹配时，容器的class是light，&lt;Home /&gt;会被渲染</span></span><br><span class="line"><span class="comment">// 在不匹配时，容器的class是dark，&lt;About /&gt;会被渲染</span></span><br><span class="line">&lt;Route path=<span class="string">&#x27;/home&#x27;</span> children=&#123;<span class="function">(<span class="params">&#123; match &#125;</span>) =&gt;</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;match</span> ? &#x27;<span class="attr">light</span>&#x27; <span class="attr">:</span> &#x27;<span class="attr">dark</span>&#x27;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;match ? <span class="tag">&lt;<span class="name">Home</span>/&gt;</span>:<span class="tag">&lt;<span class="name">About</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">)&#125;/&gt;</span></span><br></pre></td></tr></table></figure>

<p>一、它同 render 类似,是一个 function。不同的地方在于它会被传入一个 match 参数来告诉你这个 Route 的 path 和 location 匹配上没有。</p>
<p>二、第二个特殊的地方在于，即使 path 没有匹配上，我们也可以将它渲染出来。秘诀就在于前面一点提到的 match 参数。我们可以根据这个参数来决定在匹配的时候渲染什么，不匹配的时候又渲染什么。</p>
</li>
</ul>
</li>
</ul>
<h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a><strong>参数</strong></h5><ul>
<li><p><a id="exact">exact</a> 是否进行精确匹配，路由 <code>/a</code> 可以和 <code>/a/、/a</code> 匹配</p>
<blockquote>
<p>当exact为false时，根据路由匹配所有组件，例如/a/b/c 能匹配到/、/a、/a/b、/a/b/c 且匹配还是按顺序的</p>
<p>例如路由设置的前后顺序为:<br>1./ ；<br>2./a；<br>3./a/b ; <br>4./a/b/c<br>且前3个路径都没有设置 exact，这样前3个组件<strong>都会被渲染</strong>并且默认将2当作1的子页面，3当作2的子页面</p>
</blockquote>
</li>
<li><p><code>strict</code> 是否进行严格匹配，指明路径只匹配以斜线结尾的路径，路由<code>/a</code>可以和<code>/a</code>匹配，不能和<code>/a/</code>匹配，相比 <code>exact</code> 会更严格些</p>
</li>
<li><p><code>path (string)</code> 标识路由的路径,<code>path</code>属性可以使用通配符。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&quot;/hello/:name&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>通配符的规则如下:</p>
<ul>
<li><p><strong>paramName</strong></p>
<p><code>:paramName</code>匹配URL的一个部分，直到遇到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。这个路径参数可以通过<code>this.props.params.paramName</code>取出。</p>
</li>
<li><p>()</p>
<p><code>()</code>表示URL的这个部分是可选的。</p>
</li>
<li><p>*</p>
<p><code>*</code>匹配任意字符，直到模式里面的下一个字符为止。匹配方式是非贪婪模式。</p>
</li>
<li><p>**</p>
<p><code>**</code> 匹配任意字符，直到下一个<code>/</code>、<code>?</code>、<code>#</code>为止。匹配方式是贪婪模式。</p>
</li>
</ul>
</li>
<li><p><code>component</code> 表示路径对应显示的组件</p>
</li>
<li><p><code>location (object)</code> 除了通过 path 传递路由路径，也可以通过传递 location 对象可以匹配</p>
</li>
<li><p><code>sensitive (boolean)</code> 匹配路径时，是否区分大小写</p>
</li>
</ul>
<h4 id="Swtich"><a href="#Swtich" class="headerlink" title="Swtich"></a>Swtich</h4><p><code>Swtich</code> 就近匹配路由，仅渲染一个路由，路由的默认行为是匹配了就直接渲染</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 假设你访问的URL为 /dog</span></span><br><span class="line">&lt;Route path=<span class="string">&#x27;/dog&#x27;</span> component=&#123;Dog&#125;&gt;&lt;<span class="regexp">/Route&gt; /</span><span class="regexp">/ 虽然这里匹配了，但不会停止查找</span></span><br><span class="line"><span class="regexp">&lt;Route path=&quot;/</span>:dog<span class="string">&quot; component=&#123;Husky&#125;&gt;&lt;/Route&gt; // 这个路由依然会被匹配，这样两个组件都会被渲染</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">&lt;Switch&gt;</span></span><br><span class="line"><span class="string">  &lt;Route path=&#x27;/dog&#x27; component=&#123;Dog&#125;&gt;&lt;/Route&gt; // Switch 匹配一个路由后就不会再去查找下一个路由，那么下面的路由就不会被匹配</span></span><br><span class="line"><span class="string">  &lt;Route path=&quot;</span>/:dog<span class="string">&quot; component=&#123;Husky&#125;&gt;&lt;/Route&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><h4 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h4><p><code>&lt;Link&gt;</code> 组件被用来在<strong>页面之间</strong>进行导航，它其实就是 HTML 中的 <code>&lt;a&gt;</code> 标签的上层封装，不过在其源码中使用 <code>event.preventDefault</code> 禁止了其默认行为，然后使用 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/API/History_API">history API</a> 自己实现了跳转。我们都知道，如果使用 <code>&lt;a&gt;</code> 标签去进行导航的话，整个页面都会被刷新，这是我们不希望看到的。所以我们使用 <code>&lt;Link&gt;</code> 组件来导航到一个目标 URL，可以在不刷新页面的情况下重新渲染页面。</p>
<p><strong>参数</strong></p>
<ul>
<li><p>to（string | object | function）</p>
<ul>
<li><p>为 string 时 就是一个明确的路径地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&quot;/courses?sort=name&quot; /&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>为 object 时有如下属性（就是一个location对象）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Link</span><br><span class="line">  to=&#123;&#123;</span><br><span class="line">  	pathname: &quot;/courses&quot;,</span><br><span class="line">    search: &quot;?sort=name&quot;,</span><br><span class="line">    hash: &quot;#the-hash&quot;,</span><br><span class="line">    state: &#123; fromDashboard: true &#125;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>pathname：URL路径。</li>
<li>search：URl中查询字符串。</li>
<li>hash：URL的hash分段，例如#a-hash。</li>
<li>state：表示location中的状态</li>
</ul>
</li>
<li><p>为 function 时，就是一个函数接收当前 location 为参数，然后以字符串或对象的形式返回位置形式</p>
</li>
</ul>
</li>
<li><p><code>replace (boolean)</code>，当为 <code>true</code> 时，单击链接将替换历史堆栈中的当前记录，而不是添加一个新记录。</p>
</li>
</ul>
<h4 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h4><p><code>NavLink</code> 功能与 <code>Link</code> 类似不过参数更多，并且可以设置被选中时的样式或者类</p>
<ul>
<li><p><code>exact (boolean)</code> 是否进行精确匹配</p>
</li>
<li><p><code>strict (boolean)</code> 是否进行严格匹配</p>
</li>
<li><p><code>to（string | object）</code> 需要跳转到的路径(pathname)或地址（location）</p>
</li>
<li><p><code>activeClassName (string)</code> 是选中状态的类名，我们可以为其添加样式</p>
<p>当激活(<code>to</code> 属性与当前 URL 匹配)时，会将这个 class 选择器名添加到元素上，默认值为 <code>&#39;active&#39;</code></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;NavLink to=<span class="string">&quot;/faq&quot;</span> activeClassName=<span class="string">&quot;selected&quot;</span>&gt;</span><br><span class="line">  FAQs</span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>activeStyle (Object)</code> 元素处于选中状态时，应用于元素的样式</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">&quot;/faq&quot;</span></span><br><span class="line">  activeStyle=&#123;&#123;</span><br><span class="line">    <span class="attr">fontWeight</span>: <span class="string">&quot;bold&quot;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&quot;red&quot;</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  FAQs</span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><code>isActive(function)</code> ，一个函数，用于添加额外的逻辑，以确定链接是否处于激活状态。如果您想做的不仅仅是验证链接的路径名是否与当前 URL 的路径名匹配，那么应该使用此方法来返回 <code>true</code> 或 <code>false</code>。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;NavLink</span><br><span class="line">  to=<span class="string">&quot;/events/123&quot;</span></span><br><span class="line">  isActive=&#123;<span class="function">(<span class="params">match, location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!match) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// only consider an event active if its event id is an odd number</span></span><br><span class="line">    <span class="keyword">const</span> eventID = <span class="built_in">parseInt</span>(match.params.eventID);</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isNaN</span>(eventID) &amp;&amp; eventID % <span class="number">2</span> === <span class="number">1</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  Event <span class="number">123</span></span><br><span class="line">&lt;/NavLink&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h4><p><strong>重定向，新位置将覆盖历史堆栈中的当前位置</strong></p>
<p><code>from (string)</code> 需要重定向的路径，可以包括动态参数</p>
<p><code>push (boolean)</code> 为 true 时，重定向会将新条目推入历史记录，而不是替换当前条目</p>
<p><code>to (string | object)</code> 重定向到的路径</p>
<p><code>exact (boolean)</code> 是否要对 from 进行精确匹配</p>
<p><code>strict (boolean)</code> 是否要对 from 进行严格匹配</p>
<p><code>sensitive (boolean)</code> 匹配 from 时是否区分大小写</p>
<h3 id="IndexRoute和IndexRedirect"><a href="#IndexRoute和IndexRedirect" class="headerlink" title="IndexRoute和IndexRedirect"></a>IndexRoute和IndexRedirect</h3><h4 id="Index-Routes"><a href="#Index-Routes" class="headerlink" title="Index Routes"></a>Index Routes</h4><p>通常情况下，我们会建立如下情况的路由：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Accounts&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;statements&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Statements&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>

<p>当用户访问 <code>/</code> 时, App 组件被渲染，但组件内的子元素却没有， <code>App</code> 内部的 <code>this.props.children</code> 为 undefined 。 你可以简单地使用 <code>&#123;this.props.children ||&#125;</code> 来渲染一些默认的 UI 组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;App&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">IndexRoute</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;accounts&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Accounts&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;statements&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Statements&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>

<p>如此配置后，我们再次访问 <code>/</code> 路由，你会发现页面渲染了 Home 组件的内容。这就是 IndexRoute 的功能，指定一个路由的默认页。</p>
<h4 id="Index-Redirects"><a href="#Index-Redirects" class="headerlink" title="Index Redirects"></a>Index Redirects</h4><p>上面这种情况比较常见，还有一种非常常见的方式就是当我们尝试访问 <code>/</code> 这个路由时，我们想让其直接跳转到 ‘/Accounts’，直接免去了默认页 Home，这样来的更加直接。由此我们就需要 <code>IndexRedirect</code> 功能。考虑如下路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Router&gt;</span><br><span class="line">  &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;IndexRedirect to=&quot;/accounts&quot;/&gt;</span><br><span class="line">    &lt;Route path=&quot;accounts&quot; component=&#123;Accounts&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;statements&quot; component=&#123;Statements&#125;/&gt;</span><br><span class="line">  &lt;/Route&gt;</span><br><span class="line">&lt;/Router&gt;</span><br></pre></td></tr></table></figure>

<p>这样设计路由后，我们再次访问 <code>/</code> 时，系统默认会跳转到 <code>/accounts</code> 路由。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上就是 IndexRoute 和 IndexRedirect 的功能介绍，让我们来总结一下他们两个的区别。</p>
<ul>
<li>IndexRoute 一般情况下用于设计一个默认页且不改变 URL 地址，而 IndexRedirect 则是跳转默认地址且地址会发生改变。</li>
<li>IndexRoute 指定一个组件作为默认页，而 IndexRedirect 指定一个路由地址作为跳转地址。</li>
</ul>
<h2 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h2><h3 id="属性的隐式传递"><a href="#属性的隐式传递" class="headerlink" title="属性的隐式传递"></a><strong>属性的隐式传递</strong></h3><p>this.props.history/match/location</p>
<table>
<thead>
<tr>
<th>所属</th>
<th>属性</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>history</td>
<td>length</td>
<td>number</td>
<td>表示history堆栈的数量</td>
</tr>
<tr>
<td></td>
<td>action</td>
<td>string</td>
<td>表示当前的动作。比如pop、replace或push</td>
</tr>
<tr>
<td></td>
<td>location</td>
<td>object</td>
<td>表示当前的位置</td>
</tr>
<tr>
<td></td>
<td>push(path, [state])</td>
<td>function</td>
<td>在history堆栈顶加入一个新的条目</td>
</tr>
<tr>
<td></td>
<td>replace(path, [state])</td>
<td>function</td>
<td>替换在history堆栈中的当前条目</td>
</tr>
<tr>
<td></td>
<td>go(n)</td>
<td>function</td>
<td>将history堆栈中的指针向前移动</td>
</tr>
<tr>
<td></td>
<td>goBack()</td>
<td>function</td>
<td>等同于go(-1)</td>
</tr>
<tr>
<td></td>
<td>goForward()</td>
<td>function</td>
<td>等同于go(1)</td>
</tr>
<tr>
<td></td>
<td>block(promt)</td>
<td>function</td>
<td>阻止跳转</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>match</td>
<td>params</td>
<td>object</td>
<td>表示路径参数，通过解析URL中动态的部分获得的键值对</td>
</tr>
<tr>
<td></td>
<td>isExact</td>
<td>boolean</td>
<td>为true时，表示精确匹配</td>
</tr>
<tr>
<td></td>
<td>path</td>
<td>string</td>
<td>用来做匹配的路径格式</td>
</tr>
<tr>
<td></td>
<td>url</td>
<td>string</td>
<td>URL匹配的部分</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>location</td>
<td>pathname</td>
<td>string</td>
<td>URL路径</td>
</tr>
<tr>
<td></td>
<td>search</td>
<td>string</td>
<td>URl中查询字符串</td>
</tr>
<tr>
<td></td>
<td>hash</td>
<td>string</td>
<td>URL的hash分段</td>
</tr>
<tr>
<td></td>
<td>state</td>
<td>string</td>
<td>表示location中的状态</td>
</tr>
</tbody></table>
<h3 id="useHistory"><a href="#useHistory" class="headerlink" title="useHistory"></a>useHistory</h3><p>用以获取history对象，进行编程式的导航</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">  console.log(useHistory()); // 与 props.history 结果一致</span><br><span class="line">  console.log(props.history);</span><br><span class="line">  return &lt;div&gt;哈士奇&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">&lt;Route path=&quot;/dog&quot; component=&#123;Dog&#125;&gt;&lt;/Route&gt; // 必须这么写，props 才能拿到相关值</span><br><span class="line">...</span><br><span class="line">&lt;Route path=&quot;/husky&quot;&gt;</span><br><span class="line">	&lt;Husky /&gt;</span><br><span class="line">&lt;/Route&gt; // 这样写的话 useHistory 可以正常取值，但是 props 不行</span><br></pre></td></tr></table></figure>

<h3 id="useLocation"><a href="#useLocation" class="headerlink" title="useLocation"></a>useLocation</h3><p>用以获取location对象，可以查看当前路由信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">  console.log(useLocation()); // 与 props.location 结果一致</span><br><span class="line">  console.log(props.location);</span><br><span class="line">  return &lt;div&gt;哈士奇&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h3><p>useParams和props.match.params可以获取路由参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&quot;/blog/:eat&quot;&gt;</span><br><span class="line">    &lt;Husky /&gt;</span><br><span class="line">&lt;/Route&gt;</span><br><span class="line"></span><br><span class="line">const Husky = props =&gt; &#123;</span><br><span class="line">    console.log(useParams()) // 与 props.match.params 结果一致，但明显更简洁</span><br><span class="line">    console.log(props.match.params)</span><br><span class="line">    const &#123;eat&#125; = props.match.params;</span><br><span class="line">    return (</span><br><span class="line">    	&lt;div&gt;哈士奇 吃 &#123;eat&#125;&lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="useRouteMatch"><a href="#useRouteMatch" class="headerlink" title="useRouteMatch"></a>useRouteMatch</h3><p><code>useRouteMatch</code>，接受一个<strong>path字符串</strong>作为参数。当参数的path与当前的路径相匹配时，useRouteMatch会返回match对象，否则返回null。</p>
<p><code>useRouteMatch</code>在对于一些，<strong>不是路由级别的组件</strong>。但是<strong>组件自身的显隐却和当前路径相关的组件时</strong>，非常有用。</p>
<p>比如，你在做一个后台管理系统时，网页的Header只会在登录页显示，登录完成后不需要显示，这种场景下就可以用到<code>useRouteMatch</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const Home = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;Home&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">// Header组件只会在匹配`/detail/:id`时出现</span><br><span class="line">const Header = () =&gt; &#123;</span><br><span class="line">  // 只有当前路径匹配`/detail/:id`时，match不为null</span><br><span class="line">  const match = useRouteMatch(&#x27;/detail/:id&#x27;)</span><br><span class="line">  return (</span><br><span class="line">    match &amp;&amp; &lt;div&gt;Header&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">const Detail = () =&gt; &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div&gt;Detail&lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">function App() &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &lt;Header/&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route exact path=&quot;/&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">          &lt;Route exact path=&quot;/detail/:id&quot; component=&#123;Detail&#125;/&gt; </span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">      &lt;/Router&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="路由嵌套"><a href="#路由嵌套" class="headerlink" title="路由嵌套"></a>路由嵌套</h3><p>可以通过嵌套 <code>route</code> 来实现路由嵌套，注意<a href="#exact">exact</a></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根路由</span></span><br><span class="line">&lt;Switch&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;router&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Router&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line">&lt;/Switch&gt;</span><br><span class="line"><span class="comment">//Router.jsx</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>router<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/router/second/1&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/router/second/12&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="comment">//子路由的配置分散到各组件中</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/router/second/:id&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Second&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">Route</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>注意：如果在父路由中开启 exact 匹配，就会导致子组件加载不出来</p>
<h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p><a href="https://zh-hans.reactjs.org/docs/code-splitting.html">https://zh-hans.reactjs.org/docs/code-splitting.html</a></p>
<p><strong>Suspense和lazy</strong></p>
<p>如果我们项目有三个模块，用户管理（UserManage）、资产管理（AssetManage）、考勤管理（AttendanceManage）。当我们进入首页的时候由于没有进入任何一个模块，为了提高响应效率是不需要进行模块资源加载的，同时当我们进入用户管理的时候只需要加载用户管理路由对应的模块资源，进入其他模块亦然。这时候我们就需要对代码进行拆分，React.lazy可以结合Router来对模块进行懒加载。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React, &#123; Suspense, lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载引入组件 在用到路由组件时才发送请求</span></span><br><span class="line"><span class="comment">// 通过React的lazy函数配合import()函数动态加载路由组件 ===&gt; 路由组件代码会被分开打包 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/Home&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> UserManage = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/UserManage&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> AssetManage = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/AssetManage&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> AttendanceManage = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./routes/AttendanceManage&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="xml">     &#123;/* 用Suspense包含所有需要注册的路由 fallback为响应未回来时显示的内容 */&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/userManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;UserManage&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/assetManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AssetManage&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/attendanceManage&quot;</span> <span class="attr">component</span>=<span class="string">&#123;AttendanceManage&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter"></a>withRouter</h3><p>本质: 高阶组件</p>
<p>作用: 可以在非路由组件中注入路由对象</p>
<p>在没有路由指向(就是没有Route对象)的组件默认this.props当中没有路由所需要的参数，使用withRouter可以添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">import BackHome from &#x27;./backhome&#x27;;</span><br><span class="line">export default class Test extends React.Component &#123;</span><br><span class="line"> render () &#123;</span><br><span class="line">  console.log(this.props)</span><br><span class="line">  return (</span><br><span class="line">   &lt;div&gt;</span><br><span class="line">    这是测试的内容</span><br><span class="line">	//返回首页的按钮不是通过route标签渲染的，所以该子组件的this.props中没有路由参数</span><br><span class="line">    &lt;BackHome&gt;返回首页&lt;/BackHome&gt; </span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &#x27;react&#x27;;</span><br><span class="line">//导入withRoute</span><br><span class="line">import &#123;withRouter&#125; from &#x27;react-router-dom&#x27;;</span><br><span class="line">class BackHome extends React.Component &#123;</span><br><span class="line"> goHome = () =&gt; &#123;</span><br><span class="line">  //必须在使用withRouter的情况下，该组件在this.props中才有路由参数和方法</span><br><span class="line">  //否则，会报错</span><br><span class="line">  this.props.history.push(&#123;</span><br><span class="line">   pathname: &#x27;/home&#x27;,</span><br><span class="line">   state: &#123;</span><br><span class="line">    name: &#x27;dx&#x27; //同样，可以通过state向home路由对应的组件传递参数</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"> render () &#123;</span><br><span class="line">  return (</span><br><span class="line">   &lt;button onClick=&#123;this.goHome&#125;&gt;this.props.children&lt;/button&gt;</span><br><span class="line">  )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">//导出的时候，用withRouter标签将backHome组件以参数形式传出</span><br><span class="line">export default withRouter(BackHome)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h3><h4 id="param动态路由传参"><a href="#param动态路由传参" class="headerlink" title="param动态路由传参"></a><strong>param动态路由传参</strong></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/path/:name&#x27;</span> component=&#123;Path&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">to</span>=<span class="string">&#123;</span> &#x27;/<span class="attr">user</span>/&#x27; + &#x27;<span class="attr">2</span>&#x27; &#125;&gt;</span>xxx<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="built_in">this</span>.props.history.push(&#123;<span class="attr">pathname</span>:<span class="string">&quot;/path/&quot;</span> + name&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数用:this.props.match.params.name</span></span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、刷新页面参数不会丢失<br>缺点：<br>1、 当复杂数据对象或数组需要传参时，这样做比较麻烦，需要通过json字符串的方式进行处理</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义路由匹配</span></span><br><span class="line">&lt;Route path=<span class="string">&quot;/user/:data&quot;</span> component=&#123;Component&#125; /&gt;;</span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;tom&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> path = <span class="built_in">JSON</span>.Stringify(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递路由参数</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;path&#125;</span>&gt;</span>用户<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span>;</span><br><span class="line"><span class="built_in">this</span>.props.history.push(path);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由参数</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, name, age &#125; = <span class="built_in">this</span>.props.match.params.data;</span><br></pre></td></tr></table></figure>

<p>2、多个参数的传递，url 会又长又不美观<br>3、参数会出现在url上，不够安全 </p>
<h4 id="search传参"><a href="#search传参" class="headerlink" title="search传参"></a>search传参</h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/web/departManange&#x27;</span> component=&#123;DepartManange&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">to</span>=<span class="string">&quot;web/departManange?tenantId=12121212&quot;</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="built_in">this</span>.props.history.push(&#123;<span class="attr">pathname</span>:<span class="string">&quot;/web/departManange?tenantId&quot;</span> + row.tenantId&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取参数用: this.props.location.search</span></span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、刷新页面参数不会丢失<br>3、可以传递多个参数<br>缺点：<br>1、当复杂数据对象或数组需要传参时，这样做比较麻烦，需要通过json字符串的方式进行处理<br>2、参数会出现在url上，不够安全 </p>
<h4 id="query传参"><a href="#query传参" class="headerlink" title="query传参"></a><strong>query传参</strong></h4><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;Route path=<span class="string">&#x27;/query&#x27;</span> component=&#123;Query&#125;/&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&#123;&#123;</span> <span class="attr">path</span> <span class="attr">:</span> &#x27; /<span class="attr">query</span>&#x27; , <span class="attr">query</span> <span class="attr">:</span> &#123; <span class="attr">name</span> <span class="attr">:</span> &#x27;<span class="attr">sunny</span>&#x27; &#125;&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="xml">this.props.history.push(&#123;pathname:&quot;/query&quot;,query: &#123; name : &#x27;sunny&#x27; &#125;&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">//读取参数用: this.props.location.query.name</span></span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、可以传递多个参数<br>3、传递对象数组等复杂参数方便<br>4、不会暴露给用户，比较安全<br>缺点：<br>1、如果手动刷新当前路由时，数据参数有可能会丢失 </p>
<h4 id="state传参"><a href="#state传参" class="headerlink" title="state传参"></a><strong>state传参</strong></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;Link to=&#123;&#123;</span><br><span class="line">    pathname: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    state: &#123;</span><br><span class="line">        name: <span class="string">&#x27;dx&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#125;&gt;关于&lt;/Link&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.props.location.state</span><br></pre></td></tr></table></figure>

<p>优点：<br>1、传参和接收都比较简单<br>2、可以传递多个参数<br>3、传递对象数组等复杂参数方便<br>4、不会暴露给用户，比较安全<br>缺点：<br>1、如果手动刷新当前路由时，数据参数有可能会丢失 </p>
<p>在<a href="https://so.csdn.net/so/search?q=react&spm=1001.2101.3001.7020">react</a>中，最外层包裹了BrowserRouter时，不会丢失,但如果使用的时HashRouter，刷新当前页面时，会丢失state中的数据 </p>
<h1 id="状态管理器"><a href="#状态管理器" class="headerlink" title="状态管理器"></a>状态管理器</h1><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux是将整个应用状态存储到一个地方，称为store。里面保存一棵状态树(state tree)。组件可以派发(dispatch)行为(action)给store,action发出命令后将state放入reucer加工函数中，返回新的state。其它组件可以通过订阅store中的状态(state)来刷新自己的视图</p>
<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f09a0b5196a2dd~tplv-t2oaga2asx-watermark.awebp" alt="img" style="zoom:50%;" />



<h3 id="三大原则"><a href="#三大原则" class="headerlink" title="三大原则"></a>三大原则</h3><h4 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h4><p><strong>整个应用的state被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个store 中。</strong></p>
<h4 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h4><p><strong>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</strong></p>
<p>这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。<strong>action就是改变state的指令，有多少操作state的动作就会有多少action。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加todo任务的 action 是这样的：</span></span><br><span class="line"><span class="keyword">const</span> ADD_TODO = <span class="string">&#x27;ADD_TODO&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//action创建函数，返回一个action对象 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">  <span class="attr">type</span>: ADD_TODO,<span class="comment">//执行的动作</span></span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Build my first Redux app&#x27;</span>，</span><br><span class="line">  index：<span class="number">5</span>，<span class="comment">//用户完成任务的动作序列号</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Redux 中只需把 action 创建函数的结果传给 dispatch() 方法即可发起一次dispatch 过程。</span></span><br><span class="line">dispatch(addTodo(text))</span><br><span class="line"><span class="comment">//或者创建一个被绑定的 action 创建函数来自动 dispatch：</span></span><br><span class="line"><span class="keyword">const</span> boundAddTodo = <span class="function"><span class="params">text</span> =&gt;</span> dispatch(addTodo(text))</span><br><span class="line">boundAddTodo(text);</span><br><span class="line"><span class="comment">//store 里能直接通过 store.dispatch() 调用 dispatch() 方法，但是多数情况下你会使用 react-redux 提供的 connect() 帮助器来调用。</span></span><br></pre></td></tr></table></figure>

<h4 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h4><p><strong>reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(previousState, action) =&gt; newState</span><br></pre></td></tr></table></figure>

<p>之所以将这样的函数称之为reducer，是因为这种函数与被传入 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce"><code>Array.prototype.reduce(reducer, ?initialValue)</code></a> 里的回调函数属于相同的类型。保持 reducer 纯净非常重要。<strong>永远不要</strong>在 reducer 里做这些操作：</p>
<ul>
<li>修改传入参数；</li>
<li>执行有副作用的操作，如 API 请求和路由跳转；</li>
<li>调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</li>
</ul>
<p><strong>这是一个redux的经典案例</strong></p>
<ul>
<li><p>通过createStore创建store</p>
</li>
<li><p>actions 定义指令</p>
</li>
<li><p>调用store.dispatch()发出修改state的命令</p>
</li>
<li><p>定义reducer函数根据action的类型改变state</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span>;</span><br><span class="line"><span class="comment">//这里一个技巧是使用 ES6 参数默认值语法 来精简代码。</span></span><br><span class="line"><span class="keyword">const</span> reducer = <span class="function">(<span class="params">state = &#123;count: <span class="number">0</span>&#125;, action</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;INCREASE&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;DECREASE&#x27;</span>: <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count - <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">  <span class="attr">increase</span>: <span class="function">() =&gt;</span> (&#123;<span class="attr">type</span>: <span class="string">&#x27;INCREASE&#x27;</span>&#125;),</span><br><span class="line">  <span class="attr">decrease</span>: <span class="function">() =&gt;</span> (&#123;<span class="attr">type</span>: <span class="string">&#x27;DECREASE&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建 Redux store 来存放应用的状态。</span></span><br><span class="line"><span class="comment">// API 是 &#123; subscribe, dispatch, getState &#125;。</span></span><br><span class="line"><span class="keyword">let</span> store = createStore(counter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以手动订阅更新，也可以事件绑定到视图层。</span></span><br><span class="line">store.subscribe(<span class="function">() =&gt;</span></span><br><span class="line">  <span class="built_in">console</span>.log(store.getState())</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变内部 state 惟一方法是 dispatch 一个 action。</span></span><br><span class="line"><span class="comment">// action 可以被序列化，用日记记录和储存下来，后期还可以以回放的方式执行</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 1&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 2&#125;</span></span><br><span class="line">store.dispatch(actions.increase()) <span class="comment">// &#123;count: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="store构建"><a href="#store构建" class="headerlink" title="store构建"></a>store构建</h3><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a><strong>目录结构</strong></h4><p><a href="https://imgchr.com/i/sgpjbR"><img src="https://z3.ax1x.com/2021/01/19/sgpjbR.png" alt="屏幕截图"></a></p>
<h4 id="action"><a href="#action" class="headerlink" title="action"></a>action</h4><p><strong>存放描述行为的数据结构(本质上是 JavaScript 普通对象),一般来说你会通过 store.dispatch() 将 action 传到 store。</strong></p>
<p>我们约定，action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作。多数情况下，<code>type</code> 会被定义成字符串常量。当应用规模越来越大时，建议使用单独的模块或文件来存放 action。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	./actions/counter.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> INCREMENT = <span class="string">&#x27;INCREMENT&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> DECREMENT = <span class="string">&#x27;DECREMENT&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> increment = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  &#123;<span class="attr">type</span>:INCREMENT&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> decrement = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  &#123;<span class="attr">type</span>:DECREMENT&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：当我们表示用户完成任务的动作序列号时，我们还需要再添加一个 action index 来，所以我们通过下标 <code>index</code> 来引用特定的任务。而实际项目中一般会在新建数据的时候生成唯一的 ID 作为数据的引用标识。</p>
<h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a><strong>Reducer</strong></h4><p><strong>Reducers</strong> 指定了应用状态的变化如何响应 <a href="https://www.redux.org.cn/docs/basics/Actions.html">actions</a> 并发送到 store 的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	./reducers/counter.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT, DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;../actions/counter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">state = <span class="number">0</span>, action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> INCREMENT:</span><br><span class="line">          <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">case</span> DECREMENT:</span><br><span class="line">          <span class="keyword">return</span> state - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	./reducers/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> counter <span class="keyword">from</span> <span class="string">&#x27;./counter&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</span><br><span class="line">	counter</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="store"><a href="#store" class="headerlink" title="store"></a>store</h4><p><strong>注意：Redux 应用只有一个单一的 store</strong></p>
<p>我们学会了使用 action 来描述“发生了什么”，和使用 reducers 来根据 action 更新 state 的用法。</p>
<p><strong>Store</strong> 就是把它们联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#getState"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/258017257">https://zhuanlan.zhihu.com/p/258017257</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createLogger &#125; <span class="keyword">from</span> <span class="string">&#x27;redux-logger&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducers <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">configureStore</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> logger = createLogger(&#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middlewares = [thunk]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    middlewares.push(logger)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> composeEnhancers =</span><br><span class="line">    <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__</span><br><span class="line">      ? <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;)</span><br><span class="line">      : compose</span><br><span class="line">  <span class="keyword">const</span> enhancer = composeEnhancers(applyMiddleware(...middlewares))</span><br><span class="line"><span class="comment">//createStore() 的第二个参数是可选的, 用于设置 state 初始状态。这对开发同构应用时非常有用，服务器端 redux 应用的 state 结构可以与客户端保持一致, 那么客户端可以将从网络接收到的服务端 state 直接用于本地数据初始化。</span></span><br><span class="line">  <span class="keyword">return</span> createStore(reducers, enhancer)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> configureStore()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="redux-异步请求"><a href="#redux-异步请求" class="headerlink" title="redux 异步请求"></a>redux 异步请求</h3><p><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p>
<p><img src="https://upload-images.jianshu.io/upload_images/18616547-35a9f5f3f9956a6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800/format/webp" alt="img"></p>
<p>Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。<br>在实际的开发中，redux中管理的很多数据可能来自服务器，我们需要进行异步的请求，再将数据保存到redux中。就是说在异步的网络请求中通过dispatch action来更新state中的数据。这时候就需要用到Redux中间件**(指这个框架允许我们在某个流程的执行中间插入我们自定义的一段代码)**。</p>
<p><a href="https://github.com/gaearon/redux-thunk">Thunk middleware</a> 并不是 Redux 处理异步 action 的唯一方式：</p>
<ul>
<li>你可以使用 <a href="https://github.com/acdlite/redux-promise">redux-promise</a> 或者 <a href="https://github.com/pburtchaell/redux-promise-middleware">redux-promise-middleware</a> 来 dispatch Promise 来替代函数。</li>
<li>你可以使用 <a href="https://github.com/redux-observable/redux-observable">redux-observable</a> 来 dispatch Observable。</li>
<li>你可以使用 <a href="https://github.com/yelouafi/redux-saga/">redux-saga</a> 中间件来创建更加复杂的异步 action。</li>
<li>你可以使用 <a href="https://github.com/lelandrichardson/redux-pack">redux-pack</a> 中间件 dispatch 基于 Promise 的异步 Action。</li>
</ul>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="Provider-组件"><a href="#Provider-组件" class="headerlink" title="Provider 组件"></a>Provider 组件</h4><p><code>&lt;Provider store&gt;</code> 使组件层级中的 <code>connect()</code> 方法都能够获得 Redux store。正常情况下，你的根组件应该嵌套在 <code>&lt;Provider&gt;</code> 中才能使用 <code>connect()</code> 方法。</p>
<p>React-Redux 提供<code>Provider</code>组件，可以让容器组件拿到<code>state</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todoApp <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./components/App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todoApp);</span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span>,</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;root&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>Provider</code>在根组件外面包了一层，这样一来，<code>App</code>的所有子组件就默认都可以拿到<code>state</code>了。</p>
<p><strong>它的原理是<code>React</code>组件的<a href="https://facebook.github.io/react/docs/context.html"><code>context</code></a>属性</strong>，请看源码。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">getChildContext</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">store</span>: <span class="built_in">this</span>.props.store</span><br><span class="line"> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">this</span>.props.children;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line"><span class="attr">store</span>: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>store</code>放在了上下文对象<code>context</code>上面。然后，子组件就可以从<code>context</code>拿到<code>store</code>，代码大致如下。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisibleTodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> &#123; store &#125; = <span class="built_in">this</span>.context;</span><br><span class="line"> <span class="built_in">this</span>.unsubscribe = store.subscribe(<span class="function">() =&gt;</span></span><br><span class="line">   <span class="built_in">this</span>.forceUpdate()</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"> <span class="keyword">const</span> props = <span class="built_in">this</span>.props;</span><br><span class="line"> <span class="keyword">const</span> &#123; store &#125; = <span class="built_in">this</span>.context;</span><br><span class="line"> <span class="keyword">const</span> state = store.getState();</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VisibleTodoList.contextTypes = &#123;</span><br><span class="line"><span class="attr">store</span>: React.PropTypes.object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>React-Redux</code>自动生成的容器组件的代码，就类似上面这样，从而拿到<code>store</code>。</p>
<h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>React-Redux 提供<code>connect</code>方法，用于从 UI 组件生成容器组件。<code>connect</code>的意思，就是将这两种组件连起来。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect()(TodoList);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>TodoList</code>是 UI 组件，<code>VisibleTodoList</code>就是由 React-Redux 通过<code>connect</code>方法自动生成的容器组件。</p>
<p>但是，因为没有定义业务逻辑，上面这个容器组件毫无意义，只是 UI 组件的一个单纯的包装层。为了定义业务逻辑，需要给出下面两方面的信息。</p>
<blockquote>
<p>（1）输入逻辑：外部的数据（即<code>state</code>对象）如何转换为 UI 组件的参数</p>
<p>（2）输出逻辑：用户发出的动作如何变为 Action 对象，从 UI 组件传出去。</p>
</blockquote>
<p>因此，<code>connect</code>方法的完整 API 如下。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> VisibleTodoList = connect(</span><br><span class="line">mapStateToProps,</span><br><span class="line">mapDispatchToProps</span><br><span class="line">)(TodoList)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>connect</code>方法接受两个参数：<code>mapStateToProps</code>和<code>mapDispatchToProps</code>。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将<code>state</code>映射到 UI 组件的参数（<code>props</code>），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。</p>
<h5 id="mapStateToProps"><a href="#mapStateToProps" class="headerlink" title="mapStateToProps()"></a>mapStateToProps()</h5><p><code>mapStateToProps</code>是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）<code>state</code>对象到（UI 组件的）<code>props</code>对象的映射关系。也就是说， <strong>把state映射到props中去</strong> </p>
<p>作为函数，<code>mapStateToProps</code>执行后应该返回一个对象，里面的每一个键值对就是一个映射。请看下面的例子。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">todos</span>: getVisibleTodos(state.todos, state.visibilityFilter)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，<code>mapStateToProps</code>是一个函数，它接受<code>state</code>作为参数，返回一个对象。这个对象有一个<code>todos</code>属性，代表 UI 组件的同名参数，后面的<code>getVisibleTodos</code>也是一个函数，可以从<code>state</code>算出 <code>todos</code> 的值。</p>
<p>下面就是<code>getVisibleTodos</code>的一个例子，用来算出<code>todos</code>。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getVisibleTodos = <span class="function">(<span class="params">todos, filter</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (filter) &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;SHOW_ALL&#x27;</span>:</span><br><span class="line">   <span class="keyword">return</span> todos</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;SHOW_COMPLETED&#x27;</span>:</span><br><span class="line">   <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> t.completed)</span><br><span class="line"> <span class="keyword">case</span> <span class="string">&#x27;SHOW_ACTIVE&#x27;</span>:</span><br><span class="line">   <span class="keyword">return</span> todos.filter(<span class="function"><span class="params">t</span> =&gt;</span> !t.completed)</span><br><span class="line"> <span class="attr">default</span>:</span><br><span class="line">   <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown filter: &#x27;</span> + filter)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>mapStateToProps</code>会订阅 Store，每当<code>state</code>更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。</p>
<p><code>mapStateToProps</code>的第一个参数总是<code>state</code>对象，还可以使用第二个参数，代表容器组件的<code>props</code>对象。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 容器组件的代码</span></span><br><span class="line"><span class="comment">//    &lt;FilterLink filter=&quot;SHOW_ALL&quot;&gt;</span></span><br><span class="line"><span class="comment">//      All</span></span><br><span class="line"><span class="comment">//    &lt;/FilterLink&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="attr">active</span>: ownProps.filter === state.visibilityFilter</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用<code>ownProps</code>作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。</p>
<p><code>connect</code>方法可以省略<code>mapStateToProps</code>参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。</p>
<h5 id="mapDispatchToProps"><a href="#mapDispatchToProps" class="headerlink" title="mapDispatchToProps()"></a>mapDispatchToProps()</h5><p><code>mapDispatchToProps</code>是<code>connect</code>函数的第二个参数，<strong>用来建立各种dispatch变成props，让你可以直接使用  UI 组件的参数到<code>store.dispatch</code>方法的映射</strong>。也就是说，<strong>把各种dispatch变成了props让你可以直接使用</strong> </p>
<p>如果<code>mapDispatchToProps</code>是一个函数，会得到<code>dispatch</code>和<code>ownProps</code>（容器组件的<code>props</code>对象）两个参数。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">dispatch,</span></span></span><br><span class="line"><span class="params"><span class="function">ownProps</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"> <span class="attr">onClick</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">   dispatch(&#123;</span><br><span class="line">     <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line">     <span class="attr">filter</span>: ownProps.filter</span><br><span class="line">   &#125;);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>从上面代码可以看到，<code>mapDispatchToProps</code>作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。</p>
<p>如果<code>mapDispatchToProps</code>是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，返回的 Action 会由 Redux 自动发出。举例来说，上面的<code>mapDispatchToProps</code>写成对象就是下面这样。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mapDispatchToProps = &#123;</span><br><span class="line"><span class="attr">onClick</span>: <span class="function">(<span class="params">filter</span>) =&gt;</span> &#123;</span><br><span class="line"> <span class="attr">type</span>: <span class="string">&#x27;SET_VISIBILITY_FILTER&#x27;</span>,</span><br><span class="line"> <span class="attr">filter</span>: filter</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="实例：计数器"><a href="#实例：计数器" class="headerlink" title="实例：计数器"></a>实例：计数器</h5><p>我们来看一个实例。下面是一个计数器组件，它是一个纯的 UI 组件。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; increment, decrement &#125; <span class="keyword">from</span> <span class="string">&quot;../../store/actions/counter&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="keyword">function</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line"> <span class="comment">//生成props</span></span><br><span class="line"><span class="keyword">const</span> &#123; count, onincrement, ondecrement&#125; = props;</span><br><span class="line"><span class="comment">// console.log(props);</span></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">   <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">variant</span>=<span class="string">&quot;contained&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">color</span>=<span class="string">&quot;primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">onClick</span>=<span class="string">&#123;onincrement&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">     &gt;</span></span></span><br><span class="line"><span class="xml">       increment</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">Button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">variant</span>=<span class="string">&quot;contained&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">color</span>=<span class="string">&quot;primary&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">onClick</span>=<span class="string">&#123;ondecrement&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">       <span class="attr">style</span>=<span class="string">&#123;&#123;marginLeft:</span>&#x27;<span class="attr">30px</span>&#x27;&#125;&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">     &gt;</span></span></span><br><span class="line"><span class="xml">       decrement</span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span></span><br><span class="line"><span class="xml">     <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">30px</span>&#x27;&#125;&#125;&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面代码中，这个 UI 组件有三个参数：count和 onincrement, ondecrement。前者需要从<code>state</code>计算得到，后者需要向外发出 Action。</p>
<p>接着，定义<code>count</code>到<code>state</code>的映射，以及<code>onincrement, ondecrement</code>到<code>dispatch</code>的映射。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(state)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">   <span class="attr">count</span>: state.counter.count,</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">onincrement</span>: <span class="function">() =&gt;</span> dispatch(increment()),</span><br><span class="line">   <span class="attr">ondecrement</span>: <span class="function">() =&gt;</span> dispatch(decrement())</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，使用<code>connect</code>方法生成容器组件。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Home);</span><br></pre></td></tr></table></figure>
</blockquote>
<p>然后，定义这个组件的 Reducer。</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123;INCREMENT, DECREMENT&#125; <span class="keyword">from</span> <span class="string">&quot;../actions/counter&quot;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">state = &#123; count: <span class="number">0</span>&#125;, action</span>)</span>&#123;</span><br><span class="line"><span class="keyword">const</span> count = state.count</span><br><span class="line"><span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">     <span class="keyword">case</span> INCREMENT:</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="attr">count</span>:count + <span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">case</span> DECREMENT:</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="attr">count</span>:count - <span class="number">1</span>&#125;;</span><br><span class="line">     <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> &#123;<span class="attr">count</span>:count&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后，生成<code>store</code>对象，并使用<code>Provider</code>在根组件外面包一层。</p>
<blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> route <span class="keyword">from</span> <span class="string">&quot;../route/index.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;../store&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Menu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> classes = useStyles();</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line"> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="createStore"><a href="#createStore" class="headerlink" title="createStore"></a>createStore</h4><p><code>createStore(reducer, [preloadedState], enhancer)</code></p>
<p>创建一个 Redux <a href="https://www.redux.org.cn/docs/api/Store.html">store</a> 来以存放应用中所有的 state。<br>应用中应有且仅有一个 store。</p>
<p><strong>参数</strong></p>
<ol>
<li><code>reducer</code> <em>(Function)</em>: 接收两个参数，分别是当前的 state 树和要处理的 <a href="https://www.redux.org.cn/docs/Glossary.html#action">action</a>，返回新的 <a href="https://www.redux.org.cn/docs/Glossary.html#state">state 树</a>。</li>
<li>[<code>preloadedState</code>] <em>(any)</em>: 初始时的 state。 在同构应用中，你可以决定是否把服务端传来的 state 水合（hydrate）后传给它，或者从之前保存的用户会话中恢复一个传给它。如果你使用 <a href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers</code></a> 创建 <code>reducer</code>，它必须是一个普通对象，与传入的 keys 保持同样的结构。否则，你可以自由传入任何 <code>reducer</code> 可理解的内容。</li>
<li><code>enhancer</code> <em>(Function)</em>: Store enhancer 是一个组合 store creator 的<strong>高阶函数</strong>，返回一个新的强化过的 store creator。这与 middleware 相似，它也允许你通过复合函数改变 store 接口。</li>
</ol>
<p><strong>返回值</strong></p>
<p>(<a href="https://www.redux.org.cn/docs/api/Store.html"><em><code>Store</code></em></a>): 保存了应用所有 state 的对象。改变 state 的惟一方法是 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch">dispatch</a> action。你也可以 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe">subscribe 监听</a> state 的变化，然后更新 UI。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">todos</span>(<span class="params">state = [], action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;ADD_TODO&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> state.concat([action.text])</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(todos, [<span class="string">&#x27;Use Redux&#x27;</span>])</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Read the docs&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(store.getState())</span><br><span class="line"><span class="comment">// [ &#x27;Use Redux&#x27;, &#x27;Read the docs&#x27; ]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>应用中不要创建多个 store！相反，使用 <a href="https://www.redux.org.cn/docs/api/combineReducers.html"><code>combineReducers</code></a> 来把多个 reducer 创建成一个根 reducer。</li>
<li>要使用多个 store 增强器的时候，你可能需要使用 <a href="https://www.redux.org.cn/docs/api/compose.html">compose</a></li>
</ul>
<h4 id="Store-方法"><a href="#Store-方法" class="headerlink" title="Store 方法"></a>Store 方法</h4><p>Store 就是用来维持应用所有的 state 树 的一个对象。 改变 store 内 state 的惟一途径是对它 dispatch 一个 action。</p>
<ul>
<li>getState()</li>
<li>dispatch(action)</li>
<li>subscribe(listener)</li>
<li>replaceReducer(nextReducer)</li>
</ul>
<h4 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers"></a>combineReducers</h4><p>随着应用变得越来越复杂，可以考虑将 <a href="https://www.redux.org.cn/docs/Glossary.html#reducer">reducer 函数</a> 拆分成多个单独的函数，拆分后的每个函数负责独立管理 <a href="https://www.redux.org.cn/docs/Glossary.html#state">state</a> 的一部分。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#x27;redux&#x27;</span><br><span class="line">import counter from &#x27;./counter&#x27;</span><br><span class="line"></span><br><span class="line">export default combineReducers(&#123;</span><br><span class="line">	counter</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>combineReducers把一个由多个不同 reducer 函数作为 value 的 object，合并成一个最终的 reducer 函数，然后就可以对这个 reducer 调用 createStore 方法。</p>
<p>合并后的 reducer 可以调用各个子 reducer，并把它们返回的结果合并成一个 state 对象。</p>
<h4 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware"></a>applyMiddleware</h4><p><a href="https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html">https://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html</a></p>
<p><strong>applyMiddleware(…middlewares)</strong></p>
<p>使用包含自定义功能的 middleware 来扩展 Redux 是一种推荐的方式。Middleware 可以让你包装 store 的 dispatch 方法来达到你想要的目的。同时， middleware 还拥有“可组合”这一关键特性。多个 middleware 可以被组合到一起使用，形成 middleware 链。其中，每个 middleware 都不需要关心链中它前后的 middleware 的任何信息。</p>
<p>Middleware 最常见的使用场景是实现异步 actions。这种方式可以让你像 dispatch 一般的 actions 那样 <strong>dispatch 异步 actions</strong>。</p>
<p><strong>示例: 自定义 Logger Middleware</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> todos <span class="keyword">from</span> <span class="string">&#x27;./reducers&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logger</span>(<span class="params">&#123; getState &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">next</span>) =&gt;</span> <span class="function">(<span class="params">action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;will dispatch&#x27;</span>, action)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 middleware 链中下一个 middleware 的 dispatch。</span></span><br><span class="line">    <span class="keyword">let</span> returnValue = next(action)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;state after dispatch&#x27;</span>, getState())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一般会是 action 本身，除非</span></span><br><span class="line">    <span class="comment">// 后面的 middleware 修改了它。</span></span><br><span class="line">    <span class="keyword">return</span> returnValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> store = createStore(</span><br><span class="line">  todos,</span><br><span class="line">  [ <span class="string">&#x27;Use Redux&#x27;</span> ],</span><br><span class="line">  applyMiddleware(logger)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;ADD_TODO&#x27;</span>,</span><br><span class="line">  <span class="attr">text</span>: <span class="string">&#x27;Understand the middleware&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// (将打印如下信息:)</span></span><br><span class="line"><span class="comment">// will dispatch: &#123; type: &#x27;ADD_TODO&#x27;, text: &#x27;Understand the middleware&#x27; &#125;</span></span><br><span class="line"><span class="comment">// state after dispatch: [ &#x27;Use Redux&#x27;, &#x27;Understand the middleware&#x27; ]</span></span><br></pre></td></tr></table></figure>

<h4 id="compose-functions"><a href="#compose-functions" class="headerlink" title=" compose(...functions)"></a><code> compose(...functions)</code></h4><p>从右到左来组合多个函数。</p>
<p>这是函数式编程中的方法，为了方便，被放到了 Redux 里。<br>当需要把多个 <a href="https://www.redux.org.cn/docs/Glossary.html#store-enhancer">store 增强器</a> 依次执行的时候，需要用到它。</p>
<p><strong>参数</strong></p>
<ol>
<li>(<em>arguments</em>): 需要合成的多个函数。预计每个函数都接收一个参数。它的返回值将作为一个参数提供给它左边的函数，以此类推。例外是最右边的参数可以接受多个参数，因为它将为由此产生的函数提供签名。（译者注：<code>compose(funcA, funcB, funcC)</code> 形象为 <code>compose(funcA(funcB(funcC())))</code>）</li>
</ol>
<p><strong>返回值</strong></p>
<p>(<em>Function</em>): 从右到左把接收到的函数合成后的最终函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&#x27;redux-thunk&#x27;</span></span><br><span class="line"><span class="keyword">import</span> DevTools <span class="keyword">from</span> <span class="string">&#x27;./containers/DevTools&#x27;</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&#x27;../reducers/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  compose(</span><br><span class="line">    applyMiddleware(thunk),</span><br><span class="line">    DevTools.instrument()</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="Mobx"><a href="#Mobx" class="headerlink" title="Mobx"></a><strong>Mobx</strong></h2><p>作为了解的内容，在项⽬中使⽤redux的情况更多。</p>
<p>Mobx是⼀个功能强⼤，上⼿⾮常容易的状态管理⼯具。redux的作者也曾经向⼤家推荐过它，在不少情况下可以使⽤Mobx来替代掉redux。</p>
<h2 id="hox"><a href="#hox" class="headerlink" title="hox"></a>hox</h2><p><strong>定义 Model</strong>： 用 <code>createModel</code> 包装后，就变成了持久化，且全局共享的数据。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createModel &#125; <span class="keyword">from</span> <span class="string">&#x27;hox&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 任意一个 custom Hook */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCounter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> decrement = <span class="function">() =&gt;</span> setCount(count - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> increment = <span class="function">() =&gt;</span> setCount(count + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    decrement,</span><br><span class="line">    increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createModel(useCounter)</span><br></pre></td></tr></table></figure>

<p><strong>使用 Model</strong>：<code>createModel</code> 返回值是个 Hook，你可以按 React Hooks 的用法正常使用它。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useCounterModel &#125; <span class="keyword">from</span> <span class="string">&quot;../models/useCounterModel&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> counter = useCounterModel();</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;counter.count&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;counter.increment&#125;</span>&gt;</span>Increment<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="TS与React"><a href="#TS与React" class="headerlink" title="TS与React"></a>TS与React</h1><h2 id="jsx转ts"><a href="#jsx转ts" class="headerlink" title="jsx转ts"></a>jsx转ts</h2><p><a href="https://blog.yangteng.me/articles/2021/migrate-react-project-to-typescript/">https://blog.yangteng.me/articles/2021/migrate-react-project-to-typescript/</a></p>
<h3 id="配置TS"><a href="#配置TS" class="headerlink" title="配置TS"></a>配置TS</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add typescript</span><br></pre></td></tr></table></figure>

<p>然后加入 TypeScript 的配置文件：将 tsconfig.json 放到项目的根目录下。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;target&quot;</span>: <span class="string">&quot;es5&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;lib&quot;</span>: [<span class="string">&quot;dom&quot;</span>, <span class="string">&quot;dom.iterable&quot;</span>, <span class="string">&quot;esnext&quot;</span>],</span><br><span class="line">    <span class="attr">&quot;experimentalDecorators&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">//有的项目webpack会设置一些module的别名alias，ts也得配一下防止找不到</span></span><br><span class="line">    <span class="attr">&quot;baseUrl&quot;</span>: <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;paths&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;@@/*&quot;</span>: [<span class="string">&quot;./*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@/*&quot;</span>: [<span class="string">&quot;src/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@api/*&quot;</span>: [<span class="string">&quot;src/api/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@assets/*&quot;</span>: [<span class="string">&quot;src/assets/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@common/*&quot;</span>: [<span class="string">&quot;src/common/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@enum/*&quot;</span>: [<span class="string">&quot;src/enum/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@context/*&quot;</span>: [<span class="string">&quot;src/context/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@components/*&quot;</span>: [<span class="string">&quot;src/components/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@models/*&quot;</span>: [<span class="string">&quot;src/models/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@hooks/*&quot;</span>: [<span class="string">&quot;src/hooks/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@pages/*&quot;</span>: [<span class="string">&quot;src/pages/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@store/*&quot;</span>: [<span class="string">&quot;src/store/*&quot;</span>],</span><br><span class="line">      <span class="attr">&quot;@utils/*&quot;</span>: [<span class="string">&quot;src/utils/*&quot;</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;allowJs&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;skipLibCheck&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;esModuleInterop&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;allowSyntheticDefaultImports&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">&quot;forceConsistentCasingInFileNames&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;module&quot;</span>: <span class="string">&quot;esnext&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;moduleResolution&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;resolveJsonModule&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;isolatedModules&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;noEmit&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">&quot;jsx&quot;</span>: <span class="string">&quot;react&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;include&quot;</span>: [<span class="string">&quot;src&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="package"><a href="#package" class="headerlink" title="package"></a>package</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@babel/core&quot;: &quot;^7.15.8&quot;,</span><br><span class="line">    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.15.0&quot;,</span><br><span class="line">    &quot;@babel/preset-env&quot;: &quot;^7.15.8&quot;,</span><br><span class="line">    &quot;@babel/preset-react&quot;: &quot;^7.14.5&quot;,</span><br><span class="line">    &quot;@babel/preset-typescript&quot;: &quot;^7.15.0&quot;,</span><br><span class="line">    &quot;@types/react-redux&quot;: &quot;^7.1.23&quot;,</span><br><span class="line">    &quot;babel-loader&quot;: &quot;^8.2.2&quot;,</span><br><span class="line">    &quot;typescript&quot;: &quot;^4.6.3&quot;,</span><br><span class="line">&#125;</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;@types/node&quot;: &quot;^17.0.23&quot;,</span><br><span class="line">    &quot;@types/react&quot;: &quot;^17.0.43&quot;,</span><br><span class="line">    &quot;@types/react-dom&quot;: &quot;^17.0.14&quot;,</span><br><span class="line">    &quot;@types/react-router&quot;: &quot;^5.1.16&quot;,</span><br><span class="line">    &quot;@types/react-router-dom&quot;: &quot;^5.1.7&quot;,</span><br><span class="line">    &quot;less-loader&quot;: &quot;^10.2.0&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置-babel-和-webpack"><a href="#配置-babel-和-webpack" class="headerlink" title="配置 babel 和 webpack"></a>配置 babel 和 webpack</h3><p>将 babel 的 TypeScript 预设加入项目依赖中，并添加到 babel 的配置文件里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @babel/preset-typescript --dev</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// .babelrc</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="comment">// other presets</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&quot;@babel/typescript&quot;</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// other settings</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 修改 webpack 的配置，将 TypeScript 文件加入 <code>resolve</code> 和<code>babel-loader</code> 的 match 规则中。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// other settings</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.ts&#x27;</span>, <span class="string">&#x27;.tsx&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.(js|jsx|ts|tsx)$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: &#123;</span><br><span class="line">          <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">          <span class="attr">options</span>: &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引入类型定义的-package"><a href="#引入类型定义的-package" class="headerlink" title="引入类型定义的 package"></a>引入类型定义的 package</h3><p>上一步完成后，实际上已经可以在代码中使用 TypeScript 了。但这时候如果你去写一个 React 组件，就会发现类似 <code>Cannot find module &#39;react&#39;.</code> 的报错。这就需要将一些你用到的 library 的类型定义加进来了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add @types/react @types/react-dom @types/node <span class="comment">#@types/&lt;package-used-in-your-project&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h3><ul>
<li><p><strong>antd,css</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        loader: &#x27;less-loader&#x27;, // 编译 Less 为 CSS</span><br><span class="line">        options: &#123;</span><br><span class="line">          lessOptions: &#123;</span><br><span class="line">            javascriptEnabled: true,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="React-FC"><a href="#React-FC" class="headerlink" title="React.FC"></a>React.FC</h2><p><code>React.FC</code>是函数式组件，是在TypeScript使用的一个<strong>泛型</strong>。FC是FunctionComponent的缩写，<code>React.FC</code>可以写成<code>React.FunctionComponent</code>。这个类型定义了默认的 props(如 children)以及一些静态属性(如 defaultProps)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 声明Props类型</span><br><span class="line"> */</span><br><span class="line">export interface MyComponentProps &#123;</span><br><span class="line">  className?: string;</span><br><span class="line">  style?: React.CSSProperties;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const MyComponent: FC&lt;MyComponentProps&gt; = props =&gt; &#123;</span><br><span class="line">  return &lt;div&gt;hello react&lt;/div&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="NEXT"><a href="#NEXT" class="headerlink" title="NEXT"></a>NEXT</h1><p><a href="https://www.nextjs.cn/">https://www.nextjs.cn/</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>要从头开始使用 React 构建一个完整的 Web 应用程序，需要考虑许多重要的细节：</p>
<ul>
<li>必须使用打包程序（例如 webpack）打包代码，并使用 Babel 等编译器进行代码转换。</li>
<li>你需要针对生产环境进行优化，例如代码拆分。</li>
<li>你可能需要对一些页面进行预先渲染以提高页面性能和 SEO。你可能还希望使用服务器端渲染或客户端渲染。</li>
<li>你可能必须编写一些服务器端代码才能将 React 应用程序连接到数据存储。</li>
</ul>
<p><strong>Next.js：React 开发框架</strong></p>
<ul>
<li>直观的、 <a href="https://www.nextjs.cn/docs/basic-features/pages">基于页面</a> 的路由系统（并支持 <a href="https://www.nextjs.cn/docs/routing/dynamic-routes">动态路由</a>）</li>
<li><a href="https://www.nextjs.cn/docs/basic-features/pages#pre-rendering">预渲染</a>。支持在页面级的 <a href="https://www.nextjs.cn/docs/basic-features/pages#static-generation-recommended">静态生成</a> (SSG) 和 <a href="https://www.nextjs.cn/docs/basic-features/pages#server-side-rendering">服务器端渲染</a> (SSR)</li>
<li>自动代码拆分，提升页面加载速度</li>
<li>具有经过优化的预取功能的 <a href="https://www.nextjs.cn/docs/routing/introduction#linking-between-pages">客户端路由</a></li>
<li><a href="https://www.nextjs.cn/docs/basic-features/built-in-css-support">内置 CSS</a> 和 <a href="https://www.nextjs.cn/docs/basic-features/built-in-css-support#sass-support">Sass 的支持</a>，并支持任何 <a href="https://www.nextjs.cn/docs/basic-features/built-in-css-support#css-in-js">CSS-in-JS</a> 库</li>
<li>开发环境支持 <a href="https://www.nextjs.cn/docs/basic-features/fast-refresh">快速刷新</a></li>
<li>利用 Serverless Functions 及 <a href="https://www.nextjs.cn/docs/api-routes/introduction">API 路由</a> 构建 API 功能</li>
<li>完全可扩展</li>
</ul>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npx create-next-app nextjs-blog --use-npm --example &quot;https://github.com/vercel/next-learn-starter/tree/master/learn-starter&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd nextjs-blog</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>在浏览器中打开 <a href="http://localhost:3000/">http://localhost:3000</a> 。</p>
<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><h3 id="客户端导航"><a href="#客户端导航" class="headerlink" title="客户端导航"></a>客户端导航</h3><p>在 Next.js 中，页面是从<a href="https://www.nextjs.cn/docs/basic-features/pages"><code>pages</code>目录中</a>的文件导出的 React 组件。</p>
<p>页面与基于其<strong>文件名</strong>的路由相关联。例如，在开发中：</p>
<ul>
<li><code>pages/index.js</code>与<code>/</code>路由相关联。</li>
<li><code>pages/posts/first-post.js</code>与<code>/posts/first-post</code>路由相关联。</li>
</ul>
<p><strong>在页面之间导航</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Link from &#x27;next/link&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Read &lt;Link href=&quot;/posts/first-post&quot;&gt;&lt;a&gt;this page!&lt;/a&gt;&lt;/Link&gt;</span><br></pre></td></tr></table></figure>

<p>该<a href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件支持在同一个 Next.js 应用程序中的两个页面之间进行<strong>客户端导航</strong>。</p>
<p>客户端导航意味着页面转换<em>使用 JavaScript 进行</em>，这比浏览器执行的默认导航更快。</p>
<p>该<a href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件支持在同一个 Next.js 应用程序中的两个页面之间进行<strong>客户端导航</strong>。</p>
<p>客户端导航意味着页面转换<em>使用 JavaScript 进行</em>，这比浏览器执行的默认导航更快。</p>
<p>这是您可以验证的简单方法：</p>
<ul>
<li>使用浏览器的开发人员工具将<code>background</code>CSS 属性更改<code>&lt;html&gt;</code>为<code>yellow</code>。</li>
<li>单击链接可在两个页面之间来回切换。</li>
<li>您会看到黄色背景在页面转换之间持续存在。</li>
</ul>
<p>这表明浏览器<em>未</em>加载完整页面并且客户端导航正在工作。</p>
<img src="https://www.nextjs.cn/static/images/learn/navigate-between-pages/client-side.gif" alt="Links" style="zoom:50%;" />

<p>如果您使用了<code>&lt;a href=&quot;…&quot;&gt;</code>代替<code>&lt;Link href=&quot;…&quot;&gt;</code>并执行了此操作，则链接点击时背景颜色将被清除，因为浏览器会完全刷新。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>Next.js 支持具有动态路由的 pages（页面）。例如，如果你创建了一个命名为 <code>pages/posts/[id].js</code> 的文件，那么就可以通过 <code>posts/1</code>、<code>posts/2</code> 等类似的路径进行访问。</p>
<ul>
<li><code>pages/blog/[slug].js</code> → <code>/blog/:slug</code> (<code>/blog/hello-world</code>)</li>
<li><code>pages/[username]/settings.js</code> → <code>/:username/settings</code> (<code>/foo/settings</code>)</li>
<li><code>pages/post/[...all].js</code> → <code>/post/*</code> (<code>/post/2020/id/title</code>)</li>
</ul>
<h3 id="代码拆分和预取"><a href="#代码拆分和预取" class="headerlink" title="代码拆分和预取"></a>代码拆分和预取</h3><p>Next.js 会自动进行代码拆分，因此每个页面只加载该页面所需的内容。这意味着在呈现主页时，最初不会提供其他页面的代码。</p>
<p>这可确保即使您添加数百个页面，主页也能快速加载。</p>
<p>仅加载您请求的页面的代码也意味着页面变得孤立。如果某个页面抛出错误，应用程序的其余部分仍然可以工作。</p>
<p>此外，在 Next.js 的生产版本中，每当<a href="https://www.nextjs.cn/docs/api-reference/next/link"><code>Link</code></a>组件出现在浏览器的视口中时，Next.js 都会在后台自动<strong>预取</strong>链接页面的代码。当您单击链接时，目标页面的代码已在后台加载，页面转换将近乎即时！</p>
<h3 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h3><h4 id="html"><a href="#html" class="headerlink" title="html"></a>html</h4><p><code>&lt;Head&gt;</code>使用 代替小写字母<code>&lt;head&gt;</code>。<code>&lt;Head&gt;</code>是一个内置于 Next.js 的 React 组件。它允许您修改<code>&lt;head&gt;</code>页面的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import Head from &#x27;next/head&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charSet</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&#123;props.description&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">meta</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>&#123;props.title&#125;<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Head</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="img"><a href="#img" class="headerlink" title="img"></a>img</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img统一放在public中，引用直接引用img，不需要添加图像路径</span><br><span class="line">src=&quot;/head.jpg&quot;</span><br></pre></td></tr></table></figure>

<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style jsx&gt;&#123;`</span><br><span class="line">  …</span><br><span class="line">`&#125;&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>这是使用一个名为<a href="https://github.com/vercel/styled-jsx">styled-jsx</a>的库。它是一个“CSS-in-JS”库——它允许你在 React 组件中编写 CSS，并且 CSS 样式将被<em>限定</em>（其他组件不会受到影响）。</p>
<p>Next.js 内置了对<a href="https://github.com/vercel/styled-jsx">styled-jsx 的</a>支持，但您也可以使用其他流行的 CSS-in-JS 库。我用的是materialUI框架中的css-in-js</p>
<ul>
<li><p>全局样式</p>
<p>如果你希望<strong>每个页面</strong>都加载一些 CSS，添加pages/_app.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#x27;../styles/global.css&#x27;</span><br><span class="line">export default function App(&#123; Component, pageProps &#125;) &#123;</span><br><span class="line">  return &lt;Component &#123;...pageProps&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建一个顶级styles目录并global.css在里面创建。将其导入pages/_app.js</p>
</li>
</ul>
<h2 id="内置API"><a href="#内置API" class="headerlink" title="内置API"></a>内置API</h2><p>某些页面需要获取外部数据以进行预渲染。有两种情况，在每种情况下，您都可以使用 Next.js 提供的特殊功能：</p>
<ol>
<li>您的页面 <strong>内容</strong> 取决于外部数据：使用 <code>getStaticProps</code>。</li>
<li>你的页面 <strong>paths（路径）</strong> 取决于外部数据：使用 <code>getStaticPaths</code> （通常还要同时使用 <code>getStaticProps</code>）。</li>
</ol>
<p><strong>getStaticProps</strong>函数在<strong>构建时</strong>被调用，并允许你在预渲染时将获取的数据作为 <code>props</code> 参数传递给页面。<strong>getStaticProps不会在页面组件中生效</strong></p>
<p>Next.js 允许你创建具有 <strong>动态路由</strong> 的页面。例如，你可以创建一个名为 <code>pages/posts/[id].js</code> 的文件用以展示以 <code>id</code> 标识的单篇博客文章。当你访问 <code>posts/1</code> 路径时将展示 <code>id: 1</code> 的博客文章。但是，在构建 <code>id</code> 所对应的内容时可能需要从外部获取数据。<strong>getStaticPaths</strong>函数在构建时被调用，并允许你指定要预渲染的路径。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此函数在构建时被调用</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getStaticPaths</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 调用外部 API 获取博文列表</span></span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(<span class="string">&#x27;https://.../posts&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> res.json()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 据博文列表生成所有需要预渲染的路径</span></span><br><span class="line">  <span class="keyword">const</span> paths = posts.map(<span class="function">(<span class="params">post</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">params</span>: &#123; <span class="attr">id</span>: post.id &#125;,</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We&#x27;ll pre-render only these paths at build time.</span></span><br><span class="line">  <span class="comment">// &#123; fallback: false &#125; means other routes should 404.</span></span><br><span class="line">  <span class="keyword">return</span> &#123; paths, <span class="attr">fallback</span>: <span class="literal">false</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了让页面使用服务端渲染，你需要导出 getServerSideProps 异步函数。这个函数将在<strong>每次请求</strong>时在服务端被调用。例如，假设你的页面需要用最新的数据预渲染（通过外部的 api 获取数据）。你应该写下 getServerSideProps 来获取数据传递给 Page。</p>
<p>getServerSideProps 和 getStaticProps 很像，但是区别的是，getServerSideProps 是每个请求都会调用而不是在构建时。</p>
<h2 id="mardown解析"><a href="#mardown解析" class="headerlink" title="mardown解析"></a>mardown解析</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p><a href="https://dev.to/imranib/build-a-next-js-markdown-blog-5777">https://dev.to/imranib/build-a-next-js-markdown-blog-5777</a></p>
<ul>
<li><p><a href="https://www.npmjs.com/package/react-markdown">react-markdown</a>将帮助我们解析和渲染 Markdown 文件</p>
</li>
<li><p>代码格式化：<code>react-syntax-highlighter</code>包</p>
</li>
<li><p>gray-matter](<a href="https://www.npmjs.com/package/react-markdown">https://www.npmjs.com/package/react-markdown</a>) 将解析我们博客的<em>顶部内容</em>。（文件顶部的部分<code>---</code> ）</p>
<p>我们需要这样的元数据<code>title</code>，<code>data</code> 并<code>description</code>和<code>slug</code>。您可以在此处添加任何您喜欢的内容</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>slug</td>
<td>导航的参数</td>
</tr>
<tr>
<td>title</td>
<td>文章名称</td>
</tr>
<tr>
<td>data</td>
<td>最新时间</td>
</tr>
<tr>
<td>updated</td>
<td>文章更新日期</td>
</tr>
<tr>
<td>tags</td>
<td>文章標籤</td>
</tr>
<tr>
<td>category</td>
<td>文章分類</td>
</tr>
<tr>
<td>description</td>
<td>文章描述</td>
</tr>
</tbody></table>
<ul>
<li><a href="https://www.npmjs.com/package/raw-loader">raw-loader</a>将帮助我们导入我们的markdown文件。 </li>
</ul>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><a href="https://dev.to/imranib/build-a-next-js-markdown-blog-5777">https://dev.to/imranib/build-a-next-js-markdown-blog-5777</a></p>
<p><a href="https://thetombomb.com/posts/adding-code-snippets-to-static-markdown-in-Next%20js">https://thetombomb.com/posts/adding-code-snippets-to-static-markdown-in-Next%20js</a></p>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><ul>
<li>material,classname报错，每次刷新，material失去效果。添加_app.js和__document.js文件</li>
</ul>
]]></content>
      <categories>
        <category>react技术栈</category>
      </categories>
      <tags>
        <tag>router</tag>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>hooks</tag>
        <tag>生命周期</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6，TS和设计模式</title>
    <url>/2020/09/25/04-ES6%E5%92%8CTS/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="http://caibaojian.com/es6/">http://caibaojian.com/es6/</a></p>
<h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="let和const"><a href="#let和const" class="headerlink" title="let和const"></a><strong>let和const</strong></h2><p><code>let</code>和<code>const</code>。其中，<code>let</code>完全可以取代<code>var</code>，因为两者语义相同，而且<code>let</code>没有副作用。在<code>let</code>和<code>const</code>之间，建议优先使用<code>const</code>，尤其是在全局环境，不应该设置变量，只应设置常量。同时JavaScript 编译器会对<code>const</code>进行优化，所以多使用<code>const</code>，有利于提高程序的运行效率 </p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域定义了变量的可见性或可访问性。大白话来说，就是一个变量能不能被访问或引用，是由它的作用域决定的。</p>
<ul>
<li><p><strong>全局作用域（Global Scope）</strong></p>
<p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p>
<p>（1）最外层函数和在最外层函数外面定义的变量拥有全局作用域</p>
<p>（2）所有末定义直接赋值的变量自动声明为拥有全局作用域</p>
<p>（3）所有window对象的属性拥有全局作用域</p>
</li>
<li><p><strong>局部作用域（Local Scope）</strong></p>
<ul>
<li><p><strong>函数作⽤域</strong>：函数体中的局部变量只在函数执行时生成，函数执行完毕时局部变量即刻销毁</p>
</li>
<li><p><strong>块级作⽤域</strong>：ES6引⼊了 let 和 const 关键字,和 var 关键字不同，在⼤括号中使⽤ let 和 const 声明的变量存 在于块级作⽤域中。在⼤括号之外不能访问这些变量</p>
</li>
</ul>
</li>
</ul>
<p><strong>作用域链</strong></p>
<p>当一个变量在当前作用域无法找到时，便会尝试寻找其外层的作用域，如果还找不到，再继续往上寻找</p>
<p><strong>好处</strong></p>
<ol>
<li><code>防止命名冲突</code>：你写了一万行的代码文件，如果没有作用域，你要给每个变量取独一无二的名字，屁股想想也知道是种折磨。</li>
<li><code>安全性</code>： 变量不会被外部访问，保证了变量值不会被随意修改。你定义在函数内的变量，如果能在几千行之后不小心被修改，脚趾头想想也知道是种折磨。</li>
<li><code>更高级的语法</code>：封装、面向对象等的实现离不开对变量的隔离，这是依靠作用域所达到的。</li>
</ol>
<h3 id="var变量和函数提升"><a href="#var变量和函数提升" class="headerlink" title="var变量和函数提升"></a>var变量和函数提升</h3><p><strong>词法分析阶段/预解析</strong>：在JS代码执行之前，浏览器的解析器在<strong>遇到 var 变量名 和function 整个函数</strong> 提升到当前作用域的最前面。</p>
<ul>
<li><p>变量提升只会提升变量名的声明，而不会提升变量的赋值初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(foo); // undefined</span><br><span class="line">var foo = &#x27;小花猫&#x27;;</span><br><span class="line">console.log(foo)  // 小花猫</span><br></pre></td></tr></table></figure></li>
<li><p>函数声明会提升而函数表达表达式不会提升</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(test1()) // &#x27;this is test1&#x27;</span><br><span class="line">function test1()&#123;</span><br><span class="line">  return &#x27;this is test1&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(test2) // undefined</span><br><span class="line">var test2 = function()&#123;</span><br><span class="line">  return &#x27;this is test2&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>函数提升的优先级大于变量提升的优先级</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = foo || <span class="number">5</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">hoistVariable();</span><br><span class="line"></span><br><span class="line"><span class="comment">//预编译后</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hoistVariable</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> foo</span><br><span class="line">  foo = foo || <span class="number">5</span>; <span class="comment">// 此时 等号右侧 foo 为 undefined</span></span><br><span class="line">  <span class="built_in">console</span>.log(foo); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line">foo = <span class="number">3</span></span><br><span class="line">hoistVariable();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a><strong>不存在变量提升</strong></h3><p>暂时性死区: 区级作用域中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。<strong>凡是在声明之前就使用这些变量，就会报错。</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">x = y, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(x = y, y = 2)作为函数参数作用域，父作用域</span></span><br><span class="line"><span class="comment">//函数内部是一个单独的子作用域</span></span><br><span class="line">bar(); <span class="comment">// 报错。参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。</span></span><br></pre></td></tr></table></figure>

<h3 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a><strong>暂时性死区</strong></h3><p>只要块级作用域内存在<code>let</code>命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  tmp = <span class="string">&#x27;abc&#x27;</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，存在全局变量<code>tmp</code>，但是块级作用域内<code>let</code>又声明了一个局部变量<code>tmp</code>，导致后者绑定这个块级作用域，所以在<code>let</code>声明变量前，对<code>tmp</code>赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在<code>let</code>和<code>const</code>命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<h3 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a><strong>不允许重复声明</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错。let不允许在相同作用域内，重复声明同一个变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a><strong>为什么需要块级作用域</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.变量提升,内层变量可能会覆盖外层变量。 </span></span><br><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.用来计数的循环变量泄露为全局变量。</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="块级作用域与函数"><a href="#块级作用域与函数" class="headerlink" title="块级作用域与函数"></a><strong>块级作用域与函数</strong></h3><p> <code>let</code>实际上为 JavaScript 新增了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的函数有两个代码块，都声明了变量<code>n</code>，运行后输出 5。这表示外层代码块不受内层代码块的影响,即<strong>块级作用域也属于作用域链中</strong>。如果两次都使用<code>var</code>定义变量<code>n</code>，最后输出的值才是 10。</p>
<h3 id="const命令"><a href="#const命令" class="headerlink" title="const命令"></a><strong>const命令</strong></h3><p> <code>const</code>声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<p> 只在声明所在的块级作用域内有效 </p>
<p> 对于<strong>复合类型</strong>的变量，变量名不指向数据，而是指向数据所在的地址。<code>const</code>命令只是保证变量名指向的地址不变，并不保证该地址的数据不变  </p>
<h3 id="顶层对象的属性"><a href="#顶层对象的属性" class="headerlink" title="顶层对象的属性"></a><strong>顶层对象的属性</strong></h3><p>顶层对象，在浏览器环境指的是<code>window</code>对象，在Node指的是<code>global</code>对象。 </p>
<p>ES5之中，顶层对象的属性与全局变量是等价的。  这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道 。 其次，程序员很容易不知不觉地就创建了全局变量 。 顶层对象的属性是到处可以读写的，这非常不利于模块化编程。 </p>
<p> ES6为了改变这一点，一方面规定，为了保持兼容性，<code>var</code>命令和<code>function</code>命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，<code>let</code>命令、<code>const</code>命令、<code>class</code>命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在Node的REPL环境，可以写成global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>



<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//“模式匹配”</span></span><br><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>]);<span class="comment">//x=&quot;a&quot;</span></span><br><span class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>, <span class="string">&quot;baz&quot;</span>]; <span class="comment">//third = &quot;baz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span><span class="comment">//另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。</span></span><br><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];<span class="comment">//x = 1  y = 2</span></span><br><span class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">x <span class="comment">// &quot;a&quot;</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span><span class="comment">//嵌套</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];<span class="comment">//b=2</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];<span class="comment">//head=1	tail=[2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span><span class="comment">//只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line"><span class="comment">//sixth=5</span></span><br><span class="line"></span><br><span class="line"><span class="number">6</span><span class="comment">//解构赋值允许指定默认值。</span></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>]; x <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]; x <span class="comment">// null</span></span><br><span class="line">[x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line">[x, y = <span class="string">&#x27;b&#x27;</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="literal">undefined</span>]; <span class="comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">7</span><span class="comment">//ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">//x=1</span></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];<span class="comment">//x=null</span></span><br><span class="line"><span class="comment">//undefined == null 	true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2.对象"></a>2.对象</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="comment">//数组的元素是按次序排列的，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</span></span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = &#123; <span class="attr">foo</span>: <span class="string">&quot;aaa&quot;</span>, <span class="attr">bar</span>: <span class="string">&quot;bbb&quot;</span> &#125;;</span><br><span class="line"><span class="number">2</span><span class="comment">//如果变量名与属性名不一致，必须写成下面这样。</span></span><br><span class="line"><span class="keyword">var</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">bar</span>: <span class="string">&#x27;bbb&#x27;</span> &#125;;</span><br><span class="line"><span class="number">3</span><span class="comment">//</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">&#x27;hello&#x27;</span>, <span class="attr">last</span>: <span class="string">&#x27;world&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</span><br><span class="line"><span class="comment">//f = &#x27;hello&#x27;</span></span><br><span class="line"><span class="comment">//l = &#x27;world&#x27;</span></span><br><span class="line"><span class="number">4</span><span class="comment">//与数组一样，解构也可以用于嵌套结构的对象。</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">p</span>: [</span><br><span class="line">    <span class="string">&#x27;Hello&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">y</span>: <span class="string">&#x27;World&#x27;</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">p</span>: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line">y <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="number">5</span><span class="comment">//对象的解构也可以指定默认值。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>:y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"><span class="comment">//默认值生效的条件是，对象的属性值严格等于undefined。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="literal">null</span>&#125;;</span><br><span class="line">x <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点</span></span><br><span class="line"><span class="comment">//如果要将一个已经声明的变量用于解构赋值，必须非常小心。</span></span><br><span class="line"><span class="comment">//JavaScript 引擎会将&#123;x&#125;理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;<span class="comment">// SyntaxError: syntax error</span></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">(&#123;x&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;);</span><br><span class="line"><span class="number">2</span><span class="comment">//由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="number">0</span> : first, [arr.length - <span class="number">1</span>] : last&#125; = arr;</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">last <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<h3 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3.字符串"></a>3.字符串</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a <span class="comment">// &quot;h&quot;</span></span><br><span class="line">b <span class="comment">// &quot;e&quot;</span></span><br><span class="line">c <span class="comment">// &quot;l&quot;</span></span><br><span class="line">d <span class="comment">// &quot;l&quot;</span></span><br><span class="line">e <span class="comment">// &quot;o&quot;</span></span><br><span class="line"><span class="comment">//类似数组的对象都有一个length属性</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">len <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>

<h3 id="4-函数参数"><a href="#4-函数参数" class="headerlink" title="4.函数参数"></a>4.函数参数</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">[x, y]</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y</span></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]].map(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> a + b);</span><br><span class="line"><span class="comment">// [ 3, 7 ]</span></span><br></pre></td></tr></table></figure>

<p><strong>函数参数的默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x = <span class="number">0</span>, y = <span class="number">0</span> &#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;)<span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x, y = <span class="number">5</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;) <span class="comment">// 1 2</span></span><br><span class="line"><span class="comment">//解构赋值没有设置默认值</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>解构赋值的默认值</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123; x, y &#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span> &#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123; <span class="attr">x</span>: <span class="number">3</span> &#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>

<p>上面代码是为函数<code>move</code>的参数指定默认值，而不是为变量<code>x</code>和<code>y</code>指定默认值</p>
<p><strong>为了更容易理解，将上面两个代码合成一个，如下。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123; x: <span class="number">1</span>, y: <span class="number">1</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解构赋值的模式 &#123;x, y&#125;</span></span><br><span class="line"><span class="comment">// 解构赋值的默认值 x = 0, y = 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;<span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">8</span>&#125;)); <span class="comment">// 被解构赋值的参数 : &#123;x: 3, y: 8&#125; </span></span><br><span class="line"><span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;<span class="attr">x</span>: <span class="number">3</span>&#125;)); <span class="comment">// 被解构赋值的参数 : &#123;x: 3&#125; </span></span><br><span class="line"><span class="comment">// [3, 0]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(&#123;&#125;)); <span class="comment">// 被解构赋值的参数 : &#123;&#125; </span></span><br><span class="line"><span class="comment">// [0, 0]</span></span><br><span class="line"><span class="built_in">console</span>.log(move()); <span class="comment">// 被解构赋值的参数 : &#123;x: 1, y: 1&#125; </span></span><br><span class="line"><span class="comment">// [1, 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(move(<span class="literal">undefined</span>)); <span class="comment">// 被解构赋值的参数 : &#123;x: 1, y: 1&#125; </span></span><br><span class="line"><span class="comment">// [1, 1]</span></span><br></pre></td></tr></table></figure>

<h3 id="5-变量的解构赋值的作用"><a href="#5-变量的解构赋值的作用" class="headerlink" title="5.变量的解构赋值的作用"></a>5.变量的解构赋值的作用</h3><p>（1）交换变量的值</p>
<p>（2）从函数返回多个值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br></pre></td></tr></table></figure>

<p>（3）函数参数的定义</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有序的参数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x,y,z]</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([x,y,z])</span><br><span class="line">&#125;</span><br><span class="line">f([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//无序的参数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x,y,z&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(&#123;x,z,y&#125;)</span><br><span class="line">&#125;</span><br><span class="line">f(&#123;<span class="attr">z</span>:<span class="number">3</span>,<span class="attr">x</span>:<span class="number">22</span>,<span class="attr">y</span>:<span class="number">31</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>（4）提取 JSON 数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonData = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">42</span>,</span><br><span class="line">  <span class="attr">status</span>: <span class="string">&quot;OK&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</span><br></pre></td></tr></table></figure>

<p>（4）函数参数的默认值(数组或者对象的默认值)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123; x, y = <span class="number">5</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined 5</span></span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;) <span class="comment">// 1 5</span></span><br><span class="line">foo(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;) <span class="comment">// 1 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>（5）遍历 Map 结构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">&#x27;first&#x27;</span> ,<span class="string">&#x27;hello&#x27;</span>);</span><br><span class="line">map.set(<span class="string">&#x27;second&#x27;</span> ,<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> map)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key + <span class="string">&quot;is&quot;</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）输入模块的指定方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;first,second&#125; = <span class="built_in">require</span>(<span class="string">&#x27;xxx&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="数据类型扩展"><a href="#数据类型扩展" class="headerlink" title="数据类型扩展"></a>数据类型扩展</h2><h3 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//允许采用\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。</span></span><br><span class="line"><span class="string">&quot;\u0061&quot;</span>  <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="comment">//但是，这种表示法只限于\u0000——\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。</span></span><br><span class="line"><span class="string">&quot;\uD842\uDFB7&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="string">&quot;\u20BB7&quot;</span></span><br><span class="line"><span class="comment">// &quot; 7&quot;,如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</span></span><br><span class="line"><span class="string">&quot;\u&#123;20BB7&#125;&quot;</span></span><br><span class="line"><span class="comment">// &quot;𠮷&quot;,只要将码点放入大括号，就能正确解读该字符</span></span><br><span class="line"><span class="comment">//&#x27;\u&#123;1F680&#125;&#x27; === &#x27;\uD83D\uDE80&#x27;大括号表示法与四字节的UTF-16编码是等价的。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。charCodeAt方法只能分别返回前两个字节和后两个字节的值</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷a&#x27;</span>;</span><br><span class="line"><span class="comment">//汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271）</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;20bb7&quot;</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br><span class="line">s.codePointAt(<span class="number">2</span>).toString(<span class="number">16</span>) <span class="comment">// &quot;61&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is32Bit</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> c.codePointAt(<span class="number">0</span>) &gt; <span class="number">0xFFFF</span>;</span><br><span class="line">&#125;</span><br><span class="line">is32Bit(<span class="string">&quot;𠮷&quot;</span>) <span class="comment">// true</span></span><br><span class="line">is32Bit(<span class="string">&quot;a&quot;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">//ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）.所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。</span></span><br><span class="line"><span class="comment">//String.fromCodePoint</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === <span class="string">&#x27;x\uD83D\uDE80y&#x27;</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">字符串的遍历器接口：<span class="keyword">for</span>...of循环遍历，可以识别大于<span class="number">0xFFFF</span>的码点</span><br><span class="line">ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于<span class="number">0xFFFF</span>的字符。</span><br><span class="line"><span class="string">&#x27;abc&#x27;</span>.at(<span class="number">0</span>) <span class="comment">// &quot;a&quot;</span></span><br><span class="line"><span class="string">&#x27;𠮷&#x27;</span>.charAt(<span class="number">0</span>) <span class="comment">// &quot;\uD842&quot;</span></span><br><span class="line"><span class="string">&#x27;𠮷&#x27;</span>.at(<span class="number">0</span>) <span class="comment">// &quot;𠮷&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>===<span class="string">&#x27;\u004F\u030C&#x27;</span> <span class="comment">//false</span></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.length <span class="comment">// 1</span></span><br><span class="line"><span class="string">&#x27;\u004F\u030C&#x27;</span>.length <span class="comment">// 2</span></span><br><span class="line"><span class="string">&#x27;\u01D1&#x27;</span>.normalize() === <span class="string">&#x27;\u004F\u030C&#x27;</span>.normalize()</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;Hello world!&#x27;</span>;</span><br><span class="line">s.startsWith(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.endsWith(<span class="string">&#x27;!&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">&#x27;o&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;x&#x27;</span>.repeat(<span class="number">3</span>) <span class="comment">// &quot;xxx&quot;</span></span><br><span class="line"><span class="comment">//如果repeat的参数是负数或者Infinity，会报错。</span></span><br><span class="line"><span class="comment">//如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。</span></span><br><span class="line"><span class="comment">//参数NaN等同于0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板字符串，</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Bob&quot;</span>, time = <span class="string">&quot;today&quot;</span>;</span><br><span class="line"><span class="string">`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?`</span></span><br><span class="line"><span class="comment">//模板字符串之中还能调用函数。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6还为原生的String对象，提供了一个raw方法。</span></span><br><span class="line"><span class="comment">//String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// &quot;Hi\\n5!&quot;</span></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// &#x27;Hi\\u000A!&#x27;</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: <span class="string">&#x27;test&#x27;</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// &#x27;t0e1s2t&#x27;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; <span class="attr">raw</span>: [<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;t&#x27;</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h3 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h3><p> 字符串对象共有4个方法，可以使用正则表达式：<code>match()</code>、<code>replace()</code>、<code>search()</code>和<code>split()</code>。 </p>
<p>ES6对正则表达式添加了<code>u</code>修饰符，含义为“Unicode模式”，用来正确处理大于<code>\uFFFF</code>的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">/^\uD83D/u.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">/^\uD83D/.test(<span class="string">&#x27;\uD83D\uDC2A&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>对于码点大于<code>0xFFFF</code>的Unicode字符，点字符不能识别，必须加上<code>u</code>修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;𠮷&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="regexp">/^.$/</span>.test(s) <span class="comment">// false</span></span><br><span class="line">/^.$/u.test(s) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上<code>u</code>修饰符，才能识别。  使用<code>u</code>修饰符后，所有量词都会正确识别码点大于<code>0xFFFF</code>的Unicode字符。 </p>
<p> 除了<code>u</code>修饰符，ES6还为正则表达式添加了<code>y</code>修饰符，叫做“粘连”（sticky）修饰符。 </p>
<p> <code>g</code>修饰符只要剩余位置中存在匹配就可，而<code>y</code>修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 </p>
<h3 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h3><h4 id="二进制和八进制表达方式"><a href="#二进制和八进制表达方式" class="headerlink" title="二进制和八进制表达方式"></a>二进制和八进制表达方式</h4><p>ES6提供了二进制和八进制数值的新的写法，分别用前缀<code>0b</code>（或<code>0B</code>）和<code>0o</code>（或<code>0O</code>）表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>从ES5开始，在严格模式之中，八进制就不再允许使用前缀<code>0</code>表示，ES6进一步明确，要使用前缀<code>0o</code>表示。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure>

<p>如果要将<code>0b</code>和<code>0o</code>前缀的字符串数值转为十进制，要使用<code>Number</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0b111&#x27;</span>)  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">&#x27;0o10&#x27;</span>)  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<h4 id="isFinite和isNaN"><a href="#isFinite和isNaN" class="headerlink" title="isFinite和isNaN"></a>isFinite和isNaN</h4><p><code>Number.isFinite()</code>用来检查一个数值是否为有限的（finite）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;foo&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">&#x27;15&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><code>Number.isNaN()</code>用来检查一个值是否为<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;15&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;true&#x27;</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">&#x27;true&#x27;</span>/<span class="string">&#x27;true&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>它们与传统的全局方法<code>isFinite()</code>和<code>isNaN()</code>的区别在于，传统方法先调用<code>Number()</code>将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回<code>false</code>。</p>
<h4 id="parseInt和parseFloat"><a href="#parseInt和parseFloat" class="headerlink" title="parseInt和parseFloat"></a>parseInt和parseFloat</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br><span class="line"><span class="comment">// ES6的写法，这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</span></span><br><span class="line"><span class="built_in">Number</span>.parseInt(<span class="string">&#x27;12.34&#x27;</span>) <span class="comment">// 12</span></span><br><span class="line"><span class="built_in">Number</span>.parseFloat(<span class="string">&#x27;123.45#&#x27;</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>

<h4 id="isInteger"><a href="#isInteger" class="headerlink" title="isInteger"></a>isInteger</h4><p> <code>Number.isInteger()</code>用来判断一个数值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Math对象的扩展"><a href="#Math对象的扩展" class="headerlink" title="Math对象的扩展"></a>Math对象的扩展</h4><h5 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.</span></span><br><span class="line"><span class="comment">//Math.trunc方法用于去除一个数的小数部分，返回整数部分。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.1</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">4.9</span>) <span class="comment">// -4</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(-<span class="number">0.1234</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="comment">//对于非数值，Math.trunc内部使用Number方法将其先转为数值。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;123.456&#x27;</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="comment">//对于空值和无法截取整数的值，返回NaN。</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">&#x27;foo&#x27;</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h5><p><code>Math.sign</code>方法用来判断一个数到底是正数、负数、还是零。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;&#x27;</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;9&#x27;</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">&#x27;foo&#x27;</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign()  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<h5 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h5><p>方法用于计算一个数的立方根。对于非数值，Math.cbrt()方法内部也是先使用Number()方法将其转为数值。</p>
<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p><code>Array.from</code>方法用于将两类对象转为真正的数组：<strong>类似数组的对象（array-like object）和可遍历（iterable）的对象</strong>（包括ES6新增的数据结构Set和Map）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类似数组的对象</span></span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">    <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">let</span> arr2 = <span class="built_in">Array</span>.from(arrayLike); <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的<code>arguments</code>对象。<code>Array.from</code>都可以将它们转为真正的数组。</p>
<p>只要是部署了<strong>Iterator</strong>接口的数据结构，<code>Array.from</code>都能将其转为数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可遍历（iterable）</span></span><br><span class="line"><span class="built_in">Array</span>.from(<span class="string">&#x27;123123&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> namesSet = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="built_in">Array</span>.from(namesSet) <span class="comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">//&#123; [Iterator]  0: 1, 1: 2 &#125;</span></span><br><span class="line">  <span class="keyword">var</span> args = [...arguments];</span><br><span class="line">  <span class="keyword">return</span> args</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">&#x27;div&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>扩展运算符背后调用的是遍历器接口（<code>Symbol.iterator</code>），如果一个对象没有部署这个接口，就无法转换。<code>Array.from</code>方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有<code>length</code>属性。因此，任何有<code>length</code>属性的对象，都可以通过<code>Array.from</code>方法转为数组，而此时扩展运算符就无法转换。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.from</code>还可以接受第二个参数，作用类似于数组的<code>map</code>方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>

<p>下面的例子是取出一组DOM节点的文本内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;span.name&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent)</span><br></pre></td></tr></table></figure>

<h4 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of"></a>Array.of</h4><p><code>Array.of</code>方法用于将一组值，转换为数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>这个方法的主要目的，是弥补数组构造函数<code>Array()</code>的不足。因为参数个数的不同，会导致<code>Array()</code>的行为有差异。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"><span class="comment">//参数个数只有一个时，实际上是指定数组的长度。</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>

<p><code>Array.of</code>基本上可以用来替代<code>Array()</code>或<code>new Array()</code>，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.of() <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="literal">undefined</span>) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>

<h4 id="copyWithin"><a href="#copyWithin" class="headerlink" title="copyWithin"></a>copyWithin</h4><p>数组实例的<code>copyWithin</code>方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.copyWithin(target, start = <span class="number">0</span>, end = <span class="built_in">this</span>.length)</span><br></pre></td></tr></table></figure>

<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。</li>
<li>start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。</li>
</ul>
<p>这三个参数都应该是数值，如果不是，会自动转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<h4 id="find和findIndex"><a href="#find和findIndex" class="headerlink" title="find和findIndex"></a>find和findIndex</h4><p>数组实例的<code>find</code>方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出<strong>第一个</strong>返回值为<code>true</code>的成员，然后<strong>返回该成员</strong>。如果没有符合条件的成员，则返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, -<span class="number">5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>

<p>上面代码找出数组中第一个小于0的成员。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>find</code>方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的<code>findIndex</code>方法的用法与<code>find</code>方法非常类似，<strong>返回第一个符合条件的数组成员的位置</strong>，如果所有成员都不符合条件，则返回<code>-1</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>另外，这两个方法都可以发现<code>NaN</code>，弥补了数组的<code>IndexOf</code>方法的不足。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>indexOf</code>方法无法识别数组的<code>NaN</code>成员，但是<code>findIndex</code>方法可以借助<code>Object.is</code>方法做到。</p>
<h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><p><code>fill</code>方法使用给定值，填充一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>].fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>fill</code>方法用于空数组的初始化非常方便。</p>
<h4 id="entries和keys和values"><a href="#entries和keys和values" class="headerlink" title="entries和keys和values"></a>entries和keys和values</h4><p>ES6提供三个新的方法——<code>entries()</code>，<code>keys()</code>和<code>values()</code>——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用<code>for...of</code>循环进行遍历，唯一的区别是<code>keys()</code>是对键名的遍历、<code>values()</code>是对键值的遍历，<code>entries()</code>是对键值对的遍历。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;a&#x27;</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 &quot;a&quot;</span></span><br><span class="line"><span class="comment">// 1 &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>如果不使用<code>for...of</code>循环，可以手动调用遍历器对象的<code>next</code>方法，进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next()); <span class="comment">// &#123; value: [ 0, &#x27;a&#x27; ], done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h4><p><code>Array.prototype.includes</code>方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的<code>includes</code>方法类似。该方法属于ES7，但Babel转码器已经支持。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>);     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>);     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#123;a:1&#125;,2,3,&#123;b:2&#125;].includes(&#123;a:1&#125;)//false</span><br></pre></td></tr></table></figure>

<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>数组的空位指，数组的某一个位置没有任何值。比如，<code>Array</code>构造函数返回的数组都是空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Array(3)</code>返回一个具有3个空位的数组。</p>
<p>注意，空位不是<code>undefined</code>，一个位置的值等于<code>undefined</code>，依然是有值的。空位是没有任何值，<code>in</code>运算符可以说明这一点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> <span class="keyword">in</span> [<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> <span class="keyword">in</span> [, , ,] <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。</p>
<p>ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li><code>forEach()</code>, <code>filter()</code>, <code>every()</code> 和<code>some()</code>都会跳过空位。</li>
<li><code>map()</code>会跳过空位，但会保留这个值</li>
<li><code>join()</code>和<code>toString()</code>会将空位视为<code>undefined</code>，而<code>undefined</code>和<code>null</code>会被处理成空字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// [&#x27;a&#x27;,&#x27;b&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">&#x27;a&#x27;</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">&#x27;a&#x27;</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">&#x27;#&#x27;</span>) <span class="comment">// &quot;#a##&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// &quot;,a,,&quot;</span></span><br></pre></td></tr></table></figure>

<p>ES6则是明确将空位转为<code>undefined</code>。</p>
<p><code>Array.from</code>方法会将数组的空位，转为<code>undefined</code>，也就是说，这个方法不会忽略空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>])</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure>

<p>扩展运算符（<code>...</code>）也会将空位转为<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...[<span class="string">&#x27;a&#x27;</span>,,<span class="string">&#x27;b&#x27;</span>]]</span><br><span class="line"><span class="comment">// [ &quot;a&quot;, undefined, &quot;b&quot; ]</span></span><br></pre></td></tr></table></figure>

<p><code>copyWithin()</code>会连空位一起拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) <span class="comment">// [,&quot;a&quot;,,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>fill()</code>会将空位视为正常的数组位置。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="string">&#x27;a&#x27;</span>) <span class="comment">// [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p><code>for...of</code>循环也会遍历空位。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>有两个空位，<code>for...of</code>并没有忽略它们。如果改成<code>map</code>方法遍历，空位是会跳过的。</p>
<p><code>entries()</code>、<code>keys()</code>、<code>values()</code>、<code>find()</code>和<code>findIndex()</code>会将空位处理成<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].entries()] <span class="comment">// [[0,undefined], [1,&quot;a&quot;]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">&#x27;a&#x27;</span>].values()] <span class="comment">// [undefined,&quot;a&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">&#x27;a&#x27;</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
<h3 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h3><h4 id="简洁表示法"><a href="#简洁表示法" class="headerlink" title="简洁表示法"></a>简洁表示法</h4><h5 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a><strong>属性简写</strong></h5><p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123;foo&#125;;</span><br><span class="line"> <span class="comment">// &#123;foo: &quot;bar&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，ES6允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">x</span>: x, <span class="attr">y</span>: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="方法简写"><a href="#方法简写" class="headerlink" title="方法简写"></a><strong>方法简写</strong></h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    <span class="function"><span class="title">method</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是一个实际的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> birth = <span class="string">&#x27;2000/01/01&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">  <span class="comment">//等同于birth: birth</span></span><br><span class="line">  birth,</span><br><span class="line">  <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">  <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123; <span class="built_in">console</span>.log(<span class="string">&#x27;我的名字是&#x27;</span>, <span class="built_in">this</span>.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法用于函数的返回值，将会非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure>

<p>CommonJS模块输出变量，就非常合适使用简洁写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ms = &#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">getItem</span>: getItem,</span><br><span class="line">  <span class="attr">setItem</span>: setItem,</span><br><span class="line">  <span class="attr">clear</span>: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cart = &#123;</span><br><span class="line">  <span class="attr">_wheels</span>: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  get wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  set wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;数值太小了！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>._wheels = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> () </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">&#x27;class&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个Generator函数，前面需要加上星号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  * <span class="function"><span class="title">m</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&#x27;hello world&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h4><p>JavaScript语言定义对象的属性，有两种方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">abc</span>: <span class="number">123</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>

<p>方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> propKey = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [propKey]: <span class="literal">true</span>,</span><br><span class="line">  [<span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;bc&#x27;</span>]: <span class="number">123</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lastWord = <span class="string">&#x27;last word&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  <span class="string">&#x27;first word&#x27;</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  [lastWord]: <span class="string">&#x27;world&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a[<span class="string">&#x27;first word&#x27;</span>] <span class="comment">// &quot;hello&quot;</span></span><br><span class="line">a[lastWord] <span class="comment">// &quot;world&quot;</span></span><br><span class="line">a[<span class="string">&#x27;last word&#x27;</span>] <span class="comment">// &quot;world&quot;</span></span><br></pre></td></tr></table></figure>

<p>表达式还可以用于定义方法名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="string">&#x27;h&#x27;</span> + <span class="string">&#x27;ello&#x27;</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hi&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() <span class="comment">// hi</span></span><br></pre></td></tr></table></figure>

<p>注意，<strong>属性名表达式与简洁表示法，不能同时使用</strong>，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> baz = &#123; [foo]: <span class="string">&#x27;abc&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [keyA]: <span class="string">&#x27;valueA&#x27;</span>,</span><br><span class="line">  [keyB]: <span class="string">&#x27;valueB&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: &quot;valueB&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h4 id="方法的name属性"><a href="#方法的name属性" class="headerlink" title="方法的name属性"></a>方法的name属性</h4><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.sayName.name);   <span class="comment">// &quot;sayName&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h4><p>目前，ES7有一个<a href="https://github.com/sebmarkbage/ecmascript-rest-spread">提案</a>，将Rest运算符（解构赋值）/扩展运算符（<code>...</code>）引入对象。Babel转码器已经支持这项功能。</p>
<h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">null</span>; <span class="comment">// 运行时错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, y, ...z &#125; = <span class="literal">undefined</span>; <span class="comment">// 运行时错误</span></span><br></pre></td></tr></table></figure>

<p>解构赋值必须是最后一个参数，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = obj; <span class="comment">// 句法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，<strong>解构赋值不会拷贝继承自原型对象的属性</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> o1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> o2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line">o2.__proto__ = o1;</span><br><span class="line"><span class="keyword">let</span> o3 = &#123; ...o2 &#125;;</span><br><span class="line">o3 <span class="comment">// &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o3</code>是<code>o2</code>的拷贝，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.create(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br><span class="line">o.z = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量<code>y</code>和<code>z</code>，只能读取对象自身的属性，所以只有变量<code>z</code>可以赋值成功。</p>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span>(<span class="params">&#123; a, b &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span>(<span class="params">&#123; x, y, ...restConfig &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 使用x和y参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><p>扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">a</span>: <span class="number">3</span>, <span class="attr">b</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>

<p>这等同于使用<code>Object.assign</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure>

<p>扩展运算符可以用于合并两个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = <span class="built_in">Object</span>.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure>

<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = <span class="built_in">Object</span>.assign(&#123;&#125;, a, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的部分属性就很方便了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;New Name&#x27;</span> <span class="comment">// Override the name property</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithDefaults = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithDefaults = <span class="built_in">Object</span>.assign(&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;, a);</span><br></pre></td></tr></table></figure>

<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为x属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">    throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;not thrown yet&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为x属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    <span class="keyword">get</span> <span class="title">x</span>() &#123;</span><br><span class="line">      throws <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;thrown now&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这个两个值会被忽略，不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyObject = &#123; ...null, ...undefined &#125;; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>

<h4 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h4><p>JavaScript 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等。这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。</p>
<p>属性描述对象提供6个元属性。</p>
<p>（1）<code>value</code></p>
<p><code>value</code>是该属性的属性值，默认为<code>undefined</code>。</p>
<p>（2）<code>writable</code></p>
<p><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>。</p>
<p>（3）<code>enumerable</code></p>
<p><code>enumerable</code>是一个布尔值，<strong>表示该属性是否可遍历</strong>，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性。</p>
<p>（4）<code>configurable</code></p>
<p><code>configurable</code>是一个布尔值，表示属性的可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写属性描述对象，比如无法删除该属性，也不得改变各种元属性（<code>value</code>属性除外）。也就是说，<code>configurable</code>属性控制了属性描述对象的可写性。</p>
<p>（5）<code>get</code></p>
<p><code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>。</p>
<p>（6）<code>set</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set`是一个函数，表示该属性的存值函数（setter），默认为`undefined</span><br></pre></td></tr></table></figure>

<h5 id="属性的可枚举性"><a href="#属性的可枚举性" class="headerlink" title="属性的可枚举性"></a>属性的可枚举性</h5><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">foo</span>: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//    value: 123,</span></span><br><span class="line"><span class="comment">//    writable: true,</span></span><br><span class="line"><span class="comment">//    enumerable: true,</span></span><br><span class="line"><span class="comment">//    configurable: true</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br></pre></td></tr></table></figure>

<p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>ES5有三个操作会台跳过<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和<strong>继承</strong>的可枚举的属性</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性</li>
</ul>
<p>ES6新增了一个操作<code>Object.assign()</code>，会忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</p>
<p><strong>这四个操作之中，只有<code>for...in</code>会返回继承的属性。实际上，引入<code>enumerable</code>的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作。</strong></p>
<p>比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过这种手段，不会被<code>for...in</code>遍历到。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;toString&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor([], <span class="string">&#x27;length&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p><strong>另外，ES6规定，所有Class的原型的方法都是不可枚举的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="class"><span class="keyword">class</span> </span>&#123;<span class="function"><span class="title">foo</span>(<span class="params"></span>)</span> &#123;&#125;&#125;.prototype, <span class="string">&#x27;foo&#x27;</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h5 id="get和set"><a href="#get和set" class="headerlink" title="get和set"></a>get和set</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">firstName</span>: <span class="string">&#x27;liming&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">sayName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.secondName</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">secondName</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title">secondName</span>(<span class="params">a</span>) &#123;<span class="comment">//set里面不能给secondName赋值</span></span><br><span class="line">    <span class="built_in">console</span>.log(a, <span class="built_in">this</span>.firstName);<span class="comment">//newliming liming</span></span><br><span class="line">    <span class="built_in">this</span>.firstName = a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">person.secondName = <span class="string">&#x27;newliming&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.firstName, person.secondName)<span class="comment">//newliming Nicholas</span></span><br><span class="line"><span class="built_in">console</span>.log(person.sayName())<span class="comment">//Nicholas</span></span><br></pre></td></tr></table></figure>

<p>当使用 <code>get</code> 关键字时，属性将被定义在实例的原型上，当使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>时，属性将被定义在实例自身上。</p>
<h4 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h4><h5 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a><strong>for…in</strong></h5><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。</p>
<h5 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h5><p>ES5引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(obj)</span><br><span class="line"><span class="comment">// [&quot;foo&quot;, &quot;baz&quot;]</span></span><br></pre></td></tr></table></figure>

<p>目前，ES7有一个<a href="https://github.com/tc39/proposal-object-values-entries">提案</a>，引入了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2], [&#x27;c&#x27;, 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&quot;bar&quot;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;bar&quot;, 42]</span></span><br></pre></td></tr></table></figure>

<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="number">100</span>: <span class="string">&#x27;a&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;b&#x27;</span>, <span class="number">7</span>: <span class="string">&#x27;c&#x27;</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;<span class="attr">p</span>: &#123;<span class="attr">value</span>: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的。<code>Object.values</code>不会返回这个属性。</p>
<p><code>Object.values</code>会过滤属性名为Symbol值的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [&#x27;abc&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// [&#x27;f&#x27;, &#x27;o&#x27;, &#x27;o&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="literal">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure>

<h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h5><p><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line"><span class="comment">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></span><br></pre></td></tr></table></figure>

<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个Symbol值，该属性会被省略。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.entries(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, <span class="attr">foo</span>: <span class="string">&#x27;abc&#x27;</span> &#125;);</span><br><span class="line"><span class="comment">// [ [ &#x27;foo&#x27;, &#x27;abc&#x27; ] ]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非Symbol值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>
<p><code>Object.entries</code>的基本用途是遍历对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &quot;one&quot;: 1</span></span><br><span class="line"><span class="comment">// &quot;two&quot;: 2</span></span><br></pre></td></tr></table></figure>

<p><code>Object.entries</code>方法的一个用处是，将对象转为真正的<code>Map</code>结构。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>(<span class="built_in">Object</span>.entries(obj));</span><br><span class="line">map <span class="comment">// Map &#123; foo: &quot;bar&quot;, baz: 42 &#125;</span></span><br></pre></td></tr></table></figure>

<p>自己实现<code>Object.entries</code>方法，非常简单。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    arr.push([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="属性删除"><a href="#属性删除" class="headerlink" title="属性删除"></a>属性删除</h5><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> 删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。 </p>
<p> 只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;p&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">delete</span> obj.p <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p> <strong><code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性</strong> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">delete</span> obj.toString <span class="comment">// true</span></span><br><span class="line">obj.toString <span class="comment">// function toString() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="属性是否存在：in"><a href="#属性是否存在：in" class="headerlink" title="属性是否存在：in"></a><strong>属性是否存在：in</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="string">&#x27;p&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p> <code>in</code>运算符的一个问题是，<strong>它不能识别哪些属性是对象自身的，哪些属性是继承的。</strong><br> 可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>)) <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p><strong><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(obj.valueOf() === obj);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// &quot;1[object Object]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj =&#123;</span><br><span class="line">  <span class="attr">valueOf</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + obj);<span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 JavaScript 就会默认调用<code>valueOf()</code>和<code>toString</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。</p>
<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p><code>Object.prototype.toString</code>方法<strong>返回对象的类型字符串，因此可以用来判断一个值的类型。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.toString() <span class="comment">// &quot;[object Object]&quot;</span></span><br></pre></td></tr></table></figure>

<p>返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。</p>
<p>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call(value)</span><br></pre></td></tr></table></figure>

<p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法。</p>
<p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p>
<ul>
<li>数值：返回<code>[object Number]</code>。</li>
<li>字符串：返回<code>[object String]</code>。</li>
<li>布尔值：返回<code>[object Boolean]</code>。</li>
<li>undefined：返回<code>[object Undefined]</code>。</li>
<li>null：返回<code>[object Null]</code>。</li>
<li>数组：返回<code>[object Array]</code>。</li>
<li>arguments 对象：返回<code>[object Arguments]</code>。</li>
<li>函数：返回<code>[object Function]</code>。</li>
<li>Error 对象：返回<code>[object Error]</code>。</li>
<li>Date 对象：返回<code>[object Date]</code>。</li>
<li>RegExp 对象：返回<code>[object RegExp]</code>。</li>
<li>其他对象：返回<code>[object Object]</code>。</li>
</ul>
<p><a href="https://wangdoc.com/javascript/stdlib/attributes.html">https://wangdoc.com/javascript/stdlib/attributes.html</a></p>
<h5 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h5><p>方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto，[propertiesObject])</span><br></pre></td></tr></table></figure>

<ul>
<li><p>proto<br>新创建对象的原型对象。</p>
</li>
<li><p>propertiesObject<br>可选。需要传入一个对象，<strong>该对象的属性类型参照Object.defineProperties()的第二个参数</strong>。如果该参数被指定且不为 undefined，该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">b</span>:<span class="number">3</span>&#125;)</span><br><span class="line"><span class="comment">// Uncaught TypeError: Property description must be an object: 3</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;, &#123;<span class="attr">b</span>:&#123;<span class="attr">value</span>:<span class="number">2</span>&#125;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">// &#123;b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a) <span class="comment">// 1</span></span><br><span class="line">obj.b = <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.b) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))<span class="comment">// []</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="built_in">Object</span>.create(<span class="literal">null</span>,&#123;<span class="attr">a</span>:&#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2</span>,       <span class="comment">// 属性值</span></span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,     <span class="comment">//  是否可以重写值</span></span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,   <span class="comment">//是否可枚举</span></span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>  <span class="comment">//是否可以修改以上几项配置</span></span><br><span class="line">&#125;&#125;)</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">//&#123;a: 2&#125;</span></span><br><span class="line">obj2.a=<span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2)<span class="comment">// &#123;a: 3&#125;</span></span><br><span class="line"><span class="built_in">Object</span>.keys(obj2)<span class="comment">// [&quot;a&quot;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is"></a>Object.is</h5><p>ES5比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会<strong>自动转换数据类型</strong>，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法<strong>。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.is(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>ES5可以通过下面的代码，部署<code>Object.is</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">&#x27;is&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h5><p><a href="https://www.cnblogs.com/xiaoxiaoxun/p/12157591.html">https://www.cnblogs.com/xiaoxiaoxun/p/12157591.html</a></p>
<p><strong>基本用法</strong></p>
<p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的<strong>所有可枚举属性</strong>，复制到目标对象（target）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> source1 = &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> source2 = &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// &quot;object&quot;</span></span><br></pre></td></tr></table></figure>

<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>(<span class="literal">true</span>) <span class="comment">// &#123;[[PrimitiveValue]]: true&#125;</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">10</span>)  <span class="comment">//  &#123;[[PrimitiveValue]]: 10&#125;</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="string">&#x27;abc&#x27;</span>) <span class="comment">// &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123;<span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>&#125;,</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(&#123;&#125;, <span class="string">&#x27;invisible&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">value</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: &#x27;c&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为Symbol值的属性，也会被<code>Object.assign</code>拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(&#123; <span class="attr">a</span>: <span class="string">&#x27;b&#x27;</span> &#125;, &#123; [<span class="built_in">Symbol</span>(<span class="string">&#x27;c&#x27;</span>)]: <span class="string">&#x27;d&#x27;</span> &#125;)</span><br><span class="line"><span class="comment">// &#123; a: &#x27;b&#x27;, Symbol(c): &#x27;d&#x27; &#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意点</strong></p>
<p><code>Object.assign</code>方法实行的是<strong>浅拷贝</strong>，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>: <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;c&#x27;</span>, <span class="attr">d</span>: <span class="string">&#x27;e&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="keyword">var</span> source = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: <span class="string">&#x27;hello&#x27;</span> &#125; &#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: &#x27;hello&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>&#123; a: &#123; b: &#39;hello&#39;, d: &#39;e&#39; &#125; &#125;</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>有一些函数库提供<code>Object.assign</code>的定制版本（比如Lodash的<code>_.defaultsDeep</code>方法），可以解决浅拷贝的问题，得到深拷贝的合并。</p>
<p>注意，<code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.assign</code>把数组视为属性名为0、1、2的对象，因此目标数组的0号属性<code>4</code>覆盖了原数组的0号属性<code>1</code>。</p>
<p><strong>常见用途</strong></p>
<p><code>Object.assign</code>方法有很多用处。</p>
<p><strong>（1）为对象添加属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="built_in">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(SomeClass.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">someMethod</span>(<span class="params">arg1, arg2</span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">anotherMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ···</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。</p>
<p><strong>（3）克隆对象</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p><strong>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  <span class="function">(<span class="params">target, ...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(target, ...sources);</span><br></pre></td></tr></table></figure>

<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  <span class="function">(<span class="params">...sources</span>) =&gt;</span> <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure>

<p><strong>（5）为属性指定默认值</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  <span class="attr">logLevel</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">outputFormat</span>: <span class="string">&#x27;html&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在深拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致<code>DEFAULTS</code>对象的该属性不起作用。</p>
<h5 id="Prototype"><a href="#Prototype" class="headerlink" title="Prototype"></a>Prototype</h5><h6 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a><strong><code>__proto__</code></strong></h6><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括IE11）都部署了这个属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>该属性没有写入ES6的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>在实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">&#x27;__proto__&#x27;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> _thisObj = <span class="built_in">Object</span>(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">proto</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> === <span class="literal">undefined</span> || <span class="built_in">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(<span class="built_in">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="built_in">Reflect</span>.setPrototypeOf(<span class="built_in">this</span>, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个对象本身部署了<code>__proto__</code>属性，则该属性的值就是对象的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(&#123; <span class="attr">__proto__</span>: <span class="literal">null</span> &#125;)</span><br><span class="line"><span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<h6 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf"></a>getPrototypeOf</h6><p>该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h6 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf"></a>setPrototypeOf</h6><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象。它是ES6正式推荐的设置原型对象的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>该方法等同于下面的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure>

<p>上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。</p>
<h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><h6 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>参数</strong><br>obj<br>要定义属性的对象。</li>
<li>prop<br>要定义或修改的属性的名称或 Symbol 。</li>
<li>descriptor<br>要定义或修改的属性描述符。</li>
</ul>
<p>对象里目前存在的属性描述符有两种主要形式：<em>*<em>数据描述符</em>和*存取描述符</em><strong>。<em>数据描述符</em>是一个具有值的属性，该值可以是可写的，也可以是不可写的。<em>存取描述符</em>是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一；</strong>不能同时是两者**。</p>
<ul>
<li><p>configurable<br>true 只有该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。<br>默认为 false</p>
</li>
<li><p>enumerable<br>true 只有在枚举相应对象上的属性时该属性显现。<br>默认为 false</p>
<p><code>enumerable</code> 定义了对象的属性是否可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in"><code>for...in</code></a> 循环和 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys"><code>Object.keys()</code></a> 中被枚举。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;a&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">1</span>, <span class="attr">enumerable</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">2</span>, <span class="attr">enumerable</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;c&quot;</span>, &#123; <span class="attr">value</span> : <span class="number">3</span> &#125;); <span class="comment">// enumerable 默认为 false</span></span><br><span class="line">o.d = <span class="number">4</span>; <span class="comment">// 如果使用直接赋值的方式创建对象的属性，则 enumerable 为 true</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;e&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="built_in">Symbol</span>.for(<span class="string">&#x27;f&#x27;</span>), &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">6</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> o) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a,d</span></span><br><span class="line"><span class="built_in">Object</span>.keys(o); <span class="comment">// [&#x27;a&#x27;, &#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>value<br>与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。<br>默认为 undefined.</p>
</li>
<li><p>writable<br>true只有与该属性相关联的值被assignment operator改变时。<br>默认为 false</p>
</li>
<li><p>get<br>作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。<br>默认为 undefined</p>
</li>
<li><p>set<br>作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。<br>默认为 undefined</p>
</li>
</ul>
<h6 id="hasOwnProperty-NaN"><a href="#hasOwnProperty-NaN" class="headerlink" title="hasOwnProperty()"></a>hasOwnProperty()</h6><p>方法会返回一个布尔值，指示对象<strong>自身属性</strong>中是否具有指定的属性（也就是，是否有指定的键）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.property1 = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(object1.hasOwnProperty(<span class="string">&#x27;property1&#x27;</span>));</span><br><span class="line"><span class="comment">// expected output: true</span></span><br></pre></td></tr></table></figure>

<p>即使属性的值是 null 或 undefined，只要属性存在，hasOwnProperty 依旧会返回 true。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.propOne = <span class="literal">null</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;propOne&#x27;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">o.propTwo = <span class="literal">undefined</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;propTwo&#x27;</span>); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure>

<p><strong>自身属性与继承属性</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">o.prop = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;prop&#x27;</span>);             <span class="comment">// 返回 true</span></span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>);         <span class="comment">// 返回 false</span></span><br><span class="line">o.hasOwnProperty(<span class="string">&#x27;hasOwnProperty&#x27;</span>);   <span class="comment">// 返回 false</span></span><br></pre></td></tr></table></figure>

<h6 id="getOwnPropertyDescriptors"><a href="#getOwnPropertyDescriptors" class="headerlink" title="getOwnPropertyDescriptors"></a>getOwnPropertyDescriptors</h6><p>ES5有一个<code>Object.getOwnPropertyDescriptor</code>方法，返回某个对象属性的描述对象（descriptor）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">p</span>: <span class="string">&#x27;a&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="comment">// Object &#123; value: &quot;a&quot;,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<p>ES7有一个提案，提出了<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">bar</span>() &#123; <span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line"><span class="comment">// &#123; foo:</span></span><br><span class="line"><span class="comment">//    &#123; value: 123,</span></span><br><span class="line"><span class="comment">//      writable: true,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125;,</span></span><br><span class="line"><span class="comment">//   bar:</span></span><br><span class="line"><span class="comment">//    &#123; get: [Function: bar],</span></span><br><span class="line"><span class="comment">//      set: undefined,</span></span><br><span class="line"><span class="comment">//      enumerable: true,</span></span><br><span class="line"><span class="comment">//      configurable: true &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法的提出目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(target1, source);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target1, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，<code>Object.getOwnPropertyDescriptors</code>方法配合<code>Object.defineProperties</code>方法，就可以实现正确拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">foo</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(target2, <span class="built_in">Object</span>.getOwnPropertyDescriptors(source));</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(target2, <span class="string">&#x27;foo&#x27;</span>)</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowMerge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code>Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码会克隆对象<code>obj</code>。</p>
<p>另外，<code>Object.getOwnPropertyDescriptors</code>方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">__proto__</span>: prot,</span><br><span class="line">  <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ES6规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(prot);</span><br><span class="line">obj.foo = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>有了<code>Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  prot,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="number">123</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><code>Object.getOwnPropertyDescriptors</code>也可以用来实现Mixin（混入）模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.reduce(</span><br><span class="line">    <span class="function">(<span class="params">c, mixin</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">      c, <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">a</span>: <span class="string">&#x27;a&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;<span class="attr">b</span>: <span class="string">&#x27;b&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;<span class="attr">c</span>: <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> d = mix(c).with(a, b);</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors</code>进入标准以后，还会有<code>Reflect.getOwnPropertyDescriptors</code>方法。</p>
<h6 id="getOwnPropertyNames"><a href="#getOwnPropertyNames" class="headerlink" title="getOwnPropertyNames"></a>getOwnPropertyNames</h6><p>该方法返回一个数组，其中包含了当前对象<strong>所有属性</strong>的名称（字符串），不论它们是否可枚举。当然，也可以用<code>Object.keys()</code>来单独返回可枚举的属性。（不含Symbol属性，但是包括不可枚举属性）</p>
<h3 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h3><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><h5 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h5><p>在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>

<p>上面代码检查函数<code>log</code>的参数<code>y</code>有没有赋值，如果没有，则指定默认值为<code>World</code>。这种写法的缺点在于，如果参数<code>y</code>赋值了，但是对应的布尔值为<code>false</code>，则该赋值不起作用。就像上面代码的最后一行，参数<code>y</code>等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数<code>y</code>是否被赋值，如果没有，再等于默认值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  y = <span class="string">&#x27;World&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y = <span class="string">&#x27;World&#x27;</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;China&#x27;</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">&#x27;Hello&#x27;</span>, <span class="string">&#x27;&#x27;</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="解构赋值默认值"><a href="#解构赋值默认值" class="headerlink" title="解构赋值默认值"></a>解构赋值默认值</h5><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(&#123;&#125;) <span class="comment">// undefined, 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>&#125;) <span class="comment">// 1, 5</span></span><br><span class="line">foo(&#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;) <span class="comment">// 1, 2</span></span><br><span class="line">foo() <span class="comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123;</span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">上面两种写法都对函数的参数设定了默认值，</span><br><span class="line">区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；</span><br><span class="line">写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</span><br><span class="line">// 函数没有参数的情况</span><br><span class="line">m1() // [0, 0]</span><br><span class="line">m2() // [0, 0]</span><br><span class="line"></span><br><span class="line">// x和y都有值的情况</span><br><span class="line">m1(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line">m2(&#123;x: 3, y: 8&#125;) // [3, 8]</span><br><span class="line"></span><br><span class="line">// x有值，y无值的情况</span><br><span class="line">m1(&#123;x: 3&#125;) // [3, 0]</span><br><span class="line">m2(&#123;x: 3&#125;) // [3, undefined]</span><br><span class="line"></span><br><span class="line">// x和y都无值的情况</span><br><span class="line">m1(&#123;&#125;) // [0, 0];</span><br><span class="line">m2(&#123;&#125;) // [undefined, undefined]</span><br><span class="line"></span><br><span class="line">m1(&#123;z: 3&#125;) // [0, 0]</span><br><span class="line">m2(&#123;z: 3&#125;) // [undefined, undefined]</span><br></pre></td></tr></table></figure>



<h4 id="函数的length属性"><a href="#函数的length属性" class="headerlink" title="函数的length属性"></a>函数的length属性</h4><p>指定了默认值以后，函数的<code>length</code>属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;&#125;).length <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c = <span class="number">5</span></span>) </span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...values</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val <span class="keyword">of</span> values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展运算符-1"><a href="#扩展运算符-1" class="headerlink" title="扩展运算符"></a>扩展运算符</h4><h5 id="含义"><a href="#含义" class="headerlink" title="含义"></a><strong>含义</strong></h5><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>

<p>该运算符主要用于函数调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h5><p><strong>（1）合并数组</strong></p>
<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(more)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, ...more]</span><br></pre></td></tr></table></figure>

<p><strong>（2）与解构赋值结合</strong></p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>

<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）字符串</strong></p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[...<span class="string">&#x27;hello&#x27;</span>]</span><br><span class="line"><span class="comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></span><br></pre></td></tr></table></figure>

<p><strong>（5）实现了Iterator接口的对象</strong></p>
<p>任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> nodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> array = [...nodeList];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>querySelectorAll</code>方法返回的是一个<code>nodeList</code>对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于<code>NodeList</code>对象实现了Iterator接口。</p>
<p>对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">&#x27;0&#x27;</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;c&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用<code>Array.from</code>方法将<code>arrayLike</code>转为真正的数组。</p>
<h4 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h4><h5 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h5><p>ES6允许使用“箭头”（<code>=&gt;</code>）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br></pre></td></tr></table></figure>

<p>上面的箭头函数等同于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">() =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用<code>return</code>语句返回。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>

<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">&quot;Temp&quot;</span> &#125;);</span><br></pre></td></tr></table></figure>

<h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul>
<li><p>函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line">foo()<span class="comment">//id: undefined</span></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);<span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout</code>的参数是一个箭头函数，这个箭头函数的定义生效是在<code>foo</code>函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时<code>this</code>应该指向全局对象<code>window</code>，这时应该输出<code>21</code>。但是，箭头函数导致<code>this</code>总是指向函数定义生效时所在的对象（本例是<code>&#123;id: 42&#125;</code>），所以输出的是<code>42</code>。</p>
</li>
<li><p>不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p>
</li>
<li><p>不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。</p>
</li>
<li><p>不可以使用<code>yield</code>命令，因此箭头函数不能用作Generator函数。</p>
</li>
</ul>
<p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<h2 id="Iterator循环"><a href="#Iterator循环" class="headerlink" title="Iterator循环"></a>Iterator循环</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>JavaScript表示“<strong>集合</strong>”的数据结构：数组（<code>Array</code>）和对象（<code>Object</code>），Map和Set</p>
<p>若数组的成员是<code>Map</code>，<code>Map</code>的成员是对象 ， 这样就需要一种统一的接口机制，来处理所有不同的数据结构。  </p>
<p>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构<strong>提供统一的访问机制</strong>。 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作 </p>
<p><strong>Iterator 的遍历过程是这样的。</strong></p>
<p>（1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，<strong>遍历器对象本质上，就是一个指针对象。</strong></p>
<p>（2）第一次调用指针对象的<code>next</code>方法，可以将指针指向数据结构的第一个成员。</p>
<p>（3）第二次调用指针对象的<code>next</code>方法，指针就指向数据结构的第二个成员。</p>
<p>（4）不断调用指针对象的<code>next</code>方法，直到它指向数据结构的结束位置。</p>
<p> 每一次调用<code>next</code>方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含<code>value</code>和<code>done</code>两个属性的对象。其中，<code>value</code>属性是当前成员的值，<code>done</code>属性是一个布尔值，表示遍历是否结束。 </p>
<p>模拟<code>next</code>方法返回值的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> it = makeIterator([<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nextIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">//闭包</span></span><br><span class="line">      <span class="built_in">console</span>.log(nextIndex); <span class="comment">// 0，1，2</span></span><br><span class="line">      <span class="keyword">return</span> nextIndex &lt; array.length ?</span><br><span class="line">        &#123; <span class="attr">value</span>: array[nextIndex++], <span class="attr">done</span>: <span class="literal">false</span> &#125; :</span><br><span class="line">        &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value: &quot;a&quot;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next()); <span class="comment">// &#123; value: &quot;b&quot;, done: false &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next());<span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据结构的默认Iterator接口"><a href="#数据结构的默认Iterator接口" class="headerlink" title="数据结构的默认Iterator接口"></a>数据结构的默认Iterator接口</h3><p>Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即<code>for...of</code>循环（详见下文）。当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。</p>
<p><strong>一种数据结构只要部署了Iterator接口，我们就称这种数据结构是”可遍历的“（iterable）。</strong></p>
<p>ES6规定，<strong>默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性</strong>，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。</p>
<p><code>Symbol.iterator</code>属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名<code>Symbol.iterator</code>，它是一个表达式，返回<code>Symbol</code>对象的<code>iterator</code>属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在<strong>方括号</strong>内</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  [Symbol.iterator] : function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      next: function () &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          value: 1,</span><br><span class="line">          done: true</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。</strong></p>
<p>一个对象如果要有可被<code>for...of</code>循环调用的Iterator接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangeIterator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">start, stop</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = start;</span><br><span class="line">    <span class="built_in">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123; <span class="keyword">return</span> <span class="built_in">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">next</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="built_in">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="built_in">this</span>.stop) &#123;</span><br><span class="line">      <span class="built_in">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: value&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个类部署Iterator接口的写法。<code>Symbol.iterator</code>属性对应一个函数，执行后返回当前对象的遍历器对象。</p>
<h3 id="调用Iterator接口的场合"><a href="#调用Iterator接口的场合" class="headerlink" title="调用Iterator接口的场合"></a>调用Iterator接口的场合</h3><h4 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a><strong>解构赋值</strong></h4><p>对数组和 Set 结构进行解构赋值时，会默认调用<code>Symbol.iterator</code>方法。</p>
<h4 id="扩展运算符-2"><a href="#扩展运算符-2" class="headerlink" title="扩展运算符"></a><strong>扩展运算符</strong></h4><p>扩展运算符（…）也会调用默认的 Iterator 接口。</p>
<h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a><strong>yield</strong></h4><p><code>yield*</code>后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iterator = generator();</span><br><span class="line"></span><br><span class="line">iterator.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="其他场合"><a href="#其他场合" class="headerlink" title="其他场合"></a><strong>其他场合</strong></h4><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。</p>
<ul>
<li>for…of</li>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><p>当使用<code>for...of</code>循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。 </p>
<p> 默认的 Iterator 接口部署在数据结构的<code>Symbol.iterator</code>属性，或者说，一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。**<code>Symbol.iterator</code>属性本身是一个函数**，就是当前数据结构默认的遍历器生成函数。  执行这个函数，就会返回一个遍历器对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">value</span>: <span class="number">1</span>,</span><br><span class="line">          <span class="attr">done</span>: <span class="literal">true</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p> 对象<code>obj</code>是可遍历的（iterable），因为具有<code>Symbol.iterator</code>属性。执行这个属性，会返回一个遍历器对象。</p>
<p> 一个对象如果要具备可被<code>for...of</code>循环调用的 Iterator 接口，就必须在<code>Symbol.iterator</code>的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 如果<code>Symbol.iterator</code>方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。  </p>
<p> <strong>原生具备 Iterator 接口的数据结构如下。</strong></p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>TypedArray</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">let</span> iter = arr[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;a&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;b&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: &#x27;c&#x27;, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>

<p> 变量<code>arr</code>是一个数组，原生就具有遍历器接口，部署在<code>arr</code>的<code>Symbol.iterator</code>属性上面。所以，调用这个属性，就得到遍历器对象。 </p>
<p>对于原生部署 Iterator 接口的数据结构，不用自己写遍历器生成函数，<code>for...of</code>循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在<code>Symbol.iterator</code>属性上面部署，这样才会被<code>for...of</code>循环遍历。</p>
<h3 id="与其他遍历语法的比较"><a href="#与其他遍历语法的比较" class="headerlink" title="与其他遍历语法的比较"></a>与其他遍历语法的比较</h3><ol>
<li><p>最原始的写法就是<code>for</code>循环。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index = <span class="number">0</span>; index &lt; myArray.length; index++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>数组提供内置的<code>forEach</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>for...in</code>循环可以遍历数组的键名。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//for...in循环主要是为遍历对象而设计的，不适用于遍历数组。</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>for...of</code>循环相比上面几种做法，有一些显著的优点。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">of</span> fibonacci) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">1000</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不同于forEach方法，它可以与break、continue和return配合使用。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h3 id="Class基本语法"><a href="#Class基本语法" class="headerlink" title="Class基本语法"></a>Class基本语法</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> Point(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个“类”，可以看到里面有一个<code>constructor</code>方法，这就是构造方法，而<code>this</code>关键字则代表实例对象。也就是说，ES5的构造函数<code>Point</code>，对应ES6的<code>Point</code>类的构造方法。</p>
<p><code>Point</code>类除了构造方法，还定义了一个<code>toString</code>方法。注意，<strong>定义“类”的方法的时候，前面不需要加上<code>function</code>这个关键字</strong>，直接把函数定义放进去了就可以了。另外，<strong>方法之间不需要逗号分隔</strong>，加了会报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Point)<span class="comment">// &quot;function&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(Point === Point.prototype.constructor); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，<strong>类的数据类型就是函数，类本身就指向构造函数。</strong></p>
<p><strong>构造函数的<code>prototype</code>属性，在ES6的“类”上面继续存在</strong>。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Point.prototype); <span class="comment">// constructor，fn</span></span><br></pre></td></tr></table></figure>

<p><img src="https://z3.ax1x.com/2021/01/28/y9AUb9.png" alt="class"></p>
<p><code>b</code>是B类的实例，它的<code>constructor</code>方法就是B类原型的<code>constructor</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B</span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">toValue</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>另外，<strong>类的内部所有定义的方法，都是不可枚举的</strong>（non-enumerable）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure>

<p>这一点与ES5的行为不一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;toString&quot;]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype)</span><br><span class="line"><span class="comment">// [&quot;constructor&quot;,&quot;toString&quot;]</span></span><br></pre></td></tr></table></figure>

<h3 id="constructor方法"><a href="#constructor方法" class="headerlink" title="constructor方法"></a>constructor方法</h3><p><code>constructor</code>方法是类的默认方法，通过<code>new</code>命令生成对象实例时，<strong>自动调用</strong>该方法。一个类必须有<code>constructor</code>方法，如果没有显式定义，一个空的<code>constructor</code>方法会被默认添加。</p>
<p><strong><code>constructor</code>方法默认返回实例对象（即<code>this</code>），可以指定返回另外一个对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//Foo &#123;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// return Object.create(this);将Foo赋值给了实例对象的原型对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>函数返回一个全新的对象，结果导致实例对象不是<code>Foo</code>类的实例。</p>
<h3 id="prototype和-proto"><a href="#prototype和-proto" class="headerlink" title="prototype和__proto__"></a>prototype和__proto__</h3><p>大多数浏览器的ES5实现之中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<p>（1）子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</p>
<p>（2）子类<code>prototype</code>属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的<code>prototype</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> C = <span class="keyword">new</span> B()</span><br><span class="line">B.__proto__ === A <span class="comment">// true</span></span><br><span class="line">B.prototype.__proto__ === A.prototype <span class="comment">// true</span></span><br><span class="line">C.__proto__ === B.prototype <span class="comment">// true</span></span><br><span class="line">C.__proto__.__proto__===A.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img src="img/js/class-proto.png" alt="class-proto"></p>
<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>类的方法内部如果含有<code>this</code>，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">printName</span>(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">print</span>(<span class="params">text</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(text);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger();</span><br><span class="line"><span class="keyword">const</span> &#123; printName &#125; = logger;</span><br><span class="line">printName(); <span class="comment">// TypeError: Cannot read property &#x27;print&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>printName</code>方法中的<code>this</code>，默认指向<code>Logger</code>类的实例。但是，如果将这个方法提取出来单独使用，<code>this</code>会指向该方法运行时所在的环境，因为找不到<code>print</code>方法而导致报错。</p>
<p>一个比较简单的解决方法是，在构造方法中绑定<code>this</code>，这样就不会找不到<code>print</code>方法了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="built_in">this</span>.printName.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种解决方法是使用箭头函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.printName = <span class="function">(<span class="params">name = <span class="string">&#x27;there&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.print(<span class="string">`Hello <span class="subst">$&#123;name&#125;</span>`</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种解决方法是使用<code>Proxy</code>，获取方法的时候，自动绑定<code>this</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selfish</span> (<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">  <span class="keyword">const</span> handler = &#123;</span><br><span class="line">    get (target, key) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">Reflect</span>.get(target, key);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!cache.has(value)) &#123;</span><br><span class="line">        cache.set(value, value.bind(target));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> cache.get(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = selfish(<span class="keyword">new</span> Logger());</span><br></pre></td></tr></table></figure>

<h3 id="类的实例对象"><a href="#类的实例对象" class="headerlink" title="类的实例对象"></a>类的实例对象</h3><p>类的构造函数，不使用<code>new</code>是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用<code>new</code>也可以执行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x;</span><br><span class="line">    <span class="built_in">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span> + <span class="built_in">this</span>.x + <span class="string">&#x27;, &#x27;</span> + <span class="built_in">this</span>.y + <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> point = <span class="keyword">new</span> Point(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">point.toString() <span class="comment">// (2, 3)</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;x&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;y&#x27;</span>) <span class="comment">// true</span></span><br><span class="line">point.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// false</span></span><br><span class="line">point.__proto__.hasOwnProperty(<span class="string">&#x27;toString&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>和<code>y</code>都是实例对象<code>point</code><strong>自身的属性</strong>（因为定义在<code>this</code>变量上），所以<code>hasOwnProperty</code>方法返回<code>true</code>，而<code>toString</code>是原型对象的属性（因为定义在<code>Point</code>类上），所以<code>hasOwnProperty</code>方法返回<code>false</code>。这些都与ES5的行为保持一致。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。这也意味着，<strong>可以通过实例的<code>__proto__</code>属性为Class添加方法。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Point(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Point(<span class="number">3</span>,<span class="number">2</span>);</span><br><span class="line">p1.__proto__ === p2.__proto__ <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">p1.__proto__.printName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="string">&#x27;Oops&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">p1.printName() <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line">p2.printName() <span class="comment">// &quot;Oops&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> Point(<span class="number">4</span>,<span class="number">2</span>);</span><br><span class="line">p3.printName() <span class="comment">// &quot;Oops&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo &#123;</span><br><span class="line">  static a1 = 1</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    return &#x27;hello&#x27;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Foo.a1, Foo.classMethod()); //1 &#x27;hello&#x27;</span><br><span class="line"></span><br><span class="line">const foo = new Foo();</span><br><span class="line">console.log(foo.a1);//undefined</span><br><span class="line">// TypeError: foo.classMethod is not a function</span><br></pre></td></tr></table></figure>

<h4 id="类的实例属性"><a href="#类的实例属性" class="headerlink" title="类的实例属性"></a>类的实例属性</h4><p>类的实例属性可以用等式，写入类的定义之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  myProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.myProp); <span class="comment">// 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>myProp</code>就是<code>MyClass</code>的实例属性。在<code>MyClass</code>的实例上，可以读取这个属性。</p>
<p>以前，我们定义实例属性，只能写在类的<code>constructor</code>方法里面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReactCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造方法<code>constructor</code>里面，定义了<code>this.state</code>属性。有了新的写法以后，可以不在<code>constructor</code>方法里面定义。</p>
<h4 id="类的静态属性"><a href="#类的静态属性" class="headerlink" title="类的静态属性"></a>类的静态属性</h4><p>静态属性指的是Class本身的属性，即<code>Class.myStaticProp</code>，而不是定义在实例对象（<code>this</code>）上的属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> myStaticProp = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(MyClass.age, MyClass.myStaticProp); <span class="comment">// 2 42</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">MyClass.age = <span class="number">2</span></span><br><span class="line"><span class="keyword">new</span> MyClass()</span><br></pre></td></tr></table></figure>

<h4 id="类的静态方法"><a href="#类的静态方法" class="headerlink" title="类的静态方法"></a>类的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上<code>static</code>关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.classMethod()); <span class="comment">// &#x27;hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: foo.classMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Foo</code>类的<code>classMethod</code>方法前有<code>static</code>关键字，表明该方法是一个静态方法，可以直接在<code>Foo</code>类上调用（<code>Foo.classMethod()</code>），而不是在<code>Foo</code>类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。<strong>静态属性指的是Class本身的属性，即<code>Class.propname</code>，而不是定义在实例对象（<code>this</code>）上的属性。</strong></p>
<p>父类的静态方法，可以被子类继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod(); <span class="comment">// &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，父类<code>Foo</code>有一个静态方法，子类<code>Bar</code>可以调用这个方法。</p>
<p>静态方法也是可以从<code>super</code>对象上调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword">extends</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">classMethod</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.classMethod() + <span class="string">&#x27;, too&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Bar.classMethod();</span><br></pre></td></tr></table></figure>

<h4 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h4><p>私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。</p>
<p>一种做法是在命名上加以区别。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    <span class="built_in">this</span>._bar(baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  <span class="function"><span class="title">_bar</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>_bar</code>方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。</p>
<p>另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">  foo (baz) &#123;</span><br><span class="line">    bar.call(<span class="built_in">this</span>, baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">baz</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.snaf = baz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>是公有方法，内部调用了<code>bar.call(this, baz)</code>。这使得<code>bar</code>实际上成为了当前模块的私有方法。</p>
<p>还有一种方法是利用<code>Symbol</code>值的唯一性，将私有方法的名字命名为一个<code>Symbol</code>值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">Symbol</span>(<span class="string">&#x27;bar&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> snaf = <span class="built_in">Symbol</span>(<span class="string">&#x27;snaf&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">myClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 公有方法</span></span><br><span class="line">  <span class="function"><span class="title">foo</span>(<span class="params">baz</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>[bar](baz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 私有方法</span></span><br><span class="line">  [bar](baz) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[snaf] = baz;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bar</code>和<code>snaf</code>都是<code>Symbol</code>值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。</p>
<h3 id="Class的继承"><a href="#Class的继承" class="headerlink" title="Class的继承"></a>Class的继承</h3><p>Class之间可以通过<code>extends</code>关键字实现继承，让子类继承父类的属性和方法。除了私有属性，父类的所有属性和方法，都会被子类继承，其中包括静态方法。这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPoint</span> <span class="keyword">extends</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">x, y, color</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y); <span class="comment">// 调用父类的constructor(x, y)</span></span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.color + <span class="string">&#x27; &#x27;</span> + <span class="built_in">super</span>.toString(); <span class="comment">// 调用父类的toString()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类没有自己的<code>this</code>对象，而是继承父类的<code>this</code>对象，然后对其进行加工。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(new.target.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() // A</span><br><span class="line">new B() // B</span><br></pre></td></tr></table></figure>

<p><strong>ES5的继承，实质是先创造子类的实例对象<code>this</code>，然后再将父类的属性和方法添加到<code>this</code>上面（<code>Parent.apply(this)</code>）。</strong></p>
<p><strong>ES6的继承机制完全不同，实质是先初始化父类，创造父类的实例对象<code>this</code>（所以必须先调用<code>super</code>方法），然后再用子类的构造函数修改<code>this</code>。<code>super()</code>在这里相当于<code>A.prototype.constructor.call(this)</code>。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;animal&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//执行a,this是指向Animal</span></span><br><span class="line">    <span class="comment">//执行b,super先创建Animal实例对象，this指向Rabbit，但还没赋值name，此时还是animal</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">//Animal &#123; name: &#x27;animal&#x27; &#125; Rabbit &#123; name: &#x27;animal&#x27; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">//animal,animal</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;rabbit&#x27;</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>()</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//Rabbit &#123; name: &#x27;rabbit&#x27; &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// rabbit</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Rabbit.prototype); <span class="comment">//Animal &#123;constructor: ƒ&#125;</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(); <span class="comment">// *</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Rabbit(); <span class="comment">// *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果子类没有定义<code>constructor</code>方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有<code>constructor</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">constructor</span>(<span class="params">...args</span>)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="new-target属性"><a href="#new-target属性" class="headerlink" title="new.target属性"></a>new.target属性</h3><p><code>new</code>是从构造函数生成实例的命令。ES6为<code>new</code>命令引入了一个<code>new.target</code>属性，（在构造函数中）**返回<code>new</code>命令作用于的那个构造函数。如果构造函数不是通过<code>new</code>命令调用的，<code>new.target</code>会返回<code>undefined</code>**，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span>.target === Person) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;必须使用new生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&#x27;张三&#x27;</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> notAPerson = Person.call(person, <span class="string">&#x27;张三&#x27;</span>);  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p>上面代码确保构造函数只能通过<code>new</code>命令调用。</p>
<p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">length</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>

<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>不存在变量提升</strong></li>
<li>类的所有实例共享一个原型对象（_proto_）</li>
<li>类本身就指向构造函数</li>
<li>类的所有方法都定义在类的<code>prototype</code>属性上面</li>
<li>类的内部所有定义的方法，都是不可枚举的</li>
<li>类没有自身属性，所有方法都定义在类的<code>prototype</code>属性上面。而类创造的实例，有自身属性，这是类中constructor赋值给实例的，相当于调用了类中的constructor方法，并返回给实例对象。</li>
</ul>
<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p><strong>js语言执行环境是单线程</strong></p>
<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>
<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“<strong>事件循环</strong>”机制（Event Loop）</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当主函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。回调，回调，就是回头调用的意思。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	callback()<span class="comment">//f1的任务</span></span><br><span class="line">	&#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>

<p>但是回调函数有一个致命的弱点，就是容易写出<strong>回调地狱（Callback hell）</strong>。假设多个请求存在依赖性，你可能就会写出如下代码：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        <span class="comment">// 处理逻辑</span></span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理逻辑</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度耦合，使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。此外它不能使用 try catch 捕获错误，不能直接 return。</p>
<h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>这种方式下，<strong>异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生</strong>。</p>
<p>监听函数:on,bind,listen,addEventListener</p>
<p>监听方法:onclick…</p>
<h3 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h3><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）。</p>
<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery.subscribe(&#x27;done&#x27;, f2);</span><br></pre></td></tr></table></figure>

<p>然后，<code>f1</code>进行如下改写。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    // ...</span><br><span class="line">    jQuery.publish(&#x27;done&#x27;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>
<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jQuery.unsubscribe(&#x27;done&#x27;, f2);	</span><br></pre></td></tr></table></figure>

<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul>
<li><p><strong>状态</strong></p>
<p>一共有三种状态，分别为<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。</p>
</li>
<li><p><strong>特点</strong></p>
</li>
<li><p>(1)只有异步操作可以决定当前处于的状态，并且任何其他操作无法改变这个状态；<br>(2)一旦状态改变，就不会在变。状态改变的过程只可能是：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。如果状态发生上述变化后，此时状态就不会在改变了，这时就称为<code>resolved</code>（已定型）</p>
</li>
<li><p><strong>优点：</strong> 可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数 </p>
</li>
<li><p><strong>缺点：</strong> 无法取消<code>Promise</code>  其次，如果没有使用<code>catch()</code>方法指定错误处理的回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。 <strong>Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</strong>    </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);<span class="comment">//&#x27;x 必须为正数&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><ul>
<li> <strong><code>Promise</code>对象是一个构造函数，用来生成<code>Promise</code>实例。</strong> </li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);<span class="comment">//在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。第二个函数是可选的，不一定要提供。</span></span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>Promise</code>对象实现的 Ajax 操作的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handler = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.readyState !== <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="built_in">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="built_in">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">    client.send();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line">getJSON(<span class="string">&quot;/posts.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Contents: &#x27;</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">&#x27;出错了&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>调用<code>resolve</code>函数和<code>reject</code>函数时带有参数,参数是另一个Promise对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//`p1`和`p2`都是 Promise 的实例，但是`p2`的`resolve`方法将`p1`作为参数，即一个异步操作的结果是返回另一个异步操作。p1的状态由p2决定</span></span><br><span class="line"><span class="comment">//注意，这时`p1`的状态就会传递给`p2`，也就是说，`p1`的状态决定了`p2`的状态。如果`p1`的状态是`pending`，那么`p2`的回调函数就会等待`p1`的状态改变；如果`p1`的状态已经是`resolved`或者`rejected`，那么`p2`的回调函数将会立刻执行。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> resolve(p1), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;result&#x27;</span>, result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;error&#x27;</span>, error))</span><br><span class="line"><span class="comment">// error [Error: fail] </span></span><br><span class="line"><span class="comment">//上面代码中，`p1`是一个 Promise，3 秒之后变为`rejected`。`p2`的状态在 1 秒之后改变，`resolve`方法返回的是`p1`。由于`p2`返回的是另一个 Promise，导致`p2`自己的状态无效了，由`p1`的状态决定`p2`的状态。所以，后面的`then`语句都变成针对后者（`p1`）。又过了 2 秒，`p1`变为`rejected`，导致触发`catch`方法指定的回调函数。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><h5 id="then"><a href="#then" class="headerlink" title="then"></a>then</h5><p><code>Promise.prototype.then()</code>方法返回的是一个新的<code>Promise</code>实例（注意，不是原来那个<code>Promise</code>实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个<code>then</code>方法。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&quot;/post/1.json&quot;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;resolved: &quot;</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;rejected: &quot;</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个<code>then</code>方法指定的回调函数，返回的是另一个<code>Promise</code>对象。这时，第二个<code>then</code>方法指定的回调函数，就会等待这个新的<code>Promise</code>对象状态发生变化。如果变为<code>resolved</code>，就调用第一个回调函数，如果状态变为<code>rejected</code>，就调用第二个回调函数。</p>
<h5 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h5><p><code>Promise.prototype.catch</code>方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">getJSON(<span class="string">&#x27;/posts.json&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理 getJSON 和 前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;发生错误！&#x27;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>getJSON()</code>方法返回一个 Promise 对象，如果该对象状态变为<code>resolved</code>，则会调用<code>then()</code>方法指定的回调函数；如果异步操作抛出错误，状态就会变为<code>rejected</code>，就会调用<code>catch()</code>方法指定的回调函数，处理这个错误。另外，**<code>then()</code>方法指定的回调函数**，如果运行中抛出错误，也会被<code>catch()</code>方法捕获。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);<span class="comment">// Error: test</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>));</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);<span class="comment">// Error: test</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果Promise状态已经变成<code>Resolved</code>，再抛出错误是无效的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，Promise在<code>resolve</code>语句后面，再抛出错误，不会被捕获，等于没有抛出。</p>
<p>总结：一般来说，不要在<code>then</code>方法里面定义Reject状态的回调函数（即<code>then</code>的第二个参数），总是使用<code>catch</code>方法。理由是catch可以捕获前面<code>then</code>方法执行中的错误，也更接近同步的写法（<code>try/catch</code>）。因此，建议总是使用<code>catch</code>方法，而不使用<code>then</code>方法的第二个参数。</p>
<h5 id="all"><a href="#all" class="headerlink" title="all"></a>all</h5><p><code>Promise.prototype.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="built_in">Promise</span>.all([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p> <code>Promise.all()</code>方法接受一个数组作为参数，<code>p1</code>、<code>p2</code>、<code>p3</code>都是 Promise 实例，<strong>如果不是，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理</strong>。另外，<code>Promise.all()</code>方法的参数可以不是数组，但<strong>必须具有 Iterator 接口</strong>，且返回的每个成员都是 Promise 实例。 </p>
<p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p>
<p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p>
<p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p>
<h5 id="race"><a href="#race" class="headerlink" title="race"></a>race</h5><p><code>Promise.race</code>方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([p1, p2, p3]);</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p>
<p><code>Promise.race</code>方法的参数与<code>Promise.all</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve</code>方法，将参数转为 Promise 实例，再进一步处理。</p>
<p>下面是一个例子，<strong>如果指定时间内没有获得结果，就将Promise的状态变为<code>reject</code>，否则变为<code>resolve</code>。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">&#x27;/resource-that-may-take-a-while&#x27;</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;request timeout&#x27;</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response))</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果5秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p>
<h5 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h5><p> <code>finally()</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。 <code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">promise</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123;···&#125;)</span><br><span class="line">.finally(<span class="function">() =&gt;</span> &#123;···&#125;);</span><br></pre></td></tr></table></figure>

<p> 在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。  </p>
<h5 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h5><p>有时需要将现有对象转为Promise对象，<code>Promise.resolve</code>方法就起到这个作用。</p>
<p><strong>（1）参数是一个Promise实例</strong></p>
<p>如果参数是Promise实例，那么<code>Promise.resolve</code>将不做任何修改、原封不动地返回这个实例。</p>
<p><strong>（3）参数不是一个Promise实例</strong></p>
<p>如果参数是一个原始值，或者是一个不具有<code>then</code>方法的对象，则<code>Promise.resolve</code>方法返回一个新的Promise对象，状态为<code>Resolved</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>

<p><strong>（4）不带有任何参数</strong></p>
<p><code>Promise.resolve</code>方法允许调用时不带参数，直接返回一个<code>Resolved</code>状态的Promise对象。</p>
<p>所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用<code>Promise.resolve</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码的变量<code>p</code>就是一个Promise对象。</p>
<p>需要注意的是，立即<code>resolve</code>的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;three&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;two&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;one&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// one</span></span><br><span class="line"><span class="comment">// two</span></span><br><span class="line"><span class="comment">// three</span></span><br></pre></td></tr></table></figure>

<h5 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h5><p><code>Promise.reject(reason)</code>方法也会返回一个新的Promise实例，该实例的状态为<code>rejected</code>。它的参数用法与<code>Promise.resolve</code>方法完全一致。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(<span class="string">&#x27;出错了&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>

<p>上面代码生成一个Promise对象的实例<code>p</code>，状态为<code>rejected</code>，回调函数会立即执行。</p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p><a href="https://zhuanlan.zhihu.com/p/76811638">https://zhuanlan.zhihu.com/p/76811638</a></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  reject(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line">a.catch(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">//返回新的promise，那么下一级.then()会在新的promise状态改变之后执行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>返回新的promise，那么下一级.then()会在新的promise状态改变之后执行</li>
<li>没有return，相当于return Promise.resolve(undefined);</li>
<li>return非Promise的数据data，相当于return Promise.resolve(data);</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    resolve(<span class="number">3</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">a.then(<span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> ​​​​​at ​​​​​​quokka.js:<span class="number">2</span>:<span class="number">3</span>​</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span> &#123; &lt;pending&gt; &#125;</span><br><span class="line">  ​​​​​at ​​​​​​​​a​​​ ​quokka.js:<span class="number">11</span>:<span class="number">1</span>​</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ​​​​​at ​​​​​​quokka.js:<span class="number">4</span>:<span class="number">5</span>​</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> ​​​​​at ​​​​​​​​index​​​ ​quokka.js:<span class="number">9</span>:<span class="number">3</span>​</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved,reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  resolved(<span class="number">2</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  resolved(<span class="number">4</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">  reject(<span class="number">4</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> ​​​​​at ​​​​​​quokka.js:<span class="number">2</span>:<span class="number">3</span>​</span><br><span class="line"></span><br><span class="line"><span class="number">3</span> ​​​​​at ​​​​​​quokka.js:<span class="number">4</span>:<span class="number">3</span>​</span><br><span class="line"></span><br><span class="line"><span class="number">5</span> ​​​​​at ​​​​​​quokka.js:<span class="number">6</span>:<span class="number">3</span>​</span><br><span class="line"></span><br><span class="line"><span class="number">2</span> ​​​​​at ​​​​​​​​res​​​ ​quokka.js:<span class="number">9</span>:<span class="number">3</span>​</span><br></pre></td></tr></table></figure>



<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">[<span class="built_in">Error</span>: x 必须为正数] ​​​​​at ​​​​​​​​res​​​ ​quokka.js:<span class="number">6</span>:<span class="number">3</span>​</span><br></pre></td></tr></table></figure>



<h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><h4 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h4><h4 id="async含义"><a href="#async含义" class="headerlink" title="async含义"></a>async含义</h4><p>定义：使异步函数以同步函数的形式书写(Generator函数语法糖)</p>
<p>原理：将<code>Generator函数</code>和自动执行器<code>spawn</code>包装在一个函数里</p>
<p>形式：将<code>Generator函数</code>的<code>*</code>替换成<code>async</code>，将<code>yield</code>替换成<code>await</code></p>
<p><code>async</code>函数对 Generator 函数的改进，体现在以下四点。 </p>
<p>（1）内置执行器</p>
<p>Generator 函数的执行必须靠执行器，所以才有了<code>co</code>模块，而<code>async</code>函数自带执行器。也就是说，<code>async</code>函数的执行，与普通函数一模一样，只要一行。 不像 Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行 </p>
<p>（2）更好的语义</p>
<p><code>async</code>和<code>await</code>，比起星号和<code>yield</code>，语义更清楚了。</p>
<p>（3）更广的适用性。</p>
<p><code>co</code>模块约定，<code>yield</code>命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code>函数的<code>await</code>命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</p>
<p>（4）<strong>返回值是 Promise</strong></p>
<p><code>async</code>函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用<code>then</code>方法指定下一步的操作。 <code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。 </p>
<h4 id="async语法"><a href="#async语法" class="headerlink" title="async语法"></a>async语法</h4><h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><ul>
<li>函数：<code>async function Func() &#123;&#125;</code></li>
<li>函数表达式：<code>const func = async function() &#123;&#125;</code></li>
<li>箭头函数：<code>const func = async() =&gt; &#123;&#125;</code></li>
<li>对象方法：<code>const obj = &#123; async func() &#123;&#125; &#125;</code></li>
<li>类方法：<code>class Cla &#123; async Func() &#123;&#125; &#125;</code></li>
</ul>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><ul>
<li><p>没有显式return，相当于return Promise.resolve(undefined);</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line">    <span class="comment">//没有return，就类似于resolved(undefined)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">    <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),<span class="comment">//undefined</span></span><br><span class="line">    <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>return非Promise的数据data，相当于return Promise.resolve(data);</p>
<p><code>async</code>函数内部<code>return</code>语句返回的值，会成为<code>then</code>方法回调函数的参数。如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async function f() &#123;</span><br><span class="line">  return &#x27;hello world&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(v =&gt; console.log(v))</span><br><span class="line">// &quot;hello world&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><code>async</code>函数返回一个Promise对象。</p>
<ul>
<li><p>return Promise, 会得到Promise对象本身。</p>
<p><code>async</code>函数返回的Promise对象，必须等到内部所有<code>await</code>命令的Promise对象执行完，才会发生状态改变。也就是说，只有<code>async</code>函数内部的异步操作执行完，才会执行<code>then</code>方法指定的回调函数。</p>
</li>
<li><p>返回rejected</p>
<p><code>async</code>函数内部抛出错误，会导致返回的Promise对象变为<code>reject</code>状态。抛出的错误对象会被<code>catch</code>方法回调函数接收到。<strong>只要一个<code>await</code>语句后面的Promise变为<code>reject</code>，那么整个<code>async</code>函数都会中断执行。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="comment">//await Promise.reject(&#x27;出错了&#x27;);</span></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f().then(</span><br><span class="line">  <span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v),</span><br><span class="line">  <span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// Error: 出错了</span></span><br></pre></td></tr></table></figure>

<p>为了避免这个问题，可以将第一个<code>await</code>放在<code>try...catch</code>结构里面，这样第二个<code>await</code>就会执行。</p>
</li>
</ul>
</li>
</ul>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>如果<code>await</code>后面的异步操作出错，那么等同于<code>async</code>函数返回的 Promise 对象被<code>reject</code>。且下面的代码不会被执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>); <span class="comment">// 不会执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">.catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e))</span><br><span class="line"><span class="comment">//出错了</span></span><br></pre></td></tr></table></figure>

<p><strong>为了防止状态变为rejected，中断后面的异步操作</strong>，将报错代码放在<code>try...catch</code>代码块之中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> (<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">  .then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line">  .catch(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<p>另一种方法是<code>await</code>后面的Promise对象再跟一个<code>catch</code>方面，处理前面可能出现的错误。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.reject(<span class="string">&#x27;出错了&#x27;</span>)</span><br><span class="line">    .catch(<span class="function"><span class="params">e</span> =&gt;</span> <span class="built_in">console</span>.log(e));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">.then(<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">console</span>.log(v))</span><br><span class="line"><span class="comment">// 出错了</span></span><br><span class="line"><span class="comment">// hello world</span></span><br></pre></td></tr></table></figure>

<h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><ul>
<li><p>多个<code>await</code>命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let foo = await getFoo();</span><br><span class="line">let bar = await getBar();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getFoo</code>和<code>getBar</code>是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有<code>getFoo</code>完成以后，才会执行<code>getBar</code>，完全可以让它们同时触发。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 写法一</span><br><span class="line">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</span><br><span class="line"></span><br><span class="line">// 写法二</span><br><span class="line">let fooPromise = getFoo();</span><br><span class="line">let barPromise = getBar();</span><br><span class="line">let foo = await fooPromise;</span><br><span class="line">let bar = await barPromise;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## </span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">//在async中将异步的代码同步执行</span><br><span class="line">var a = async () =&gt; &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  function fn()&#123;</span><br><span class="line">    setTimeout(()=&gt;&#123;</span><br><span class="line">        console.log(5)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  await fn()</span><br><span class="line">  // await的Promise会同步执行完</span><br><span class="line">  await的 new Promise((resolved) =&gt; &#123;</span><br><span class="line">    console.log(2);</span><br><span class="line">    resolved(3);</span><br><span class="line">  &#125;).then((v) =&gt; &#123;</span><br><span class="line">    console.log(v);</span><br><span class="line">  &#125;);</span><br><span class="line">  console.log(4);</span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">1 ​​​​​at ​quokka.js:2:2​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​quokka.js:10:4​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​v​​​ ​quokka.js:13:4​</span><br><span class="line"></span><br><span class="line">4 ​​​​​at ​quokka.js:16:2​</span><br><span class="line"></span><br><span class="line">5 ​​​​​at ​quokka.js:5:8​</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">async function f1()&#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">  await f2()</span><br><span class="line">  console.log(6);</span><br><span class="line">&#125;</span><br><span class="line">async function f2()&#123;</span><br><span class="line">  console.log(3);</span><br><span class="line">&#125;</span><br><span class="line">console.log(1);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(8);</span><br><span class="line">&#125;, 0);</span><br><span class="line">f1()</span><br><span class="line">new Promise((resolved)=&gt;&#123;</span><br><span class="line">  console.log(4);</span><br><span class="line">  resolved(7)</span><br><span class="line">&#125;).then((res)=&gt;&#123;</span><br><span class="line">  console.log(res);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(5);</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line">1 ​​​​​at ​​​​​​quokka.js:9:1​</span><br><span class="line"></span><br><span class="line">2 ​​​​​at ​​​​​​quokka.js:2:3​</span><br><span class="line"></span><br><span class="line">3 ​​​​​at ​​​​​​quokka.js:7:3​</span><br><span class="line"></span><br><span class="line">4 ​​​​​at ​​​​​​quokka.js:15:3​</span><br><span class="line"></span><br><span class="line">5 ​​​​​at ​​​​​​quokka.js:20:1​</span><br><span class="line"></span><br><span class="line">6 ​​​​​at ​​​​​​quokka.js:4:3​</span><br><span class="line"></span><br><span class="line">7 ​​​​​at ​​​​​​​​res​​​ ​quokka.js:18:3​</span><br><span class="line"></span><br><span class="line">8 ​​​​​at ​​​​​​quokka.js:11:3​</span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<h2 id="Proxy-和-Reflect"><a href="#Proxy-和-Reflect" class="headerlink" title="Proxy 和 Reflect"></a>Proxy 和 Reflect</h2><p><a href="https://mp.weixin.qq.com/s/Ez2Cf6w4SwX1HOjnE1wl6g">https://mp.weixin.qq.com/s/Ez2Cf6w4SwX1HOjnE1wl6g</a></p>
<h3 id="Proxy代理"><a href="#Proxy代理" class="headerlink" title="Proxy代理"></a>Proxy代理</h3><p>Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码对一个空对象架设了一层拦截，重定义了属性的读取（<code>get</code>）和设置（<code>set</code>）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象<code>obj</code>，去读写它的属性，就会得到下面的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">obj.count = <span class="number">1</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line">++obj.count</span><br><span class="line"><span class="comment">//  getting count!</span></span><br><span class="line"><span class="comment">//  setting count!</span></span><br><span class="line"><span class="comment">//  2</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。</p>
<p>ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br></pre></td></tr></table></figure>

<p>Proxy 对象的所有用法，都是上面这种形式，不同的只是<code>handler</code>参数的写法。其中，<code>new Proxy()</code>表示生成一个<code>Proxy</code>实例，<code>target</code>参数表示所要拦截的目标对象，<code>handler</code>参数也是一个对象，用来定制拦截行为。</p>
<p>下面是另一个拦截读取属性行为的例子。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，作为构造函数，<code>Proxy</code>接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有<code>Proxy</code>的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个<code>get</code>方法，用来拦截对目标对象属性的访问请求。**<code>get</code>方法的两个参数分别是目标对象和所要访问的属性**。可以看到，由于拦截函数总是返回<code>35</code>，所以访问任何属性都得到<code>35</code>。</p>
<p><strong>如果<code>handler</code>没有设置任何拦截，那就等同于直接通向原对象。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler);</span><br><span class="line">proxy.a = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">target.a <span class="comment">// &quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<p>Proxy 实例也可以作为其他对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>proxy</code>对象是<code>obj</code>对象的原型，<code>obj</code>对象本身并没有<code>time</code>属性，所以根据原型链，会在<code>proxy</code>对象上读取该属性，导致被拦截。</p>
<h3 id="Reflect映射对象"><a href="#Reflect映射对象" class="headerlink" title="Reflect映射对象"></a>Reflect映射对象</h3><p><code>Reflect</code>对象与<code>Proxy</code>对象一样，也是ES6为了操作对象而提供的新API。</p>
<h4 id="为什么会有Reflect"><a href="#为什么会有Reflect" class="headerlink" title="为什么会有Reflect"></a>为什么会有Reflect</h4><p>1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。</p>
<p>（2） 修改某些Object方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回<code>false</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, property, attributes);</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">Reflect</span>.defineProperty(target, property, attributes)) &#123;</span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3） 让<code>Object</code>操作都变成函数行为。某些<code>Object</code>操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 老写法</span></span><br><span class="line"><span class="string">&#x27;assign&#x27;</span> <span class="keyword">in</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新写法</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(<span class="built_in">Object</span>, <span class="string">&#x27;assign&#x27;</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法。这就让<code>Proxy</code>对象可以方便地调用对应的<code>Reflect</code>方法，完成默认行为，作为修改行为的基础。也就是说，不管<code>Proxy</code>怎么修改默认行为，你总可以在<code>Reflect</code>上获取默认行为。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Proxy</span>(target, &#123;</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span>(<span class="params">target, name, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> success = <span class="built_in">Reflect</span>.set(target,name, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      log(<span class="string">&#x27;property &#x27;</span> + name + <span class="string">&#x27; on &#x27;</span> + target + <span class="string">&#x27; set to &#x27;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Proxy</code>方法拦截<code>target</code>对象的属性赋值行为。它采用<code>Reflect.set</code>方法将值赋值给对象的属性，然后再部署额外的功能。</p>
<h4 id="Reflect对象操作Object对象"><a href="#Reflect对象操作Object对象" class="headerlink" title="Reflect对象操作Object对象"></a>Reflect对象操作Object对象</h4><p>Reflect对象让我们操作<code>Object</code>对象不再是通过点语法了，而是变成了函数行为。</p>
<p>我们看下面的例子，获取对象属性可以使用<code>Reflect.get</code>方法、将对象的属性赋值可以使用<code>Reflect.set</code>方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;_island&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取对应属性的值</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// _island</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(obj, <span class="string">&quot;name&quot;</span>)); <span class="comment">// _island</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对对象的属性赋值操作</span></span><br><span class="line">obj.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">Reflect</span>.set(obj, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.get(obj, <span class="string">&quot;name&quot;</span>)); <span class="comment">// abc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个对象中是否有该属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> obj); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Reflect</span>.has(obj, <span class="string">&quot;name&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;_island&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span> === objProxy</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> objProxy=<span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,&#123;&#125;)</span><br><span class="line"> <span class="built_in">console</span>.log(obj.foo()); <span class="comment">// false</span></span><br><span class="line"> <span class="built_in">console</span>.log(objProxy.foo()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Proxy</code>对象可以对我们的目标对象进行访问，但没有做任何拦截时，也不能保证与目标对象的行为一致，因为目标对象内部的<code>this</code>会自动改变为<code>Proxy</code>代理对象。</p>
<h3 id="Reflect搭配Proxy"><a href="#Reflect搭配Proxy" class="headerlink" title="Reflect搭配Proxy"></a>Reflect搭配Proxy</h3><p><code>Proxy</code>对象中的方法也能在<code>Reflect</code>对象中调用。</p>
<p>通常我们将<code>Reflect</code>对象搭配<code>Proxy</code>一起使用，我们看下面这个<code>Reflect</code>搭配<code>Proxy</code>对象使用的案例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;_island&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line"> <span class="comment">// get陷阱中target表示原对象 key表示访问的属性名</span></span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(receiver === proxy);<span class="comment">//true</span></span><br><span class="line">    <span class="comment">// 原来的写法</span></span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">    <span class="comment">// 使用Reflect</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, newVal, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 原来的写法</span></span><br><span class="line">    <span class="comment">// target[key]=newVal</span></span><br><span class="line">    <span class="comment">// 使用Reflect</span></span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, newVal, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objProxy.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objProxy.name); <span class="comment">// abc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面，<code>Proxy</code>对象中<code>get</code>、<code>set</code>捕获器多了一个<code>receiver</code>参数，这是这两个捕获器特有的，这个<code>receiver</code>参数是当前代理的目标。</p>
<p>当<code>Proxy</code>和<code>Reflect</code>搭配使用时，<code>Proxy</code>对象会拦截对应的操作，后者完成对应的操作，如果传入<code>receiver</code>，那么<code>Reflect.get</code>属性会触发<code>Proxy.defineProperty</code>捕获器。我们再上面这里案例上再新增一些代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;_island&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 原来的写法</span></span><br><span class="line">    <span class="comment">// return target[key]</span></span><br><span class="line">    <span class="comment">// 使用Reflect</span></span><br><span class="line">    <span class="built_in">console</span>.log(receiver);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, newVal, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 原来的写法</span></span><br><span class="line">    <span class="comment">// target[key]=newVal</span></span><br><span class="line">    <span class="comment">// 使用Reflect</span></span><br><span class="line">    <span class="built_in">Reflect</span>.set(target, key, newVal, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">defineProperty</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, attr</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;defineProperty&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(target, key, attr);</span><br><span class="line">    <span class="built_in">Reflect</span>.defineProperty(target, key, attr);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">objProxy.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objProxy.name); </span><br><span class="line"><span class="comment">// defineProperty</span></span><br><span class="line"><span class="comment">// &#123; name: &#x27;_island&#x27; &#125; name &#123; value: &#x27;abc&#x27; &#125;</span></span><br><span class="line"><span class="comment">// &#123; name: &#x27;abc&#x27; &#125;</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>传入在我们获取代理对象中的<code>name</code>属性时，当<code>Reflect</code>有<code>receiver</code>参数传入时，获取属性值时会获取到<code>receiver</code>中的，所以会触发<code>defineProperty</code>捕获器，如果没有传入<code>receiver</code>参数，则不会触发<code>defineProperty</code>捕获器。</p>
<h3 id="监听案例"><a href="#监听案例" class="headerlink" title="监听案例"></a>监听案例</h3><p>在<code>ES5</code>中使用<code>Object.defineProperty</code>（对象属性描述符）对对象的监听，将一个对象进行遍历，并设定<code>getter</code>、<code>setter</code>方法进行监听和拦截。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个Object对象</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;_island&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(obj).forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> val = obj[key];</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key + <span class="string">&quot;调用了get方法&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(key + <span class="string">&quot;调用了set方法&quot;</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作obj对象</span></span><br><span class="line">obj.name = <span class="string">&quot;QC2125&quot;</span>;</span><br><span class="line"><span class="comment">// name调用了set方法</span></span><br><span class="line">obj.age = <span class="number">30</span>;</span><br><span class="line"><span class="comment">// age调用了set方法</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.name); </span><br><span class="line"><span class="comment">// name调用了get方法</span></span><br><span class="line"><span class="comment">// QC2125</span></span><br></pre></td></tr></table></figure>

<p><code>Object.defineProperty</code>的设计初衷并不是为了去监听拦截一个对象中的属性，且他也实现不了更加丰富的操作，例如添加、删除属性等操作。</p>
<p>我们将上面通过<code>Object.defineProperty</code>实现对象监听的方法修改成<code>Proxy</code>方案。在Vue3框架中的响应式原理也是用到了Proxy对象进行对属性的监听操作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;_island&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// 获取值时的捕获器</span></span><br><span class="line">  <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到了<span class="subst">$&#123;key&#125;</span>被获取值`</span>);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 设置值时的捕获器</span></span><br><span class="line">  <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">target, key, newValue</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`监听到了<span class="subst">$&#123;key&#125;</span>被设置值`</span>);</span><br><span class="line">    target[key] = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objProxy.name);</span><br><span class="line"><span class="comment">// 监听到了name被获取值</span></span><br><span class="line"><span class="comment">// _island</span></span><br><span class="line"><span class="built_in">console</span>.log(objProxy.age);</span><br><span class="line"><span class="comment">// 监听到了age被获取值</span></span><br><span class="line"><span class="comment">// 18</span></span><br><span class="line">objProxy.name = <span class="string">&quot;QC2125&quot;</span>;</span><br><span class="line"><span class="comment">// 监听到了name被设置值</span></span><br><span class="line"><span class="built_in">console</span>.log(objProxy.name);</span><br><span class="line"><span class="comment">// 监听到了name被获取值</span></span><br><span class="line"><span class="comment">// QC2125</span></span><br></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，只要是<code>Proxy</code>对象的方法，就能在<code>Reflect</code>对象上找到对应的方法</p>
<table>
<thead>
<tr>
<th>对象中的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Reflect.apply()</td>
<td>对一个函数进行<code>apply</code>调用</td>
</tr>
<tr>
<td>Reflect.construct()</td>
<td>对构造函数进行<code>new</code>操作</td>
</tr>
<tr>
<td>Reflect.defineProperty()</td>
<td>定义一个属性</td>
</tr>
<tr>
<td>Reflect.deleteProperty()</td>
<td>删除一个属性</td>
</tr>
<tr>
<td>Reflect.get()</td>
<td>获取一个属性</td>
</tr>
<tr>
<td>Reflect.getOwnPropertyDescriptor()</td>
<td>获取一个属性描述符</td>
</tr>
<tr>
<td>Reflect.getPrototypeOf()</td>
<td>获取一个对象的原型</td>
</tr>
<tr>
<td>Reflect.has()</td>
<td>判断一个属性是否在对象中</td>
</tr>
<tr>
<td>Reflect.isExtensible()</td>
<td>判断可以扩展</td>
</tr>
<tr>
<td>Reflect.ownKeys()</td>
<td>获取一个对象中的<code>key</code>集合</td>
</tr>
<tr>
<td>Reflect.preventExtensions()</td>
<td>使一个对象不可扩展</td>
</tr>
<tr>
<td>Reflect.set()</td>
<td>设置一个属性</td>
</tr>
<tr>
<td>Reflect.setPrototypeOf()</td>
<td>设置一个对象的原型</td>
</tr>
</tbody></table>
<h1 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h1><p>TypeScript 是一门基于 JavaScript 拓展的语言，它是 JavaScript 的超集，并且给 JavaScript 添加了静态类型检查系统。TypeScript 能让我们在开发时发现程序中类型定义不一致的地方，及时消除隐藏的风险，大大增强了代码的可读性以及可维护性。</p>
<h2 id="TS和JS"><a href="#TS和JS" class="headerlink" title="TS和JS"></a>TS和JS</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>具体可在中查看<a href="./02-%E5%B8%B8%E8%AF%86.md">常识文档</a></p>
<h3 id="类型绑定"><a href="#类型绑定" class="headerlink" title="类型绑定"></a>类型绑定</h3><p><strong>JavaScript</strong></p>
<p>JavaScript 是一门解释型语言，没有编译阶段，所以它是动态类型。<code>JavaScript</code><strong>动态</strong>绑定类型，只有运行程序才能知道类型，在程序运行之前<code>JavaScript</code>对类型一无所知</p>
<p><strong>TypeScript</strong></p>
<p><code>TypeScript</code>是在程序运行前（也就是编译时）就会知道当前是什么类型。当然如果该变量没有定义类型，那么<code>TypeScript</code>会自动类型推导出来。</p>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p><strong>JavaScript弱类型语言</strong></p>
<p>比如在<code>JavaScript</code>中<code>1 + true</code>这样一个代码片段，<code>JavaScript</code>存在隐式转换，这时<code>true</code>会变成<code>number</code>类型<code>number(true)</code>和1相加。</p>
<p><strong>TypeScript强类型语言</strong></p>
<p>在<code>TypeScript</code>中，<code>1+true</code>这样的代码会在<code>TypeScript</code>中报错，提示<code>number</code>类型不能和<code>boolean</code>类型进行运算。</p>
<h3 id="何时检查类型"><a href="#何时检查类型" class="headerlink" title="何时检查类型"></a>何时检查类型</h3><p><strong>JavaScript</strong></p>
<p>在<code>JavaScript</code>中只有在程序运行时才能检查类型。类型也会存在隐式转换，很坑。</p>
<p><strong>TypeScript</strong></p>
<p>在<code>TypeScript</code>中，在编译时就会检查类型，如果和预期的类型不符合直接会在编辑器里报错、爆红</p>
<h2 id="TS特殊符号"><a href="#TS特殊符号" class="headerlink" title="TS特殊符号"></a>TS特殊符号</h2><p><a href="https://blog.csdn.net/qiwoo_weekly/article/details/108557466">https://blog.csdn.net/qiwoo_weekly/article/details/108557466</a></p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="?. 运算符"></a>?. 运算符</h3><p>可选链（Optional Chaining）运算符是一种先检查属性是否存在，再尝试访问该属性的运算符</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a?.b;</span><br><span class="line"><span class="comment">// 相当于 a == null ? undefined : a.b;</span></span><br><span class="line"><span class="comment">// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a.b 的值.</span></span><br><span class="line"></span><br><span class="line">a?.[x];</span><br><span class="line"><span class="comment">// 相当于 a == null ? undefined : a[x];</span></span><br><span class="line"><span class="comment">// 如果 a 是 null/undefined，那么返回 undefined，否则返回 a[x] 的值</span></span><br><span class="line"></span><br><span class="line">a?.b();</span><br><span class="line"><span class="comment">// 相当于a == null ? undefined : a.b();</span></span><br><span class="line"><span class="comment">// 如果 a 是 null/undefined，那么返回 undefined</span></span><br><span class="line"><span class="comment">// 如果 a.b 不是函数的话，会抛类型错误异常，否则计算 a.b() 的结果</span></span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title="?:"></a>?:</h3><p>在 TypeScript 中使用 <code>interface</code> 关键字就可以声明一个接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="keyword">string</span>;</span><br><span class="line">  age: number;</span><br><span class="line">&#125;</span><br><span class="line">let semlinker: Person = &#123;</span><br><span class="line">  name: <span class="string">&quot;semlinker&quot;</span>,</span><br><span class="line">  age: <span class="number">33</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在以上代码中，我们声明了 <code>Person</code> 接口，它包含了两个必填的属性 <code>name</code> 和 <code>age</code>。在初始化 Person 类型变量时，如果缺少某个属性，TypeScript 编译器就会提示相应的错误信息，比如：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Property &#x27;age&#x27; is missing in type &#x27;&#123; name: string; &#125;&#x27; but required in type &#x27;Person&#x27;.(2741)</span></span><br><span class="line">let lolo: Person  = &#123; <span class="comment">// Error</span></span><br><span class="line">  name: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决上述的问题，我们可以把某个属性声明为可选的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">  name: <span class="keyword">string</span>;</span><br><span class="line">  age?: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let lolo: Person  = &#123;</span><br><span class="line">  name: <span class="string">&quot;lolo&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="-1"><a href="#-1" class="headerlink" title="!:"></a>!:</h3><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="| 分隔符"></a>| 分隔符</h3><p>在 TypeScript 中联合类型（Union Types）表示取值可以为多种类型中的一种，联合类型使用 <code>|</code> 分隔每个类型。联合类型通常与 <code>null</code> 或 <code>undefined</code> 一起使用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sayHello = (name: <span class="keyword">string</span> | undefined) =&gt; &#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>以上示例中 <code>name</code> 的类型是 <code>string | undefined</code> 意味着可以将 <code>string</code> 或 <code>undefined</code> 的值传递给 <code>sayHello</code> 函数。</p>
<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>定义类型由两种方式：接口（interface）和类型别名（type alias）</p>
<p>interface只能定义对象类型，type声明的方式可以定义组合类型，交叉类型和原始类型</p>
<h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做<code>boolean</code>（其它语言中也一样）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isDone: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><p>和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 <code>number</code>。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> decLiteral: <span class="built_in">number</span> = <span class="number">6</span>;<span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> hexLiteral: <span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">// 十六进制</span></span><br><span class="line"><span class="keyword">let</span> binaryLiteral: <span class="built_in">number</span> = <span class="number">0b1010</span>;<span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> octalLiteral: <span class="built_in">number</span> = <span class="number">0o744</span>;  <span class="comment">// 八进制</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">&quot;bob&quot;</span>;</span><br><span class="line">name = <span class="string">&quot;smith&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>你还可以使用<em>模版字符串</em>，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ ```），并且以<code>$&#123; expr &#125;</code>这种形式嵌入表达式</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">`Gene`</span>;</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = <span class="number">37</span>;</span><br><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">`Hello, my name is <span class="subst">$&#123; name &#125;</span>.I&#x27;ll be <span class="subst">$&#123; age + <span class="number">1</span> &#125;</span> years old next month.`</span>;</span><br></pre></td></tr></table></figure>

<p>这与下面定义<code>sentence</code>的方式效果相同：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> sentence: <span class="built_in">string</span> = <span class="string">&quot;Hello, my name is &quot;</span> + name + <span class="string">&quot;.\n\n&quot;</span> +<span class="string">&quot;I&#x27;ll be &quot;</span> + (age + <span class="number">1</span>) + <span class="string">&quot; years old next month.&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Null-和-Undefined"><a href="#Null-和-Undefined" class="headerlink" title="Null 和 Undefined"></a>Null 和 Undefined</h3><p><strong>null</strong></p>
<p>null是一个只有一个值的特殊类型。表示一个空对象引用。在 JavaScript 中 null 表示 “什么都没有”。用 typeof 检测 null 返回是 object。</p>
<p><strong>undefined</strong></p>
<p>在 JavaScript 中, undefined 是一个没有设置值的变量。typeof 一个没有值的变量会返回 undefined。</p>
<p>与 <code>void</code> 的区别是，<code>undefined</code> 和 <code>null</code> 是所有类型的子类型。也就是说 <code>undefined</code> 类型的变量，可以赋值给 <code>number</code> 类型的变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样不会报错</span></span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="comment">// 这样也不会报错</span></span><br><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = u;</span><br></pre></td></tr></table></figure>

<p>而 <code>void</code> 类型的变量不能赋值给 <code>number</code> 类型的变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="built_in">void</span>;</span><br><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = u;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Type &#x27;void&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在<strong>元素类型</strong>后面接上 <code>[]</code>，表示由此类型元素组成的一个数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>第二种方式是使用<strong>数组泛型</strong>，<code>Array&lt;元素类型&gt;</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组 Tuple"></a>元组 Tuple</h3><p><strong>元组类型允许表示一个已知元素数量和类型的数组</strong>，各元素的类型不必相同。 比如，你可以定义一对值分别为 <code>string</code>和<code>number</code>类型的元组。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare a tuple type</span></span><br><span class="line"><span class="keyword">let</span> x: [<span class="built_in">string</span>, <span class="built_in">number</span>];</span><br><span class="line"><span class="comment">// Initialize it</span></span><br><span class="line">x = [<span class="string">&#x27;hello&#x27;</span>, <span class="number">10</span>]; <span class="comment">// OK</span></span><br><span class="line"><span class="comment">// Initialize it incorrectly</span></span><br><span class="line">x = [<span class="number">10</span>, <span class="string">&#x27;hello&#x27;</span>]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<p>当访问一个已知索引的元素，会得到正确的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(x[<span class="number">0</span>].substr(<span class="number">1</span>)); <span class="comment">// OK</span></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">1</span>].substr(<span class="number">1</span>)); <span class="comment">// Error, &#x27;number&#x27; does not have &#x27;substr&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当访问一个越界的元素，会使用<strong>联合类型</strong>替代：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">x[<span class="number">3</span>] = <span class="string">&#x27;world&#x27;</span>; <span class="comment">// OK, 字符串可以赋值给(string | number)类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x[<span class="number">5</span>].toString()); <span class="comment">// OK, &#x27;string&#x27; 和 &#x27;number&#x27; 都有 toString</span></span><br><span class="line"></span><br><span class="line">x[<span class="number">6</span>] = <span class="literal">true</span>; <span class="comment">// Error, 布尔不是(string | number)类型</span></span><br></pre></td></tr></table></figure>

<h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><code>object</code>表示非原始类型，也就是除<code>number</code>，<code>string</code>，<code>boolean</code>，<code>symbol</code>，<code>null</code>或<code>undefined</code>之外的类型。</p>
<p>使用<code>object</code>类型，就可以更好的表示像<code>Object.create</code>这样的API。例如：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o: <span class="built_in">object</span> | <span class="literal">null</span></span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line">create(&#123; <span class="attr">prop</span>: <span class="number">0</span> &#125;); <span class="comment">// OK</span></span><br><span class="line">create(<span class="literal">null</span>); <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">42</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="string">&quot;string&quot;</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">false</span>); <span class="comment">// Error</span></span><br><span class="line">create(<span class="literal">undefined</span>); <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>

<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>有时候，<strong>我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库</strong>。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 <code>any</code>类型来标记这些变量：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">&quot;maybe a string instead&quot;</span>;</span><br><span class="line">notSure = <span class="literal">false</span>; <span class="comment">// okay, definitely a boolean</span></span><br></pre></td></tr></table></figure>

<p>在对现有代码进行改写的时候，<code>any</code>类型是十分有用的，它允许你在<strong>编译时</strong>可选择地包含或移除类型检查。 </p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> notSure: <span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure.ifItExists(); <span class="comment">// okay, ifItExists might exist at runtime</span></span><br><span class="line">notSure.toFixed(); <span class="comment">// okay, toFixed exists (but the compiler doesn&#x27;t check)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> prettySure: <span class="built_in">Object</span> = <span class="number">4</span>;</span><br><span class="line">prettySure.toFixed(); <span class="comment">// Error: Property &#x27;toFixed&#x27; doesn&#x27;t exist on type &#x27;Object&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>当你只知道一部分数据的类型时，<code>any</code>类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">any</span>[] = [<span class="number">1</span>, <span class="literal">true</span>, <span class="string">&quot;free&quot;</span>];</span><br><span class="line"></span><br><span class="line">list[<span class="number">1</span>] = <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p><strong>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> something;</span><br><span class="line">something = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> something: <span class="built_in">any</span>;</span><br><span class="line">something = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">something = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">something.setName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Void空值"><a href="#Void空值" class="headerlink" title="Void空值"></a>Void空值</h3><p>某种程度上来说，<code>void</code>类型像是与<code>any</code>类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 <code>void</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;This is my warning message&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个<code>void</code>类型的变量没有什么大用，因为你只能为它赋予<code>undefined</code>和<code>null</code>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> unusable: <span class="built_in">void</span> = <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h3 id="Never"><a href="#Never" class="headerlink" title="Never"></a>Never</h3><p>never 是其它类型（包括 null 和 undefined）的子类型，代表那些永不存在的值的类型。这意味着声明为 never 类型的变量只能被 never 类型所赋值。 例如， <code>never</code>类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型；</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行错误，数字类型不能转为 never 类型</span></span><br><span class="line">x = <span class="number">123</span>;</span><br><span class="line">y = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 never类型</span></span><br><span class="line">x = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行正确，never 类型可以赋值给 数字类型</span></span><br><span class="line">y = (<span class="function">()=&gt;</span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;exception&#x27;</span>)&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是抛出异常的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">error</span>(<span class="params">message: <span class="built_in">string</span></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值为 never 的函数可以是无法被执行到的终止点的情况</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言（Type Assertion）可以用来手动指定一个值的类型。</p>
<p>通过<em>类型断言</em>这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 它没有运行时的影响，只是在编译阶段起作用。 <strong>类型断言会假设程序员，已经进行了必须的检查，让TypeScript跳过类型检测。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：&lt;类型&gt;值 或 值 as 类型</span><br><span class="line">在 tsx 语法（React 的 jsx 语法的 ts 版）中必须用后一种</span><br></pre></td></tr></table></figure>

<p>类型断言有两种形式。 其一是“尖括号”语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (&lt;<span class="built_in">string</span>&gt;someValue).length;</span><br></pre></td></tr></table></figure>

<p>另一个为<code>as</code>语法：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someValue: <span class="built_in">any</span> = <span class="string">&quot;this is a string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strLength: <span class="built_in">number</span> = (someValue <span class="keyword">as</span> <span class="built_in">string</span>).length;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>例子一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func(val: string | number): number &#123;</span><br><span class="line">  if (val.length) &#123;</span><br><span class="line">    return val.length</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return val.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的参数 val 是一个联合类型，在这里的意思是说 val 可以是字符串类型也可以是数值类型。代码中要返回参数的长度，但是 length 是字符串的属性，而数值是没有这个属性的，所以当 val 是数值时，就先用 toSting() 来将数字转换为字符串再取长度。这样的逻辑本身没问题，但是在编译阶段一访问 val.length 时就报错了，因为 <strong>访问联合类型值的属性时，这个属性必须是所有可能类型的共有属性，</strong>而length不是共有属性，val 的类型此时也没确定，所以编译不通过。为了通过编译，此时就可以使用类型断言了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func(val: string | number): number &#123;</span><br><span class="line">  if ((&lt;string&gt;val).length) &#123;</span><br><span class="line">    return (&lt;string&gt;val).length</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return val.toString().length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>例子二</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const foo = &#123;&#125;;</span><br><span class="line">foo.bar = 123; // Error: &#x27;bar&#x27; 属性不存在于 ‘&#123;&#125;’</span><br><span class="line">foo.bas = &#x27;hello&#x27;; // Error: &#x27;bas&#x27; 属性不存在于 &#x27;&#123;&#125;&#x27;</span><br><span class="line"></span><br><span class="line">interface Foo &#123;</span><br><span class="line">  bar: number;</span><br><span class="line">  bas: string;</span><br><span class="line">&#125;</span><br><span class="line">const foo = &#123;&#125; as Foo;</span><br><span class="line">foo.bar = 123;</span><br><span class="line">foo.bas = &#x27;hello&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="const-断言"><a href="#const-断言" class="headerlink" title="const 断言"></a>const 断言</h4><p>TypeScript 3.4 引入了一种新的字面量构造方式，也称为 const 断言。当我们使用 const 断言构造新的字面量表达式时，我们可以向编程语言发出以下信号</p>
<ul>
<li>表达式中的任何字面量类型都不应该被扩展；</li>
<li><strong>对象字面量的属性</strong>，将使用 <code>readonly</code> 修饰；</li>
<li><strong>数组字面量</strong>将变成 <code>readonly</code> 元组。</li>
</ul>
<p>下面我们来举一个 const 断言的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="string">&quot;hello&quot;</span> <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> X = <span class="keyword">typeof</span> x; <span class="comment">// type X = &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> y:X=<span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> y = [<span class="number">10</span>, <span class="number">20</span>] <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> Y = <span class="keyword">typeof</span> y; <span class="comment">// type Y = readonly [10, 20]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> z = &#123; <span class="attr">text</span>: <span class="string">&quot;hello&quot;</span> &#125; <span class="keyword">as</span> <span class="keyword">const</span>;</span><br><span class="line"><span class="keyword">type</span> Z = <span class="keyword">typeof</span> z; <span class="comment">// let z: &#123; readonly text: &quot;hello&quot;; &#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="类型断言的用途"><a href="#类型断言的用途" class="headerlink" title="类型断言的用途"></a>类型断言的用途</h4><ul>
<li>将一个联合类型断言为其中一个类型</li>
<li>将一个父类断言为更加具体的子类</li>
<li>将任何一个类型断言为 <code>any</code></li>
<li>将 <code>any</code> 断言为一个具体的类型</li>
</ul>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。</p>
<p>以下代码虽然没有指定类型，但是会在编译的时候报错：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>事实上，它等价于：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。</p>
<p><strong>如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 <code>any</code> 类型而完全不被类型检查</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>枚举是一个被命名的整型常数的集合，用于声明一组命名的常数,当一个变量有几种可能的取值时,可以将它定义为枚举类型。</p>
<p>通俗来说，枚举就是一个对象的所有可能取值的集合。</p>
<p>在日常生活中也很常见，例如表示星期的SUNDAY、MONDAY、TUESDAY、WEDNESDAY、THURSDAY、FRIDAY、SATURDAY就可以看成是一个枚举。</p>
<p>枚举的说明与结构和联合相似，其形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum 枚举名&#123;</span><br><span class="line">    标识符①[=整型常数],</span><br><span class="line">    标识符②[=整型常数],</span><br><span class="line">    ...</span><br><span class="line">    标识符N[=整型常数],</span><br><span class="line">&#125;枚举变量;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>枚举的使用是通过<code>enum</code>关键字进行定义，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum xxx &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>声明关键字为枚举类型的方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 声明d为枚举类型Direction</span><br><span class="line">let d: Direction;</span><br></pre></td></tr></table></figure>

<p>类型可以分成：</p>
<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举</li>
</ul>
<h4 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h4><p>当我们声明一个枚举类型是,虽然没有给它们赋值,但是它们的值其实是默认的数字类型,而且<strong>默认从0开始依次累加:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up,   // 值默认为 0</span><br><span class="line">    Down, // 值默认为 1</span><br><span class="line">    Left, // 值默认为 2</span><br><span class="line">    Right // 值默认为 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Direction.Up === 0); // true</span><br><span class="line">console.log(Direction.Down === 1); // true</span><br><span class="line">console.log(Direction.Left === 2); // true</span><br><span class="line">console.log(Direction.Right === 3); // true</span><br></pre></td></tr></table></figure>

<p><strong>如果我们将第一个值进行赋值后，后面的值也会根据前一个值进行累加1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = 10,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Direction.Up, Direction.Down, Direction.Left, Direction.Right); // 10 11 12 13</span><br></pre></td></tr></table></figure>

<h4 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">枚举类型的值其实也可以是字符串类型：</span><br><span class="line"></span><br><span class="line">enum Direction &#123;</span><br><span class="line">    Up = &#x27;Up&#x27;,</span><br><span class="line">    Down = &#x27;Down&#x27;,</span><br><span class="line">    Left = &#x27;Left&#x27;,</span><br><span class="line">    Right = &#x27;Right&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Direction[&#x27;Right&#x27;], Direction.Up); // Right Up</span><br></pre></td></tr></table></figure>

<p>如果设定了一个变量为字符串之后，后续的字段也需要赋值字符串，否则报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line"> Up = &#x27;UP&#x27;,</span><br><span class="line"> Down, // error TS1061: Enum member must have initializer</span><br><span class="line"> Left, // error TS1061: Enum member must have initializer</span><br><span class="line"> Right // error TS1061: Enum member must have initializer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h4><p>即将数字枚举和字符串枚举结合起来混合起来使用，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = 0,</span><br><span class="line">    Yes = &quot;YES&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常情况下我们很少会使用异构枚举</p>
<h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>现在一个枚举的案例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过编译后，<code>javascript</code>如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Direction;</span><br><span class="line">(function (Direction) &#123;</span><br><span class="line">    Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;;</span><br><span class="line">    Direction[Direction[&quot;Down&quot;] = 1] = &quot;Down&quot;;</span><br><span class="line">    Direction[Direction[&quot;Left&quot;] = 2] = &quot;Left&quot;;</span><br><span class="line">    Direction[Direction[&quot;Right&quot;] = 3] = &quot;Right&quot;;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>上述代码可以看到， <code>Direction[Direction[&quot;Up&quot;] = 0] = &quot;Up&quot;</code>可以分成</p>
<ul>
<li>Direction[“Up”] = 0</li>
<li>Direction[0] = “Up”</li>
</ul>
<p>所以定义枚举类型后，可以通过正反映射拿到对应的值，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(Direction.Up === 0); // true</span><br><span class="line">console.log(Direction[0]); // Up</span><br></pre></td></tr></table></figure>

<p><strong>并且多处定义的枚举是可以进行合并操作</strong>，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Direction &#123;</span><br><span class="line">    Up = &#x27;Up&#x27;,</span><br><span class="line">    Down = &#x27;Down&#x27;,</span><br><span class="line">    Left = &#x27;Left&#x27;,</span><br><span class="line">    Right = &#x27;Right&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enum Direction &#123;</span><br><span class="line">    Center = 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后，<code>js</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var Direction;</span><br><span class="line">(function (Direction) &#123;</span><br><span class="line">    Direction[&quot;Up&quot;] = &quot;Up&quot;;</span><br><span class="line">    Direction[&quot;Down&quot;] = &quot;Down&quot;;</span><br><span class="line">    Direction[&quot;Left&quot;] = &quot;Left&quot;;</span><br><span class="line">    Direction[&quot;Right&quot;] = &quot;Right&quot;;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br><span class="line">(function (Direction) &#123;</span><br><span class="line">    Direction[Direction[&quot;Center&quot;] = 1] = &quot;Center&quot;;</span><br><span class="line">&#125;)(Direction || (Direction = &#123;&#125;));</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>Direction</code>对象属性回叠加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  1: &#x27;Center&#x27;,</span><br><span class="line">  Up: &#x27;Up&#x27;,</span><br><span class="line">  Down: &#x27;Down&#x27;,</span><br><span class="line">  Left: &#x27;Left&#x27;,</span><br><span class="line">  Right: &#x27;Right&#x27;,</span><br><span class="line">  Center: 1 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>就拿回生活的例子，后端返回的字段使用 0 - 6 标记对应的日期，这时候就可以使用枚举可提高代码可读性，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Days &#123;Sun, Mon, Tue, Wed, Thu, Fri, Sat&#125;;</span><br><span class="line"></span><br><span class="line">console.log(Days[&quot;Sun&quot;] === 0); // true</span><br><span class="line">console.log(Days[&quot;Mon&quot;] === 1); // true</span><br><span class="line">console.log(Days[&quot;Tue&quot;] === 2); // true</span><br><span class="line">console.log(Days[&quot;Sat&quot;] === 6); // true</span><br></pre></td></tr></table></figure>

<p>包括后端日常返回0、1 等等状态的时候，我们都可以通过枚举去定义，这样可以提高代码的可读性，便于后续的维护</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 投放方式</span><br><span class="line"> * 0: 无对接投放</span><br><span class="line"> * 1: 直接投放</span><br><span class="line"> * 2: 事件触发投放</span><br><span class="line"> */</span><br><span class="line">export enum PUT_WAY &#123;</span><br><span class="line">  NO_DOCKING = 0,</span><br><span class="line">  DIRECT = 1,</span><br><span class="line">  EVENT = 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export const PUT_WAY_LABEL = &#123;</span><br><span class="line">  [`$&#123;PUT_WAY.NO_DOCKING&#125;`]: &#x27;无对接投放&#x27;,</span><br><span class="line">  [`$&#123;PUT_WAY.DIRECT&#125;`]: &#x27;直接投放&#x27;,</span><br><span class="line">  [`$&#123;PUT_WAY.EVENT&#125;`]: &#x27;事件触发投放&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p><strong>作用：</strong></p>
<ul>
<li>对“对象”进行约束描述</li>
<li>对“类”的一部分行为进行抽象</li>
</ul>
<p><strong>特点：</strong></p>
<ul>
<li><p>接口与值的结构必须相同</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">    size: number;</span><br><span class="line">    label: string;</span><br><span class="line">&#125;</span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">    console.log(labelledObj.label);</span><br><span class="line">&#125;</span><br><span class="line">let myObj1 = &#123; label: &quot;Size 10 Object&quot; &#125;;</span><br><span class="line">let myObj2 = &#123; label: &quot;Size 10 Object&quot;, other:1 &#125;;</span><br><span class="line">//少了</span><br><span class="line">printLabel(myObj1);</span><br><span class="line">//多了</span><br><span class="line">printLabel(myObj2);</span><br></pre></td></tr></table></figure></li>
<li><p>可以捕获引用了不存在的属性时的错误</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface LabelledValue &#123;</span><br><span class="line">    size: number;</span><br><span class="line">    label: string;</span><br><span class="line">&#125;</span><br><span class="line">function printLabel(labelledObj: LabelledValue) &#123;</span><br><span class="line">    console.log(labelledObj.labell);</span><br><span class="line">  &#125;</span><br><span class="line">let myObj = &#123; size:10, label: &quot;Size 10 Object&quot; &#125;;</span><br><span class="line">printLabel(myObj);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。</p>
<p>下面是应用了“option bags”的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">  color?: <span class="built_in">string</span>;</span><br><span class="line">  width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123;color: <span class="built_in">string</span>; area: <span class="built_in">number</span>&#125; &#123;</span><br><span class="line">  <span class="keyword">let</span> newSquare = &#123;<span class="attr">color</span>: <span class="string">&quot;white&quot;</span>, <span class="attr">area</span>: <span class="number">100</span>&#125;;</span><br><span class="line">  <span class="keyword">if</span> (config.color) &#123;</span><br><span class="line">    newSquare.color = config.color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (config.width) &#123;</span><br><span class="line">    newSquare.area = config.width * config.width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newSquare;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123;<span class="attr">color</span>: <span class="string">&quot;black&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个<code>?</code>符号。</p>
<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 <code>readonly</code>来指定只读属性:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Point &#123;</span><br><span class="line">    <span class="keyword">readonly</span> x: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">readonly</span> y: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以通过赋值一个对象字面量来构造一个<code>Point</code>。 赋值后， <code>x</code>和<code>y</code>再也不能被改变了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> p1: Point = &#123; <span class="attr">x</span>: <span class="number">10</span>, <span class="attr">y</span>: <span class="number">20</span> &#125;;</span><br><span class="line">p1.x = <span class="number">5</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>TypeScript具有<code>ReadonlyArray&lt;T&gt;</code>类型，它与<code>Array&lt;T&gt;</code>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> ro: ReadonlyArray&lt;<span class="built_in">number</span>&gt; = a;</span><br><span class="line">ro[<span class="number">0</span>] = <span class="number">12</span>; <span class="comment">// 类型“readonly number[]”中的索引签名仅允许读取</span></span><br><span class="line">ro.push(<span class="number">5</span>); <span class="comment">// 类型“readonly number[]”上不存在属性“push”</span></span><br><span class="line">ro.length = <span class="number">100</span>; <span class="comment">// 无法分配到 &quot;length&quot; ，因为它是只读属性</span></span><br><span class="line">a = ro; <span class="comment">// 类型 &quot;readonly number[]&quot; 为 &quot;readonly&quot;，不能分配给可变类型 &quot;number[]&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面代码的最后一行，可以看到就算把整个<code>ReadonlyArray</code>赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">a = ro <span class="keyword">as</span> <span class="built_in">number</span>[];</span><br></pre></td></tr></table></figure>

<p><strong><code>readonly</code> vs <code>const</code></strong></p>
<p>最简单判断该用<code>readonly</code>还是<code>const</code>的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 <code>const</code>，若做为属性则使用<code>readonly</code>。</p>
<h3 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createSquare</span>(<span class="params">config: SquareConfig</span>): </span>&#123; color: <span class="built_in">string</span>; width: <span class="built_in">number</span> &#125; &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">color</span>: <span class="string">&#x27;1&#x27;</span>, <span class="attr">width</span>: <span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>

<p>注意传入<code>createSquare</code>的参数拼写为*<code>colour</code>*而不是<code>color</code>。 在JavaScript里，这会默默地失败。 <strong>编译器能够捕获引用了未声明属性的错误</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error: &#x27;colour&#x27; not expected in type &#x27;SquareConfig&#x27;</span></span><br><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">colour</span>: <span class="string">&quot;red&quot;</span>, <span class="attr">width</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>解决</strong></p>
<ul>
<li>最简便的方法是使用<strong>类型断言</strong>：</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> mySquare = createSquare(&#123; <span class="attr">width</span>: <span class="number">100</span>, <span class="attr">opacity</span>: <span class="number">0.5</span> &#125; <span class="keyword">as</span> SquareConfig);</span><br></pre></td></tr></table></figure>

<ul>
<li>加上额外属性声明，允许对象引用除可选属性以外的其他属性</li>
</ul>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> SquareConfig &#123;</span><br><span class="line">    color?: <span class="built_in">string</span>;</span><br><span class="line">    width?: <span class="built_in">number</span>;</span><br><span class="line">    [propName: <span class="built_in">string</span>]: <span class="built_in">any</span>;<span class="comment">//加上额外属性声明，允许对象引用除可选属性以外的其他属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 具体的格式是一个只有<strong>参数列表</strong>和<strong>返回值类型</strong>的函数定义。<strong>参数列表</strong>里的每个参数都需要名字和类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">  (param1: <span class="built_in">string</span>, <span class="attr">param2</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何<strong>创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> myFunc: Func = <span class="function"><span class="keyword">function</span>(<span class="params">param1, param2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> param1 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> param2 === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。</strong> 比如，我们使用下面的代码重写上面的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Func &#123;</span><br><span class="line">  (param1: <span class="built_in">string</span>, <span class="attr">param2</span>: <span class="built_in">number</span>): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myFunc: Func = <span class="function"><span class="keyword">function</span>(<span class="params">param2, param3</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(param2, param3);<span class="comment">// 1，2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> param2 === <span class="string">&quot;string&quot;</span> &amp;&amp; <span class="keyword">typeof</span> param3 === <span class="string">&quot;number&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myFunc(<span class="string">&#x27;1&#x27;</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h3><p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如<code>a[10]</code>或<code>ageMap[&quot;daniel&quot;]</code>。 可索引类型具有一个 <em>索引签名</em>，它描述了对象索引的类型，还有相应的索引返回值类型。 </p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数字索引——约束数组</span></span><br><span class="line"><span class="comment">// index 是随便取的名字，可以任意取名</span></span><br><span class="line"><span class="comment">// 只要 index 的类型是 number，那么值的类型必须是 string</span></span><br><span class="line"><span class="keyword">interface</span> StringArray &#123;</span><br><span class="line">  <span class="comment">// key 的类型为 number ，一般都代表是数组</span></span><br><span class="line">  <span class="comment">// 限制 value 的类型为 string</span></span><br><span class="line">  [index:<span class="built_in">number</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr:StringArray = [<span class="string">&#x27;aaa&#x27;</span>,<span class="string">&#x27;bbb&#x27;</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串索引——约束对象</span></span><br><span class="line"><span class="comment">// 只要 index 的类型是 string，那么值的类型必须是 string</span></span><br><span class="line"><span class="keyword">interface</span> StringObject &#123;</span><br><span class="line">  <span class="comment">// key 的类型为 string ，一般都代表是对象</span></span><br><span class="line">  <span class="comment">// 限制 value 的类型为 string</span></span><br><span class="line">  [index:<span class="built_in">string</span>]:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj:StringObject = &#123;<span class="attr">name</span>:<span class="string">&#x27;ccc&#x27;</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符串索引签名能够很好的描述<code>dictionary</code>模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 <code>obj.property</code>和<code>obj[&quot;property&quot;]</code>两种形式都可以。 下面的例子里， <code>name</code>的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> NumberDictionary &#123;</span><br><span class="line">  [index: <span class="built_in">string</span>]: <span class="built_in">number</span>;</span><br><span class="line">  length: <span class="built_in">number</span>;    <span class="comment">// 可以，length是number类型</span></span><br><span class="line">  name: <span class="built_in">string</span>       <span class="comment">// 错误，`name`的类型与索引类型返回值的类型不匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> ReadonlyStringArray &#123;</span><br><span class="line">    <span class="keyword">readonly</span> [index: <span class="built_in">number</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myArray: ReadonlyStringArray = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>];</span><br><span class="line">myArray[<span class="number">2</span>] = <span class="string">&quot;Mallory&quot;</span>; <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>你不能设置<code>myArray[2]</code>，因为索引签名是只读的。</p>
<p><strong>Element implicitly has an ‘any‘ type because expression of type ‘string‘ can‘t be used to index type</strong><br>英文报错：Element implicitly has an ‘any’ type because expression of type ‘string’ can’t be used to index type</p>
<p>中文报错：元素隐式具有 “any” 类型，因为类型为 “string” 的表达式不能用于索引类型 “UserInfo”。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface UserInfo &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  address: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let userInfo: UserInfo = &#123;</span><br><span class="line">  name: &quot;刘德华&quot;,</span><br><span class="line">  age: 18,</span><br><span class="line">  address: &quot;吉林市长春市九台区其塔木镇&quot;,</span><br><span class="line">&#125;;</span><br><span class="line">let coontent = userInfo[v.value]</span><br><span class="line">解决方法：</span><br><span class="line">let content = userInfo[v.value as keyof typeof userInfo]</span><br><span class="line">原因分析：</span><br><span class="line"></span><br><span class="line">根据英文分析，是断言 v.value 的值是对象 userInfo 的 key</span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。</p>
<h4 id="类实现接口"><a href="#类实现接口" class="headerlink" title="类实现接口"></a>类实现接口</h4><p>实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候<strong>不同类之间可以有一些共有的特性</strong>，这时候就可以把特性提取成接口（interfaces），用 <code>implements</code> 关键字来实现。这个特性大大提高了面向对象的灵活性。</p>
<p>举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecurityDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;SecurityDoor alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> SecurityDoor()</span><br><span class="line">a.alert()</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> Car()</span><br><span class="line">b.alert()</span><br></pre></td></tr></table></figure>

<p>一个类可以实现多个接口，下例中，<code>Car</code> 实现了 <code>Alarm</code> 和 <code>Light</code> 接口，既能报警，也能开关车灯：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Light &#123;</span><br><span class="line">    lightOn();</span><br><span class="line">    lightOff();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">implements</span> <span class="title">Alarm</span>, <span class="title">Light</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car alert&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">lightOn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car light on&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">lightOff</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Car light off&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h4><p>接口可以继承接口，下例中，我们使用 <code>extends</code> 使 <code>LightableAlarm</code> 继承 <code>Alarm：</code></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Alarm &#123;</span><br><span class="line">  alert();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> LightableAlarm <span class="keyword">extends</span> Alarm &#123;</span><br><span class="line">  lightOn()</span><br><span class="line">  lightOff()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">LightableAlarm</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">alert</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lightOn</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">lightOff</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> A();</span><br></pre></td></tr></table></figure>

<h4 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h4><p>接口也可以继承类：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="attr">x</span>: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">point</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Point3d <span class="keyword">extends</span> Point &#123;</span><br><span class="line">    <span class="attr">z</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> point3d: Point3d = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">z</span>: <span class="number">3</span>, <span class="attr">point</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.x)</span><br><span class="line">&#125;&#125;;</span><br><span class="line">point3d.point()</span><br></pre></td></tr></table></figure>

<p>为什么 TypeScript 会支持接口继承类呢？</p>
<p>实际上，当我们在声明 <code>class Point</code> 时，除了会创建一个名为 <code>Point</code> 的类之外，同时也创建了一个名为 <code>Point</code> 的类型（实例的类型）。</p>
<p>所以我们既可以将 <code>Point</code> 当做一个类来用（使用 <code>new Point</code> 创建它的实例）,也可以将 <code>Point</code> 当做一个类型来用（使用 <code>: Point</code> 表示参数的类型）</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> SquareSquare <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square =&#123;&#125; <span class="keyword">as</span> SquareSquare;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Shape &#123;</span><br><span class="line">    <span class="attr">color</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PenStroke &#123;</span><br><span class="line">    <span class="attr">penWidth</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square <span class="keyword">extends</span> Shape, PenStroke &#123;</span><br><span class="line">    <span class="attr">sideLength</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> square = &lt;Square&gt;&#123;&#125;;</span><br><span class="line">square.color = <span class="string">&quot;blue&quot;</span>;</span><br><span class="line">square.sideLength = <span class="number">10</span>;</span><br><span class="line">square.penWidth = <span class="number">5.0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承。而在 ES6 中，我们终于迎来了 <code>class</code>。</p>
<p>TypeScript 除了实现了所有 ES6 中的类的功能以外，还添加了一些新的用法。</p>
<p>这一节主要介绍类的用法，下一节再介绍如何定义类的类型。</p>
<h3 id="类的概念"><a href="#类的概念" class="headerlink" title="类的概念"></a>类的概念</h3><p>虽然 JavaScript 中有类的概念，但是可能大多数 JavaScript 程序员并不是非常熟悉类，这里对类相关的概念做一个简单的介绍。</p>
<ul>
<li>类（Class）：定义了一件事物的抽象特点，包含它的属性和方法</li>
<li>对象（Object）：类的实例，通过 <code>new</code> 生成</li>
<li>面向对象（OOP）的三大特性：封装、继承、多态</li>
<li>封装（Encapsulation）：将对数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据</li>
<li>继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性</li>
<li>多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如 <code>Cat</code> 和 <code>Dog</code> 都继承自 <code>Animal</code>，但是分别实现了自己的 <code>eat</code> 方法。此时针对某一个实例，我们无需了解它是 <code>Cat</code> 还是 <code>Dog</code>，就可以直接调用 <code>eat</code> 方法，程序会自动判断出来应该如何执行 <code>eat</code></li>
<li>存取器（getter &amp; setter）：用以改变属性的读取和赋值行为</li>
<li>修饰符（Modifiers）：修饰符是一些关键字，用于限定成员或类型的性质。比如 <code>public</code> 表示公有属性或方法</li>
<li>抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现</li>
<li>接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口</li>
</ul>
<h3 id="ES6-中类的用法"><a href="#ES6-中类的用法" class="headerlink" title="ES6 中类的用法"></a>ES6 中类的用法</h3><p>下面我们先回顾一下 ES6 中类的用法，更详细的介绍可以参考 <a href="http://es6.ruanyifeng.com/#docs/class">ECMAScript 6 入门 - Class</a>。</p>
<h4 id="属性和方法-1"><a href="#属性和方法-1" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>使用 <code>class</code> 定义类，使用 <code>constructor</code> 定义构造函数。</p>
<p>通过 <code>new</code> 生成新实例的时候，会自动调用构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    public name;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure>

<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><p>使用 <code>extends</code> 关键字实现继承，子类中使用 <code>super</code> 关键字来调用父类的构造函数和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// 调用父类的 constructor(name)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Meow, &#x27;</span> + <span class="built_in">super</span>.sayHi(); <span class="comment">// 调用父类的 sayHi()</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>); <span class="comment">// Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(c.sayHi()); <span class="comment">// Meow, My name is Tom</span></span><br></pre></td></tr></table></figure>

<h4 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h4><p>使用 getter 和 setter 可以改变属性的赋值和读取行为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">name</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> <span class="title">name</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;setter: &#x27;</span> + value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Kitty&#x27;</span>); <span class="comment">// setter: Kitty</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>; <span class="comment">// setter: Tom</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>使用 <code>static</code> 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">isAnimal</span>(<span class="params">a</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">instanceof</span> Animal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line">Animal.isAnimal(a); <span class="comment">// true</span></span><br><span class="line">a.isAnimal(a); <span class="comment">// TypeError: a.isAnimal is not a function</span></span><br></pre></td></tr></table></figure>

<h3 id="ES7-中类的用法"><a href="#ES7-中类的用法" class="headerlink" title="ES7 中类的用法"></a>ES7 中类的用法</h3><p>ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。</p>
<h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>ES6 中实例的属性只能通过构造函数中的 <code>this.xxx</code> 来定义，ES7 提案中可以直接在类里面定义：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  name = <span class="string">&#x27;Jack&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br></pre></td></tr></table></figure>

<h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>ES7 提案中，可以使用 <code>static</code> 定义一个静态属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> num = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Animal.num); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>

<h3 id="TypeScript-中类的用法"><a href="#TypeScript-中类的用法" class="headerlink" title="TypeScript 中类的用法"></a>TypeScript 中类的用法</h3><h4 id="public-private-和-protected"><a href="#public-private-和-protected" class="headerlink" title="public private 和 protected"></a>public private 和 protected</h4><p>TypeScript 可以使用三种访问修饰符（Access Modifiers），分别是 <code>public</code>、<code>private</code> 和 <code>protected</code>。</p>
<ul>
<li><code>public</code> 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 <code>public</code> 的</li>
<li><code>private</code> 修饰的属性或方法是私有的，不能在声明它的类的外部访问</li>
<li><code>protected</code> 修饰的属性或方法是受保护的，它和 <code>private</code> 类似，区别是它在子类中也是允许被访问的</li>
</ul>
<p>下面举一些例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Tom</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>name</code> 被设置为了 <code>public</code>，所以直接访问实例的 <code>name</code> 属性是允许的。</p>
<p>很多时候，我们希望有的属性是无法直接存取的，这时候就可以用 <code>private</code> 了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,13): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br><span class="line"><span class="comment">// index.ts(10,1): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，TypeScript 编译之后的代码中，并没有限制 <code>private</code> 属性在外部的可访问性。</p>
<p>上面的例子编译后的代码是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name);</span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>private</code> 修饰的属性或方法，在子类中也是不允许访问的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(11,17): error TS2341: Property &#x27;name&#x27; is private and only accessible within class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>而如果是用 <code>protected</code> 修饰，则允许在子类中访问：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当构造函数修饰为 <code>private</code> 时，该类不允许被继承或者实例化：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(7,19): TS2675: Cannot extend a class &#x27;Animal&#x27;. Class constructor is marked as private.</span></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2673: Constructor of class &#x27;Animal&#x27; is private and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure>

<p>当构造函数修饰为 <code>protected</code> 时，该类只允许被继承：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(13,9): TS2674: Constructor of class &#x27;Animal&#x27; is protected and only accessible within the class declaration.</span></span><br></pre></td></tr></table></figure>

<h4 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h4><p>修饰符和<code>readonly</code>还可以使用在构造函数参数中，等同于类中定义该属性同时给该属性赋值，使代码更简洁。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// public name: string;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.name = name;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>只读属性关键字，只允许出现在属性声明或索引签名或构造函数中。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">readonly</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// Jack</span></span><br><span class="line">a.name = <span class="string">&#x27;Tom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(10,3): TS2540: Cannot assign to &#x27;name&#x27; because it is a read-only property.</span></span><br></pre></td></tr></table></figure>

<p>注意如果 <code>readonly</code> 和其他访问修饰符同时存在的话，需要写在其后面。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// public readonly name;</span></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">public</span> <span class="keyword">readonly</span> name</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.name = name;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p><code>abstract</code> 用于定义抽象类和其中的抽象方法。</p>
<p>什么是抽象类？</p>
<p>首先，抽象类是不允许被实例化的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,11): error TS2511: Cannot create an instance of the abstract class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们定义了一个抽象类 <code>Animal</code>，并且定义了一个抽象方法 <code>sayHi</code>。在实例化抽象类的时候报错了。</p>
<p>其次，抽象类中的抽象方法必须被子类实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> is eating.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(9,7): error TS2515: Non-abstract class &#x27;Cat&#x27; does not implement inherited abstract member &#x27;sayHi&#x27; from class &#x27;Animal&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们定义了一个类 <code>Cat</code> 继承了抽象类 <code>Animal</code>，但是没有实现抽象方法 <code>sayHi</code>，所以编译报错了。</p>
<p>下面是一个正确使用抽象类的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> name;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> sayHi();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Meow, My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们实现了抽象方法 <code>sayHi</code>，编译通过了。</p>
<p>需要注意的是，即使是抽象方法，TypeScript 的编译结果中，仍然会存在这个类，上面的代码的编译结果是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> __extends =</span><br><span class="line">  (<span class="built_in">this</span> &amp;&amp; <span class="built_in">this</span>.__extends) ||</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">d, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> p <span class="keyword">in</span> b) <span class="keyword">if</span> (b.hasOwnProperty(p)) d[p] = b[p];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.constructor = d;</span><br><span class="line">    &#125;</span><br><span class="line">    d.prototype = b === <span class="literal">null</span> ? <span class="built_in">Object</span>.create(b) : ((__.prototype = b.prototype), <span class="keyword">new</span> __());</span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">var</span> Cat = (<span class="function"><span class="keyword">function</span> (<span class="params">_super</span>) </span>&#123;</span><br><span class="line">  __extends(Cat, _super);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _super.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Cat.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;Meow, My name is &#x27;</span> + <span class="built_in">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> Cat;</span><br><span class="line">&#125;)(Animal);</span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="类的类型"><a href="#类的类型" class="headerlink" title="类的类型"></a>类的类型</h4><p>给类加上 TypeScript 的类型很简单，与接口类似：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal = <span class="keyword">new</span> Animal(<span class="string">&#x27;Jack&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.sayHi()); <span class="comment">// My name is Jack</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>书写完整函数类型</strong></p>
<p>现在我们已经为函数指定了类型，下面让我们写出函数的完整类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure>

<p>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number = </span><br><span class="line">	function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>

<p>只要参数类型是匹配的，那么就认为它是有效的函数类型，<strong>而不在乎参数名是否正确。</strong></p>
<p><strong>推断类型</strong></p>
<p>如果你在赋值语句的一边指定了类型但是另一边没有类型的话，TypeScript编译器会自动识别出类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// myAdd has the full function type</span><br><span class="line">let myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;</span><br><span class="line"></span><br><span class="line">// The parameters `x` and `y` have the type number</span><br><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number =</span><br><span class="line">    function(x, y) &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>

<p>这叫做“按上下文归类”，是类型推论的一种。</p>
<h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>前面提到，输入多余的（或者少于要求的）参数，是不允许的。那么如何定义可选的参数呢？</p>
<p>与接口中的可选属性类似，我们用 <code>?</code> 表示可选的参数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，可选参数必须接在必需参数后面。换句话说，<strong>可选参数后面不允许再出现必需参数了</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName?: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (firstName) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="literal">undefined</span>, <span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(1,40): error TS1016: A required parameter cannot follow an optional parameter.</span></span><br></pre></td></tr></table></figure>

<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a><strong>默认参数</strong></h4><p>在 ES6 中，我们允许给函数的参数添加默认值，<strong>TypeScript 会将添加了默认值的参数识别为可选参数</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span> = <span class="string">&#x27;Cat&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> tom = buildName(<span class="string">&#x27;Tom&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>此时就不受「可选参数必须接在必需参数后面」的限制了：</strong></p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span> = <span class="string">&#x27;Tom&#x27;</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&#x27; &#x27;</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tomcat = buildName(<span class="string">&#x27;Tom&#x27;</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> cat = buildName(<span class="literal">undefined</span>, <span class="string">&#x27;Cat&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>ES6 中，可以使用 <code>...rest</code> 的方式获取函数中的剩余参数（rest 参数）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array, ...items</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: any[] = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>事实上，<code>items</code> 是一个数组。所以我们可以用数组的类型来定义它：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span>(<span class="params">array: <span class="built_in">any</span>[], ...items: <span class="built_in">any</span>[]</span>) </span>&#123;</span><br><span class="line">    items.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">        array.push(item);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>注意，rest 参数只能是最后一个参数，关于 rest 参数，可以参考 <a href="http://es6.ruanyifeng.com/#docs/function#rest%E5%8F%82%E6%95%B0">ES6 中的 rest 参数</a>。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h3><p>学习如何在JavaScript里正确使用<code>this</code>就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 <code>this</code>工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 <code>this</code>的地方。 如果你想了解JavaScript里的 <code>this</code>是如何工作的，那么首先阅读Yehuda Katz写的<a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/">Understanding JavaScript Function Invocation and “this”</a>。 Yehuda的文章详细的阐述了 <code>this</code>的内部工作原理，因此我们这里只做简单介绍。</p>
<h4 id="this和箭头函数"><a href="#this和箭头函数" class="headerlink" title="this和箭头函数"></a><code>this</code>和箭头函数</h4><p>JavaScript里，<code>this</code>的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</p>
<p>下面看一个例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="built_in">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard.card + <span class="string">&quot; of &quot;</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>

<p>可以看到<code>createCardPicker</code>是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有弹出对话框而是报错了。 因为 <code>createCardPicker</code>返回的函数里的<code>this</code>被设置成了<code>window</code>而不是<code>deck</code>对象。 因为我们只是独立的调用了 <code>cardPicker()</code>。 顶级的非方法式调用会将 <code>this</code>视为<code>window</code>。 （注意：在严格模式下， <code>this</code>为<code>undefined</code>而不是<code>window</code>）。</p>
<p>为了解决这个问题，我们可以在函数被返回时就绑好正确的<code>this</code>。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 <strong>箭头函数能保存函数创建时的 <code>this</code>值，而不是调用时的值</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture &#x27;this&#x27; right here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="built_in">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard.card + <span class="string">&quot; of &quot;</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>

<p>更好事情是，TypeScript会警告你犯了一个错误，如果你给编译器设置了<code>--noImplicitThis</code>标记。 它会指出 <code>this.suits[pickedSuit]</code>里的<code>this</code>的类型为<code>any</code>。</p>
<h4 id="this参数"><a href="#this参数" class="headerlink" title="this参数"></a><code>this</code>参数</h4><p>不幸的是，<code>this.suits[pickedSuit]</code>的类型依旧为<code>any</code>。 这是因为 <code>this</code>来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 <code>this</code>参数。 <code>this</code>参数是个假的参数，它出现在参数列表的最前面：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们往例子里添加一些接口，<code>Card</code> 和 <code>Deck</code>，让类型重用能够变得清晰简单些：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">    <span class="attr">suit</span>: <span class="built_in">string</span>;</span><br><span class="line">    card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">    <span class="attr">suits</span>: <span class="built_in">string</span>[];</span><br><span class="line">    cards: <span class="built_in">number</span>[];</span><br><span class="line">    createCardPicker(<span class="built_in">this</span>: Deck): <span class="function">() =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    <span class="attr">suits</span>: [<span class="string">&quot;hearts&quot;</span>, <span class="string">&quot;spades&quot;</span>, <span class="string">&quot;clubs&quot;</span>, <span class="string">&quot;diamonds&quot;</span>],</span><br><span class="line">    <span class="attr">cards</span>: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">    <span class="attr">createCardPicker</span>: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">suit</span>: <span class="built_in">this</span>.suits[pickedSuit], <span class="attr">card</span>: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&quot;card: &quot;</span> + pickedCard.card + <span class="string">&quot; of &quot;</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure>

<p>现在TypeScript知道<code>createCardPicker</code>期望在某个<code>Deck</code>对象上调用。 也就是说 <code>this</code>是<code>Deck</code>类型的，而非<code>any</code>，因此<code>--noImplicitThis</code>不会报错了。</p>
<h4 id="this参数在回调函数里"><a href="#this参数在回调函数里" class="headerlink" title="this参数在回调函数里"></a><code>this</code>参数在回调函数里</h4><p>你可以也看到过在回调函数里的<code>this</code>报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， <code>this</code>将为<code>undefined</code>。 稍做改动，你就可以通过 <code>this</code>参数来避免错误。 首先，库函数的作者要指定 <code>this</code>的类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>this: void</code> means that <code>addClickListener</code> expects <code>onclick</code> to be a function that does not require a <code>this</code> type. Second, annotate your calling code with <code>this</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">onClickBad</span>(<span class="params"><span class="built_in">this</span>: Handler, e: Event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// oops, used this here. using this callback would crash at runtime</span></span><br><span class="line">        <span class="built_in">this</span>.info = e.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickBad); <span class="comment">// error!</span></span><br></pre></td></tr></table></figure>

<p>指定了<code>this</code>类型后，你显式声明<code>onClickBad</code>必须在<code>Handler</code>的实例上调用。 然后TypeScript会检测到 <code>addClickListener</code>要求函数带有<code>this: void</code>。 改变 <code>this</code>类型来修复这个错误：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="function"><span class="title">onClickGood</span>(<span class="params"><span class="built_in">this</span>: <span class="built_in">void</span>, e: Event</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t use this here because it&#x27;s of type void!</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;clicked!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure>

<p>因为<code>onClickGood</code>指定了<code>this</code>类型为<code>void</code>，因此传递<code>addClickListener</code>是合法的。 当然了，这也意味着不能使用 <code>this.info</code>. 如果你两者都想要，你不得不使用箭头函数了：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="attr">info</span>: <span class="built_in">string</span>;</span><br><span class="line">    onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123; <span class="built_in">this</span>.info = e.message &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是可行的因为箭头函数不会捕获<code>this</code>，所以你总是可以把它们传给期望<code>this: void</code>的函数。 缺点是每个 <code>Handler</code>对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 <code>Handler</code>的原型链上。 它们在不同 <code>Handler</code>对象间是共享的。</p>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>重载允许一个函数接受不同数量或类型的参数时，作出不同的处理。</p>
<p>比如，我们需要实现一个函数 <code>reverse</code>，输入数字 <code>123</code> 的时候，输出反转的数字 <code>321</code>，输入字符串 <code>&#39;hello&#39;</code> 的时候，输出反转的字符串 <code>&#39;olleh&#39;</code>。</p>
<p>利用联合类型，我们可以这么实现：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>然而这样有一个缺点，就是不能够精确的表达，输入为数字的时候，输出也应该为数字，输入为字符串的时候，输出也应该为字符串。</strong></p>
<p>这时，我们可以使用重载定义多个 <code>reverse</code> 的函数类型：为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">string</span></span>): <span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">number</span> | <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Number</span>(x.toString().split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p>考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型</p>
</blockquote>
<p>泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<p>当我们需要写一个传入什么类型就得到什么类型的函数</p>
<ul>
<li><p>```ts<br>function one(a: any) : any{<br>  return a;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```ts</span><br><span class="line">  function one(a: any) : any&#123;</span><br><span class="line">      if(typeof a === &#x27;number&#x27;) &#123;</span><br><span class="line">          let ret = (a as number)</span><br><span class="line">          return ret ;</span><br><span class="line">      &#125;</span><br><span class="line">      return a;</span><br><span class="line">  &#125;</span><br><span class="line">  //每一种类型都写一个方法</span><br></pre></td></tr></table></figure></li>
<li><p>```ts<br>function one<T>(a: T) : T{</p>
<pre><code>return a;
</code></pre>
<p>}<br>let a1 = one<number>(1)<br>let a2 = one(520)<br>//描述T是什么类型的时候，可以在<number>描述它是一个number类型，<br>//也可以类型推论</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 使用泛型变量</span><br><span class="line"></span><br><span class="line">如果我们想同时打印出`arg`的长度。 我们很可能会这样做：</span><br><span class="line"></span><br><span class="line">```ts</span><br><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Error: T doesn&#x27;t have .length</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果这么做，编译器会报错说我们使用了<code>arg</code>的<code>.length</code>属性，但是没有地方指明<code>arg</code>具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 <code>.length</code>属性的。</p>
<p>现在假设我们想操作是<code>T</code>类型的数组而不直接是<code>T</code>。由于我们操作的是数组，所以<code>.length</code>属性是应该存在的。 我们可以像创建其它数组一样创建这个数组：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><p>泛型函数的类型与非泛型函数的类型没什么不同，只是有一个类型参数在最前面，像函数声明一样：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T = identity;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure>

<p>我们还可以使用带有调用签名的对象字面量来定义泛型函数：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</span><br></pre></td></tr></table></figure>

<p>这引导我们去写第一个泛型接口了。 我们把上面例子里的对象字面量拿出来做为一个接口：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity;</span><br></pre></td></tr></table></figure>

<p>一个相似的例子，我们可以把<strong>泛型参数当作整个接口的一个参数</strong>。 这样我们就能清楚的知道使用的具体是哪个泛型类型（比如： <code>Dictionary&lt;string&gt;而不只是Dictionary</code>）。 这样接口里的其它成员也能知道这个参数的类型了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity;</span><br></pre></td></tr></table></figure>

<h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><p>泛型类看上去与泛型接口差不多。 泛型类使用（ <code>&lt;&gt;</code>）括起泛型类型，跟在类名后面。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="attr">zeroValue</span>: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myGenericNumber.add(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。</p>
<h3 id="泛型约束extends"><a href="#泛型约束extends" class="headerlink" title="泛型约束extends"></a>泛型约束extends</h3><p>你应该会记得之前的一个例子，我们有时候想操作某类型的一组值，并且我们知道这组值具有什么样的属性。 在 <code>loggingIdentity</code>例子中，我们想访问<code>arg</code>的<code>length</code>属性，但是编译器并不能证明每种类型都有<code>length</code>属性，所以就报错了。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn&#x27;t have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于操作any所有类型，我们想要限制函数去处理任意带有<code>.length</code>属性的所有类型。 只要传入的类型有这个属性，我们就允许，就是说至少包含这一属性。 为此，我们需要列出对于T的约束要求。</p>
<p>为此，我们定义一个接口来描述约束条件。 创建一个包含 <code>.length</code>属性的接口，使用这个接口和<code>extends</code>关键字来实现约束：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    <span class="attr">length</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error, 类型“number”的参数不能赋给类型“Lengthwise”的参数。</span></span><br></pre></td></tr></table></figure>

<p>我们需要传入符合约束类型的值，必须包含必须的属性：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">loggingIdentity(&#123;<span class="attr">length</span>: <span class="number">10</span>, <span class="attr">value</span>: <span class="number">3</span>&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul>
<li><p>Promise的泛型T(Promise<T>)的含义</p>
<p>interface AxiosInstance {  &lt;T = any&gt;(value: T): Promise<T> }</p>
<p><a href="https://so.csdn.net/so/search?q=Promise&spm=1001.2101.3001.7020">Promise</a>的泛型T代表promise变成成功态之后resolve的值，resolve(value)</p>
</li>
</ul>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如，type是type1和type2接口的交集。 就是说这个类型的对象同时拥有了这二种类型的成员。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> type1&#123;</span><br><span class="line">    <span class="attr">a1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">a2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type2&#123;</span><br><span class="line">    <span class="attr">b1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">b2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type&lt;t,k&gt;&#123;</span><br><span class="line">   <span class="attr">a</span>:t,</span><br><span class="line">   <span class="attr">b</span>:k</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c:<span class="keyword">type</span>&lt;type1,type2&gt; = &#123;</span><br><span class="line">   <span class="attr">a</span>:&#123;</span><br><span class="line">       <span class="attr">a1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">a2</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">b</span>:&#123;</span><br><span class="line">       <span class="attr">b1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">b2</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c)<span class="comment">//&#123; a: &#123; a1: 1, a2: &#x27;1&#x27; &#125;, b: &#123; b1: 1, b2: &#x27;1&#x27; &#125; &#125; </span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> type1&#123;</span><br><span class="line">    <span class="attr">a1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">a2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type2&#123;</span><br><span class="line">    <span class="attr">b1</span>:<span class="built_in">number</span>,</span><br><span class="line">    <span class="attr">b2</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> type&lt;t,k&gt;&#123;</span><br><span class="line">   a1,</span><br><span class="line">   a2,</span><br><span class="line">   b1,</span><br><span class="line">   b2</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c:<span class="keyword">type</span>&lt;type1,type2&gt; = &#123;</span><br><span class="line">       <span class="attr">a1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">a2</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">       <span class="attr">b1</span>:<span class="number">1</span>,</span><br><span class="line">       <span class="attr">b2</span>:<span class="string">&#x27;1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(c)<span class="comment">//&#123; a1: 1, a2: &#x27;1&#x27;, b1: 1, b2: &#x27;1&#x27; &#125; </span></span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>联合类型（Union Types）表示取值可以为多种类型中的一种。</p>
<h4 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h4><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,1): error TS2322: Type &#x27;boolean&#x27; is not assignable to type &#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Type &#x27;boolean&#x27; is not assignable to type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>联合类型使用 <code>|</code> 分隔每个类型。</p>
<p>这里的 <code>let myFavoriteNumber: string | number</code> 的含义是，允许 <code>myFavoriteNumber</code> 的类型是 <code>string</code> 或者 <code>number</code>，但是不能是其他类型。</p>
<h4 id="访问联合类型的属性或方法"><a href="#访问联合类型的属性或方法" class="headerlink" title="访问联合类型的属性或方法"></a>访问联合类型的属性或方法</h4><p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们<strong>只能访问此联合类型的所有类型里共有的属性或方法</strong>：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(2,22): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;string | number&#x27;.</span></span><br><span class="line"><span class="comment">//   Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>上例中，<code>length</code> 不是 <code>string</code> 和 <code>number</code> 的共有属性，所以会报错。</p>
<p>访问 <code>string</code> 和 <code>number</code> 的共有属性是没问题的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> something.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>联合类型的变量在被赋值的时候，会根据<strong>类型推论</strong>的规则推断出一个类型：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFavoriteNumber: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">myFavoriteNumber = <span class="string">&#x27;seven&#x27;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 5</span></span><br><span class="line">myFavoriteNumber = <span class="number">7</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myFavoriteNumber.length); <span class="comment">// 编译时报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// index.ts(5,30): error TS2339: Property &#x27;length&#x27; does not exist on type &#x27;number&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>上例中，第二行的 <code>myFavoriteNumber</code> 被推断成了 <code>string</code>，访问它的 <code>length</code> 属性不会报错。</p>
<p>而第四行的 <code>myFavoriteNumber</code> 被推断成了 <code>number</code>，访问它的 <code>length</code> 属性时就报错了。</p>
<h3 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a><code>typeof</code>类型保护</h3><h3 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a><code>instanceof</code>类型保护</h3><p><em><code>instanceof</code>类型保护</em>是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpaceRepeatingPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="built_in">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringPadder</span> <span class="title">implements</span> <span class="title">Padder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>)</span> &#123; &#125;</span><br><span class="line">    <span class="function"><span class="title">getPaddingString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">        <span class="keyword">new</span> StringPadder(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为&#x27;SpaceRepeatingPadder&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为&#x27;StringPadder&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instanceof</code>的右侧要求是一个构造函数，TypeScript将细化为：</p>
<ol>
<li>此构造函数的 <code>prototype</code>属性的类型，如果它的类型不为 <code>any</code>的话</li>
<li>构造签名所返回的类型的联合</li>
</ol>
<p>以此顺序。</p>
<h3 id="类型别名type"><a href="#类型别名type" class="headerlink" title="类型别名type"></a>类型别名type</h3><h4 id="type关键字"><a href="#type关键字" class="headerlink" title="type关键字"></a><strong>type关键字</strong></h4><p>说明：字面意思，用来给一个类型起个新名字。生成一个接口</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> str1 = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> str2 = <span class="function">()=&gt;</span><span class="built_in">string</span>;   <span class="comment">//此为函数类型形状，注意跟下面区分</span></span><br><span class="line"><span class="keyword">type</span> str = str1 | str2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s:str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s1:str = <span class="function">() =&gt;</span><span class="string">&quot;heihei&quot;</span>;   <span class="comment">//为箭头函数</span></span><br></pre></td></tr></table></figure>

<p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function">() =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>起别名不会新建一个类型 - 它创建了一个新 <em>名字</em>来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</p>
<p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; <span class="attr">value</span>: T &#125;;</span><br></pre></td></tr></table></figure>

<p>我们也可以使用类型别名来在属性里引用自己：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">value</span>: T;</span><br><span class="line">    left: Tree&lt;T&gt;;</span><br><span class="line">    right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; <span class="attr">next</span>: LinkedList&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;;</span><br><span class="line"><span class="keyword">var</span> s = people.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.next.name;</span><br></pre></td></tr></table></figure>

<p>然而，类型别名不能出现在声明右侧的任何地方。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<h4 id="type-与-interface-的区别"><a href="#type-与-interface-的区别" class="headerlink" title="type 与 interface 的区别"></a>type 与 interface 的区别</h4><p>相同点：</p>
<ul>
<li>都可以描述一个对象或者函数</li>
<li>都允许拓展（extends和交叉类型）</li>
</ul>
<p>不同点：</p>
<ul>
<li>type 可以声明基本类型别名，联合类型，元组等类型</li>
<li>type 语句中还可以使用 typeof 获取实例的类型进行赋值</li>
<li>interface 能够声明合并</li>
</ul>
<h5 id="相似的"><a href="#相似的" class="headerlink" title="相似的"></a>相似的</h5><p><code>type</code> 用于定义数据的类型别名。<code>interface</code> 用于定义数据的类型别名。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> User = &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> user:User=&#123;</span><br><span class="line">    <span class="attr">name1</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">name1</span>: <span class="built_in">string</span></span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="keyword">let</span> user:User=&#123;</span><br><span class="line">    <span class="attr">name1</span>:<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="不相似的"><a href="#不相似的" class="headerlink" title="不相似的"></a>不相似的</h5><p><code>type</code> 与 <code>interface</code> 都可以实现继承，但是他们的表现形式不同。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">//interface extends interface</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type 与 type 交叉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123; <span class="attr">age</span>: <span class="built_in">number</span>  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//interface extends type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Name = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User <span class="keyword">extends</span> Name &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//type 与 interface 交叉</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Name &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> User = Name &amp; &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>type</code> 作为类型的别名，因此可以轻易的实现声明基本类型别名，联合类型，元组等类型，而 interface 则不行。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本类型别名</span></span><br><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合类型,</span></span><br><span class="line"><span class="keyword">interface</span> Dog &#123;</span><br><span class="line">    <span class="attr">a</span>:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Cat &#123;</span><br><span class="line">    <span class="attr">b</span>:<span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Pet = Dog | Cat</span><br><span class="line"><span class="keyword">let</span> c:Pet=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体定义数组每个位置的类型</span></span><br><span class="line"><span class="keyword">type</span> PetList = [Dog, Pet]</span><br></pre></td></tr></table></figure>

<p>interface 能够声明合并，而 type 不行（会报重复声明错误）。</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> User &#123;</span><br><span class="line">    <span class="attr">sex</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a:User=&#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;q&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">sex</span>:<span class="string">&#x27;men&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> guest = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="built_in">string</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="built_in">number</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> guest = &#123;</span><br><span class="line">    <span class="attr">sex</span>: <span class="built_in">string</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//type 报错</span></span><br></pre></td></tr></table></figure>

<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="观察者和发布订阅模式"><a href="#观察者和发布订阅模式" class="headerlink" title="观察者和发布订阅模式"></a>观察者和发布订阅模式</h2><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p><a href="https://juejin.cn/post/7055441354054172709#heading-1">https://juejin.cn/post/7055441354054172709#heading-1</a></p>
<h4 id="故事背景"><a href="#故事背景" class="headerlink" title="故事背景"></a>故事背景</h4><p>前端宗门自从发布了传承方案后，宗门日渐繁荣，弟子们的水平不断提高，但新的问题出现了——高质量任务严重不足。宗门任务大殿每个月发布的五星任务是有限的，想要接取五星任务的弟子却如过江之鲫，于是滋生了<strong>武侠黄牛</strong>，恶意抢任务，坐地起价。</p>
<p>宗门不愿任务被恶意哄抢，决定调整任务市场秩序，因此推出任务订阅功能——观察者模式。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>在观察者模式中，只有两种主体：目标对象 (<code>Object</code>) 和观察者 (<code>Observer</code>)。宗门任务大殿就是目标对象，弟子们就是观察者。</p>
<ul>
<li>目标对象 Subject:<ul>
<li>维护观察者列表 <code>observerList</code> ———— 维护拥有订阅权限的弟子列表</li>
<li>定义<strong>添加观察者的方法</strong> ———— 提供弟子购买订阅权限的功能</li>
<li>当自身发生变化后，通过调用自己的 <code>notify</code> 方法依次通知每个观察者执行 <code>update</code> 方法 ———— 发布对应任务后通知有订阅权限的弟子</li>
</ul>
</li>
<li>观察者 <code>Observer</code> 需要实现 <code>update</code> 方法，供目标对象调用。<code>update</code>方法中可以执行自定义的业务逻辑 弟子们需要定义接收任务通知后的方法，例如去抢任务或任务不适合，继续等待下一个任务</li>
</ul>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f96a826bb7945dd96f9696f41b45534~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="Observer.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">update</span>(<span class="params">&#123; taskType, taskInfo &#125;</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 假设任务分为日常route和战斗war</span></span><br><span class="line">    <span class="keyword">if</span> (taskType === <span class="string">&quot;route&quot;</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>不需要日常任务`</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.goToTaskHome(taskInfo);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">goToTaskHome</span>(<span class="params">info</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>去任务大殿抢<span class="subst">$&#123;info&#125;</span>任务`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">addObserver</span>(<span class="params">observer</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observerList.push(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params">task</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;发布五星任务&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.observerList.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update(task))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subject = <span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">const</span> stu1 = <span class="keyword">new</span> Observer(<span class="string">&quot;弟子1&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> stu2 = <span class="keyword">new</span> Observer(<span class="string">&quot;弟子2&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// stu1 stu2 购买五星任务通知权限</span></span><br><span class="line">subject.addObserver(stu1);</span><br><span class="line">subject.addObserver(stu2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星战斗任务</span></span><br><span class="line"><span class="keyword">const</span> warTask = &#123;</span><br><span class="line">  <span class="attr">taskType</span>: <span class="string">&#x27;war&#x27;</span>,</span><br><span class="line">  <span class="attr">taskInfo</span>: <span class="string">&quot;猎杀时刻&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务大殿通知购买权限弟子</span></span><br><span class="line">subject.notify(warTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务殿发布五星日常任务</span></span><br><span class="line"><span class="keyword">const</span> routeTask = &#123;</span><br><span class="line">  <span class="attr">taskType</span>: <span class="string">&#x27;route&#x27;</span>,</span><br><span class="line">  <span class="attr">taskInfo</span>: <span class="string">&quot;种树浇水&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject.notify(routeTask);</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"><span class="comment">// 战斗任务</span></span><br><span class="line">发布五星任务</span><br><span class="line">弟子<span class="number">1</span>去任务大殿抢猎杀时刻任务</span><br><span class="line">弟子<span class="number">2</span>去任务大殿抢猎杀时刻任务</span><br><span class="line"></span><br><span class="line"><span class="comment">// 日常任务</span></span><br><span class="line">发布五星任务</span><br><span class="line">弟子<span class="number">1</span>不需要日常任务</span><br><span class="line">弟子<span class="number">2</span>不需要日常任务</span><br></pre></td></tr></table></figure>

<h3 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h3><p>发布订阅模式与观察者模式相比，发布订阅模式中有三个角色，发布者 <code>Publisher</code> ，事件调度中心 <code>Event Channel</code> ，订阅者 <code>Subscriber</code> 。</p>
<p>宗门感觉把任务订阅放在任务大殿中有些繁琐，于是决定在任务大殿和弟子中间添加<strong>中介</strong>。弟子在中介中订阅其需要的任务类型，当任务大殿发布任务后，中介会将发布任务给对应的订阅者。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8fc5d255760a4192a939785e427fabec~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="publish-subscribe.png"></p>
<p>以目前的<strong>热播剧开端</strong>为例，临近过年，摸鱼的心思越来越重，每天就迫不及待的等开端更新，想在开端更新的第一刻就开始看剧，那你会怎么做那？总不能时时刻刻刷新页面吧。平台提供了消息订阅功能，如果你选择订阅，平台更新开端后，会第一时间发消息通知你，订阅后，你就可以愉快的追剧了。</p>
<p>上面案例中，开端就是发布者 <code>Publisher</code>，追剧人就是订阅者 <code>Subscribe</code>，平台则承担了事件通道 <code>Event Channel</code> 功能。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PubSub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 事件中心</span></span><br><span class="line">        <span class="comment">// 存储格式: warTask: [], routeTask: []</span></span><br><span class="line">        <span class="comment">// 每种事件(任务)下存放其订阅者的回调函数</span></span><br><span class="line">        <span class="built_in">this</span>.events = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 订阅方法</span></span><br><span class="line">    <span class="function"><span class="title">subscribe</span>(<span class="params">type, cb</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.events[type] = [];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.events[type].push(cb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发布方法</span></span><br><span class="line">    <span class="function"><span class="title">publish</span>(<span class="params">type, ...args</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">            <span class="built_in">this</span>.events[type].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...args))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消订阅方法</span></span><br><span class="line">    <span class="function"><span class="title">unsubscribe</span>(<span class="params">type, cb</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">            <span class="keyword">const</span> cbIndex = <span class="built_in">this</span>.events[type].findIndex(<span class="function"><span class="params">e</span>=&gt;</span> e === cb)</span><br><span class="line">            <span class="keyword">if</span> (cbIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.events[type].splice(cbIndex, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.events[type].length === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.events[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">unsubscribeAll</span>(<span class="params">type</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.events[type]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> <span class="built_in">this</span>.events[type];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个中介公司</span></span><br><span class="line"><span class="keyword">let</span> pubsub = <span class="keyword">new</span> PubSub();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.subscribe(<span class="string">&#x27;warTask&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">taskInfo</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;宗门殿发布战斗任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 弟子一订阅战斗任务</span></span><br><span class="line">pubsub.subscribe(<span class="string">&#x27;routeTask&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">taskInfo</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;宗门殿发布日常任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 弟子三订阅全类型任务</span></span><br><span class="line">pubsub.subscribe(<span class="string">&#x27;allTask&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">taskInfo</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;宗门殿发布五星任务，任务信息:&quot;</span> + taskInfo);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布战斗任务</span></span><br><span class="line">pubsub.publish(<span class="string">&#x27;warTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line">pubsub.publish(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;猎杀时刻&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布日常任务</span></span><br><span class="line">pubsub.publish(<span class="string">&#x27;routeTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line">pubsub.publish(<span class="string">&#x27;allTask&#x27;</span>, <span class="string">&quot;种树浇水&quot;</span>);</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line"></span><br><span class="line"><span class="comment">// 战斗任务</span></span><br><span class="line">宗门殿发布战斗任务，任务信息:猎杀时刻</span><br><span class="line">宗门殿发布五星任务，任务信息:猎杀时刻</span><br><span class="line"><span class="comment">// 日常任务</span></span><br><span class="line">宗门殿发布日常任务，任务信息:种树浇水</span><br><span class="line">宗门殿发布五星任务，任务信息:种树浇水</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52a175a22ade4793a0297b18c5fb293d~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="observer-publish_subscribe.png" style="zoom: 50%;" />

<table>
<thead>
<tr>
<th><strong>设计模式</strong></th>
<th><strong>观察者模式</strong></th>
<th>发布订阅模式</th>
</tr>
</thead>
<tbody><tr>
<td>主体</td>
<td>Object观察者、Subject目标对象</td>
<td>Publisher发布者、Event Channel事件中心、Subscribe订阅者</td>
</tr>
<tr>
<td>主体关系</td>
<td>Subject中通过observerList记录ObServer</td>
<td>Publisher和Subscribe不想不知道对方，通过中介联系</td>
</tr>
<tr>
<td>优点</td>
<td>角色明确，Subject和Object要遵循约定的成员方法</td>
<td>松散耦合，灵活度高，通常应用在异步编程中</td>
</tr>
<tr>
<td>缺点</td>
<td>紧耦合</td>
<td>当事件类型变多时，会增加维护成本</td>
</tr>
<tr>
<td>使用案例</td>
<td><strong>双向数据绑定</strong></td>
<td><strong>事件总线EventBus</strong></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>ES6,TS,设计模式</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>TS</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>总结</title>
    <url>/2020/09/25/02-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//message提示</span><br><span class="line">&#123;</span><br><span class="line">    code:&#x27;&#x27;,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    message:&#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数类型：json对象，application/x-www-form-urlencoded</li>
</ul>
<ul>
<li>常用值定义：<ul>
<li>状态(0开启，1关闭)</li>
</ul>
</li>
<li>table表格传参格式定义，页数，页码</li>
</ul>
<ul>
<li><p>校验方式：后端校验，前端message展示。</p>
</li>
<li><p>错误码规范</p>
</li>
</ul>
<ul>
<li>增删改查code码，获取表格数据和操作成功的数据返回的code码需要不一致，这样就可以统一的在axios中去message了</li>
</ul>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><h3 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h3><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><ul>
<li>开发同一个组件，需要协调同步，防止代码冲突</li>
</ul>
<h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><ul>
<li><p>开发规范</p>
<ul>
<li>每个页面需要注释这个页面的作用，方法的作用</li>
<li>api接口方法用/**/注释，才有提示</li>
<li>注意后期的维护</li>
</ul>
</li>
<li><p>代码规范</p>
<ul>
<li>生命周期，布尔值放在开头</li>
<li>循环数据过多，不要用框架带的组件，用原生的标签。</li>
</ul>
</li>
<li><p>接口规范</p>
<ul>
<li>提前和后端定义好数据格式，不然前端写好再去联调，参数不一致加大开发成本</li>
<li>重复请求：加节流</li>
<li>定义好一些下拉框数据是前端保存还是后端数据库保存</li>
</ul>
</li>
<li><p>表单</p>
<ul>
<li>表单校验，哪些是必填，提示信息是什么</li>
<li>提交成功后需要清空表单数据</li>
<li>弹框中表单提交成功后，需要关闭弹框</li>
</ul>
</li>
<li><p>table</p>
<ul>
<li>查询时页码要置为1</li>
<li>修改条数时页码要置为1</li>
</ul>
</li>
<li><p>逻辑</p>
<ul>
<li>增删改要加提示信息</li>
<li>tab切换，查询条件需要重置</li>
<li>按钮请求loading（写个公共模块）</li>
<li>某些按钮需要根据状态启用和禁用</li>
<li>操作成功后，是否需要刷新table</li>
<li>注意修改某个地方之后，其他地方是否需要同步修改，最好是能去再走一遍流程</li>
<li>添加需求或者某个逻辑的时候要思考一下是否合理。</li>
</ul>
</li>
<li><p>回显</p>
<ul>
<li>树的回显</li>
</ul>
</li>
<li><p>组件</p>
<ul>
<li>可维护性，可扩展性</li>
<li>写代码的时候需要注意，多个页面会有公共的模块可以提出来</li>
<li>拒绝同一个业务写多个组件，统一用一个语法，一个组件，同一个图片。防止后期维护他人代码时，影响效率</li>
</ul>
</li>
<li><p>注意判断条件，前因后果是否符合逻辑</p>
</li>
</ul>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><ul>
<li><strong>注意需要根据用户账号去保持状态</strong></li>
</ul>
<h1 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h1><h2 id="你在公司做啥"><a href="#你在公司做啥" class="headerlink" title="你在公司做啥"></a>你在公司做啥</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul>
<li><p>阿里云上传图片组件的研发，一个是插件，一个是阿里云链接</p>
</li>
<li><p>下拉框搜索变成输入自定义邮箱后缀。他有搜索事件，和选择事件，通过输入字段不断触发搜索事件，失去焦点之后，执行blur事件，通过循环遍历默认的邮箱后缀来判断是否是自定义的邮箱后缀。最后将自定义的邮箱后缀加到邮箱后缀列表中。</p>
</li>
<li><p>指向问题。react-xarrows，react-draggable。开始的需求是textarea和笑脸图标用箭头符号相连。制作的话可以用svg或者xarrows来制作箭头符号。但是根据上手时间的情况，以及能完美呈现效果还是使用xarrows。根据GitHubxarrows文档，因为需求textarea图标能被拖拽，看到xarrows文档使用draggable配合xarrows拖拽，箭头能保持指向。所以将原来的拖拽功能注释了。遇到箭头指向错误，codesandbox测试是没找到指向对象。应该把Xarrow放在const创建的jsx对象里面。应该就是渲染时候，没找到对象就执行箭头事件了。在文本框拖拽区域的盒子上使用mousemove，事件对象的offsetX/Y是以文本框定位的</p>
<p>在mousedown中修改文本框层级之后，文本框没有触发焦点。mousedown,focus,mouseup,click事件的执行顺序。</p>
</li>
<li><p>g2,label,分行</p>
</li>
</ul>
<h3 id="cisdi"><a href="#cisdi" class="headerlink" title="cisdi"></a>cisdi</h3><ul>
<li><p>防抖</p>
</li>
<li><p>监听数据没有更新</p>
</li>
<li><p>行车终端，行车系统发送给服务器，后端通过Websocket给到前端。初始化时发送uid，后端存入这个ws对象并绑定这个uid（后端做了检验，判断只会对最早的那一个对应的uid的ws对象发送消息，所以新建立的对象收不到消息）。所以刷新页面的时候需要删除这个通道，还需要传给后端关闭通道的消息。不然，后端发送消息还是会发给旧的ws对象。这里我会在beforeunload把所有绑定的id去做注销，然后在mounted去初始化ws,并发送绑定的行车id</p>
<p>因为只能给唯一一个id绑定，不太符合现实，可以设置uuid设置唯一标识，服务器可以为每个标识绑定的uid发送信息</p>
</li>
<li><p>tag导航栏，路由导航</p>
</li>
<li><p>指令：vue本身是不推荐我们直接操作DOM的,既然你选择了使用vue，尽量考虑可以从数据层面去驱动，另外，DOM的操作是很昂贵的，每次操作DOM都会引起浏览器的重绘，虽然说现在的电脑或者手机的性能已经很好，但是，我猜测没有一个人会建议你大量操作DOM的。你可以看到现在流行的框架VUE、react，都是操作数据而不是直接操作DOM的</p>
</li>
<li><p>tablepane,onresize,height</p>
</li>
<li><p>大地图</p>
<ul>
<li>如何循环渲染库位<ul>
<li>for循环渲染行列（这是因为要定位），再根据后端给的数据循环判断，一个格子就要循环所有的数据。<code>100*100*100</code></li>
<li>后端返回所有位置，再根据给的数据循环渲染（根据行列定位）</li>
<li>偶数列放在线交叉的位置，盒子大小的一半就可以</li>
</ul>
</li>
<li>组件<ul>
<li>根据区域封装</li>
<li>特殊结构封装</li>
<li>库位做一个封装</li>
<li>公用模块封装。比如，所有的位置都有钢卷可以做一个封装。运输连的托盘做一个封装</li>
</ul>
</li>
<li>性能渲染<ul>
<li>v-show,v-if</li>
<li>分片渲染</li>
<li>图片</li>
</ul>
</li>
</ul>
</li>
<li><p>小地图，渲染绿色钢卷。储位和绿色钢卷的接口执行顺序同步。所以有时候显示有时候不显示</p>
</li>
<li><p>bufferarray 和 blob</p>
</li>
<li><p>数字平台</p>
<ul>
<li>审批流程</li>
<li>树状</li>
</ul>
</li>
</ul>
<h2 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h2><ul>
<li><p>闭包</p>
</li>
<li><p>异步</p>
</li>
<li><p>一些优化的方案</p>
</li>
<li><p>构造函数</p>
</li>
<li><p>react this指向</p>
</li>
<li><p>面向对象</p>
</li>
<li><p>作用域链</p>
</li>
<li><p>设计模式</p>
</li>
<li><p>原理</p>
<ul>
<li><p>vue,install</p>
</li>
<li><p>this.$set的原理，<a href="https://jishuin.proginn.com/p/763bfbd75fd7">https://jishuin.proginn.com/p/763bfbd75fd7</a></p>
<p>Object.assign方法有很多用处。</p>
<p>（1）为对象添加属性</p>
<p>class Point {<br>  constructor(x, y) {</p>
<pre><code>Object.assign(this, &#123;x, y&#125;);
</code></pre>
<p>  }<br>}<br>上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实</p>
</li>
</ul>
</li>
</ul>
<h2 id="前端初中高评级"><a href="#前端初中高评级" class="headerlink" title="前端初中高评级"></a>前端初中高评级</h2><h3 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h3><p>初级：</p>
<ol>
<li>知道组合寄生继承，知道class继承。</li>
<li>知道怎么创建类function + class。</li>
<li>知道闭包在实际场景中怎么用，常见的坑。</li>
<li>知道模块、组件是什么，怎么用。</li>
<li>知道event loop是什么，能举例说明event loop怎么影响平时的编码。</li>
<li>掌握基础数据结构，比如堆、栈、树，并了解这些数据结构计算机基础中的作用。</li>
<li>知道ES6数组相关方法，比如forEach，map，reduce。</li>
</ol>
<p>中级：</p>
<ol>
<li>知道class继承与组合寄生继承的差别，并能举例说明。</li>
<li>知道event loop原理，知道宏微任务，并且能从个人理解层面说出为什么要区分。知道node和浏览器在实现loop时候的差别。</li>
<li>能将继承、作用域、闭包、模块这些概念融汇贯通，并且结合实际例子说明这几个概念怎样结合在一起。</li>
<li>能脱口而出2种以上设计模式的核心思想，并结合js语言特性举例或口喷基础实现。</li>
<li>掌握一些基础算法核心思想或简单算法问题，比如排序，大数相加。</li>
</ol>
<h3 id="工程化工具"><a href="#工程化工具" class="headerlink" title="工程化工具"></a><strong>工程化工具</strong></h3><p>初级：</p>
<ol>
<li>知道webpack，rollup以及他们适用的场景。</li>
<li>知道webpack v3、v4和v5的区别。</li>
<li>webpack基础配置。</li>
<li>知道webpack打包结果的代码结构和执行流程，知道index.js，runtime.js是干嘛的。</li>
<li>知道amd，cmd，commonjs，es module分别是什么。</li>
<li>知道所有模块化标准定义一个模块怎么写。给出2个文件，能口喷一段代码完成模块打包和执行的核心逻辑</li>
</ol>
<p>中级：</p>
<ol>
<li>知道webpack打包链路，知道plugin生命周期，知道怎么写一个plugin和loader。</li>
<li>知道常见loader做了什么事情，能几句话说明白，比如babel-loader，vue-loader。</li>
<li>能结合性能优化聊webpack配置怎么做，能清楚说明白核心要点有哪些，并说明解决什么问题，需要哪些外部依赖，比如cdn，接入层等。</li>
<li>了解异步模块加载的实现原理，能口喷代码实现核心逻辑。</li>
</ol>
<p>高级：</p>
<ol>
<li>项目脚手架搭建，及如何以工具形态共享。</li>
<li>工具化打包发布流程，包括本地调试、云构建、线上发布体系、一键部署能力。同时，方案不仅限于前端工程部分，包含相关服务端基础设施，比如cdn服务搭建，接入层缓存方案设计，域名管控等。</li>
</ol>
<h3 id="React（ng-vue）"><a href="#React（ng-vue）" class="headerlink" title="React（ng/vue）"></a>React（ng/vue）</h3><p>react替换为vue或angular同样适用</p>
<p>初级：</p>
<ol>
<li>知道react常见优化方案，脱口而出常用生命周期，知道他们是干什么的。</li>
<li>知道react大致实现思路，能对比react和js控制原生dom的差异，能口喷一个简化版的react。</li>
<li>知道diff算法大致实现思路。</li>
<li>对state和props有自己的使用心得，结合受控组件、hoc等特性描述，需要说明各种方案的适用场景。</li>
</ol>
<p>中级：</p>
<ol>
<li>能说明白为什么要实现fiber，以及可能带来的坑。</li>
<li>能说明白为什么要实现hook。</li>
<li>能说明白为什么要用immutable，以及用或者不用的考虑。</li>
<li>知道react不常用的特性，比如context，portal。</li>
<li>能用自己的理解说明白react like框架的本质，能说明白如何让这些框架共存。</li>
</ol>
<p>高级：</p>
<ol>
<li>能设计出框架无关的技术架构。包括但不限于：</li>
<li>说明如何解决可能存在的冲突问题，需要结合实际案例。</li>
<li>能说明架构分层逻辑、各层的核心模块，以及核心模块要解决的问题。能结合实际场景例举一些坑或者优雅的处理方案则更佳。</li>
</ol>
<h3 id="react生态工具（ng-vue同理）"><a href="#react生态工具（ng-vue同理）" class="headerlink" title="react生态工具（ng/vue同理）"></a><strong>react生态工具（ng/vue同理）</strong></h3><p>初级：</p>
<ol>
<li>知道react-router，redux，redux-thunk，react-redux，immutable，antd或同级别社区组件库。（全家桶）</li>
<li>知道浏览器react相关插件有什么，怎么用。</li>
<li>知道react-router 各个版本的差异。</li>
<li>知道antd组件化设计思路。</li>
<li>知道thunk干嘛用的，怎么实现的。</li>
</ol>
<p>中级：</p>
<ol>
<li>看过全家桶源码，不要求每行都看，但是知道核心实现原理和底层依赖。能口喷几行关键代码把对应类库实现即达标。</li>
<li>能从数据驱动角度透彻的说明白redux，能够口喷原生js和redux结合要怎么做。</li>
<li>能结合redux，vuex，mobx等数据流谈谈自己对vue和react的异同。</li>
</ol>
<p>高级：</p>
<ol>
<li>有基于全家桶构建复杂应用的经验，比如微前端和这些类库结合的时候要注意什么，会有什么坑，怎么解决</li>
</ol>
<h3 id="各种Web前端技术"><a href="#各种Web前端技术" class="headerlink" title="各种Web前端技术"></a><strong>各种Web前端技术</strong></h3><p>初级：</p>
<ol>
<li>HTML方面包括但不限于：语义化标签，history api，storage，ajax2.0等。</li>
<li>CSS方面包括但不限于：文档流，重绘重排，flex，BFC，IFC，before/after，动画，keyframe，画三角，优先级矩阵等。</li>
<li>知道axios或同级别网络请求库，知道axios的核心功能。</li>
<li>能口喷xhr用法，知道网络请求相关技术和技术底层，包括但不限于：content-type，不同type的作用；restful设计理念；cors处理方案，以及浏览器和服务端执行流程；口喷文件上传实现；</li>
<li>知道如何完成登陆模块，包括但不限于：登陆表单如何实现；cookie登录态维护方案；token base登录态方案；session概念；</li>
</ol>
<p>中级：</p>
<ol>
<li>HTML方面能够结合各个浏览器api描述常用类库的实现。</li>
<li>css方面能够结合各个概念，说明白网上那些hack方案或优化方案的原理。</li>
<li>能说明白接口请求的前后端整体架构和流程，包括：业务代码，浏览器原理，http协议，服务端接入层，rpc服务调用，负载均衡。</li>
<li>知道websocket用法，包括但不限于：鉴权，房间分配，心跳机制，重连方案等。</li>
<li>知道pc端与移动端登录态维护方案，知道token base登录态实现细节，知道服务端session控制实现，关键字：refresh token。</li>
<li>知道oauth2.0轻量与完整实现原理。</li>
<li>知道移动端api请求与socket如何通过native发送，知道如何与native进行数据交互，知道ios与安卓jsbridge实现原理。</li>
</ol>
<p>eslint的使用</p>
<p>ts的使用</p>
<p>浏览器的一些使用和原理</p>
<p>学习资源和路径</p>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h2><p><a href="https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA">https://mp.weixin.qq.com/s/fUduX-AA618rsE3HHWySgA</a></p>
<p><a href="https://mp.weixin.qq.com/s/cqlhO6N8pGCjNkdHNSio4g">https://mp.weixin.qq.com/s/cqlhO6N8pGCjNkdHNSio4g</a></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程和线程的概念可以这样理解：</p>
<blockquote>
<p>- 进程是一个工厂，工厂有它的独立资源</p>
<p>- 工厂之间相互独立</p>
<p>- 线程是工厂中的工人，多个工人协作完成任务</p>
<p>- 工厂内有一个或多个工人</p>
<p>- 工人之间共享空间</p>
</blockquote>
<blockquote>
<p>- 工厂的资源 -&gt; 系统分配的内存（独立的一块内存）</p>
<p>- 工厂之间的相互独立 -&gt; 进程之间相互独立</p>
<p>- 多个工人协作完成任务 -&gt; 多个线程在进程中协作完成任务</p>
<p>- 工厂内有一个或多个工人 -&gt; 一个进程由一个或多个线程组成</p>
<p>- 工人之间共享空间 -&gt; 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）</p>
</blockquote>
<img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KzcDnDRlicWl0V3fV9Qtzg8n4segZjiaiaCqr982pXRSEIGOq7ics1CRm4A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

<p>进程是<code>cpu</code>资源分配的最小单位（是能拥有资源和独立运行的最小单位，系统会给它分配内存） </p>
<p>线程是<code>cpu</code>调试的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程。核心还是属于一个进程。）</p>
<h4 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h4><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KDibJqU6bBoWCNcT6QS22cFxOygakR1519HdRzOp2iagK5ibfJQWm2e4xA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 67%;" />

<p><strong>浏览器是多进程的</strong>，每打开一个<code>tab</code>页，就相当于创建了一个独立的浏览器进程。</p>
<h4 id="浏览器包含的进程"><a href="#浏览器包含的进程" class="headerlink" title="浏览器包含的进程"></a>浏览器包含的进程</h4><ol>
<li><p><code>Browser</code>进程：浏览器的主进程（负责协调，主控），只有一个，作用有：</p>
<ul>
<li><p>负责浏览器的界面显示，与用户交互，如前进，后退等</p>
</li>
<li><p>负责各个页面的管理，创建和销毁其它进程</p>
</li>
<li><p>将<code>Rendered</code>进程得到的内存中的<code>Bitmap</code>,绘制到用户界面上</p>
</li>
<li><p>网络资源的管理，下载</p>
</li>
</ul>
</li>
<li><p>第三方插件进程：每种类型的插件对应一个进程，仅当使用该插件时才创建。</p>
</li>
<li><p><code>GPU</code>进程：最多一个，用于<code>3D</code>绘制等。</p>
</li>
<li><p>浏览器渲染进程（浏览器内核）（<code>Render</code>进程，内部是多线程的）：默认每个<code>Tab</code>页面一个进程，互不影响。主要作用为：页面渲染，脚本执行，事件处理等</p>
</li>
</ol>
<p>在浏览器中打开一个网页相当于新起了一个进程（进程内有自己的多线程）</p>
<p>浏览器有时会将多个进程合并（譬如打开多个空白标签页后，会发现多个空白标签页被合并成了一个进程），如图</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTcxWjP4iaMWw41pMxuEfjju2K8EkkWh1bgSgNfibdBVwNia4IaicBdUk0rsLXS094QmiaHiawgr3Jfb8GJTQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="浏览器多进程的优势"><a href="#浏览器多进程的优势" class="headerlink" title="浏览器多进程的优势"></a>浏览器多进程的优势</h4><ul>
<li>避免单个<code>page crash</code>影响整个浏览器</li>
<li>避免第三方插件<code>crash</code>影响整个浏览器</li>
<li>多进程充分利用多核优势</li>
<li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li>
</ul>
<p>简单理解就是：如果浏览器是单进程的，某个<code>Tab</code>页崩溃了，就影响了整个浏览器，体验就会很差。同理如果是单进程的，插件崩溃了也会影响整个浏览器; 当然，内存等资源消耗也会更大，像空间换时间一样。</p>
<h3 id="浏览器内核-渲染进程"><a href="#浏览器内核-渲染进程" class="headerlink" title="浏览器内核(渲染进程)"></a>浏览器内核(渲染进程)</h3><p>浏览器内核：浏览器所采用的渲染引擎决定了浏览器如何显示网页的内容以及页面的格式信息。</p>
<ul>
<li><code>Trident</code>内核：<code>IE,MaxThon,TT,The World,360</code>,搜狗浏览器等。</li>
<li><code>Gecko</code>内核：<code>Netscape6</code>及以 上版本，<code>FF,MozillaSuite/SeaMonkey</code>等</li>
<li><code>Presto</code>内核：<code>Opera7</code>及以上。 [<code>Opera</code>内核原为：Presto，现为：<code>Blink</code>;]</li>
<li><code>Webkit</code>内核：<code>Safari,Chrome</code>等。 [ <code>Chrome</code>的<code>Blink</code>（<code>WebKit</code>的分支）]</li>
</ul>
<p><strong>浏览器是多进程的，浏览器的渲染进程是多线程的（浏览器的内核是多线程的）；</strong></p>
<p>渲染进程如下：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KO3Pmiabeq4UPvMSR2fM00YkQAicSmHoXtezy928XErvNLpFlBwcVXic0Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>虽然JavaScript是单线程的，可是浏览器内部不是单线程的。一些I/O操作、定时器的计时和事件监听（click, keydown…）等都是由浏览器提供的其他线程来完成的。</strong></p>
<h4 id="GUI渲染线程"><a href="#GUI渲染线程" class="headerlink" title="GUI渲染线程"></a><code>GUI</code>渲染线程</h4><ul>
<li>负责渲染浏览器界面，解析<code>HTML</code>,<code>CSS</code>,构建<code>DOM</code>树和<code>RenderObject</code>树，布局和绘制等。</li>
<li>当界面需要重绘或由于某种操作引发回流时，该线程就会执行。</li>
<li>注意，**<code>GUI</code>渲染线程与<code>JS</code>引擎线程是互斥的**，当<code>JS</code>引擎执行时<code>GUI</code>线程会被挂起（相当于冻结了）,<code>GUI</code>更新会被保存在一个队列中等到<code>JS</code>引擎空闲时立即被执行。</li>
</ul>
<blockquote>
<p>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。</p>
<p>因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起， GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。</p>
</blockquote>
<h4 id="JS引擎线程"><a href="#JS引擎线程" class="headerlink" title="JS引擎线程"></a><code>JS</code>引擎线程</h4><blockquote>
<p>javascript是单线程的， 假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点。所以javascript是单线程的。</p>
</blockquote>
<ul>
<li>也称为<code>JS</code>内核，负责处理<code>JavaScript</code>脚本程序。（例如<code>V8</code>引擎）。</li>
<li><code>JS</code>引擎线程负责解析<code>JavaScript</code>脚本，运行代码。</li>
<li><code>JS</code>引擎一直等待着任务队列中任务的到来，然后加以处理，<strong>一个<code>Tab</code>页（<code>render</code>进程）中无论什么时候都只有一个<code>JS</code>线程在运行<code>JS</code>程序。</strong></li>
<li><strong>GUI渲染线程与JS引擎线程是互斥的</strong>，所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
<h4 id="事件触发线程"><a href="#事件触发线程" class="headerlink" title="事件触发线程"></a>事件触发线程</h4><ul>
<li><strong>归属于浏览器而不是<code>JS</code>引擎，用来控制事件循环（可以理解成<code>JS</code>引擎自己都忙不过来，需要浏览器另开线程协助）。</strong></li>
<li>当<code>JS</code>引擎执行代码块如<code>setTimeout</code>时（也可来自浏览器内核的其它线程，如鼠标点击，<code>AJAX</code>异步请求等），会将对应任务添加到事件线程中。</li>
<li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待<code>JS</code>引擎的处理。</li>
<li>注意，由于<code>JS</code>的单线程关系，所以这些待处理队列中的事件都得排队等待<code>JS</code>引擎处理（当<code>JS</code>引擎空闲时才会去执行）。</li>
</ul>
<h4 id="定时触发器线程"><a href="#定时触发器线程" class="headerlink" title="定时触发器线程"></a>定时触发器线程</h4><ul>
<li>传说中的<code>setTimeout</code>和<code>setInterval</code>所在的线程</li>
<li>浏览器定时计数器并不是由<code>JavaScript</code>引擎计数的，（<strong>因为<code>JavaScript</code>引擎是单线程的，如果处于阻塞线程状态就会影响计时的准确</strong>）</li>
<li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待<code>JS</code>引擎空闲后执行）</li>
<li>注意，<code>W3C</code>在<code>HTML</code>标准中规定，规定要求<code>setTimeout</code>中低于<code>4ms</code>的时间间隔算为<code>4ms</code>。</li>
</ul>
<h4 id="异步http请求线程"><a href="#异步http请求线程" class="headerlink" title="异步http请求线程"></a>异步<code>http</code>请求线程</h4><ul>
<li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行</li>
</ul>
<h3 id="渲染流程"><a href="#渲染流程" class="headerlink" title="渲染流程"></a>渲染流程</h3><h4 id="浏览器主进程"><a href="#浏览器主进程" class="headerlink" title="浏览器主进程"></a>浏览器主进程</h4><p>浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行 http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程</p>
<h4 id="浏览器渲染进程"><a href="#浏览器渲染进程" class="headerlink" title="浏览器渲染进程"></a>浏览器渲染进程</h4><h6 id="基础版本"><a href="#基础版本" class="headerlink" title="基础版本"></a>基础版本</h6><p>浏览器内核拿到响应报文之后，渲染大概分为以下步骤</p>
<ol>
<li>解析html生产DOM树。</li>
<li>解析CSS规则。</li>
<li>根据DOM Tree和CSS Tree生成Render Tree。</li>
<li>根据Render树进行layout，负责各个元素节点的尺寸、位置计算。</li>
<li>绘制Render树(painting)，绘制页面像素信息。</li>
<li>浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。</li>
</ol>
<h6 id="详细版"><a href="#详细版" class="headerlink" title="详细版"></a><strong>详细版</strong></h6><ol>
<li><p>在浏览器地址栏输入URL</p>
</li>
<li><p>浏览器查看缓存，如果请求资源在缓存中并且新鲜，跳转到转码步骤</p>
<ol>
<li><p>如果资源未缓存，发起新请求</p>
</li>
<li><p>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</p>
</li>
<li><p>检验新鲜通常有两个HTTP头进行控制</p>
<p>Expires和Cache-Control：</p>
<ul>
<li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li>
<li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
</ul>
</li>
</ol>
</li>
<li><p>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</p>
</li>
<li><p>浏览器获取主机ip地址，过程如下：</p>
<ol>
<li>浏览器缓存</li>
<li>本机缓存</li>
<li>hosts文件</li>
<li>路由器缓存</li>
<li>ISP DNS缓存</li>
<li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
</ol>
</li>
<li><p>浏览器<strong>组装一个HTTP（GET）请求报文</strong></p>
</li>
<li><p>打开一个socket与目标IP地址，端口建立TCP链接</p>
<p>三次握手如下：</p>
<ol>
<li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li>
<li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li>
<li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li>
</ol>
</li>
<li><p>TCP链接建立后<strong>发送HTTP请求</strong></p>
</li>
<li><p>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</p>
</li>
<li><p>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</p>
</li>
<li><p>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</p>
</li>
<li><p>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></p>
</li>
<li><p>浏览器接收HTTP响应，然后根据情况选择关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</p>
<ol>
<li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li>
<li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li>
<li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li>
<li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li>
</ol>
</li>
<li><p>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</p>
</li>
<li><p>如果资源可缓存，<strong>进行缓存</strong></p>
</li>
<li><p>对响应进行<strong>解码</strong>（例如gzip压缩）</p>
</li>
<li><p>根据资源类型决定如何处理（假设资源为HTML文档）</p>
</li>
<li><p><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</p>
</li>
<li><p>构建DOM树：</p>
<ol>
<li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li>
<li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li>
<li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li>
</ol>
</li>
<li><p>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></p>
</li>
<li><p>构建CSSOM树：</p>
<ol>
<li><strong>Tokenizing</strong>：字符流转换为标记流</li>
<li><strong>Node</strong>：根据标记创建节点</li>
<li><strong>CSSOM</strong>：节点创建CSSOM树</li>
</ol>
</li>
<li><p><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树</a>:</p>
<ol>
<li><p>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：</p>
<p>1）<code>script</code>,<code>meta</code>这样本身不可见的标签。</p>
<p>2)被css隐藏的节点，如<code>display: none</code></p>
</li>
<li><p>对每一个可见节点，找到恰当的CSSOM规则并应用</p>
</li>
<li><p>发布可视节点的内容和计算样式</p>
</li>
</ol>
</li>
</ol>
<h4 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h4><ul>
<li>DOM Tree： 浏览器将HTML解析成树形的数据结构。</li>
<li>CSS Rule Tree：浏览器将CSS解析成树形的数据结构。</li>
<li>Render Tree：DOM树和CSS规则树合并后生产Render树。</li>
<li>layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。</li>
<li>painting: 按照算出来的规则，通过显卡，把内容画到屏幕上。</li>
<li>重排（重构/回流/reflow）：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 <code>reflow</code>。reflow 会从 <html> 这个 root frame 开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</li>
<li>重绘（repaint或redraw）：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。<strong>重排必定会引发重绘，但重绘不一定会引发重排。</strong></li>
</ul>
<h5 id="普通图层和复合图层"><a href="#普通图层和复合图层" class="headerlink" title="普通图层和复合图层"></a>普通图层和复合图层</h5><p>浏览器渲染的图层一般包含两大类：<code>渲染图层（普通图层）</code>以及<code>复合图层</code></p>
<p>渲染图层：是页面普通的文档流。无论添加多少元素，还在在同一个默认复合层。<br>虽然绝对定位（absolute），相对定位（fixed），浮动定位（float）会让元素成为脱离文档流，但它仍然属于<code>默认复合层</code>，共用同一个绘图上下文对象（GraphicsContext）。</p>
<p>复合图层，又称图形层。它会单独分配系统资源，每个复合图层都有一个独立的GraphicsContext。（当然也会脱离普通文档流，这样一来，不管这个复合图层中怎么变化，也不会影响<code>默认复合层</code>里的回流Reflow重绘Repaint）</p>
<p><strong>通过<code>硬件加速</code>就可以使渲染图层提升为复合图层，GPU中，各个复合图层是单独绘制的，所以互不影响</strong></p>
<p>将元素变成一个复合图层，就是传说中的硬件加速技术</p>
<ul>
<li><p>最常用的方式：<code>translate3d</code>,<code>translatez</code></p>
</li>
<li><p><code>opacity</code>属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）</p>
</li>
<li><p><code>will-chang</code>属性（这个比较偏僻），一般配合<code>opacity</code>与<code>translate</code>使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）</p>
</li>
<li><p>```<br><video><iframe><canvas><webgl>等元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 其它，譬如以前的`flash`插件</span><br><span class="line"></span><br><span class="line">**复合图层的作用**</span><br><span class="line"></span><br><span class="line">一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。但是尽量不要大量使用复合图层，否则由于资源消耗过度，页面反而会变的更卡。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### Browser主进程和渲染进程的通信</span><br><span class="line"></span><br><span class="line">打开一个浏览器，可以看到：任务管理器出现了2个进程（一个主进程，一个是打开`Tab`页的渲染进程）</span><br><span class="line"></span><br><span class="line">- `Browser`主进程收到用户请求，首先需要获取页面内容（如通过网络下载资源）,随后将该任务通过`RendererHost`接口传递给`Render`渲染进程</span><br><span class="line">- `Render`渲染进程的`Renderer`接口收到消息，简单解释后，交给渲染线程`GUI`，然后开始渲染</span><br><span class="line">- `GUI`渲染线程接收请求，加载网页并渲染网页，这其中可能需要`Browser`主进程获取资源和需要`GPU`进程来帮助渲染</span><br><span class="line">- 当然可能会有`JS`线程操作`DOM`（这可能会造成回流并重绘）</span><br><span class="line">- 最后`Render`渲染进程将结果传递给`Browser`主进程</span><br><span class="line">- `Browser`主进程接收到结果并将结果绘制出来</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0nhu2cWXvaXBtsxLYGEe6p3KHgay7bNfvibNicDvJGvOhbupYVh19Vgbbm37TxbgqxYgMtEJwdIibolsQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">### JS的多线程WebWorker</span><br><span class="line"></span><br><span class="line">`JS`引擎是单线程的，而且`JS`执行时间过长会阻塞页面，那么`JS`就真的对`cpu`密集型计算无能为力么？</span><br><span class="line"></span><br><span class="line">所以，后来`HTML5`中支持了`WebWorker`。</span><br><span class="line"></span><br><span class="line">来自MDN的官方解释</span><br><span class="line"></span><br><span class="line">&gt; Web Worker为Web内容在后台线程中运行脚本提供了一种简单的方法。线程可以执行任务而不干扰用户界面</span><br><span class="line">&gt;</span><br><span class="line">&gt; 一个worker是使用一个构造函数创建的一个对象(e.g. Worker()) 运行一个命名的JavaScript文件 </span><br><span class="line">&gt;</span><br><span class="line">&gt; 这个文件包含将在工作线程中运行的代码; workers 运行在另一个全局上下文中,不同于当前的window</span><br><span class="line">&gt;</span><br><span class="line">&gt; 因此，使用 window快捷方式获取当前全局的范围 (而不是self) 在一个 Worker 内将返回错误</span><br><span class="line"></span><br><span class="line">这样理解下：</span><br><span class="line"></span><br><span class="line">- 创建Worker时，JS引擎向浏览器申请开一个子线程**（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）**</span><br><span class="line">- JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）</span><br><span class="line"></span><br><span class="line">所以，如果需要进行一些高耗时的计算时，可以单独开启一个WebWorker线程，这样不管这个WebWorker子线程怎么密集计算、怎么阻塞，都不会影响JS引擎主线程，只需要等计算结束，将结果通过postMessage传输给主线程就可以了。</span><br><span class="line"></span><br><span class="line">而且注意下，JS引擎是单线程的，这一点的本质仍然未改变，Worker可以理解是浏览器给JS引擎开的外挂，专门用来解决那些大量计算问题。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">**`WebWorker`与`SharedWorker`**</span><br><span class="line"></span><br><span class="line">既然都到了这里，就再提一下`SharedWorker`（避免后续将这两个概念搞混）</span><br><span class="line"></span><br><span class="line">- WebWorker只属于某个页面，不会和其他页面的Render进程（浏览器内核进程）共享</span><br><span class="line"></span><br><span class="line">- - 所以Chrome在Render进程中（每一个Tab页就是一个render进程）创建一个新的线程来运行Worker中的JavaScript程序。</span><br><span class="line"></span><br><span class="line">- SharedWorker是浏览器所有页面共享的，不能采用与Worker同样的方式实现，因为它不隶属于某个Render进程，可以为多个Render进程共享使用</span><br><span class="line"></span><br><span class="line">- - 所以Chrome浏览器为SharedWorker单独创建一个进程来运行JavaScript程序，在浏览器中每个相同的JavaScript只存在一个SharedWorker进程，不管它被创建多少次。</span><br><span class="line"></span><br><span class="line">看到这里，应该就很容易明白了，本质上就是进程和线程的区别。SharedWorker由独立的进程管理，WebWorker只是属于render进程下的一个线程</span><br><span class="line"></span><br><span class="line">### Event Loop事件循环机制</span><br><span class="line"></span><br><span class="line">事件触发线程去执行事件循环机制</span><br><span class="line"></span><br><span class="line">![yuque_diagram.jpg](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/52fed7e3ab8643e885034e6f03e5e36d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)</span><br><span class="line"></span><br><span class="line">#### Event Loop目的</span><br><span class="line"></span><br><span class="line">`Event Loop`即事件循环，是指浏览器或`Node`的一种**解决`javaScript`单线程运行时不会阻塞的**一种机制，也就是我们经常使用**异步**的原理。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">单线程是必要的，如果javascript是多线程的，那么当两个线程同时对dom进行一项操作，例如一个向其添加事件，而另一个删除了这个dom，此时该如何处理呢？因此，为了保证不会 发生类似于这个例子中的情景，javascript选择只用一个主线程来执行代码，这样就保证了程序执行的一致性。</span><br><span class="line"></span><br><span class="line">#### macrotask与microtask</span><br><span class="line"></span><br><span class="line">在ECMAScript中，macrotask可称为`task`，microtask称为`jobs`</span><br><span class="line"></span><br><span class="line">**MacroTask（宏任务）**:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>script(整体代码)<br>setTimeout<br>setInterval<br>nodejs的setImmediate<br>网络I/O、文件I/O<br>UI渲染事件（DOM解析、布局计算、绘制）<br>MessageChannel（react的fiber用到）<br>postMessage<br>requestAnimationFrame</p>
</blockquote>
</li>
</ul>
<p><em>宿主环境：node、浏览器</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**MicroTask（微任务）**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>process.nextTick<br>Promise<br>Async/Await(实际就是promise)<br>MutationObserver(html5新特性</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### Event Loop流程</span><br><span class="line"></span><br><span class="line">1. 执行script代码块</span><br><span class="line">   1. 将同步任务放到主线程直接执行</span><br><span class="line">   2. 执行过程中如果遇到微任务(异步任务)，就将它添加到微任务的任务队列中</span><br><span class="line">   3. 执行过程中如果遇到宏任务(异步任务)，就将它添加到宏任务的任务队列中</span><br><span class="line">   4. 同步任务，执行完成，执行当前微任务队列</span><br><span class="line">2. script代码块执行结束，检查宏任务队列，取下一个宏任务执行，执行完检查微任务队列，重复执行步骤</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/6a2d22cc2af84f84ac072e89dc7dee90.png#pic_center)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; 调用`setTimeout`后，是如何等待特定时间后才添加到事件队列中的？</span><br><span class="line">&gt;</span><br><span class="line">&gt; 由定时器线程控制，因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时</span><br><span class="line">&gt;</span><br><span class="line">&gt; 当使用`setTimeout`或`setInterval`时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件队列中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Node事件循环</span><br><span class="line"></span><br><span class="line">##### 特点</span><br><span class="line"></span><br><span class="line">- 分为6个阶段</span><br><span class="line">- 每个阶段对应一个宏任务队列。</span><br><span class="line">- 每个阶段都要等对应的宏任务队列执行完毕才会进入到下一个阶段的宏任务队列</span><br><span class="line">- 每两个阶段之间执行微任务队列</span><br><span class="line"></span><br><span class="line">##### 流程</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/e4b35b71625e4070adf93a8417e6a634.png)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">定时器（timers）：本阶段执行 setTimeout和 setInterval的回调函数。</span><br><span class="line">待定回调（pending callback）：执行某些操作的回调</span><br><span class="line">idle, prepare：仅系统内部使用。</span><br><span class="line">轮询（poll）：计算应该阻塞和轮询 I/O 的时间，然后，处理 轮询 队列里的事件</span><br><span class="line">检测（check）：setImmediate() 回调函数在这里执行。</span><br><span class="line">关闭的回调函数（close callback）：一些关闭的回调函数，如：socket.on(‘close’, …)</span><br><span class="line"></span><br><span class="line">## JS和TS编译</span><br><span class="line"></span><br><span class="line">https://mp.weixin.qq.com/s/qMLRyru1qxKige9GuVZ0Xw</span><br><span class="line"></span><br><span class="line">### V8 引擎</span><br><span class="line"></span><br><span class="line">**编程语言可以分为机器语言、汇编语言、高级语言。**</span><br><span class="line"></span><br><span class="line">- 机器语言：由 0 和 1 组成的二进制码，对于人类来说是很难记忆的，还要考虑不同 CPU 平台的兼容性。</span><br><span class="line"></span><br><span class="line">- 汇编语言：用更容易记忆的英文缩写标识符代替二进制指令，但还是需要开发人员有足够的硬件知识。</span><br><span class="line">- 高级语言：更简单抽象且不需要考虑硬件，但是需要更复杂、耗时更久的翻译过程才能被执行。</span><br><span class="line"></span><br><span class="line">**高级语言又可以分为解释型语言、编译型语言。**</span><br><span class="line"></span><br><span class="line">- 编译型语言：需要编译器进行一次编译，被编译过的文件可以多次执行。如 C++、C 语言。编译执行的特点是启动速度慢，但是执行时的速度快。</span><br><span class="line"></span><br><span class="line">- 解释型语言：不需要事先编译，通过解释器一边解释一边执行。启动快，但执行慢。</span><br><span class="line"></span><br><span class="line">&gt; 我们知道 JavaScript 是一门高级语言，并且是动态类型语言，我们在定义一个变量时不需要关心它的类型，并且可以随意的修改变量的类型。而在像 C++这样的静态类型语言中，我们必须提前声明变量的类型并且赋予正确的值才行。也正是因为 JavaScript 没有像 C++那样可以事先提供足够的信息供编译器编译出更加低级的机器代码，它只能在运行阶段收集类型信息，然后根据这些信息进行编译再执行，所以 JavaScript 也是解释型语言。</span><br><span class="line"></span><br><span class="line">这也就意味着 JavaScript 要想被计算机执行，需要一个能够快速解析并且执行 JavaScript 脚本的程序，这个程序就是我们平时所说的 JavaScript 引擎。这里我们给出 V8 引擎的概念:**V8 是 Google 基于 C++ 编写的开源高性能 Javascript 与 WebAssembly 引擎。用于 Google Chrome（Google 的开源浏览器） 以及 Node.js 等。**</span><br><span class="line"></span><br><span class="line">### V8 引擎的编译流水线</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_png/anMXc7ia02zOq3m8u7diavjWEkJaZpKb2hbpNePdNI1rMC4WR1B5gYjxoia1sVypf8KiarLfSDZ4ZC5NWZ0b6V8qAw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">#### 初始化基础环境</span><br><span class="line"></span><br><span class="line">V8 执行 Js 代码是离不开宿主环境的，V8 的宿主可以是浏览器，也可以是 Node.js。下图是浏览器的组成结构，其中渲染引擎就是平时所说的浏览器内核，它包括网络模块，Js 解释器等。当打开一个渲染进程时，就为 V8 初始化了一个运行时环境。</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0KyaSUZF2cTUWH3D4WbicFx1cK9KIY01lfynWrTBOHOrmrwId2BEzQow/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">运行时环境为 V8 提供了堆空间，栈空间、全局执行上下文、消息循环系统、宿主对象及宿主 API 等。V8 的核心是实现了 ECMAScript 标准，此外还提供了垃圾回收器等内容。</span><br><span class="line"></span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0l3vr44a7UPQa3wPx9VQNicj3rHc3OOic5fRnlzQlOIUHEicjDP7zuFa9Q/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">#### 解析器</span><br><span class="line"></span><br><span class="line">**解析源码生成 AST 和作用域**</span><br><span class="line"></span><br><span class="line">基础环境准备好之后，接下来就可以向 V8 提交要执行的 JavaScript 代码了。首先 V8 会接收到要执行的 JavaScript 源代码，不过这对 V8 来说只是一堆字符串，V8 并不能直接理解这段字符串的含义，它需要结构化这段字符串。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>function add(x, y) {<br>  var z = x+y<br>  return z<br>}</p>
<p>console.log(add(1, 2))</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">比如针对如上源代码，V8 首先通过解析器（parser）解析成如下的抽象语法树 AST</span><br><span class="line"></span><br><span class="line">#### 解释器</span><br><span class="line"></span><br><span class="line">##### 依据 AST 和作用域生成字节码</span><br><span class="line"></span><br><span class="line">生成了作用域和 AST 之后，V8 就可以依据它们来生成字节码了。AST 之后会被作为输入传到字节码生成器 (BytecodeGenerator)，这是 Ignition 解释器中的一部分，用于生成以函数为单位的字节码。</span><br><span class="line"></span><br><span class="line">##### 解释执行字节码</span><br><span class="line"></span><br><span class="line">和 CPU 执行二进制机器代码类似：使用内存中的一块区域来存放字节码；使通用寄存器用来存放一些中间数据；PC 寄存器用来指向下一条要执行的字节码；栈顶寄存器用来指向当前的栈顶的位置。![图片](https://mmbiz.qpic.cn/mmbiz_jpg/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS07CSKESKibqsV9xjAEIibJ1cvzOtyq85ia36ev9LTiaNh9gsDv7FkcAWXVA/640?wx_fmt=jpeg&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)</span><br><span class="line"></span><br><span class="line">- StackCheck 字节码指令就是检查栈是否达到了溢出的上限。</span><br><span class="line"></span><br><span class="line">- Ldar 表示将寄存器中的值加载到累加器中。</span><br><span class="line">- Add 表示寄存器加载值并将其与累加器中的值相加，然后将结果再次放入累加器。</span><br><span class="line">- Star 表示 把累加器中的值保存到某个寄存器中。</span><br><span class="line">- Return 结束当前函数的执行，并将控制权传回给调用方。返回的值是累加器中的值。</span><br><span class="line"></span><br><span class="line">##### 即时编译</span><br><span class="line"></span><br><span class="line">在解释器 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），**比如一段代码被重复执行多次，这种就称为热点代码**，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。**这种字节码配合解释器和编译器的技术被称为即时编译（JIT）。**</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9o1UvQH2OibWhkHAmAkJFS0KkDH6QODtJRY2Wf3icPoYcyyhSEv9iaf1r1wTKRCpIkyW6ddFkXRFXBg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&quot; alt=&quot;图片&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">### **TypeScript编译**</span><br><span class="line"></span><br><span class="line">https://zhuanlan.zhihu.com/p/45898674</span><br><span class="line"></span><br><span class="line">- 将`TypeScript`代码编译为 `TypeScript-AST`</span><br><span class="line">- 检查`AST`代码上**类型检查**</span><br><span class="line">- 类型检查后，编译为`JavaScript`代码</span><br><span class="line">- `JavaScript`代码转换为`JavaScript-AST`</span><br><span class="line">- 将`AST`代码转换为字节码</span><br><span class="line">- 运算时计算字节码</span><br><span class="line"></span><br><span class="line">![preview](https://pic1.zhimg.com/v2-4f4017f944fb4ef89084df4bcdc79d3c_r.jpg)</span><br><span class="line"></span><br><span class="line">#### **预处理器处理**</span><br><span class="line"></span><br><span class="line">预处理器（preprocessing）负责根据`待编译文件`计算参与编译的文件，生成`源文件`列表，构成`编译上下文` 和 `Program`</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://pic2.zhimg.com/80/v2-d130e0803514d7562191618337a74b2d_720w.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">**编译列表中的文件 = 待编译文件 + 依赖文件 + @types 文件**</span><br><span class="line"></span><br><span class="line">**待编译文件**:默认为项目目录下所有的 .ts、.tsx、.d.ts 为待编译文件(tsconfig.json)</span><br><span class="line"></span><br><span class="line">**依赖文件** :</span><br><span class="line"></span><br><span class="line">1. `&lt;reference path=... /&gt;` 标签引入的依赖声明文件</span><br><span class="line">2. `import` 表达式引入的文件</span><br><span class="line"></span><br><span class="line">&gt; 注意：</span><br><span class="line">&gt; 当解析 import 导入的的时候，会优先选择 .ts/.tsx文件而不是 .d.ts 文件，以确保处理的是最新的文件</span><br><span class="line"></span><br><span class="line">**@types**:</span><br><span class="line"></span><br><span class="line">所有可见的 `@types` 目录下的所有文件</span><br><span class="line"></span><br><span class="line">&gt; 如：`node_modules/@types`、`./node_modules/@types/`等等</span><br><span class="line"></span><br><span class="line">#### **语法分析器处理**</span><br><span class="line"></span><br><span class="line">语法分析器（parser）将`预处理器`得到的`源文件列表`中的文件解析生成包含抽象语法树（AST）Node 的 `SourceFile` 对象</span><br><span class="line"></span><br><span class="line">**`SourceFile`对象 = `源文件 AST` + `额外信息` (如文件名及文件信息等)**</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_41257129/article/details/100901729</span><br><span class="line"></span><br><span class="line">&gt; 类似：</span><br><span class="line">&gt;</span><br><span class="line">&gt; var myDiv = React.createElement(&#x27;div&#x27;, &#123; title: &#x27;this is a div&#x27;, id: &#x27;mydiv&#x27; &#125;, &#x27;这是一个div&#x27;, myH1)</span><br><span class="line"></span><br><span class="line">#### **联合器处理**</span><br><span class="line"></span><br><span class="line">联合器（Binder）遍历并处理`语法分析器`生成的 `AST`，并将 AST 中的声明结合放到一个 `Symbol` 中。</span><br><span class="line"></span><br><span class="line">然后通过 `createSourceFile` API 生成带有 `Symbol`的 `SourceFile`</span><br><span class="line"></span><br><span class="line">**`SourceFile对象` = `源文件 AST` + `Symbol` + `额外信息` (如文件名及文件信息等)**</span><br><span class="line"></span><br><span class="line">&gt; 此时的 Symobl 仅表示**单个文件**的声明信息</span><br><span class="line"></span><br><span class="line">#### **类型解析器与检查器处理**</span><br><span class="line"></span><br><span class="line">**4.1、生成 `Program`**</span><br><span class="line"></span><br><span class="line">通过调用 `createProgramAPI` 来创建 `Program`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Program = All SourceFile + CompilerOptions</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">**4.2、生成 `TypeChecker` 进行处理**</span><br><span class="line"></span><br><span class="line">通过 `Program` 实例创建 `TypeChecker`</span><br><span class="line"></span><br><span class="line">&gt; TypeChecker是TypeScript类型系统的核心，它负责计算出不同文件里的Symbols之间的关系，将Type赋值给Symbol，并生成任何语义Diagnostic（比如：error）</span><br><span class="line"></span><br><span class="line">处理内容：</span><br><span class="line"></span><br><span class="line">1. `TypeChecker` **合并**不同的 `SourceFile` 里的 `Symbol` 到一个单独的视图，创建单一的`Symbol`表（囊括所有文件的全局Symbol视图 ）</span><br><span class="line"></span><br><span class="line">2. 类型检查</span><br><span class="line"></span><br><span class="line">   &gt; Symbol 合并到一张表后，TypeChecker就可以解决关于这个程序的任何问题了。 这些“问题”可以是：</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 1. 这个Node的Symbol是什么？</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 2. 这个Symbol的Type是什么？</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 3. 在AST的某个部分里有哪些Symbol是可见的？</span><br><span class="line">   &gt;</span><br><span class="line">   &gt; 4. 某个函数声明的Signature都有哪些？</span><br><span class="line">   &gt; 5. 针对某个文件应该报哪些错误？</span><br><span class="line"></span><br><span class="line">#### **生成器处理**</span><br><span class="line"></span><br><span class="line">通过 Program 创建一个生成器 **（Emitter）**</span><br><span class="line"></span><br><span class="line">Emitter 将给定的 SourceFile 生成编译后文件（`.js`，`.jsx`，`.d.ts`和`.js.map`）</span><br><span class="line"></span><br><span class="line">## 调试工具Network</span><br><span class="line"></span><br><span class="line">https://mp.weixin.qq.com/s/CfL-uVNcKPasfcBcrifROA</span><br><span class="line"></span><br><span class="line">Network面板记录了与服务器交互的具体细节。在这里我们可以看到发起的请求数量，传输体积以及解压缩后的体积，同时还可以知道哪些资源是命中了强缓存，哪些资源命中的协商缓存。</span><br><span class="line"></span><br><span class="line">Network面板可以让我们初步评估网站性能，对网站整体的体积，网络的影响带来一个整体的认知，同时提供一些辅助功能，如禁用缓存，block某些资源。</span><br><span class="line"></span><br><span class="line">### 资源接口解析</span><br><span class="line"></span><br><span class="line">&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/HLN2IKtpicicGicicOVtKg9wVF4czfJvEIdeo09qdFM2poL7rdmxdriaHl6F5zQZXyNeze3lzic6Nia5Su2awfdjpREDw/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&quot; alt=&quot;图片&quot; style=&quot;zoom:67%;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">查看某一个请求的瀑布流可以让我们清晰的看到一个资源从服务器到达我们的电脑所花的时间。</span><br><span class="line"></span><br><span class="line">- 资源调度</span><br><span class="line"></span><br><span class="line">  - 排队用了1.65ms</span><br><span class="line"></span><br><span class="line">- 开始连接</span><br><span class="line"></span><br><span class="line">  - DNS查询用了21.47ms</span><br><span class="line"></span><br><span class="line">  - initial connection(进行TCP握手的时间)用了56.25ms</span><br><span class="line"></span><br><span class="line">  - SSL握手的时间用了37.87ms</span><br><span class="line"></span><br><span class="line">- 请求/响应	</span><br><span class="line">  - 已发送请求	0.16ms</span><br><span class="line">  - 正在等待服务器响应TTFB：233.09ms</span><br><span class="line">  - 下载文档内容	花了17ms</span><br><span class="line"></span><br><span class="line">**名词解释：**</span><br><span class="line"></span><br><span class="line">- Queueing: 在请求队列中的时间。</span><br><span class="line">- Stalled: 从TCP 连接建立完成，到真正可以传输数据之间的时间差，此时间包括代理协商时间。</span><br><span class="line">- Proxy negotiation: 与代理服务器连接进行协商所花费的时间。</span><br><span class="line">- DNS Lookup: 执行DNS查找所花费的时间，页面上的每个不同的域都需要进行DNS查找。</span><br><span class="line">- Initial Connection / Connecting: 建立连接所花费的时间，包括TCP握手/重试和协商SSL。</span><br><span class="line">- SSL: 完成SSL握手所花费的时间。</span><br><span class="line">- Request sent: 发出网络请求所花费的时间，通常为一毫秒的时间。</span><br><span class="line">- Waiting(TFFB): TFFB 是发出页面请求到接收到应答数据第一个字节的时间。</span><br><span class="line">- Content Download: 接收响应数据所花费的时间。</span><br><span class="line"></span><br><span class="line">### 时长解析</span><br><span class="line"></span><br><span class="line">Chrome控制台network底部的**DOMContentLoaded和Load，Finish**</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdnimg.cn/20200508160958440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTM5MjEz,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">打开chrome控制台network部分刷新页面，可以看到浏览器记录的网络资源加载时间，可以用于评估网页性能。</span><br><span class="line">DOMContentLoaded 和 Load</span><br><span class="line"></span><br><span class="line">- DOMContentLoaded：DOM树构建完成。 即HTML页面由上向下解析HTML结构到末尾封闭标签</span><br><span class="line"></span><br><span class="line">- Load：页面加载完毕。 DOM树构建完成后，继续加载html/css 中的图片资源等外部资源，加载完成后视为页面加载完毕。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DOMContentLoaded 会比 Load 时间小，两者时间差大致等于外部资源加载的时间。</span><br><span class="line"></span><br><span class="line">Finish</span><br><span class="line"></span><br><span class="line">Finish： 是页面上所有 http 请求发送到响应完成的时间， HTTP1.0/1.1 协议限定，单个域名的请求并发量是 6 个，即 Finish 是所有请求（不只是XHR请求，还包括DOC，img，js，css等资源的请求）在并发量为6的限制下完成的时间。</span><br><span class="line"></span><br><span class="line">Finish 的时间比 Load 大，意味着页面有相当部分的请求量，Finish 的时间比 Load 小，意味着页面请求量很少，如果页面是只有一个 html文档请求的静态页面，Finish时间基本就等于HTML文档请求的时间。</span><br><span class="line"></span><br><span class="line">页面发送请求和页面解析文档结构，分属两个不同的线程，所以 Finish 时间与DOMContentLoaded 和 Load 并无直接关系。</span><br><span class="line"></span><br><span class="line">### prefetch 和 prefetch解析</span><br><span class="line"></span><br><span class="line">`prefetch.html` 定义了一个 `rel` 为 `prefetch` 的链接</span><br><span class="line"></span><br><span class="line">```xml</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Prefetch&lt;/title&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</span><br><span class="line">&lt;link rel=&quot;prefetch&quot; href=&quot;script.js&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>main.js</code> 创建了一个按钮，并绑定了点击事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>);</span><br><span class="line">button.innerHTML = <span class="string">&#x27;Add Script&#x27;</span>;</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line">  script.src = <span class="string">&quot;script.js&quot;</span>;</span><br><span class="line">  <span class="built_in">document</span>.head.appendChild(script);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(button);</span><br></pre></td></tr></table></figure>

<p><code>script.js</code> 只是简单的打印了一下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script run&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="预取资源"><a href="#预取资源" class="headerlink" title="预取资源"></a>预取资源</h4><p><img src="https://chanvinxiao.com/blog/prefetch-and-preload-with-webpack/prefetch-init.png" alt="img"></p>
<ul>
<li><code>script.js</code> 被 fetch 下来，size 列的两个数字，275 B 表示下载的字节大小，0 B 表示解析的字节大小（即目前并没有解析）</li>
<li>控制台是空的，即脚本没有运行</li>
</ul>
<p>点击页面上的 <code>Add Script</code>，会在页面增加地址为 <code>script.js</code> 的 <code>&lt;script&gt;</code> 标签，此时网络选项卡会增加以下内容</p>
<p><img src="https://chanvinxiao.com/blog/prefetch-and-preload-with-webpack/prefetch-add.png" alt="img"></p>
<ul>
<li><p>下载字节量为 <code>(prefetch cache)</code> ，即直接从预取缓存获取资源，下面的解析后的字节不再为 0</p>
</li>
<li><p>控制台打印出脚本中的调试内容，即这时脚本才被解析并运</p>
</li>
</ul>
<h4 id="预加载资源"><a href="#预加载资源" class="headerlink" title="预加载资源"></a>预加载资源</h4><p>将 prefetch.html 的 link 标签的 prefetch 改为 <code>preload</code>，并增加资源类型 <code>as</code> 为 <code>script</code>，即得 preload.html</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;script.js&quot;</span> as=<span class="string">&quot;script&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p><img src="https://chanvinxiao.com/blog/prefetch-and-preload-with-webpack/preload.png" alt="img"></p>
<ul>
<li><code>script.js</code> 被优先下载， size 列的解压字节不再为 0，即 <code>preload</code> 除了把脚本下载了下来，还进行了解析</li>
<li>控制台目前仍为空，即脚本虽然被解析，但并没有运行。</li>
</ul>
<p>点击 <code>Add Script</code>，网络选项卡并没有增加任何记录，但是控制台输出了脚本的打印内容</p>
<ul>
<li>因为脚本已经解析完成，所以连从缓存获取都不需要了，直接运行即可</li>
<li>如果没有在 3 秒内点击 <code>Add Script</code>，控制台会进行警告，因为没有及时使用应该优先加载的资源</li>
</ul>
<blockquote>
<p>The resource <a href="https://chanvinxiao.com/demo/html/script.js">https://chanvinxiao.com/demo/html/script.js</a> was preloaded using link preload but not used within a few seconds from the window’s load event. Please make sure it has an appropriate <code>as</code> value and it is preloaded intentionally.</p>
</blockquote>
<h1 id="网络与安全"><a href="#网络与安全" class="headerlink" title="网络与安全"></a>网络与安全</h1><h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4><p><strong>统一资源定位符</strong>（Uniform Resource Locator，缩写：URL），是对资源（web上每一种可用的资源，如 HTML文档、图像、视频片段、程序）的引用和访问该资源的方法。俗称网址。</p>
<p>一个 URL 由以下不同的部分组成：</p>
<p>协议：通常是 https 或 http，一种告诉浏览器或者设备如何访问资源的方法，当然还有其他的协议，如 ftp 、mailto 或者 file。接下来是 :// 。主机名：表示 IP 地址的注册名称（域名） 或 IP 地址，用于识别连接到网络的设备的数字标识符。后面是可选的端口好，前面是冒号 ： 。路径：可以引用文件系统路径，通常作为一个代码段使用。参数：以问号开头的可选查询参数，其中多个参数用 &amp; 连接hash：用于为页面上的标题提供快速链接，如锚点链接。上面是 URL 组成部份的简介，为了更加直观，如下图所示：</p>
<p><img src="https://pics2.baidu.com/feed/2f738bd4b31c8701d84cbce25aa37c270608ff25.jpeg?token=333256e42fecae798358d70e88a5ea3b" alt="img"></p>
<h4 id="URI"><a href="#URI" class="headerlink" title="URI"></a>URI</h4><p><strong>统一资源标志符</strong>(Uniform Resource Identifier， URI)，表示能把一个资源独一无二地标识出来。</p>
<p>URI通常由三部分组成：</p>
<p>①资源的命名机制；</p>
<p>②存放资源的<a href="https://so.csdn.net/so/search?q=%E4%B8%BB%E6%9C%BA%E5%90%8D&spm=1001.2101.3001.7020">主机名</a>；</p>
<p>③资源自身的名称。</p>
<p>注意：这只是一般URI资源的命名方式，只要是可以唯一标识资源的都被称为URI，上面三条合在一起是URI的充分不必要条件</p>
<p>其实URL和URI的差异就是一个子集的关系，如下图：</p>
<img src="https://pics2.baidu.com/feed/55e736d12f2eb9385f6b11cbaabe673de4dd6fee.jpeg?token=adebc2b35a1876aa182b9d51b3dc228d" alt="img" style="zoom:33%;" />



<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP三点注意事项：</p>
<ul>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>HTTP是无状态：无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态协议，即：服务器不需要知道客户端是谁,只认请求（一次请求request,一次相应response）</li>
</ul>
<p><img src="https://img-blog.csdn.net/20140610210038140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2019022420515851.png" alt="img"></p>
<p>请求协议的格式如下：</p>
<ul>
<li>请求首行<ul>
<li>请求方式 </li>
<li>请求路径 </li>
<li>协议和版本，</li>
<li>例如：GET/index.html HTTP/1.1</li>
</ul>
</li>
<li>请求头信息<ul>
<li>键值对格式 =》请求头名称：请求头内容，</li>
<li>即，例如：Host:localhost</li>
</ul>
</li>
<li>空行；用来与请求体分隔开</li>
<li>请求体。GET没有请求体，只有POST有请求体。</li>
</ul>
<h3 id="HTTP请求响应报文"><a href="#HTTP请求响应报文" class="headerlink" title="HTTP请求响应报文"></a>HTTP请求响应报文</h3><p>HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文</p>
<h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p>
<img src="https://upload-images.jianshu.io/upload_images/12603307-27e3bf8fde18f443.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />



<p>Query Params：常用是<strong>get</strong>方式请求，query是指<strong>请求行</strong>中请求的参数，一般是指URL中？后面的参数</p>
<p>Body Params：常用是<strong>post</strong>方式请求，body是指<strong>请求体</strong>中的数据</p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)</p>
<img src="https://upload-images.jianshu.io/upload_images/12603307-cf75b41f632499a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp" alt="img" style="zoom: 67%;" />

<h3 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h3><h4 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h4><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了<code>Connection: Keep-Alive</code>，<code>keep-alive</code>的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生<strong>队头阻塞</strong>的问题。HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。connection keep-alive</p>
<table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>示例</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>可接受的响应内容类型（<code>Content-Types</code>）。</td>
<td><code>Accept: text/plain</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的编码方式。</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Datetime</td>
<td>可接受的按照时间来表示的响应内容版本</td>
<td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td>
<td>临时</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于表示HTTP协议中需要认证资源的认证信息</td>
<td>Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==</td>
<td>固定</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中的，是否使用缓存机制。</td>
<td><code>Cache-Control: no-cache</code>              max-age：缓存无法返回缓存时间长于max-age规定秒的文档</td>
<td>固定</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端（浏览器）想要优先使用的连接类型</td>
<td><code>Connection: keep-alive``Connection: Upgrade</code></td>
<td>固定</td>
</tr>
<tr>
<td>Cookie</td>
<td>由之前服务器通过<code>Set-Cookie</code>（见下文）设置的一个HTTP协议Cookie</td>
<td><code>Cookie: $Version=1; Skin=new;</code></td>
<td>固定：标准</td>
</tr>
<tr>
<td>Content-Length</td>
<td>以8进制表示的请求体的长度</td>
<td><code>Content-Length: 348</code></td>
<td>固定</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果</td>
<td>Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==</td>
<td>废弃</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的MIME类型 （用于POST和PUT请求中）</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
<td>固定</td>
</tr>
<tr>
<td>Date</td>
<td>发送该消息的日期和时间（以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来发送）</td>
<td>Date: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Expect</td>
<td>表示客户端要求服务器做出特定的行为</td>
<td><code>Expect: 100-continue</code></td>
<td>固定</td>
</tr>
<tr>
<td>From</td>
<td>发起此请求的用户的邮件地址</td>
<td><code>From: user@itbilu.com</code></td>
<td>固定</td>
</tr>
<tr>
<td>Host</td>
<td>表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。</td>
<td><code>Host: www.itbilu.com:80``Host: www.itbilu.com</code></td>
<td>固定</td>
</tr>
<tr>
<td>If-Match</td>
<td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。</td>
<td>If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td>固定</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</td>
<td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td><strong>固定</strong></td>
</tr>
<tr>
<td><strong>If-None-Match</strong></td>
<td>If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</td>
<td>If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td>固定</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体</td>
<td>If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td>固定</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。</td>
<td>If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制该消息可被代理及网关转发的次数。</td>
<td><code>Max-Forwards: 10</code></td>
<td>固定</td>
</tr>
<tr>
<td>Origin</td>
<td>发起一个针对<a href="http://itbilu.com/javascript/js/VkiXuUcC.html">跨域资源共享</a>的请求（该请求要求服务器在响应中加入一个<code>Access-Control-Allow-Origin</code>的消息头，表示访问控制所允许的来源）。</td>
<td><code>Origin: http://www.itbilu.com</code></td>
<td>固定: 标准</td>
</tr>
<tr>
<td>Pragma</td>
<td>与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。</td>
<td><code>Pragma: no-cache</code></td>
<td>固定</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>用于向代理进行认证的认证信息。</td>
<td>Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==</td>
<td>固定</td>
</tr>
<tr>
<td>Range</td>
<td>表示请求某个实体的一部分，字节偏移以0开始。</td>
<td><code>Range: bytes=500-999</code></td>
<td>固定</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。<code>Referer</code>其实是<code>Referrer</code>这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用<code>Referer</code>了。</td>
<td>Referer: <a href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td>
<td>固定</td>
</tr>
<tr>
<td>TE</td>
<td>浏览器预期接受的传输时的编码方式：可使用回应协议头<code>Transfer-Encoding</code>中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。</td>
<td><code>TE: trailers,deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的身份标识字符串</td>
<td><code>User-Agent: Mozilla/……</code></td>
<td>固定</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求服务器升级到一个高版本协议。</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td>固定</td>
</tr>
<tr>
<td>Via</td>
<td>告诉服务器，这个请求是由哪些代理发出的。</td>
<td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td>
<td>固定</td>
</tr>
<tr>
<td>Warning</td>
<td>一个一般性的警告，表示在实体内容体中可能存在错误。</td>
<td>Warning: 199 Miscellaneous warning</td>
<td>固定</td>
</tr>
</tbody></table>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><table>
<thead>
<tr>
<th align="left">响应头</th>
<th align="left">说明</th>
<th align="left">示例</th>
<th align="left">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Access-Control-Allow-Origin</td>
<td align="left">指定哪些网站可以<code>跨域源资源共享</code></td>
<td align="left"><code>Access-Control-Allow-Origin: *</code></td>
<td align="left">临时</td>
</tr>
<tr>
<td align="left">Accept-Patch</td>
<td align="left">指定服务器所支持的文档补丁格式</td>
<td align="left">Accept-Patch: text/example;charset=utf-8</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">服务器所支持的内容范围</td>
<td align="left"><code>Accept-Ranges: bytes</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">响应对象在代理缓存中存在的时间，以秒为单位</td>
<td align="left"><code>Age: 12</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Allow</td>
<td align="left">对于特定资源的有效动作;</td>
<td align="left"><code>Allow: GET, HEAD</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td>
<td align="left"><code>Cache-Control: max-age=3600</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">针对该连接所预期的选项</td>
<td align="left"><code>Connection: close</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Disposition</td>
<td align="left">对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td>
<td align="left">Content-Disposition: attachment; filename=”fname.ext”</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">响应资源所使用的编码类型。</td>
<td align="left"><code>Content-Encoding: gzip</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">响就内容所使用的语言</td>
<td align="left"><code>Content-Language: zh-cn</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">响应消息体的长度，用8进制字节表示</td>
<td align="left"><code>Content-Length: 348</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">所返回的数据的一个候选位置</td>
<td align="left"><code>Content-Location: /index.htm</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">响应内容的二进制 MD5 散列值，以 Base64 方式编码</td>
<td align="left">Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td>
<td align="left">已淘汰</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">如果是响应部分消息，表示属于完整消息的哪个部分</td>
<td align="left">Content-Range: bytes 21010-47021/47022</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">当前内容的<code>MIME</code>类型</td>
<td align="left">Content-Type: text/html; charset=utf-8</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">此条消息被发送时的日期和时间(以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td>
<td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td>
<td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td>
<td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td>
<td align="left">固定: 标准</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td>
<td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Link</td>
<td align="left">用来表示与另一个资源之间的类型关系，此类型关系是在<a href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td>
<td align="left"><code>Link: </code>; rel=”alternate”</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">用于在进行重定向，或在创建了某个新资源时使用。</td>
<td align="left">Location: <a href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">P3P</td>
<td align="left">P3P策略相关设置</td>
<td align="left">P3P: CP=”This is not a P3P policy!</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td>
<td align="left"><code>Pragma: no-cache</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">要求在访问代理时提供身份认证信息。</td>
<td align="left"><code>Proxy-Authenticate: Basic</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Public-Key-Pins</td>
<td align="left">用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td>
<td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td>
<td align="left">Refresh: 5; url=<a href="http://itbilu.com/">http://itbilu.com</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td>
<td align="left">示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">服务器的名称</td>
<td align="left"><code>Server: nginx/1.6.3</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置<code>HTTP cookie</code></td>
<td align="left">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td>
<td align="left">固定标准</td>
</tr>
<tr>
<td align="left">Status</td>
<td align="left">通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td>
<td align="left"><code>Status: 200 OK</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left"><code>Trailer</code>用户说明传输中分块编码的编码信息</td>
<td align="left"><code>Trailer: Max-Forwards</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td>
<td align="left">Transfer-Encoding: chunked</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">要求客户端升级到另一个高版本协议。</td>
<td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td>
<td align="left"><code>Vary: *</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">告知代理服务器的客户端，当前响应是通过什么途径发送的。</td>
<td align="left">Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">一般性警告，告知在实体内容体中可能存在错误。</td>
<td align="left">Warning: 199 Miscellaneous warning</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">表示在请求获取这个实体时应当使用的认证模式。</td>
<td align="left"><code>WWW-Authenticate: Basic</code></td>
<td align="left">固定</td>
</tr>
</tbody></table>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li><p>1XX：信息状态码</p>
<ul>
<li><code>100 Continue</code> 继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
</ul>
</li>
<li><p>2XX：成功状态码</p>
<table>
<thead>
<tr>
<th>200</th>
<th>OK</th>
<th>请求成功。一般用于GET与POST请求</th>
</tr>
</thead>
<tbody><tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
</li>
<li><p>3XX：重定向</p>
<table>
<thead>
<tr>
<th>300</th>
<th>Multiple Choices</th>
<th>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
</li>
<li><p>4XX：客户端错误</p>
<table>
<thead>
<tr>
<th>400</th>
<th>Bad Request</th>
<th>客户端请求的语法错误，服务器无法理解</th>
</tr>
</thead>
<tbody><tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
</tbody></table>
</li>
<li><p>5XX:服务器错误</p>
<table>
<thead>
<tr>
<th>500</th>
<th>Internal Server Error</th>
<th>服务器内部错误，无法完成请求</th>
</tr>
</thead>
<tbody><tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。服务器的问题，找网管</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h3><h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。</p>
<p>在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以<strong>并行传输</strong>而不被阻塞，这样就解决了HTTP1.1时复用会产生的<strong>队头阻塞</strong>的问题</p>
<blockquote>
<p>队头堵塞：</p>
<p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
</blockquote>
<h4 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h4><p>HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求1</span><br><span class="line">:authority: unpkg.zhimg.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /za-js-sdk@2.16.0/dist/zap.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36</span><br><span class="line"></span><br><span class="line">// 请求2</span><br><span class="line">:authority: zz.bdstatic.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /linksubmit/push.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36</span><br></pre></td></tr></table></figure>

<p>从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。</p>
<p>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。</p>
<p>下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header1:foo</span><br><span class="line">Header2:bar</span><br><span class="line">Header3:bat</span><br></pre></td></tr></table></figure>

<p>当客户端发送请求时，它会根据首部值创建一张表：</p>
<p><img src="https://pic2.zhimg.com/80/v2-be170562d69da5c67cfc40aa591a722d_1440w.jpg" alt="img"></p>
<p>如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">62 63 64</span><br></pre></td></tr></table></figure>

<p>服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。</p>
<h4 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h4><p>HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</p>
<p>例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。</p>
<h3 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:33%;" /></p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<h3 id="不同HTTP的协议"><a href="#不同HTTP的协议" class="headerlink" title="不同HTTP的协议"></a>不同HTTP的协议</h3><p><strong>HTTP和HTTPS协议的区别</strong></p>
<ul>
<li>HTTS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<p><strong>HTTP 1.0和 HTTP 1.1 有以下区别</strong></p>
<ul>
<li>连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li>资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。 </li>
</ul>
<p><strong>HTTP 1.1 和 HTTP 2.0 的区别</strong></p>
<ul>
<li><p>二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</p>
</li>
<li><p>多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</p>
</li>
<li><p>数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</p>
</li>
<li><p>头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</p>
</li>
<li><p>服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</p>
</li>
<li><p>它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；</p>
</li>
<li><p>网络管理（SMTP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；</p>
</li>
<li><p>域名系统（DNS），主机的域名到 IP 地址的映射</p>
<p><strong>域名解析的顺序：</strong></p>
<p>浏览器缓存；</p>
<p>找本机的hosts文件；</p>
<p>路由缓存；</p>
<p>找DNS服务器（本地域名、顶级域名、根域名）-&gt;迭代解析、递归查询。</p>
<p>顶级域（com，cn，net，gov，org）、二级域（baidu,taobao,qq,alibaba）、三级域（www）(12-2-0852)。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSQYoX1g3iboXfSY2oPtU9libeqiaFnebwhZCt93cStJibZJ4tLCP2ZWjKVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ul>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651556794&amp;idx=1&amp;sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8">https://mp.weixin.qq.com/s?__biz=MzAxODE2MjM1MA==&amp;mid=2651556794&amp;idx=1&amp;sn=0186d0c4b36b6e7e0adf7ffaf7b3f9b8</a></p>
<p><a href="https://louiszhai.github.io/2017/04/07/http-cache/">https://louiszhai.github.io/2017/04/07/http-cache/</a></p>
<p>缓存通过复用之前的获取过的资源，可以显著提高网站和应用程序的性能，合理的缓存不仅可以节省巨大的流量也会让用户二次进入时身心愉悦，如果一个资源完全走了本地缓存，那么就可以节省下整个与服务器交互的时间，如果整个网站的内容都被缓存在本地，那即使离线也可以继续访问(很酷，但还没有完全很酷)。HTTP缓存主要分为两种，一种是强缓存，另一种是协商缓存，都通过Headers控制。整体流程如下：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7567844-72f2b2c531f65689.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/886/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7567844-3fa31eccdfc2f4f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/597/format/webp" alt="img"></p>
<h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a><strong>强缓存</strong></h3><p><strong>本地缓存阶段(也称强缓存)</strong></p>
<p>先在本地查找该资源，如果有发现该资源，而且该资源还没有过期，就使用这一个资源，不会发起任何网络请求；</p>
<ul>
<li><p><code>Expires</code>（该字段是 <code>http1.0</code> 时的规范，值为一个绝对时间的 <code>GMT</code> 格式的时间字符串，代表缓存资源的过期时间）</p>
</li>
<li><p><code>Cache-Control:max-age</code>（该字段是 <code>http1.1</code>的规范，强缓存利用其 <code>max-age</code> 值来判断缓存资源的最大生命周期，它的值单位为秒）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Cache-Control: max-age=&lt;seconds&gt;</span><br><span class="line">Cache-Control: max-stale[=&lt;seconds&gt;]</span><br><span class="line">Cache-Control: min-fresh=&lt;seconds&gt;</span><br><span class="line">Cache-control: no-cache</span><br><span class="line">Cache-control: no-store</span><br><span class="line">Cache-control: no-transform</span><br><span class="line">Cache-control: only-if-cached</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如 果max-age和Expires同时出现，则max-age有更高的优先级。</p>
<p>常用的有<code>max-age</code>，<code>no-cache</code>和<code>no-store</code>。<code>max-age</code> 是资源从响应开始计时的最大新鲜时间，一般响应中还会出现<code>age</code>标明这个资源当前的新鲜程度。<code>no-cache</code> 会让浏览器缓存这个文件到本地但是不用，Network中<code>disable-cache</code>勾中的话就会在请求时带上这个haader，会在下一次新鲜度验证通过后使用这个缓存。<code>no-store</code> 会完全放弃缓存这个文件。服务器响应时的<code>Cache-Control</code>略有不同，其中有两个需要注意下:</p>
<ol>
<li>public, public 表明这个请求可以被任何对象缓存，代理/CDN等中间商。</li>
<li>private，private 表明这个请求只能被终端缓存，不允许代理或者CDN等中间商缓存。</li>
</ol>
<p><code>Expires</code>是一个具体的日期，到了那个日期就会让这个缓存失活，优先级较低，存在<code>max-age</code>的情况下会被忽略，和本地时间绑定，修改本地时间可以绕过。另外，如果你的服务器的返回内容中不存在<code>Expires</code>，<code>Cache-Control: max-age</code>，或 <code>Cache-Control:s-maxage</code>但是存在<code>Last-Modified</code>时，那么浏览器默认会采用一个启发式的算法，即启发式缓存。通常会取响应头的<code>Date_value - Last-Modified_value</code>值的10%作为缓存时间，之后浏览器仍然会按强缓存来对待这个资源一段时间，如果你不想要缓存的话务必确保有<code>no-cache</code>或<code>no-store</code>在响应头中。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a><strong>协商缓存</strong></h3><p><strong>协商缓存阶段(也称弱缓存)</strong></p>
<p>如果在本地缓存找到对应的资源，但是不知道该资源是否过期或者已经过期，则发一个http请求到服务器，然后服务器判断这个请求，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</p>
<ul>
<li><code>Last-Modified</code>（值为资源最后更新时间，随服务器response返回）</li>
<li><code>If-Modified-Since</code>（通过比较两个时间来判断资源在两次请求期间是否有过修改，如果没有修改，则命中协商缓存）</li>
<li><code>ETag</code>（表示资源内容的唯一标识，随服务器<code>response</code>返回）</li>
<li><code>If-None-Match</code>（服务器通过比较请求头部的<code>If-None-Match</code>与当前资源的<code>ETag</code>是否一致来判断资源是否在两次请求之间有过修改，如果没有修改，则命中协商缓存）</li>
</ul>
<p>协商缓存一般会在强缓存新鲜度过期后发起，向服务器确认是否需要更新本地的缓存文件，如果不需要更新，服务器会返回304否则会重新返回整个文件。服务器响应中会携带<code>ETag</code>和<code>Last-Modified</code>，<code>Last-Modified</code> 表示本地文件最后修改日期，浏览器会在request header加上<code>If-Modified-Since</code>（上次返回的<code>Last-Modified</code>的值），询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。但是如果在本地打开缓存文件，就会造成<code>Last-Modified</code>被修改，所以在HTTP / 1.1 出现了<code>ETag</code>。<code>Etag</code>就像一个指纹，资源变化都会导致<code>ETag</code>变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的。<code>If-None-Match</code>的header会将上次返回的<code>ETag</code>发送给服务器，询问该资源的<code>ETag</code>是否有更新，有变动就会发送新的资源回来<code>ETag</code>(<code>If-None-Match</code>)的优先级高于<code>Last-Modified</code>(<code>If-Modified-Since</code>)，优先使用<code>ETag</code>进行确认。协商缓存比强缓存稍慢，因为还是会发送请求到服务器进行确认。</p>
<blockquote>
<h4 id="有Last-Modified为什么还要有ETag"><a href="#有Last-Modified为什么还要有ETag" class="headerlink" title="有Last-Modified为什么还要有ETag"></a>有Last-Modified为什么还要有ETag</h4><p>HTTP1.1中Etag的出现主要是为了解决几个 Last-Modified 比较难解决的问题：</p>
<ul>
<li>Last-Modified 标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的新鲜度</li>
<li>如果某些文件会被定期生成，当有时内容并没有任何变化，但 Last-Modified 却改变了，导致文件没法使用缓存</li>
<li>有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形</li>
</ul>
</blockquote>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>在HTTP1.1规范中，新增了一个HTTP头信息：ETag。浏览器<strong>第一次</strong>请求一个资源的时候，服务端给予返回，并且返回了<strong>ETag</strong>: “50b1c1d4f775c61:df3” 这样的字样给浏览器，当浏览器再次请求这个资源的时候，浏览器会将<strong>If-None-Match</strong>: W/“50b1c1d4f775c61:df3” 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化，如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。通过Etag来利用浏览器的缓存，降低我们服务器的带宽压力。</p>
<p><strong>第一次请求，服务器返回Etag。强缓存，expires和Cache-Control，判断是否过期，过期，请求服务器，服务端拿到该ETAG，对比资源是否发生变化，如果请求的资源在服务器上没有改动过，则返回304，让浏览器使用本地找到的那个资源；</strong></p>
<h3 id="缓存的流程"><a href="#缓存的流程" class="headerlink" title="缓存的流程"></a>缓存的流程</h3><p>浏览器缓存分为强缓存和协商缓存。当客户端请求某个资源时，获取缓存的流程如下</p>
<ul>
<li>先根据这个资源的一些 <code>http header</code> 判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会发请求到服务器；</li>
<li>当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些<code>request header</code>验证这个资源是否命中协商缓存，称为<code>http</code>再验证，如果命中，服务器将请求返回，但不返回资源，而是告诉客户端直接从缓存中获取，客户端收到返回后就会从缓存中获取资源；</li>
<li>强缓存和协商缓存共同之处在于，如果命中缓存，服务器都不会返回资源； 区别是，强缓存不对发送请求到服务器，但协商缓存会。</li>
<li>当协商缓存也没命中时，服务器就会将资源发送回客户端。</li>
<li>当 <code>ctrl+f5</code> 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</li>
<li>当 <code>f5</code>刷新网页时，跳过强缓存，但是会检查协商缓存；</li>
</ul>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>Ajax表示Asynchronous JavaScript and XML(异步JavaScript和XML)，使我们可以请求特定URL获取数据并显示新的内容而不必重新刷新页面</p>
<h3 id="原生Ajax机制"><a href="#原生Ajax机制" class="headerlink" title="原生Ajax机制"></a>原生Ajax机制</h3><p><code>Ajax</code>的原理简单来说是在用户和服务器之间加了—个中间层(<code>AJAX</code>引擎)，通过<code>XmlHttpRequest</code>对象来向服务器发异步请求，从服务器获得数据，然后用<code>javascript</code>来操作<code>DOM</code>更新页面。使用户操作与服务器响应异步化。这其中最关键的一步就是从服务器获得请求数据。</p>
<h3 id="ajax过程"><a href="#ajax过程" class="headerlink" title="ajax过程"></a>ajax过程</h3><p><code>Ajax</code>的过程只涉及<code>JavaScript</code>、<code>XMLHttpRequest</code>和<code>DOM</code>。<code>XMLHttpRequest</code>是<code>aja</code>x的核心机制</p>
<p><strong>1)    创建XMLHttpRequest</strong>    </p>
<p>var xhr = new XMLHttpRequest()；标准浏览器</p>
<p>var xhr = new ActiveXObject(‘Microsoft.XMLHTTP’)；IE老版本</p>
<p><strong>2)    准备发送xhr.open(1，2，3)</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">参数1，请求方式，get获取数据，post提交数据</span><br><span class="line">参数2，请求地址url</span><br><span class="line">参数3，同步异步标志位，true是异步</span><br></pre></td></tr></table></figure>

<ul>
<li><p>get请求，url要加参数，这样php才能接受到参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;/01.php?username&#x27;+username+&#x27;&amp;password&#x27;+password</span><br></pre></td></tr></table></figure>

<p><code>encodeURI（）</code>用来对中文参数进行编码，防止中文乱码</p>
</li>
<li><p>post请求，url只需要地址,不需要参数,参数在send中传递</p>
</li>
</ul>
<p>  <strong>3)    执行发送动作</strong>   </p>
<ul>
<li>get请求 xhr.send(null)；</li>
</ul>
<ul>
<li><p>post请求 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;content-Type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>)<span class="comment">//必须要请求头信息</span></span><br><span class="line"><span class="keyword">var</span> param=<span class="string">&#x27;username&#x27;</span>+username+<span class="string">&#x27;password&#x27;</span>+password;</span><br><span class="line">xhr.send(param);这里不需要<span class="built_in">encodeURI</span>编码</span><br><span class="line"></span><br><span class="line">​	在Form元素的语法中，EncType表明提交数据的格式</span><br><span class="line">​	用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。</span><br><span class="line">- application/x-www-form-urlencoded ： 窗体数据被编码为名称/值对。这是标准的编码格式。（默认）</span><br><span class="line">- multipart/form-data ： 窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。(type=file使用)</span><br><span class="line">- text/plain ： 窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>  <strong>4）指定回调函数    浏览器调用</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 1. 创建连接 **/</span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="literal">null</span>;</span><br><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"><span class="comment">/** 2. 连接服务器 **/</span></span><br><span class="line">xhr.open(<span class="string">&#x27;get&#x27;</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">/** 3. 发送请求 **/</span></span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">/** 4. 接受请求 **/</span></span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>)&#123;<span class="comment">//是否接收到数据</span></span><br><span class="line">		<span class="keyword">if</span>(xhr.status == <span class="number">200</span>)&#123;<span class="comment">//数据是否正常</span></span><br><span class="line">			success(xhr.responseText);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">			<span class="comment">/** false **/</span></span><br><span class="line">			fail &amp;&amp; fail(xhr.status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p><strong>XMLHttpRequest</strong></p>
<p> XMLHttpRequest(XHR) 对象用于与服务器交互。通过 XMLHttpRequest 可以在<strong>不刷新页面的情况下请求特定 URL</strong>，获取数据。这允许网页在不影响用户操作的情况下，更新页面的局部内容。 </p>
<p> <code>XMLHttpRequest</code> 可以用于获取任何类型的数据，而不仅仅是 XML。它甚至支持 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a> 以外的协议（包括 file:// 和 FTP），尽管可能受到更多出于安全等原因的限制。 </p>
<p> <strong>1.  属性</strong></p>
<ul>
<li><strong>XMLHttpRequest.responseType</strong>  表示服务器返回数据的类型，这个属性是可写的，在 open 之后，send 之前，告诉服务器返回指定类型的数据。如果 responseType 设为空字符串，就等同于默认值 text 表示服务器返回文本数据； </li>
<li><strong>XMLHttpRequest.onreadystatechange</strong>当 <code>readyState</code> 属性发生变化时，调用的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/EventHandler"><code>EventHandler</code></a>。</li>
<li><strong>readyState</strong> HTTP 请求的状态，当一个 XMLHttpRequest 初次创建时，这个属性的值从 0 开始，直到接收到完整的 HTTP 响应，这个值增加到 4。 </li>
<li><strong>status</strong>由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。 </li>
<li><strong>response</strong> 该属性只读表示服务器返回的数据体，可能是任意的数据类型，比如字符串，对象，二进制对象等，具体类型由responseType 属性决定。如果本次请求没有成功或者数据不完整，该属性等于 null </li>
</ul>
<p> <strong>2.  方法</strong></p>
<table>
<thead>
<tr>
<th>abort()</th>
<th>取消当前响应，关闭连接并且结束任何未决的网络活动</th>
</tr>
</thead>
<tbody><tr>
<td>getAllResponseHeaders()</td>
<td>把 HTTP 响应头部作为未解析的字符串返回</td>
</tr>
<tr>
<td>getResponseHeader()</td>
<td>返回指定的 HTTP 响应头部的值</td>
</tr>
<tr>
<td>open()</td>
<td>初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求</td>
</tr>
<tr>
<td>send()</td>
<td>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体</td>
</tr>
<tr>
<td>setRequestHeader()</td>
<td>向一个打开但未发送的请求设置或添加一个 HTTP 请求头</td>
</tr>
</tbody></table>
<h2 id="content-Type"><a href="#content-Type" class="headerlink" title="content-Type"></a>content-Type</h2><p>接口发送参数、接收响应数据，都需要双方约定好使用什么格式的数据，只有双方按照约定好的格式去解析数据才能正确的收发数据。而 Content-Type 就是用来告诉你数据的格式</p>
<ul>
<li><code>application/json</code>：JSON数据格式，现在非常流行的格式</li>
<li> <code>application/x-www-form-urlencoded</code>：很常见的一种数据格式，post请求中通常默认是这个</li>
<li> <code>multipart/form-data</code>：上传文件时我们需要用到这个格式</li>
<li> <code>application/xml</code>：XML数据格式</li>
<li> <code>text/html</code>：HTML格式</li>
<li> <code>text/plain</code>：纯文本格式</li>
<li> <code>image/png</code>：png图片格式</li>
</ul>
<h3 id="get请求常用数据类型"><a href="#get请求常用数据类型" class="headerlink" title="get请求常用数据类型"></a>get请求常用数据类型</h3><p>要么是拼接在URl 后面, 要么就是 QueryString的方式传递,Content-Type 的值就不是那么重要了。</p>
<h4 id="url-param"><a href="#url-param" class="headerlink" title="url param"></a>url param</h4><p>Restful 的规范允许把参数写在 url 中，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http://c1998.cn/api/person/1111</span><br></pre></td></tr></table></figure>

<p>这里的111就是路径中的参数 (url params)</p>
<h4 id="query"><a href="#query" class="headerlink" title="query"></a>query</h4><p>通过 url 中 ？后面的用 &amp; 分隔的字符串传递数据。比如：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">data</span> = &#123;</span><br><span class="line">	name:<span class="string">&#x27;coder&#x27;</span>,</span><br><span class="line">	age:<span class="number">111</span></span><br><span class="line">&#125;</span><br><span class="line">export <span class="keyword">const</span> getExceptionHandling  = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.axioseRquest(&#123;</span><br><span class="line">        url: <span class="string">&#x27;http://c1998.cn/api/person&#x27;</span>,</span><br><span class="line">        method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">        params: <span class="keyword">data</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际请求的路径是: <a href="http://c1998.cn/api/person?name=coder&amp;age=111">http://c1998.cn/api/person?name=coder&amp;age=111</a><br>通过URL传递数据的方式就这两种, 后面的3种是通过 body传递数据的方式</p>
<h3 id="post请求常用数据类型"><a href="#post请求常用数据类型" class="headerlink" title="post请求常用数据类型"></a>post请求常用数据类型</h3><h4 id="application-x-www-form-urlencoded"><a href="#application-x-www-form-urlencoded" class="headerlink" title="application/x-www-form-urlencoded"></a>application/x-www-form-urlencoded</h4><p>http 请求报文<br><img src="https://img-blog.csdnimg.cn/47f2e5ccfe6f439986ad7ec20bd68118.png#pic_center" alt="在这里插入图片描述"></p>
<p>qs.stringify()作用是将对象或者数组序列化成URL的格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">对象序列化</span><br><span class="line">let obj = &#123;</span><br><span class="line">methods: &#x27;queryStu&#x27;</span><br><span class="line">id: 1,</span><br><span class="line">name: &#x27;zdy&#x27;</span><br><span class="line">&#125;</span><br><span class="line">qs.stringify(obj)</span><br><span class="line">// methods=queryStu&amp;id=1&amp;name=zdy    这就是我们的传到服务器的url</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数组序列化</span><br><span class="line">let arr = [2,3]</span><br><span class="line">qs.stringify(&#123;a:arr&#125;)</span><br><span class="line">// &#x27;arr[0]=2&amp;arr[1]=3&#x27;</span><br><span class="line"></span><br><span class="line">这种格式可以进行转为序列化，但是url中会带有数组的下标a[0]、a[1]，这并不是我们一般的处理办法。常用方法如下：</span><br><span class="line">// 常用并推荐使用</span><br><span class="line">let arr = [2,3]</span><br><span class="line">qs.stringify(&#123;a:arr&#125;,&#123;indices:false&#125;);</span><br><span class="line">// &#x27;arr=2&amp;arr=3&#x27; 注意这个格式，一般我们常用的格式</span><br></pre></td></tr></table></figure>

<p>qs.parse()则就是反过来啦，将我们通过qs.stringify()序列化的对象或者数组转回去</p>
<h4 id="multipart-form-data"><a href="#multipart-form-data" class="headerlink" title="multipart/form-data"></a>multipart/form-data</h4><p> 一般用于上传文件、二进制数据、非 ASCII 字符的内容</p>
<p>通过 new FormData将文件转成二进制数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">const</span> formData = new FormData();</span><br><span class="line">  formData.append(<span class="string">&#x27;controlId&#x27;</span>, <span class="keyword">this</span>.node.itemId);</span><br><span class="line">  formData.append(<span class="string">&#x27;file&#x27;</span>, option.file);</span><br><span class="line">  formData.append(<span class="string">&#x27;roleId&#x27;</span>, <span class="keyword">this</span>.$refs.role.currentValue);</span><br><span class="line">  </span><br><span class="line">export <span class="keyword">const</span> getExceptionHandling  = (<span class="keyword">data</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.axioseRquest(&#123;</span><br><span class="line">    url: <span class="string">&#x27;http://c1998.cn/api/person&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    <span class="keyword">data</span>: formData</span><br><span class="line">    headers: &#123; <span class="string">&#x27;content-type&#x27;</span>: <span class="string">&#x27;multipart/form-data&#x27;</span> &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200119105200249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/20200119105635306.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMzNTkxOTAz,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>请求体首先随机生成了一个boundary字段，这个boundary用来分割不同的字段。</p>
<p>一个请求的参数，会以boundary开始，然后是附加信息(参数名称，文件路径等)，再空一行，最后是参数的内容</p>
<p>请求体最后再以boundary结束。</p>
<h4 id="json"><a href="#json" class="headerlink" title="json"></a>json</h4><p><img src="https://img-blog.csdnimg.cn/7e17447496834543b155e816fc17f66f.png#pic_center" alt="在这里插入图片描述"></p>
<p>现在绝大部分的请求都会以json形式进行传输</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对</p>
<p>x-www-form-urlencoded：只能上传键值对，并且键值对都是用&amp;间隔分开的。(用Qs库转换)</p>
<p>application/json: 以序列化的 JSON 字符串形式传输</p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p><a href="https://javascript.ruanyifeng.com/bom/cors.html">https://javascript.ruanyifeng.com/bom/cors.html</a></p>
<p><a href="https://wangdoc.com/javascript/bom/cors">https://wangdoc.com/javascript/bom/cors</a></p>
<h3 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h3><p><img src="https://img2022.cnblogs.com/blog/420532/202206/420532-20220622090900141-1679123227.png" alt="img"></p>
<p>同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议</p>
<p>举例说明：比如一个黑客程序，他利用<code>Iframe</code>把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过<code>Javascript</code>读取到你的表单中<code>input</code>中的内容，这样用户名，密码就轻松到手了。</p>
<h3 id="跨域请求分类"><a href="#跨域请求分类" class="headerlink" title="跨域请求分类"></a>跨域请求分类</h3><p>浏览器将跨域请求分为两大类: 简单请求和非简单请求.</p>
<p>同时满足以下条件的请求都为简单请求:</p>
<ul>
<li>请求方式为下列之一: <ul>
<li>GET</li>
<li>POST</li>
<li>HEAD</li>
</ul>
</li>
<li>人为设置以下集合外的请求头: <ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ul>
<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><h5 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h5><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。<strong>浏览器</strong>发现回应的头信息没有包含<strong>Access-Control-Allow-Origin</strong>字段，就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p>
<p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p>
<p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h5 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h5><p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等）。如果需要包含 Cookie 信息，一方面要服务器同意，指定<code>Access-Control-Allow-Credentials</code>字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<p>另一方面，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>

<p>否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，如果省略<code>withCredentials</code>设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果要发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p>
<h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><h5 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h5><p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。<strong>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中</strong>，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了<strong>防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力</strong>，给服务器一个提前拒绝的机会，这样可以防止服务器大量收到<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p>
<p>下面是一段浏览器的 JavaScript 脚本。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var url = &#x27;http://api.alice.com/cors&#x27;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;PUT&#x27;, url, true);</span><br><span class="line">xhr.setRequestHeader(&#x27;X-Custom-Header&#x27;, &#x27;value&#x27;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）<code>Access-Control-Request-Method</code></strong></p>
<p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p>
<p><strong>（2）<code>Access-Control-Request-Headers</code></strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h5 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h5><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure>

<p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPTIONS http://api.bob.com HTTP/1.1</span><br><span class="line">Status: 200</span><br><span class="line">Access-Control-Allow-Origin: https://notyourdomain.com</span><br><span class="line">Access-Control-Allow-Method: POST</span><br></pre></td></tr></table></figure>

<p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p>
<p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>

<p>服务器回应的其他 CORS 相关字段如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>

<p><strong>（1）<code>Access-Control-Allow-Methods</code></strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Headers</code></strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p>
<p><strong>（3）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）<code>Access-Control-Max-Age</code></strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），<strong>在此期间，不用发出另一条预检请求</strong>。</p>
<h5 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h5><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure>

<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure>

<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><p><img src="https://img2022.cnblogs.com/blog/420532/202206/420532-20220622090743322-561262700.png" alt="img"></p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p><strong>jsonp的原理</strong>：利用script标签可以跨域的原理实现。</p>
<p>html中通过动态创建一个script标签，通过它的src属性发送跨域请求，从服务器端响应的<strong>数据格式是一个函数的调用</strong>，函数名要一致。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> head = <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;head&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">script.src=<span class="string">&#x27;http::/1.html/1.php?callback=hello&amp;username=123&#x27;</span>;</span><br><span class="line"></span><br><span class="line">head.appendChild(script);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限制：</p>
<ul>
<li>只能发起GET请求</li>
</ul>
<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而<strong>克服了AJAX只能同源使用的限制</strong>。</p>
<p><strong>CORS 需要浏览器和服务器同时支持</strong>。目前，所有浏览器都支持该功能。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<p><strong>服务器端对于CORS的支持</strong>，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。</p>
<p>node后端代码支持跨域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app.use(async (ctx, next) =&gt; &#123;</span><br><span class="line">  ctx.set(&quot;Access-Control-Allow-Origin&quot;, ctx.headers.origin);</span><br><span class="line">  ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);</span><br><span class="line">  ctx.set(&quot;Access-Control-Request-Method&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;);</span><br><span class="line">  ctx.set(</span><br><span class="line">    &quot;Access-Control-Allow-Headers&quot;,</span><br><span class="line">    &quot;Origin, X-Requested-With, Content-Type, Accept, cc&quot;</span><br><span class="line">  );</span><br><span class="line">  if (ctx.method === &quot;OPTIONS&quot;) &#123;</span><br><span class="line">    ctx.status = 204;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  await next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>优势：</p>
<ul>
<li>在服务端进行控制是否允许跨域，可自定义规则</li>
<li>支持各种请求方式</li>
</ul>
<p>缺点：</p>
<ul>
<li>会产生额外的请求</li>
</ul>
<h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而 且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain</p>
<h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有 的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是 持久存在一个窗口载入过的所有页面中的 </p>
<p>使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容 到几乎所有浏览器，这真是极好的一种跨域方法。</p>
<h4 id="Nginx-代理服务器配置跨域"><a href="#Nginx-代理服务器配置跨域" class="headerlink" title="Nginx 代理服务器配置跨域"></a><strong>Nginx 代理服务器配置跨域</strong></h4><p>使用 Nginx 代理服务器之后，请求不会直接到达我们的 Node.js 服务器端，请求会先经过 Nginx 在设置一些跨域等信息之后再由 Nginx 转发到我们的 Node.js 服务端，所以这个时候我们的 Nginx 服务器去监听的 3011 端口，我们把 Node.js 服务的端口修改为 30011，简单配置如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen          3011;</span><br><span class="line">  server_name     localhost;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;http://127.0.0.1:3010&#x27;;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;PUT,DELETE&#x27;;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Test-CORS, Content-Type&#x27;;</span><br><span class="line">      add_header &#x27;Access-Control-Max-Age&#x27; 1728000;</span><br><span class="line">      add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">      add_header &#x27;Content-Length&#x27; 0;</span><br><span class="line">      return 204;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;http://127.0.0.1:3010&#x27;;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line"></span><br><span class="line">    proxy_pass http://127.0.0.1:30011;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：需要在nginx进行额外配置，语义不清晰</p>
<h3 id="跨域操作cookie"><a href="#跨域操作cookie" class="headerlink" title="跨域操作cookie"></a>跨域操作cookie</h3><p>需要满足3个条件：</p>
<p>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。<br>浏览器发起ajax需要指定withCredentials 为true<br>响应头中的Access-Control-Allow-Origin一定不能为*，必须是特定的域名</p>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><p><a href="https://mp.weixin.qq.com/s/WqJTHnHMsqvqAWjjJqyfsw">https://mp.weixin.qq.com/s/WqJTHnHMsqvqAWjjJqyfsw</a></p>
<h3 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h3><h4 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h4><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。</p>
<p>攻击者往Web页面里插入恶意 html标签或者javascript代码。比 如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表 单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</p>
<h5 id="存储型XSS攻击"><a href="#存储型XSS攻击" class="headerlink" title="存储型XSS攻击"></a>存储型XSS攻击</h5><p>会经常发生在内容驱动、用户保存数据的社区网站上，比如具备论坛发帖、商品评论、用户私信等功能的网站，危害比较大，可以说是永久型的</p>
<p>攻击者事先将恶意脚本代码提交到目标网站服务端数据库内（通过用户提交时夹杂脚本代码）<br>当用户打开该目标网站时，服务端将恶意代码取出拼接HTML返回给浏览器<br>用户浏览器接收到响应后立即执行，而恶意的脚本代码也被自动执行，从而冒充用户，窃取用户数据发送到攻击者网站，或者调用接口执行其他操作<br><img src="img/%E5%89%8D%E7%AB%AF/%E6%80%BB%E7%BB%93/c0d86005b67147b2aa7f09cea37df60c.png" alt="c0d86005b67147b2aa7f09cea37df60c"></p>
<h5 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h5><p>反射型XSS漏洞常见于具有通过URL传递参数的功能网站，如网站搜索、跳转等，需要引导用户主动打开URL，和存储型XSS攻击的区别是反射型存储在URL中，存储型存储在数据库中</p>
<p>攻击者通过混杂入恶意脚本构造恶意的URL<br>用户点击打开含有恶意脚本的URL，网站服务端将恶意代码从URL中取出，拼接在HTML返回给浏览器<br>用户接收到后，浏览器执行恶意代码，同上，窃取用户数据或者调取接口执行操作<br><img src="img/前端/总结/0657ed61def749e7a74e13a898d0c18d.png" style="zoom:50%;" /></p>
<h5 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h5><p>DOM型XSS攻击主要是前端浏览器直接取出恶意代码，而前两者是由后端先取出再拼接返回。</p>
<p>攻击者利用恶意脚本构造恶意URL<br>用户直接点开恶意的URL，浏览器响应后直接解析执行，前端JS取出URL并执行<br>浏览器执行恶意代码，同上，窃取用户数据或者调取接口执行操作<br>比如是诱导用户点击后往img标签src属性里插入恶意脚本等</p>
<p>以上三种XSS攻击主要都是要攻击者构造恶意的脚本执行攻击，存储型和反射型主要是后端安全问题，DOM型主要是前端安全问题</p>
<h5 id="XSS防范方法"><a href="#XSS防范方法" class="headerlink" title="XSS防范方法"></a>XSS防范方法</h5><p> 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容 写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过 一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价 值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单</p>
<h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4><p>Cross Site Request Forgery，跨站请求伪造，字面理解意思就是在别的站点伪造了一个请求。专业术语来说就是在受害者访问一个网站时，其 Cookie 还没有过期的情况下，攻击者伪造一个链接地址发送受害者并欺骗让其点击，从而形成 CSRF 攻击。</p>
<p>eg:David 无意间打开了 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/zHYsKHjf0ng0DPsEaWQULZjqQ8Sw6KICkbQpPuo0GrtWLqYpw5aehchurtbqo0ibfvkls6mNWxHiaSOoMQIeHmoA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>首先 David 发起登录 Gmail 邮箱请求，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。</li>
<li>接着黑客通过各种手段引诱 David 去打开他的链接，比如 hacker.com，然后在 hacker.com 页面中，黑客编写好了一个邮件过滤器，并通过 Gmail 提供的 HTTP 设置接口设置好了新的邮件过滤功能，该过滤器会将 David 所有的邮件都转发到黑客的邮箱中。</li>
<li>最后的事情就很简单了，因为有了 David 的邮件内容，所以黑客就可以去域名服务商那边重置 David 域名账户的密码，重置好密码之后，就可以将其转出到黑客的账户了。</li>
</ul>
<p>如何防止 CSRF 攻击，具体来讲主要有三种方式：充分利用好 Cookie 的 SameSite 属性、验证请求的来源站点和使用 CSRF Token。</p>
<p><strong>网页验证码是干嘛的，是为了解决什么安全问题</strong></p>
<ul>
<li>区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水</li>
<li>有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试</li>
</ul>
<h4 id="XSS与CSRF区别"><a href="#XSS与CSRF区别" class="headerlink" title="XSS与CSRF区别"></a><strong>XSS与CSRF区别</strong></h4><ul>
<li><code>XSS</code>是获取信息，不需要提前知道其他用户页面的代码和数据包。</li>
<li><code>CSRF</code>是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次<code>CSRF</code>攻击，受害者必须依次完成两个步骤<ul>
<li>登录受信任网站<code>A</code>，并在本地生成<code>Cookie</code></li>
<li>在不登出<code>A</code>的情况下，访问危险网站<code>B</code></li>
</ul>
</li>
</ul>
<h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><p>重放攻击(Replay Attacks)又称重播攻击、回放攻击，是指<code>攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的</code>，主要用于身份认证过程，破坏认证的正确性。<br>重放攻击可以由<code>发起者</code>，也可以由<code>拦截并重发该数据的敌方</code>进行。攻击者利用网络监听或者其他方式盗取认证凭据，之后再把它重新发给认证服务器。<br>重放攻击在任何网络通信过程中都可能发生，是计算机世界黑客<code>常用的攻击方式之一</code></p>
<p>重放攻击的基本原理就是把以前<a href="https://baike.baidu.com/item/%E7%AA%83%E5%90%AC/1624599?fromModule=lemma_inlink">窃听</a>到的数据原封不动地重新发送给接收方。很多时候，网络上传输的数据是<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%AF%86/752748?fromModule=lemma_inlink">加密</a>过的，此时窃听者无法得到数据的准确意义。但如果他知道这些数据的作用，就可以在不知道数据内容的情况下通过再次发送这些数据达到愚弄接收端的目的。例如，有的系统会将鉴别信息进行简单加密后进行传输，这时攻击者虽然无法窃听<a href="https://baike.baidu.com/item/%E5%AF%86%E7%A0%81/65553?fromModule=lemma_inlink">密码</a>，但他们却可以首先截取加密后的口令然后将其重放，从而利用这种方式进行有效的攻击。再比如，假设网上存款系统中，一条消息表示用户支取了一笔存款，攻击者完全可以多次发送这条消息而偷窃存款。</p>
<p><strong>防御方案</strong><br>(1)加随机数。该方法优点是认证双方不需要时间同步，双方记住使用过的随机数，如发现报文中有以前使用过的随机数，就认为是重放攻击。缺点是需要额外保存使用过的随机数，若记录的时间段较长，则保存和查询的开销较大。<br>(2)加时间戳。该方法优点是不用额外保存其他信息。缺点是认证双方需要准确的时间同步，同步越好，受攻击的可能性就越小。但当系统很庞大，跨越的区域较广时，要做到精确的时间同步并不是很容易<br>(3)加流水号。就是双方在报文中添加一个逐步递增的整数，只要接收到一个不连续的流水号报文(太大或太小)，就认定有重放威胁。该方法优点是不需要时间同步，保存的信息量比随机数方式小。但是一旦攻击者对报文解密成功，就可以获得流水号，从而每次将流水号递增欺骗认证端。</p>
<h3 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a><code>sql</code>注入</h3><p>原理：就是通过把<code>SQL</code>命令插入到<code>Web</code>表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令</p>
<ul>
<li>总的来说有以下几点<ul>
<li>永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双<code>&quot;-&quot;</code>进行转换等</li>
<li>永远不要使用动态拼装SQL，可以使用参数化的<code>SQL</code>或者直接使用存储过程进行数据查询存取</li>
<li>永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接</li>
<li>不要把机密信息明文存放，请加密或者<code>hash</code>掉密码和敏感的信息</li>
</ul>
</li>
</ul>
<h1 id="html"><a href="#html" class="headerlink" title="html"></a>html</h1><h2 id="html标签"><a href="#html标签" class="headerlink" title="html标签"></a>html标签</h2><p>文本加粗标签   <strong></strong> <b></b>&gt; 工作里尽量使用strong</p>
<p>文本倾斜标签    <em></em>&gt;     <i></i>&gt;    工作里尽量使用em</p>
<p>删除线标签    <del></del>&gt;    <s></s>&gt;    工作里尽量使用del</p>
<p>下划线标签    <ins></ins>&gt;    <u></u>      工作里尽量使用ins</p>
<p> <sup>上标</sup>  <sub>下标</sub></p>
<p>超链接a:属性target,’_self’在自身页面打开，’_blank’打开一个新页面</p>
 <base target="_blank">  让所有的超链接都在新窗口打开

<p>锚链接：<p id="sd"></p>    <a href="#sd">回到顶部</a></p>
<p>关键字：<mate name="keyword" content=""></p>
<p>网页描述:<mate name="description" content=""></p>
<p>网页重定向：<mate http-equiv="refresh" content="5;http://www.baidu.com"></p>
<p>设置icon图标：<link rel="icon" href="xxx.ico"></p>
<p>img:<code>title</code>当鼠标滑动到元素上的时候显示,<code>alt</code>是<code>&lt;img&gt;</code>的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>    <table><br>        <caption>23</caption><br>        <thead><br>            <th>1</th><br>            <th>2</th><br>            <th></th><br>        </thead><br>        <tbody><br>            <tr><br>                <td>1</td><br>                <td>1</td><br>                <td>1</td><br>            </tr><br>        </tbody><br>    </table></p>
<p>cellspacing：表示各单元格之间的空隙</p>
<p>cellpadding：表示单元格内容与单元格边界之间的距离</p>
<p>边框合并  </p>
<p>colspan=”2” 合并同一行上的单元格</p>
<p>rowspan=”2” 合并同一列上的单元格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">table    &#123; display: table &#125;</span><br><span class="line">tr       &#123; display: table-row &#125;</span><br><span class="line">thead    &#123; display: table-header-group &#125;</span><br><span class="line">tbody    &#123; display: table-row-group &#125;</span><br><span class="line">tfoot    &#123; display: table-footer-group &#125;</span><br><span class="line">col      &#123; display: table-column &#125;</span><br><span class="line">colgroup &#123; display: table-column-group &#125;</span><br><span class="line">td, th   &#123; display: table-cell &#125;</span><br><span class="line">caption  &#123; display: table-caption &#125;</span><br><span class="line">HTML Table是指使用原生的&lt;table&gt;标签，而CSS Table是指用CSS属性模仿HTML 表格的模型。</span><br><span class="line">display:table最常见的例子了。对于动态高度的元素，有了它，就可以实现真正的垂直（居中）对齐。</span><br></pre></td></tr></table></figure>

<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><fieldset></fieldset>  对表单信息分组

<legend>分组</legend>   表单信息分组名称

<optgroup label=""></optgroup>  对下拉列表select进行分组。Label=”” 分组名称。

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  &lt;fieldset&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;legend&gt;信息分组名称&lt;/legend&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;select name=&quot;&quot; id=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;optgroup label=&quot;1&quot;&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">​        &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt;</span><br><span class="line"></span><br><span class="line">​      &lt;/optgroup&gt;</span><br><span class="line"></span><br><span class="line">​    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/fieldset&gt;</span><br></pre></td></tr></table></figure>

<p><strong>表单元素属性</strong></p>
<ul>
<li>value 用于大部分表单元素的内容获取(option除外)</li>
<li>type 可以获取input标签的类型(输入框或复选框等)</li>
<li>disabled 禁用属性</li>
<li>checked 复选框选中属性</li>
<li>selected 下拉菜单选中属性</li>
</ul>
<h3 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a><strong>iframe</strong></h3><h4 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h4><ul>
<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于<code>SEO</code></li>
<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>
</ul>
<p>实际应用中，iframe可以当作一个子模块，像vue单一应用那样，选择菜单栏的选项，就切换页面相应的子模块。而使用原生的话，选择菜单栏的选项，就<strong>请求</strong>相应的iframe模块。</p>
<blockquote>
<p>如何知道是iframe模块？</p>
<p>右键点击，出现重新加载框架，点击重新加载框架，就局部加载该iframe模块</p>
</blockquote>
<h4 id="iframe-父页面与子页面之间-postMessage-通信"><a href="#iframe-父页面与子页面之间-postMessage-通信" class="headerlink" title="iframe 父页面与子页面之间 postMessage() 通信"></a>iframe 父页面与子页面之间 <code>postMessage()</code> 通信</h4><p><a href="https://drylint.com/HTML/iframe%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%B8%8E%E7%88%B6%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1.html#postmessage-%E6%96%B9%E6%B3%95">https://drylint.com/HTML/iframe%E5%AD%90%E9%A1%B5%E9%9D%A2%E4%B8%8E%E7%88%B6%E9%A1%B5%E9%9D%A2%E9%80%9A%E4%BF%A1.html#postmessage-%E6%96%B9%E6%B3%95</a></p>
<h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>textarea文本域在页面中是可以拖动的，即时你给了固定的宽度和高度，但这在我们页面布局中，使我们不需要的，因为可拖拽很多时候会影响我们页面的布局和整体的美观度。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">textarea &#123;</span><br><span class="line">    width:700px;</span><br><span class="line">    height:300px;</span><br><span class="line">    border:1px solid #bcbcbc;</span><br><span class="line">    resize:none;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>resize：</p>
<p>　　1.both(默认值)–在xy方向上均可以拖拽；</p>
<p>　　2.vertical–在垂直方向上</p>
<p>　　3.horizontal–在水平方向上</p>
<p>　　4.none–不可以拖拽</p>
<p>　　5.inherit（继承）–textarea的父集一般是div元素，所以设置为继承的话，也是不可以拖拽的</p>
<ul>
<li>- </li>
</ul>
<h2 id="html5标签"><a href="#html5标签" class="headerlink" title="html5标签"></a>html5标签</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><code>HTML5</code> 现在已经不是 <code>SGML</code> 的子集，主要是关于图像，位置，存储，多任务等功能的增加</p>
<ul>
<li>新增选择器 <code>document.querySelector</code>、<code>document.querySelectorAll</code></li>
<li>拖拽释放(<code>Drag and drop</code>) API</li>
<li>媒体播放的 <code>video</code> 和 <code>audio</code></li>
<li>本地存储 <code>localStorage</code> 和 <code>sessionStorage</code></li>
<li>离线应用 <code>manifest</code></li>
<li>桌面通知 <code>Notifications</code></li>
<li>语意化标签 <code>article</code>、<code>footer</code>、<code>header</code>、<code>nav</code>、<code>section</code></li>
<li>增强表单控件 <code>calendar</code>、<code>date</code>、<code>time</code>、<code>email</code>、<code>url</code>、<code>search</code></li>
<li>地理位置 <code>Geolocation</code></li>
<li>多任务 <code>webworker</code></li>
<li>全双工通信协议 <code>websocket</code></li>
<li>历史管理 <code>history</code></li>
<li>跨域资源共享(CORS) <code>Access-Control-Allow-Origin</code></li>
<li>页面可见性改变事件 <code>visibilitychange</code></li>
<li>跨窗口通信 <code>PostMessage</code></li>
<li><code>Form Data</code> 对象</li>
<li>绘画 <code>canvas</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">list</span>=<span class="string">&quot;input_list&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;input_list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;laoma&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;lisi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!--点击展示详细信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>HTML 5<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>This slide deck teaches you everything you need to know about HTML 5.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--小窗口--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--进度条--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">progress</span>&gt;</span>working...<span class="tag">&lt;/<span class="name">progress</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;100&quot;</span> <span class="attr">low</span>=<span class="string">&quot;40&quot;</span> <span class="attr">high</span>=<span class="string">&quot;90&quot;</span> <span class="attr">optimum</span>=<span class="string">&quot;100&quot;</span> <span class="attr">value</span>=<span class="string">&quot;91&quot;</span>&gt;</span>A+<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">method</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;image&quot;</span> <span class="attr">src</span>=<span class="string">&quot;toy.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- file text password radio checkbox button image submit reset select button --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span> <span class="attr">value</span>=<span class="string">&quot;some@email.com&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;date&quot;</span> <span class="attr">min</span>=<span class="string">&quot;2010-08-14&quot;</span> <span class="attr">max</span>=<span class="string">&quot;2011-08-14&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2010-08-14&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;range&quot;</span> <span class="attr">min</span>=<span class="string">&quot;0&quot;</span> <span class="attr">max</span>=<span class="string">&quot;50&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;search&quot;</span> <span class="attr">results</span>=<span class="string">&quot;10&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Search...&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;tel&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;(555) 555-5555&quot;</span> <span class="attr">pattern</span>=<span class="string">&quot;^\(?\d&#123;3&#125;\)?[-\s]\d&#123;3&#125;[-\s]\d&#123;4&#125;.*?$&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;color&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;e.g. #bbbbbb&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">step</span>=<span class="string">&quot;1&quot;</span> <span class="attr">min</span>=<span class="string">&quot;-5&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> <span class="attr">value</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h3><p><strong>标签语义化</strong>：尽可能少的使用无语义的标签div和span；</p>
<ul>
<li>合理的<code>title</code>、<code>description</code>、<code>keywords</code>：搜索对着三项的权重逐个减小，<code>title</code>值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面<code>title</code>要有所不同；<code>description</code>把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面<code>description</code>有所不同；<code>keywords</code>列举出重要关键词即可</li>
<li>语义化的<code>HTML</code>代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>
<li>重要内容<code>HTML</code>代码放在最前：搜索引擎抓取<code>HTML</code>顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
<li>重要内容不要用<code>js</code>输出：爬虫不会执行js获取内容</li>
<li>少用<code>iframe</code>：搜索引擎不会抓取<code>iframe</code>中的内容</li>
<li>非装饰性图片必须加<code>alt</code></li>
<li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
</ul>
<h3 id="Doctype作用"><a href="#Doctype作用" class="headerlink" title="Doctype作用"></a>Doctype作用</h3><ul>
<li><code>&lt;!DOCTYPE&gt;</code> 声明位于文档中的最前面，处于 <code>&lt;html&gt;</code> 标签之前。告知浏览器的解析器， 用什么文档类型 规范来解析这个文档</li>
<li>严格模式的排版和 <code>JS</code> 运作模式是 以该浏览器支持的最高标准运行</li>
<li>在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。</li>
<li>DOCTYPE 不存在或格式不正确会导致文档以混杂模式呈现</li>
</ul>
<h3 id="严格模式与混杂模式"><a href="#严格模式与混杂模式" class="headerlink" title="严格模式与混杂模式"></a>严格模式与混杂模式</h3><p><strong>严格模式的限制</strong></p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用with语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀0表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量<code>delete prop</code>，会报错，只能删除属性<code>delete global[prop]</code></li>
<li><code>eval</code>不会在它的外层作用域引入变量</li>
<li><code>eval</code>和<code>arguments</code>不能被重新赋值</li>
<li><code>arguments</code>不会自动反映函数参数的变化</li>
<li>不能使用<code>arguments.callee</code></li>
<li>不能使用<code>arguments.caller</code></li>
<li>禁止<code>this</code>指向全局对象</li>
<li>不能使用<code>fn.caller</code>和<code>fn.arguments</code>获取函数调用的堆栈</li>
<li>增加了保留字（比如<code>protected</code>、<code>static</code>和<code>interface</code>）</li>
</ul>
<h3 id="Charset编码"><a href="#Charset编码" class="headerlink" title="Charset编码"></a><strong>Charset编码</strong></h3><p>Ascll    Ansi    Unicode  Gbk     Gb2312    Big5    Utf-8  通用字符集</p>
<h3 id="src-与-href-的区别"><a href="#src-与-href-的区别" class="headerlink" title="src 与 href 的区别"></a>src 与 href 的区别</h3><p>src 用于替换当前元素，href 用于在当前文档和引用资源之间确立联系。 </p>
<p>src 是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在 </p>
<p>位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片 </p>
<p>和 frame 等元素。 </p>
<script src =”js.js”></script> 

<p>当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行 </p>
<p>完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 </p>
<p>js 脚本放在底部而不是头部。 </p>
<p>href 是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点） </p>
<p>或当前文档（链接）之间的链接，如果我们在文档中添加 </p>
<link href="common.css" rel="stylesheet"/> 

<p>那么浏览器会识别该文档为 css 文件，就会并行下载资源并且不会停止对当前文档的处理。 </p>
<p>这也是为什么建议使用 link 方式来加载 css，而不是使用@import 方式。</p>
<h3 id="XML和JSON的区别"><a href="#XML和JSON的区别" class="headerlink" title="XML和JSON的区别"></a>XML和JSON的区别</h3><ul>
<li>数据体积方面<ul>
<li><code>JSON</code>相对<code>于XML</code>来讲，数据的体积小，传递的速度更快些。</li>
</ul>
</li>
<li>数据交互方面<ul>
<li><code>JSON</code>与<code>JavaScript</code>的交互更加方便，更容易解析处理，更好的数据交互</li>
</ul>
</li>
<li>数据描述方面<ul>
<li><code>JSON</code>对数据的描述性比<code>XML</code>较差</li>
</ul>
</li>
<li>传输速度方面<ul>
<li><code>JSON</code>的速度要远远快于<code>XML</code></li>
</ul>
</li>
</ul>
<h1 id="css"><a href="#css" class="headerlink" title="css"></a>css</h1><h2 id="class命名规范"><a href="#class命名规范" class="headerlink" title="class命名规范"></a>class命名规范</h2><p><a href="https://www.cnblogs.com/yyzyou/p/7920023.html">https://www.cnblogs.com/yyzyou/p/7920023.html</a></p>
<h3 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h3><p>头：header</p>
<p>页面主体：main</p>
<p>内容：content/container</p>
<p>侧栏：sidebar</p>
<p>栏目：column</p>
<p>页面外围控制整体布局宽度：wrapper</p>
<p>方向：left right center top bottom</p>
<p>内部： in</p>
<p>尾：footer</p>
<p>版权：copyright</p>
<h3 id="菜单和导航"><a href="#菜单和导航" class="headerlink" title="菜单和导航"></a>菜单和导航</h3><p>导航：nav</p>
<p>　　主导航：mainbav</p>
<p>　　子导航：subnav</p>
<p>　　顶导航：topnav</p>
<p>　　边导航：sidebar</p>
<p>　　左导航：leftsidebar</p>
<p>　　右导航：rightsidebar</p>
<p>菜单：menu</p>
<p>　　子菜单：submenu</p>
<p>​       下拉菜单:dropmenv</p>
<p>标签页：tab</p>
<h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><table>
<thead>
<tr>
<th>文章列表：list</th>
<th align="center">提示信息：msg</th>
<th>小技巧：tips</th>
</tr>
</thead>
<tbody><tr>
<td>栏目标题：title</td>
<td align="center">字体：font</td>
<td>注释：note</td>
</tr>
<tr>
<td>文本：text</td>
<td align="center">摘要: summary</td>
<td></td>
</tr>
<tr>
<td></td>
<td align="center"></td>
<td></td>
</tr>
</tbody></table>
<h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><table>
<thead>
<tr>
<th>加入：joinus</th>
<th>指南：guild</th>
<th>服务：service</th>
</tr>
</thead>
<tbody><tr>
<td>注册：regsiter</td>
<td>投票：vote</td>
<td>滚动：scroll</td>
</tr>
<tr>
<td>下载：download</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><table>
<thead>
<tr>
<th>当前的: current</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><table>
<thead>
<tr>
<th align="center">登录条：loginbar</th>
<th align="center">广告：banner</th>
<th align="center">功能区：shop</th>
</tr>
</thead>
<tbody><tr>
<td align="center">按钮：btn</td>
<td align="center">图标: icon</td>
<td align="center">线：line</td>
</tr>
<tr>
<td align="center">热点：hot</td>
<td align="center">新闻：news</td>
<td align="center">合作伙伴：partner</td>
</tr>
<tr>
<td align="center">友情链接：friendlink</td>
<td align="center">版权：copyright</td>
<td align="center">标签:label</td>
</tr>
<tr>
<td align="center">图片：pic</td>
<td align="center">首页：homepage</td>
<td align="center">模态：modal</td>
</tr>
<tr>
<td align="center">名片：card</td>
<td align="center">通知：notification</td>
<td align="center">平台：platform</td>
</tr>
<tr>
<td align="center">优惠券：coupon</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="行内元素和块元素"><a href="#行内元素和块元素" class="headerlink" title="行内元素和块元素"></a>行内元素和块元素</h2><p><a href="https://blog.csdn.net/Jwhahaha/article/details/102483938">https://blog.csdn.net/Jwhahaha/article/details/102483938</a></p>
<h3 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h3><p>可以设置宽高，独自占据一行高度（float浮动除外），一般可以作为其他容器使用，可容纳块级元素和行内元素。块级元素有以下特点：</p>
<ul>
<li>每个块级元素都是独自占一行。 </li>
<li>元素的高度、宽度、行高和边距都是可以设置的。　　 </li>
<li>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%）,<strong>高度由内容撑开</strong></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">h1~h6:标题标签，用于标记网页中的大标题，依次从大到小</span><br><span class="line">p：用于标记网页中的段落性文字，默认占满横向区域</span><br><span class="line">div：划分，分隔，作用是就是将页面划分为不同的区域，不设置宽高时，高度有内容撑开，宽度和父级元素一样宽</span><br><span class="line">section：区段，是用来定义文档的某个区域，章节</span><br><span class="line">nav：标签定义导航链接的部分，提示：如果文档中有“前后”按钮，则应该把它放到nav元素中。</span><br><span class="line">header：标签定义文档的页眉</span><br><span class="line">footer：标签定义文档或节的页脚，页脚通常包含文档的作者、版权信息、使用条款链接、联系信息等等</span><br><span class="line">pre：格式标签，被包围在pre元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体。</span><br><span class="line">address： 标签定义文档或文章的作者/拥有者的联系信息，元素中的文本通常呈现为斜体，大多数浏览器会在 address 元素前后添加折行</span><br><span class="line">audio：音频使用，背景音乐播放，属性autoplay自动播放，loop循环播放，src要播放的音频，controls为音频提供播放控件，比如播放按钮。preload规定是否在页面加载后载入音频，如果设置了 autoplay 属性，则忽略该属性。</span><br><span class="line">/ 表格标签 /</span><br><span class="line">table：用于显示一个表格，不能设置宽高，宽高被内容撑开，设置宽度而内部的td没有宽度时，td会按照内容长度的比例拉伸</span><br><span class="line">thead：表头，用于显示一列的名称，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tbody：表主体，一般省略不写，浏览器在解析时会自动添加</span><br><span class="line">tr：表示一行</span><br><span class="line">th：表头中的第一个单元格</span><br><span class="line">td：表示主体中的单元格，有属性rowspan合并单元格，合并行。colspan合并列</span><br><span class="line">/ 有序列表，无序列表 /</span><br><span class="line">ul：无序列表</span><br><span class="line">ol：有序列表</span><br><span class="line">li：列表项</span><br><span class="line">dl：定义列表，用于描述类表中的项目（dt（dd））</span><br></pre></td></tr></table></figure>

<h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素 inline"></a><strong>行内元素 inline</strong></h3><p>行内元素不可以设置宽（width）和高（height），但可以与其他行内元素位于同一行，行内元素内一般不可以包含块级元素。行内元素的宽和高就是内容撑开的宽高。。行内元素有以下特点： </p>
<ul>
<li><p>每一个行内元素可以和别的行内元素共享一行，相邻的行内元素会排列在同一行里，直到一行排不下了，才会换行。 </p>
</li>
<li><p>行内元素的高度、宽度、行高不可设置。 </p>
</li>
<li><p>元素的宽度就是它包含的文字或图片的宽度，不可改变。</p>
</li>
<li><p><strong>行内元素不能设置宽高，和竖直方向的margin、padding ,但左右可以</strong></p>
</li>
</ul>
<p>常见行内元素有以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">span：是超文本标记语言（HTML）的行内标签，被用来组合文档中的行内元素，span没有固定的格式表现，当对它应用样式时，它会产生视觉上的变化</span><br><span class="line"></span><br><span class="line">a：标记网页中的超链接，点击可以打开或者跳转到另一个网页，也可以链接到一个要下载的文件</span><br><span class="line">有属性：href：要链接到的资源地址，target:打开的链接方式，值_blank:表示新打开一个窗口打开目标地址</span><br><span class="line">strong：标记页面中的粗体文本，语义化标签，除了文本加粗之外，还有强调的预期，表示标签中的内容是页面中需要重点关注的内容</span><br><span class="line"></span><br><span class="line">b：标记网页中的粗体文本，仅仅将文本加粗，标签中的内容不再强调</span><br><span class="line">s：删除线，仅仅是删除的效果</span><br><span class="line">del：具有删除语义，delete删除</span><br><span class="line">em：强调文本，斜体展示</span><br><span class="line">sup：上标</span><br><span class="line">sub：下标</span><br></pre></td></tr></table></figure>

<h3 id="行内块级元素-inline-block"><a href="#行内块级元素-inline-block" class="headerlink" title="行内块级元素 inline-block"></a><strong>行内块级元素 inline-block</strong></h3><p>行内块级元素，它既具有块级元素的特点，也有行内元素的特点，它可以自由设置元素宽度和高度，也可以在一行中放置多个行内块级元素。比如input、img就是行内块级元素，它可以设置高宽以及一行多个。具体特点如下：</p>
<ul>
<li>和其他行内或行内块级元素元素放置在同一行上；</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img：用于标记网页中的图像 ，有属性src:图片资源路径 ，alt:提示信息 当图片加载失败 ，以指定文本形式代替图片显示</span><br><span class="line">button：按钮</span><br><span class="line">input：输入框，有属性type输入框类型，有属性值（text表示文本输入框，file文件选择器，password密码输入框，email邮箱输入框，number数字输入框，button按钮）。placeholder占位字符，用于提示输入框应该输入的内容。value表示输入框中的内容。name和后台服务器交互时，必须携带name属性，发送请求时的参数名。</span><br><span class="line"></span><br><span class="line">单选 type=“radio” 表示一个单选选项处于同一组单选框只能选中一个值，将多个radio的name属性值设置为相同的值</span><br><span class="line">type=&quot;checkbox&quot;复选框</span><br><span class="line"></span><br><span class="line">label:和input标签绑定到一块使用，有属性for，属性值就是input输入框的id值。checked属性为标签选中状态</span><br><span class="line">select:下拉列表</span><br><span class="line">option:下拉选项</span><br></pre></td></tr></table></figure>

<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h3><p><img src="https://i0.hdslb.com/bfs/article/8893357747d83ffb476629f3bd8e5bd25e202cdd.jpg@942w_423h_progressive.webp" alt="img"></p>
<ol>
<li><p>在属性后面使用 !important 会覆盖页面内任何位置定义的元素样式。</p>
</li>
<li><p>作为style属性写在元素内的样式        优先级1000</p>
</li>
<li><p>id选择器                                        优先级100</p>
</li>
<li><p>类选择器和<strong>伪类和属性</strong>                       优先级10</p>
</li>
<li><p>标签选择器和<strong>伪元素</strong>                        优先级1</p>
</li>
<li><p>通配符选择器                                 优先级0</p>
</li>
<li><p>浏览器自定义或继承                    没有优先级</p>
<p><strong>总结排序：!important &gt; 行内样式&gt;ID选择器 &gt; 类选择器 &gt; 标签 &gt; 通配符 &gt; 继承 &gt; 浏览器默认属性</strong></p>
</li>
<li><p>当权值相等时，后定义的样式表要优于先定义的样式表。</p>
</li>
<li><p>交集/后代选择器的优先级 所有优先级 加起来 运算 然后比较</p>
</li>
<li><p>并集的话 就是各算各的。</p>
</li>
</ol>
<h3 id="组合选择器"><a href="#组合选择器" class="headerlink" title="组合选择器"></a>组合选择器</h3><ul>
<li><p>相邻兄弟选择器 A + B，选择紧接在A后的B元素(A和B中间不能有元素)，且二者有相同的父元素</p>
</li>
<li><p>普通兄弟选择器 A ~ B，选择紧接在A后的<strong>所有B元素</strong>(A和B中间可以有元素)，且二者有相同的父元素</p>
</li>
<li><p>子选择器     A &gt; B</p>
</li>
<li><p>后代选择器 A  B</p>
</li>
<li><p>交集 A.B{} </p>
</li>
<li><p>并集 A, B｛｝ </p>
</li>
</ul>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 存在title属性的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[title]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值匹配&quot;https://example.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href=<span class="string">&quot;https://example.org&quot;</span>]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值包含&quot;example&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href*=<span class="string">&quot;example&quot;</span>]</span></span><br><span class="line"><span class="comment">/* 存在href属性并且属性值结尾是&quot;.org&quot;的&lt;a&gt; 元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href$=<span class="string">&quot;.org&quot;</span>]</span> </span><br><span class="line"><span class="comment">/* 存在class属性并且属性值包含以空格分隔的&quot;logo&quot;的&lt;a&gt;元素 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[class~=<span class="string">&quot;logo&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>用来表示定位元素的某种状态所显示的样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a:link&#123;属性:值;&#125;       链接默认状态	 </span><br><span class="line">a:visited&#123;属性:值;&#125;     链接访问之后的状态 </span><br><span class="line">a:hover&#123;属性:值;&#125;      鼠标放到链接上显示的状态  	a:active&#123;属性:值;&#125;      链接激活的状态</span><br><span class="line">a:focus&#123;属性:值；&#125;     获取焦点</span><br></pre></td></tr></table></figure>

<ul>
<li><code>p:first-of-type</code> 选择属于其父元素的首个<code>&lt;p&gt;</code>元素的每个<code>&lt;p&gt;</code> 元素。</li>
<li><code>p:last-of-type</code> 选择属于其父元素的最后 <code>&lt;p&gt;</code> 元素的每个<code>&lt;p&gt;</code> 元素。</li>
<li><code>p:only-of-type</code> 选择属于其父元素唯一的 <code>&lt;p&gt;</code>元素的每个 <code>&lt;p&gt;</code> 元素。</li>
<li><code>p:only-child</code> 选择属于其父元素的唯一子元素的每个 <code>&lt;p&gt;</code> 元素。</li>
<li><code>p:nth-child(2)</code> 选择属于其父元素的第二个子元素的每个 <code>&lt;p&gt;</code> 元素。</li>
<li><code>p:nth-of-type(n)</code> 选择E的父元素下的第n个E元素</li>
<li><code>:after</code> 在元素之前添加内容,也可以用来做清除浮动。</li>
<li><code>:before</code> 在元素之后添加内容。</li>
<li><code>:enabled</code> 已启用的表单元素。</li>
<li><code>:disabled</code> 已禁用的表单元素。</li>
<li><code>:checked</code> 单选框或复选框被选中。</li>
<li><code>:empty</code> 选中没有任何子节点的E元素；</li>
</ul>
<h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p> 用于创建一些<strong>不在文档树中的元素</strong>，并为其添加样式。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">伪元素特性</span><br><span class="line">减少 dom 节点数,但不利于不利于 SEO</span><br><span class="line">它不存在于文档中，所以 js 无法操作它</span><br><span class="line">它属于主元素本身，因此当伪元素被点击的时候触发的是主元素的 click 事件</span><br></pre></td></tr></table></figure>

<ul>
<li>E::selection 可改变选中文本的样式</li>
</ul>
<ul>
<li>E::placeholder 可改变placeholder默认样式，这个存在明显的兼容问题，比如::-webkit-input-placeholderE:after、E:before </li>
</ul>
<ul>
<li><p><code>::before</code>创建一个伪元素，该元素是所选元素的第一个子元素</p>
<p><code>::after</code>创建一个伪元素，该元素是所选元素的最后一个子元素</p>
<ul>
<li><p>块级元素才能有:before, :after，譬如 img 就不能设置</p>
</li>
<li><p>伪类元素的display是默认值inline</p>
</li>
<li><p>```<br><a href="http://www.cnblogs.com/starof">starof</a><br>attr() 通过attr()调用当前元素的属性，比如将图片alt提示文字或者链接的href地址显示出来。<br>a::after{</p>
<pre><code>content:  attr(href) ;
</code></pre>
<p>}<br>a::before{<br>  content: url(“<a href="https://www.baidu.com/img/baidu_jgylogo3.gif&quot;">https://www.baidu.com/img/baidu_jgylogo3.gif&quot;</a>);<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 清除浮动</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>.cf:before,<br>.cf:after {</p>
<pre><code>content: &quot; &quot;;
display: table; 
</code></pre>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 文字</span><br><span class="line"></span><br><span class="line">### 基础</span><br><span class="line"></span><br><span class="line">- **font-family**</span><br><span class="line"></span><br><span class="line">- font-variant 设置字母字体 </span><br><span class="line"></span><br><span class="line">  - **normal :** 正常的字体 	</span><br><span class="line"></span><br><span class="line">  - **small-caps :** 设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小</span><br><span class="line"></span><br><span class="line">- text-transform </span><br><span class="line"></span><br><span class="line">  - none</span><br><span class="line"></span><br><span class="line">  - **capitalize :** 　将每个单词的第一个字母转换成大写，其余无转换发生</span><br><span class="line"></span><br><span class="line">  - **uppercase :**  转换成大写</span><br><span class="line"></span><br><span class="line">  - **lowercase :** 　转换成小写</span><br><span class="line"></span><br><span class="line">- text-decoration下划线</span><br><span class="line"></span><br><span class="line">  -  none  |   underline   |     line-through</span><br><span class="line"></span><br><span class="line">- **direction**文本方向</span><br><span class="line">  ltr 	默认。文本方向从左到右。</span><br><span class="line">  rtl 	文本方向从右到左。</span><br><span class="line">  inherit 	规定应该从父元素继承 direction 属性的值。</span><br><span class="line"></span><br><span class="line">- **text-size-adjust**：文本溢出算法，根据设备尺寸而自动调整文字大小</span><br><span class="line"></span><br><span class="line">  auto：启用浏览器的文本溢出算法</span><br><span class="line"></span><br><span class="line">  none：禁用浏览器的文本溢出算法。</span><br><span class="line"></span><br><span class="line">  percentage：启用浏览器的文本溢出算法，并使用用一个百分数来确定文本放大程度。</span><br><span class="line"></span><br><span class="line">### 间距</span><br><span class="line"></span><br><span class="line">- **text-indent :** 规定文本块中首行文本的缩进。</span><br><span class="line"></span><br><span class="line">  | *length* | 定义固定的缩进。默认值：0。                 |</span><br><span class="line">  | -------- | ------------------------------------------- |</span><br><span class="line">  | *%*      | 定义基于父元素宽度的百分比的缩进。          |</span><br><span class="line">  | inherit  | 规定应该从父元素继承 text-indent 属性的值。 |</span><br><span class="line"></span><br><span class="line">- **letter-spacing :**增加或减少字符间的空白（字符间距）</span><br><span class="line"></span><br><span class="line">  | normal   | 默认。规定字符间没有额外的空间。               |</span><br><span class="line">  | -------- | ---------------------------------------------- |</span><br><span class="line">  | *length* | 定义字符间的固定空间（允许使用负值）。         |</span><br><span class="line">  | inherit  | 规定应该从父元素继承 letter-spacing 属性的值。 |</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">### **vertical-align **</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_42667613/article/details/123429515</span><br><span class="line"></span><br><span class="line">设置一个元素的垂直对齐方式。该属性**定义行内元素(`inline`、`inline-block`、`inline-table`、`table-cell`)的基线相对于该元素所在行的基线的对齐方式**。</span><br><span class="line"></span><br><span class="line">&gt;   vertical-align不可继承，必须对**子元素**单独设置。</span><br><span class="line"></span><br><span class="line">1. baseline：**默认值**，元素的基线与父元素基线对齐。</span><br><span class="line">2. top：把元素的顶端与父元素顶线对齐；</span><br><span class="line">3. **middle：把此元素放置在父元素的中部。**</span><br><span class="line">4. bottom：把元素的顶端与父元素底线对齐![属性值图解](https://img-blog.csdnimg.cn/8f73007c2be64c84a2e2f7e2a14c1b1d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDE3Mzk0Mw==,size_16,color_FFFFFF,t_70#pic_center)</span><br><span class="line"></span><br><span class="line">### line-height</span><br><span class="line"></span><br><span class="line">**行高是指文本行基线间的垂直距离** </span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/a2013126370/article/details/82786681</span><br><span class="line"></span><br><span class="line">*length :* 百分比数字 | 由浮点数字和单位标识符组成的长度值，允许为负值。其百分比取值是基于字体的高度尺寸。1em=字体的大小</span><br><span class="line"></span><br><span class="line">下图中两条红线之间的距离就是行高，上行的底线和下一行顶线之间的距离就是行距，而同一行顶线和底线之间的距离是font-size的大小，行距的一半是半行距。</span><br><span class="line"></span><br><span class="line">![img](https://img-blog.csdn.net/20180920105701124?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line">**line-height=font-size+行间距**</span><br><span class="line"></span><br><span class="line">当font-size等于line-height时，行距 = line-height - font-size = 0；而当font-size大于line-height时，则会出现行距为负值，则两行重叠，如下图：</span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://img-blog.csdn.net/20180920113755884?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDEzMTI2Mzcw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 如果一个标签没有定义 `height` 属性，那么其最终表现的高度是由 `line-height` 决定的</span><br><span class="line"></span><br><span class="line">- 一个容器没有设置高度，那么撑开容器高度的是 `line-height` 而不是容器内的文字内容</span><br><span class="line"></span><br><span class="line">- 把 `line-height` 值设置为 `height` 一样大小的值可以实现单行文字的垂直居中</span><br><span class="line"></span><br><span class="line">### 换行</span><br><span class="line"></span><br><span class="line">#### white-space文本换行</span><br><span class="line"></span><br><span class="line">https://blog.csdn.net/qq_37210523/article/details/103145240</span><br><span class="line"></span><br><span class="line">![img](https://img-blog.csdnimg.cn/2019111916525132.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz,size_16,color_FFFFFF,t_70)</span><br><span class="line"></span><br><span class="line">  ```css</span><br><span class="line">  white-space: normal;  /*连续的空白符会被合并，换行符会被当作空白符来处理。填充line盒子时，必要的话会换行。 */</span><br><span class="line">  white-space: nowrap;  /* 和 normal 一样，连续的空白符会被合并。但文本内的换行无效。*/</span><br><span class="line">  white-space: pre;  /* 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素时才会换行。*/</span><br><span class="line">  white-space: pre-wrap; /* 连续的空白符会被保留。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时才会换行。*/</span><br><span class="line">  white-space: pre-line;  /* 连续的空白符会被合并。在遇到换行符或者&lt;br&gt;元素，或者需要为了填充line盒子时会换行。*/</span><br><span class="line">   </span><br><span class="line">  white-space: break-spaces;</span><br><span class="line">  /**</span><br><span class="line">      与 pre-wrap的行为相同，除了：</span><br><span class="line">      任何保留的空白序列总是占用空间，包括在行尾。</span><br><span class="line">      每个保留的空格字符后都存在换行机会，包括空格字符之间。</span><br><span class="line">      这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。</span><br><span class="line">  */</span><br><span class="line">  white-space: inherit;</span><br><span class="line">  white-space: initial;</span><br><span class="line">  white-space: unset;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="word-break单词换行"><a href="#word-break单词换行" class="headerlink" title="word-break单词换行"></a><strong>word-break单词换行</strong></h4><p> <strong><code>word-break</code> 指定了怎样在单词内断行</strong></p>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">word-break</span>：指定了怎样在单词内断行</span><br><span class="line"><span class="attribute">normal</span>	只在允许的断字点换行（浏览器保持默认处理）。</span><br><span class="line">keep-all中文自动换行了，而英文使用默认换行方式 ---&gt;break-all</span><br><span class="line">break-word 允许正常的不能被分割的长单词强制分割换行</span><br><span class="line">//因为<span class="attribute">word-break</span>的break-word未列入标准，才会一般使用<span class="attribute">overflow-wrap</span>的break-word值</span><br><span class="line"><span class="attribute">overflow-wrap</span>(==<span class="attribute">word-wrap</span>) 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。</span><br><span class="line">break-all表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行。</span><br></pre></td></tr></table></figure>

<h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h4><ul>
<li>white-space控制空白字符的显示，同时还能控制是否自动换行。它有五个值：normal | nowrap | pre | pre-wrap | pre-line</li>
<li>word-break，控制单词如何被拆分换行。它有三个值：normal | break-all | keep-all</li>
<li>word-wrap（overflow-wrap）控制长度超过一行的单词是否被拆分换行，是word-break的补充，它有两个值：normal | break-word</li>
</ul>
<h3 id="文本缩略"><a href="#文本缩略" class="headerlink" title="文本缩略"></a>文本缩略</h3><p><strong>text-overflow :</strong> <strong>clip</strong> | <strong>ellipsis</strong> </p>
<p><strong>clip :</strong> 　不显示省略标记（…），而是简单的裁切<br><strong>ellipsis :</strong> 　当对象内文本溢出时显示省略标记（…）  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">section:nth-of-type(4) p &#123;</span><br><span class="line">    width: 40%;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    white-space: nowrap;</span><br><span class="line">    text-overflow: ellipsis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><h3 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h3><p><strong>clip :</strong> <strong>auto</strong> | <strong>rect (</strong> <em>number  number number number</em> **)**依据上-右-下-左的顺序剪切图像。必须将<a href="c_position.html">position</a>的值设为absolute，此属性方可使用。</p>
<p>clip-path  裁切一个圆角 inset(<top> <right> <bottom> <left> round <top-radius> <right-radius><bottom-radius> <left-radius>) </p>
<h3 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h3><p><a href="https://www.runoob.com/cssref/pr-object-fit.html">https://www.runoob.com/cssref/pr-object-fit.html</a></p>
<p>object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。</p>
<p>object-fit 一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。</p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">fill</td>
<td align="left">默认，不保证保持原有的比例，内容拉伸填充整个内容容器。</td>
</tr>
<tr>
<td align="left">contain</td>
<td align="left">保持原有尺寸比例。内容被缩放。</td>
</tr>
<tr>
<td align="left">cover</td>
<td align="left">保持原有尺寸比例。但部分内容可能被剪切。</td>
</tr>
<tr>
<td align="left">none</td>
<td align="left">保留原有元素内容的长度和宽度，也就是说内容不会被重置。</td>
</tr>
<tr>
<td align="left">scale-down</td>
<td align="left">保持原有尺寸比例。内容的尺寸与 none 或 contain 中的一个相同，取决于它们两个之间谁得到的对象尺寸会更小一些。</td>
</tr>
<tr>
<td align="left">initial</td>
<td align="left">设置为默认值，<a href="https://www.runoob.com/cssref/css-initial.html">关于 <em>initial</em></a></td>
</tr>
<tr>
<td align="left">inherit</td>
<td align="left">从该元素的父元素继承属性。 <a href="https://www.runoob.com/cssref/css-inherit.html">关于 <em>inherit</em></a></td>
</tr>
</tbody></table>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p><a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p>
<p><a href="https://www.jianshu.com/p/4d1dbb041bb2">https://www.jianshu.com/p/4d1dbb041bb2</a></p>
<p>BFC(Block Formatting Context)，块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使容器里面的元素不会在布局上影响到外面的元素。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a><strong>触发条件</strong></h4><ul>
<li>body 根元素</li>
<li>浮动元素：float 除 none 以外的值</li>
<li>绝对定位元素：position (absolute、fixed)</li>
<li>display 为 inline-block、table-cells、flex</li>
<li>overflow 除了 visible 以外的值 (hidden、auto、scroll)</li>
</ul>
<h4 id="BFC场景和应用"><a href="#BFC场景和应用" class="headerlink" title="BFC场景和应用"></a><strong>BFC场景和应用</strong></h4><p><strong>1. 同一个 BFC 下外边距会发生折叠</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">div&#123;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    background: lightblue;</span><br><span class="line">    margin: 100px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://pic4.zhimg.com/80/v2-0a9ca8952c83141250a2d9002e6d2047_720w.png" alt="img" style="zoom:33%;" />

<p>从效果上看，因为两个 div 元素都处于同一个 BFC 容器下 (这里指 body 元素) 所以第一个 div 的下边距和第二个 div 的上边距发生了重叠，所以两个盒子之间距离只有 100px，而不是 200px。</p>
<p><strong>2. BFC 可以包含浮动的元素（清除浮动）</strong></p>
<p>我们都知道，浮动的元素会脱离普通文档流，来看下下面一个例子</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://pic4.zhimg.com/80/v2-371eb702274af831df909b2c55d6a14b_720w.png" alt="img" style="zoom:33%;" />

<p>由于容器内元素浮动，脱离了文档流，所以容器只剩下 2px 的边距高度。如果使触发容器的 BFC，那么容器将会包裹着浮动元素。</p>
<blockquote>
<p>float为left/right是子元素本身触发了BFC，使普通布局流变成了浮动流布局；父级元素因为浮动从而高度塌陷，所以需要overflow来触发父级元素的BFC来重新布局回到普通布局。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;overflow: hidden&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://pic4.zhimg.com/80/v2-cc8365db5c9cc5ca003ce9afe88592e7_720w.png" alt="img" style="zoom:33%;" />

<p><strong>3. BFC 可以阻止元素被浮动元素覆盖</strong></p>
<p>先来看一个文字环绕效果：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px; height: 200px;background: #eee&quot;</span>&gt;</span></span><br><span class="line">    我是一个没有设置浮动, 也没有触发 BFC 元素, width: 200px; height:200px; background: #eee;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://pic4.zhimg.com/80/v2-dd3e636d73682140bf4a781bcd6f576b_720w.png" alt="img" style="zoom:33%;" />

<p>这时候其实第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 <strong>overflow: hidden</strong>，就会变成：</p>
<img src="https://pic3.zhimg.com/80/v2-5ebd48f09fac875f0bd25823c76ba7fa_720w.png" alt="img" style="zoom:33%;" />

<p>这个方法可以用来实现<strong>两列自适应布局</strong>，效果不错，这时候左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)。</p>
<p><strong>开发中的应用</strong></p>
<ul>
<li>阻止<code>margin</code>重叠</li>
<li>可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个 <code>div</code>都位于同一个 <code>BFC</code> 区域之中)</li>
<li>自适应两栏布局</li>
<li>可以阻止元素被浮动元素覆盖</li>
</ul>
<h3 id="float"><a href="#float" class="headerlink" title="float"></a>float</h3><p><a href="https://blog.csdn.net/qq_36595013/article/details/81810219">https://blog.csdn.net/qq_36595013/article/details/81810219</a></p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>设置元素浮动后，对应的元素会脱离文档流，该元素的 <code>display</code> 值自动变成 <code>block</code></p>
</blockquote>
<p>假如某个div元素A是浮动的，如果A元素<strong>上一个元素也是浮动的</strong>，那么A元素会跟随在上一个元素的后边(如果一行放不下这两个元素，那么A元素会被挤到下一行)；如果A元素<strong>上一个元素是标准流中的元素</strong>，那么A的顶部和上一个元素的底部对齐。</p>
<img src="https://img-blog.csdn.net/20180818160910520?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

<p>假设上图中的div2浮动，那么它将脱离标准流，但div1、div3、div4仍然在标准流当中，所以div3会自动向上移动，占据div2的位置，重新组成一个流。</p>
<img src="https://img-blog.csdn.net/20180818161114199?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTk1MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom:50%;" />

<p>把div2和div3都加上左浮动,由于div2、div3浮动，它们不再属于标准流，因此div4会自动上移，与div1组成一个“新”标准流，而浮动是漂浮在标准流之上，因此div2又挡住了div4。</p>
<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p><strong>清除浮动:清除浮动不是不用浮动，清除浮动产生的不利影响。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clear :none| left |right  | both</span><br><span class="line">none :允许两边都可以有浮动对象</span><br><span class="line">both :不允许有浮动对象</span><br><span class="line">left :不允许左边有浮动对象</span><br></pre></td></tr></table></figure>

<p>场景：CSS浮动塌陷，父级元素不设置高度时，高度由随内容增加自适应高度。当父级元素内部的子元素全部都设置浮动float之后，子元素会脱离标准流，不占位，父级元素检测不到子元素的高度，父级元素高度为0。由于父级元素没有高度，下面的元素会顶上去，造成页面的塌陷。</p>
<p>解决：</p>
<ul>
<li><p>父元素使用overflow:hidden来清除浮动，最好加上zoom:1;</p>
</li>
<li><p>父级div定义height</p>
</li>
<li><p>在父元素后面使用伪类：after和zoom</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.box:after&#123;</span><br><span class="line">- display:block;</span><br><span class="line">- content:&quot;&quot;;</span><br><span class="line">- height:0;</span><br><span class="line">- clear:both;</span><br><span class="line">- &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结尾处加空div标签clear:both</p>
</li>
<li><p>对父元素设置display:table；使父元素形成BFC（块格式化上下文）</p>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>float 可以用来让文字环绕图片而已。</li>
<li>如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</li>
</ul>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><ul>
<li><p><strong>position:absolute</strong></p>
<ul>
<li>会让元素以display:inline-block的方式显示,可以设置长宽，默认宽度并不占满父元素。</li>
<li><strong>Z-index 仅能在定位元素上奏效（例如 position:absolute;）！</strong> </li>
<li>脱离文档流</li>
</ul>
</li>
<li><p><strong>position:relative</strong></p>
<ul>
<li><p>相对定位，相对于原来该元素在普通流中的位置重新定位，依旧在普通流中占据位置，没有脱离普通流，只是视觉上发生变化</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/5627750-ec360e4418779b3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/535/format/webp" alt="img"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>Position:fixed</strong> 通常相对于浏览器窗口或 frame 进行定位。 </p>
<ul>
<li>固定定位之后，不占据原来的位置（脱标）</li>
<li>元素使用固定定位之后，会转化为行内块</li>
</ul>
</li>
<li><p>static：默认值。没有定位，元素出现在正常的流中</p>
</li>
</ul>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><ul>
<li>display: flex; 会浮动</li>
</ul>
<ul>
<li><p>flex-direction: column;决定主轴的方向(即子元素的排列方向)</p>
<p>调整主轴方向（默认为水平方向）包括row、column、row-reverse、column-reverse</p>
</li>
<li><p>justify-content（水平方向）定义了子元素在主轴上的对齐方式</p>
<p>主轴方向对齐，可以调整元素在主轴方向上的对齐方式，包括flex-start、flex-end、center、space-around(多与空间放两边)、space-between(多与空间放中间)几种方式  </p>
</li>
<li><p>align-items（垂直方向）定义子元素在侧轴上如何对齐</p>
<p>调整侧轴方向对齐方式，包括flex-start、flex-end、center、baseline、stretch</p>
</li>
<li><p>flex-wrap 控制是否换行，包括wrap、nowrap （不换行）</p>
</li>
<li><p>align-content 定义了多根轴线的对齐方式, 如果子元素只有一根轴线,该属性不起作用<br>可对应用flex-wrap: wrap后产生的换行进行控制，包括flex-start、flex-end、center、space-between、space-around、stretch </p>
</li>
<li><p>align-self 侧轴上单个项目对齐方式<br>单独对某一个子元素设置 flex-start、flex-end、center、baseline、stretch </p>
</li>
</ul>
<p><strong>flex 控制子元素伸缩比例</strong></p>
<p><a href="https://blog.csdn.net/qq_41635167/article/details/104190865">https://blog.csdn.net/qq_41635167/article/details/104190865</a></p>
<p><a href="https://www.zhangxinxu.com/wordpress/2019/12/css-flex-deep/">https://www.zhangxinxu.com/wordpress/2019/12/css-flex-deep/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">flex:1	</span><br><span class="line">	flex-grow: 1;</span><br><span class="line">  flex-shrink: 1;</span><br><span class="line">  flex-basis: 0%;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Flex布局中，一个Flex子项的宽度是由元素自身尺寸，<code>flex-basis</code>设置的基础尺寸，以及外部填充（<code>flex-grow</code>）或收缩（<code>flex-shrink</code>）规则3者共同决定的。</p>
<p>举例：分家产</p>
<ul>
<li><p>flex-basis:用于设置子盒子宽度。在Flex布局中，<strong>flex-basis优先级是比width高的</strong>。<code>flex-basis</code>的默认值是<code>auto</code>，表示自动，也就是完全根据子列表项自身尺寸渲染。</p>
<p>自身尺寸渲染优先级如下：min-width &gt; || max-width &gt; width &gt; Content Size</p>
<blockquote>
<p><code>flex-basis</code>就是分配固定的家产数量。</p>
</blockquote>
</li>
<li><p>flex-grow(用在子盒子上)属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<blockquote>
<p><code>flex-grow</code>就是家产剩余家产仍有富余的时候该如何分配。</p>
</blockquote>
</li>
<li><p>flex-shrink(flex元素仅在默认宽度之和大于容器的时候才会发生收缩，其收缩的大小是依据 flex-shrink 的值)属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p>
<blockquote>
<p><code>flex-shrink</code>就是家产剩余家产不足的时候该如何分配。</p>
</blockquote>
</li>
</ul>
<p><strong>flex参数</strong></p>
<ul>
<li><p><strong>1个值</strong></p>
<p>如果flex的属性值只有一个值，则：</p>
<ul>
<li>如果是数值，例如<code>flex: 1</code>，则这个<code>1</code>表示<code>flex-grow</code>，<del>此时<code>flex-shrink</code>和<code>flex-basis</code>都使用默认值，分别是<code>1</code>和<code>auto</code></del>。<strong>更正为：</strong>此时<code>flex-shrink</code>和<code>flex-basis</code>的值分别是<code>1</code>和<code>0%</code>，注意，这里的<code>flex-basis</code>的值是<code>0%</code>，而不是默认值<code>auto</code>。</li>
<li>如果是长度值，例如<code>flex: 100px</code>，则这个<code>100px</code>显然指<code>flex-basis</code>，因为3个缩写CSS属性中只有<code>flex-basis</code>的属性值是长度值。<del>此时<code>flex-grow</code>和<code>flex-shrink</code>都使用默认值，分别是<code>0</code>和<code>1</code>。</del><strong>更正为：</strong>此时<code>flex-grow</code>和<code>flex-shrink</code>都是<code>1</code>，注意，这里的<code>flex-grow</code>的值是<code>1</code>，而不是默认值<code>0</code>。</li>
</ul>
</li>
<li><p><strong>2个值</strong></p>
<p>如果flex的属性值有两个值，则第1个值一定指<code>flex-grow</code>，第2个值根据值的类型不同表示不同的CSS属性，具体规则如下：</p>
<ul>
<li>如果第2个值是数值，例如<code>flex: 1 2</code>，则这个<code>2</code>表示<code>flex-shrink</code>，<del>此时<code>flex-basis</code>使用默认值<code>auto</code>。</del><strong>更正为：</strong>此时<code>flex-basis</code>计算值是<code>0%</code>，并非默认值<code>auto</code>。</li>
<li>如果第2个值是长度值，例如<code>flex: 1 100px</code>，则这个<code>100px</code>指<code>flex-basis</code>，此时<code>flex-shrink</code>使用默认值<code>0</code>。</li>
</ul>
</li>
<li><p><strong>3个值</strong></p>
<p>如果<code>flex</code>的属性值有3个值，则这长度值表示<code>flex-basis</code>，其余2个数值分别表示<code>flex-grow</code>和<code>flex-shrink</code>。下面两行CSS语句的语法都是合法的，且含义也是一样的：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 下面两行CSS语句含义是一样的 */</span></span><br><span class="line"><span class="attribute">flex</span>: <span class="number">1</span> <span class="number">2</span> <span class="number">50%</span>；</span><br><span class="line">flex: <span class="number">50%</span> <span class="number">1</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>order <strong>定义子元素的排列顺序, 数值越小 排列越靠前 默认为0</strong> </p>
<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="元素的水平居中"><a href="#元素的水平居中" class="headerlink" title="元素的水平居中"></a>元素的水平居中</h4><ul>
<li><p>元素为行内元素，设置父元素<code>text-align:center</code></p>
</li>
<li><p>如果子元素宽度固定，可以设置左右<code>margin</code>为<code>auto</code>;</p>
</li>
<li><p>绝对定位和移动: <code>absolute + transform</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.parent_box&#123;</span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line">        .child_box&#123;</span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            position: absolute;</span><br><span class="line">            top: 0;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate( -50%,0);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>flex-box</code>布局，指定<code>justify-content</code>属性为center</p>
</li>
<li><p>```<br>display:block;<br>margin:auto;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 元素的垂直居中</span><br><span class="line"></span><br><span class="line">- 将显示方式设置为表格，`display:table-cell`,同时设置`vertial-align：middle`</span><br><span class="line"></span><br><span class="line">- 使用`flex`布局，设置为`align-item：center`</span><br><span class="line"></span><br><span class="line">- 绝对定位中设置`bottom:0,top:0`,并设置`margin:auto`</span><br><span class="line"></span><br><span class="line">- 绝对定位和移动: `absolute + transform`</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>.parent_box{</p>
<pre><code>        width: 400px;
        height: 200px;
        position: relative;
    &#125;
    .child_box&#123;
        width: 200px;
        height: 100px;
        position: absolute;
        left: 0;
        top: 50%;
        transform: translate( 0，-50%);
    &#125;
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 绝对定位中固定高度时设置`top:50%，margin-top`值为高度一半的负值</span><br><span class="line"></span><br><span class="line">- 文本垂直居中设置`line-height`为`height`值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 垂直水平居中</span><br><span class="line"></span><br><span class="line">```css</span><br><span class="line">/** 1 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  .box &#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 50%;</span><br><span class="line">    left: 50%;</span><br><span class="line">    width: 100px;</span><br><span class="line">    height: 100px;</span><br><span class="line">    margin: -50px 0 0 -50px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 2 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  .box &#123;</span><br><span class="line"></span><br><span class="line">        margin: 0 !important;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 50%;</span><br><span class="line">  left: 50%;</span><br><span class="line">  transform: translate(-50%, -50%);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 3 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  .box &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">    align-items: center;</span><br><span class="line">    height: 100px;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** 4 **/</span><br><span class="line">.wraper &#123;</span><br><span class="line">  display: table;</span><br><span class="line">  .box &#123;</span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>如何垂直居中一个<code>&lt;img&gt;</code></strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#container     /**&lt;img&gt;的容器设置如下**/</span><br><span class="line">&#123;</span><br><span class="line">    display:table-cell;</span><br><span class="line">    text-align:center;</span><br><span class="line">    vertical-align:middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h2><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><h4 id="设备尺寸"><a href="#设备尺寸" class="headerlink" title="设备尺寸"></a>设备尺寸</h4><p>设备尺寸指的是设备对角线的长度，单位是英寸</p>
<img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2548297ffb3741178f62c1dbc1a75388~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?" alt="img" style="zoom:33%;" />

<h4 id="像素px"><a href="#像素px" class="headerlink" title="像素px"></a>像素px</h4><p>是组成图片的色彩和亮度的最小图像单元，是显示屏的画面上能表现出来的最小单位。像素分为：<strong>css像素和物理像素</strong>。</p>
<p>**物理像素/设备像素(device pixel, dp)**： 由一个个物理像素点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的物理像素点就固定不变了，单位pt。 pt 在 css 单位中属于真正的绝对单位，1pt = 1/72(inch), inch及英寸，而1英寸等于2.54厘米。所以设备像素的特点就是大小固定，不可变。比如 iPhone 5 的分辨率为 640 x 1136px.</p>
<p>**CSS像素(css pixel, px)**： 由于不同的物理设备的物理像素的大小是不一样的，所以<code>css</code>认为浏览器应该对<code>css</code>中的像素进行调节，使得浏览器中 1css像素的大小在不同物理设备上看上去大小总是差不多 ，目的是为了保证阅读体验一致。为了达到这一点浏览器可以直接按照设备的物理像素大小进行换算。比如 iPhone 5 的 CSS 像素数为 320 x 568px.</p>
<p><strong>CSS像素 =设备独立像素 = 逻辑像素</strong> </p>
<h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a><strong>分辨率</strong></h4><p>是指桌面设定的分辨率，而不是显示器的分辨率 。分辨率指的是宽度上和高度上最多能显示的物理像素点个数。指的是屏幕的像素尺寸。<code>750X1334</code>指的是横向有<code>750</code>个像素，纵向有<code>1334</code>个像素。<code>屏幕尺寸</code>指的是设备对角线的长度。 </p>
<h4 id="像素比-DPR"><a href="#像素比-DPR" class="headerlink" title="像素比(DPR)"></a><strong>像素比(DPR)</strong></h4><p>在移动端浏览器中以及某些桌面浏览器中，window对象有一个devicePixelRatio(设备像素比)属性，它的官方的定义为：设备物理像素和设备独立像素的比例。</p>
<p><strong>devicePixelRatio = 物理像素 / 独立像素</strong>。css中的<strong>px就可以看做是设备的独立像素</strong>，所以通过devicePixelRatio，我们可以知道该设备上<strong>一个css像素代表多少个物理像素</strong>。</p>
<p>在普通屏，1个css像素对应1个物理像素；2倍屏中，一个css像素对应4个物理像素；三倍屏中则是9个。如<code>iPhone6</code>的<code>dpr</code>为<code>2</code>，物理像素<code>750</code>（x轴）,则它的逻辑像素为<code>375</code>。</p>
<p>除了设备，还有一个因素也会引起DPR的变化，那就是<strong>用户缩放</strong>。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p>
<h4 id="1px"><a href="#1px" class="headerlink" title="1px"></a>1px</h4><p>对于前端来说，在高清屏出现之前，前端代码的 <code>1px</code> 即等于手机物理像素点的 <code>1px</code>。但有了 dpr 的概念之后，由于前端代码中的使用的是 CSS 像素，手机会根据 dpr 换算成实际的物理像素大小来渲染页面。比如 iPhone6 的设备像素比 <code>dpr = 2</code> ，相当于一个 CSS 像素等于两个物理像素，即 <code>1px</code> 由 2个物理像素点组成。</p>
<p>那么问题来了，以 iPhone6 为例，其 <code>dpr = 2</code>、屏幕尺寸(CSS 像素) 为 <code>375x667</code>，一般设计稿提供 2 倍图尺寸为 <code>750x1334</code> 。那么设计稿中的 <code>1px</code>，对应屏幕尺寸其实应该写成 <code>0.5px</code>。再由 dpr 计算公式可知，<code>0.5 * 2 = 1px</code> 物理像素。</p>
<p>此时你应该已经发现了，设计稿要实现 <code>1px</code> 细线、<code>1px</code> 边框，为什么前端实现总是偏粗的？那是因为如果你在代码中直接写成 <code>1px</code>，再通过 dpr 计算之后其实是 <code>2px</code> 物理像素，并不符合设计稿的要求</p>
<p>那么当 <code>dpr=2</code> 时，代码中直接写成 <code>0.5px</code> 就解决问题了吗？</p>
<h3 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h3><p><a href="https://blog.csdn.net/liwusen/article/details/80834546">https://blog.csdn.net/liwusen/article/details/80834546</a></p>
<p><a href="https://www.cnblogs.com/zaoa/p/8630393.html">https://www.cnblogs.com/zaoa/p/8630393.html</a></p>
<h4 id="视口"><a href="#视口" class="headerlink" title="视口"></a>视口</h4><p><strong>视口针对移动设备，对PC没用</strong></p>
<p>(1) 布局视口（layout viewport）<br> 为了能在移动设备上正常显示那些为pc端浏览器设计的网站，移动设备上的浏览器都会把自己默认的 viewport 设为 980px 或其他值，一般都比移动端浏览器可视区域大很多，所以就会出现浏览器出现横向滚动条的情况 </p>
<img src="https://www.runoob.com/wp-content/uploads/2018/07/1532326331-2895-201407.png" alt="img" style="zoom: 80%;" />

<p>(2) 视觉视口（visual viewport）<br>视觉视口表示浏览器内看到的网站的显示区域，用户可以通过缩放来查看网页的显示内容，从而改变视觉视口。视觉视口的定义，就像拿着一个放大镜分别从不同距离观察同一个物体，视觉视口仅仅类似于放大镜中显示的内容，因此视觉视口不会影响布局视口的宽度和高度。</p>
<img src="https://www.runoob.com/wp-content/uploads/2018/07/1532326332-9414-201407.png" alt="img" style="zoom:50%;" />

<p>(3) 理想视口（ideal viewport）</p>
<p>理想视口或者应该全称为“理想的布局视口”，在移动设备中就是指设备的分辨率。换句话说，理想视口或者说分辨率就是给定设备物理像素的情况下，最佳的“布局视口”。 <strong>理想视口的值其实就是屏幕分辨率的值</strong> </p>
<p><strong>应用</strong></p>
<p><strong>移动设备默认的viewport是layout viewport</strong>，但在进行移动设备网站的开发时，我们需要的是ideal viewport。那么怎么才能得到ideal viewport呢？这就该轮到meta标签出场了。</p>
<pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;&gt;
</code></pre>
<p>该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。让viewport的宽度等于设备的宽度，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认viewport，也就是说会出现横向滚动条。</p>
<table>
<thead>
<tr>
<th>width</th>
<th>设置<em><strong>layout viewport</strong></em> 的宽度，为一个正整数，或字符串”width-device”</th>
</tr>
</thead>
<tbody><tr>
<td>initial-scale</td>
<td>设置页面的初始缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>minimum-scale</td>
<td>允许用户的最小缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>maximum-scale</td>
<td>允许用户的最大缩放值，为一个数字，可以带小数</td>
</tr>
<tr>
<td>height</td>
<td>设置<em><strong>layout viewport</strong></em> 的高度，这个属性对我们并不重要，很少使用</td>
</tr>
<tr>
<td>user-scalable</td>
<td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td>
</tr>
</tbody></table>
<h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p>相对于根元素html的font-size值的大小，此单位若要用于屏幕自适应，可与vw配合使用设置根元素的字体大小。375px的网页的设计稿。此时，1vw=3.75px；4vw=15px；8vw=30px；</p>
<h4 id="百分比"><a href="#百分比" class="headerlink" title="百分比%"></a>百分比%</h4><ol>
<li>子元素<strong>width</strong>或<strong>height</strong>的百分比是<strong>父元素width或height的百分比</strong></li>
<li><strong>top</strong>、<strong>bottom</strong>的百分比是相对于(默认定位)<strong>父元素的height</strong></li>
<li><strong>left</strong>、<strong>right</strong>的百分比是相对于(默认定位)<strong>父元素的width</strong></li>
<li><strong>padding</strong>、<strong>margin</strong>不论是垂直方向或者是水平方向，都相对于直接<strong>父元素的width</strong></li>
<li><strong>border-radius</strong>、<strong>translate</strong>、<strong>background-size</strong>的百分比，则是相对于<strong>自身的width</strong></li>
</ol>
<p><strong>两个缺点：</strong></p>
<p>（1）计算困难，如果我们要定义一个元素的宽度和高度，按照设计稿，必须换算成百分比单位。<br>（2）各个属性中如果使用百分比，相对父元素的属性并不是唯一的。比如width和height相对于父元素的width和height，而margin、padding不管垂直还是水平方向都相对比父元素的宽度、border-radius则是相对于元素自身等等，造成我们使用百分比单位容易使布局问题变得复杂。</p>
<h3 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h3><p><a href="https://www.cnblogs.com/chenyoumei/p/10510321.html">https://www.cnblogs.com/chenyoumei/p/10510321.html</a></p>
<ul>
<li><p>查看设计图，确定页面布局，组件的复用等</p>
</li>
<li><p>尽可能的添加多的div来包含元素，并设置对应的classname</p>
</li>
<li><p>外层盒子使用flex进行布局，不设置绝对宽高px(使用rem或者%布局)，高度由里面的内容撑开（<strong>撑不开就用margin、padding</strong>）</p>
<p><code>box-sizing:border-box以及margin：auto</code></p>
</li>
<li><p><strong>Tips</strong></p>
<ul>
<li><p>float的好处是，如果宽度太小，放不下两个元素，后面的元素会自动滚动到前面元素的下方，不会在水平方向overflow（溢出），避免了水平滚动条的出现。</p>
</li>
<li><p>图片的自适应，<code>img &#123; width: auto; max-width: 100%; &#125;</code></p>
</li>
</ul>
</li>
</ul>
<h4 id="yd-ui移动端"><a href="#yd-ui移动端" class="headerlink" title="yd ui移动端"></a><strong>yd ui移动端</strong></h4><p><a href="https://www.jianshu.com/p/b00cd3506782">https://www.jianshu.com/p/b00cd3506782</a></p>
<blockquote>
<p> <del>自适应不是指你缩放<strong>页面大小</strong>(ctrl+鼠标滚动条)，是指你浏览器大小变化自适应</del>。</p>
<p> 一般不加自适应，缩放页面，会发现<code>$(document).width()</code>会根据缩放变大变小，但是<strong>元素宽高不会变</strong>，相应元素就会<strong>感觉</strong>变大变小。加入自适应（<strong>自适应会根据页面大小来改变px，元素宽高会变</strong>），缩放页面，相应元素<strong>感觉</strong>不会改变。</p>
</blockquote>
<p>  <strong>缩放页面大小有三种情况：</strong></p>
<pre><code>1. 改变浏览器宽高
2. ctrl+鼠标滚动条，改变页面大小
3. window中显示设置中的缩放与布局
</code></pre>
<blockquote>
<p>像素比就是第二种和第三种情况</p>
</blockquote>
  <figure class="highlight css"><table><tr><td class="code"><pre><span class="line">(function (doc, win) &#123;</span><br><span class="line">  const docEl = doc<span class="selector-class">.documentElement</span>;</span><br><span class="line">  // 获取当前显示设备的物理像素分辨率与CSS像素分辨率之比;</span><br><span class="line">  <span class="selector-tag">var</span> dpr = window<span class="selector-class">.devicePixelRatio</span> || <span class="number">1</span>;</span><br><span class="line">  //orientationchange：在用户水平或者垂直翻转设备（即方向发生变化）时触发的事件</span><br><span class="line">  const resizeEvt = &#x27;orientationchange&#x27; in window ? &#x27;orientationchange&#x27; : <span class="string">&#x27;resize&#x27;</span>;</span><br><span class="line">  const recalc = function () &#123;</span><br><span class="line">    <span class="selector-tag">var</span> clientWidth = docEl<span class="selector-class">.clientWidth</span>;</span><br><span class="line">    if (!clientWidth) return;</span><br><span class="line">    if (clientWidth &gt;= <span class="number">750</span>) &#123;</span><br><span class="line">      docEl<span class="selector-class">.style</span><span class="selector-class">.fontSize</span> = &#x27;<span class="number">100px</span>&#x27;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      //<span class="selector-tag">html</span>宽度=clientWidth</span><br><span class="line">      //设计图的宽度=<span class="number">750</span>（通过设计图自行配置）</span><br><span class="line">      //在<span class="number">750</span>的设计图下，我们为了便于开发将根元素的字体大小设置成<span class="number">100px</span></span><br><span class="line">      docEl<span class="selector-class">.style</span><span class="selector-class">.fontSize</span> = <span class="number">100</span> * (clientWidth / <span class="number">750</span>) + &#x27;px&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">	// 检测是否支持<span class="number">0.5px</span></span><br><span class="line">  if (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="selector-tag">var</span> fakeBody = document<span class="selector-class">.createElement</span>(&quot;<span class="selector-tag">body</span>&quot;);</span><br><span class="line">    <span class="selector-tag">var</span> testElement = document<span class="selector-class">.createElement</span>(&quot;<span class="selector-tag">div</span>&quot;);</span><br><span class="line">    testElement<span class="selector-class">.style</span><span class="selector-class">.border</span> = &quot;.<span class="number">5px</span> solid transparent&quot;;</span><br><span class="line">    fakeBody<span class="selector-class">.appendChild</span>(testElement);</span><br><span class="line">    docEl<span class="selector-class">.appendChild</span>(fakeBody);</span><br><span class="line">    if (testElement<span class="selector-class">.offsetHeight</span> === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl<span class="selector-class">.classList</span><span class="selector-class">.add</span>(&quot;hairlines&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    docEl<span class="selector-class">.removeChild</span>(fakeBody);</span><br><span class="line">  &#125;</span><br><span class="line">	win<span class="selector-class">.addEventListener</span>(&quot;pageshow&quot;, function(e) &#123;</span><br><span class="line">		if (e<span class="selector-class">.persisted</span>) &#123; // 浏览器后退的时候重新计算</span><br><span class="line">			clearTimeout(tid);</span><br><span class="line">			tid = setTimeout(refreshRem, <span class="number">300</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, false)</span><br><span class="line"></span><br><span class="line">  if (!doc<span class="selector-class">.addEventListener</span>) return;</span><br><span class="line">  win<span class="selector-class">.addEventListener</span>(resizeEvt, recalc, false);</span><br><span class="line">  doc<span class="selector-class">.addEventListener</span>(&#x27;DOMContentLoaded&#x27;, recalc, false);//判断DOM是否加载完毕</span><br><span class="line">&#125;)(document, window);</span><br></pre></td></tr></table></figure>

<h4 id="flexible-js"><a href="#flexible-js" class="headerlink" title="flexible.js"></a>flexible.js</h4><p><a href="https://github.com/amfe/lib-flexible/blob/2.0/index.js">https://github.com/amfe/lib-flexible/blob/2.0/index.js</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先是一个立即执行函数，执行时传入的参数是window和document</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">flexible</span>(<span class="params"><span class="built_in">window</span>, <span class="built_in">document</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回文档的root元素</span></span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement; </span><br><span class="line">  <span class="comment">// 获取设备的dpr，即当前设置下物理像素与虚拟像素的比值</span></span><br><span class="line">  <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置默认字体大小，默认的字体大小继承自body</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setBodyFontSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">      <span class="comment">// 调整body标签的fontSize，fontSize = (12 * dpr) + &#x27;px&#x27;</span></span><br><span class="line">      <span class="built_in">document</span>.body.style.fontSize = <span class="number">12</span> * dpr + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.addEventListener(<span class="string">&#x27;DOMContentLoaded&#x27;</span>, setBodyFontSize);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  setBodyFontSize();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// set 1rem = viewWidth / 24</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 设置root元素的fontSize = 其clientWidth / 24 + &#x27;px&#x27;</span></span><br><span class="line">    <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">24</span>;</span><br><span class="line">    docEl.style.fontSize = rem + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  setRemUnit();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当页面展示或重新设置大小的时候，触发重新</span></span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;resize&#x27;</span>, setRemUnit);</span><br><span class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;pageshow&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e.persisted) &#123;</span><br><span class="line">      setRemUnit();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测0.5px的支持，支持则root元素的class中有hairlines</span></span><br><span class="line">  <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> fakeBody = <span class="built_in">document</span>.createElement(<span class="string">&#x27;body&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> testElement = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">    testElement.style.border = <span class="string">&#x27;.5px solid transparent&#x27;</span>;</span><br><span class="line">    fakeBody.appendChild(testElement);</span><br><span class="line">    docEl.appendChild(fakeBody);</span><br><span class="line">    <span class="keyword">if</span> (testElement.offsetHeight === <span class="number">1</span>) &#123;</span><br><span class="line">      docEl.classList.add(<span class="string">&#x27;hairlines&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    docEl.removeChild(fakeBody);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(<span class="built_in">window</span>, <span class="built_in">document</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><ul>
<li><p>清除默认样式 Normalize.css </p>
</li>
<li><p>浏览器前缀，webpack:autoprefixer</p>
<table>
<thead>
<tr>
<th>内核</th>
<th>主要代表的浏览器</th>
<th>前缀</th>
</tr>
</thead>
<tbody><tr>
<td>Trident</td>
<td>IE浏览器</td>
<td>-ms</td>
</tr>
<tr>
<td>Gecko</td>
<td>Firefox</td>
<td>-moz</td>
</tr>
<tr>
<td>Presto</td>
<td>Opera</td>
<td>-o</td>
</tr>
<tr>
<td>Webkit</td>
<td>Chrome和Safari</td>
<td>-webkit</td>
</tr>
</tbody></table>
</li>
<li><p>h5中如何处理移动端滑动卡顿的问题</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  // <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  -webkit-<span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">  <span class="attribute">overflow</span>-scrolling: touch;</span><br><span class="line">  <span class="attribute">overflow-y</span>: scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>遮罩层隐藏之后，底部div无法触发点击事件：给遮罩层pointer-events</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pointer-events</span>: none;</span><br><span class="line">阻止用户的点击动作产生任何效果</span><br><span class="line">阻止缺省鼠标指针的显示</span><br><span class="line">阻止CSS里的hover和active状态的变化触发事件</span><br><span class="line">阻止JavaScript点击动作触发的事件</span><br></pre></td></tr></table></figure></li>
<li><p>移动端开发1px像素线条变粗移动端window对象里有个 <strong>devicePixelRatios</strong> 属性，叫做 <strong>设备像数比</strong> ，也就是设备的物理像素与逻辑像素的比值。  我们以iphone6为例子：它的物理像素是750，逻辑像素是375，所以他的 dpr 为 2，那么在css里写1px映射到物理像素就是2pt了 </p>
<ul>
<li><p>伪类+transform实现 </p>
</li>
<li><p>媒体查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.border &#123; border: 1px solid #999 &#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 2) &#123;</span><br><span class="line">  .border &#123; border: 0.5px solid #999 &#125;</span><br><span class="line">&#125;</span><br><span class="line">@media screen and (-webkit-min-device-pixel-ratio: 3) &#123;</span><br><span class="line">  .border &#123; border: 0.333333px solid #999 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用viewport + js + 使用rem实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<ul>
<li>name=”viewport” content=”width=device-width: 本页面的 「viewport」 的宽度为设备宽度。</li>
<li>initial-scale=1.0: 初始缩放值为 1,</li>
<li>maximum-scale=1.0: 最大的缩放值为 1。</li>
<li>user-scalable=no: 禁止用户进行页面缩放。</li>
</ul>
<p>那么通过设置viewport的initial-scale，就可以轻松实现：</p>
<ul>
<li>当dpr = 1 时，initial-scale = 1</li>
<li>当dpr = 2 时，initial-scale = 0.5</li>
<li>当dpr = 3 时，initial-scale = 0.33333333333</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;/title&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;&gt;</span><br><span class="line">    &lt;style&gt;&lt;/style&gt;</span><br><span class="line">    &lt;script&gt;</span><br><span class="line">      let viewport = document.querySelector(&quot;meta[name=viewport]&quot;);</span><br><span class="line">      //下面是根据设备像素设置viewport</span><br><span class="line">      if (window.devicePixelRatio == 1) &#123;</span><br><span class="line">        viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (window.devicePixelRatio == 2) &#123;</span><br><span class="line">        viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      if (window.devicePixelRatio == 3) &#123;</span><br><span class="line">        viewport.setAttribute(&#x27;content&#x27;, &#x27;width=device-width,initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no&#x27;);</span><br><span class="line">      &#125;</span><br><span class="line">      let docEl = document.documentElement;</span><br><span class="line">      let fontsize = 32* (docEl.clientWidth / 750) + &#x27;px&#x27;;</span><br><span class="line">      docEl.style.fontSize = fontsize;</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h2><p>Scrollbar滚动条设置，cursor鼠标指针，zoom图像放大倍数</p>
<h3 id="连写属性"><a href="#连写属性" class="headerlink" title="连写属性"></a>连写属性</h3><ul>
<li><p>font：font-style font-weight font-size/line-height font-family;</p>
<p>文本属性连写文字大小和字体为必写项。</p>
</li>
<li><p>border：color  style(solid实线dotted 点线dashed 虚线)   width</p>
<p>没有顺序要求，线型为必写项。</p>
</li>
<li><p>Padding: 20px;  上右下左内边距都是20px</p>
<p>Padding: 20px 30px;  上下20px  左右30px</p>
<p>Padding: 20px 30px 40px;  上内边距为20px 左右内边距为30px  下内边距为40</p>
<p>Padding: 20px 30px  40px 50px;  上20px 右30px 下40px 左 50px</p>
</li>
</ul>
<h3 id="calc属性"><a href="#calc属性" class="headerlink" title="calc属性"></a>calc属性</h3><p>Calc用户动态计算长度值，任何长度值都可以使用calc()函数计算，需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；</p>
<h2 id="总结与案例"><a href="#总结与案例" class="headerlink" title="总结与案例"></a>总结与案例</h2><h3 id="隐藏和透明度"><a href="#隐藏和透明度" class="headerlink" title="隐藏和透明度"></a>隐藏和透明度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</span><br><span class="line">visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</span><br><span class="line">overflow:hidden 这个只隐藏元素溢出的部分，但是占据空间且不可交互</span><br><span class="line">opacity:0 本质上是将元素的透明度将为0，就看起来隐藏了，但是依然占据空间且可以交互</span><br><span class="line">z-index:-9999: 原理是将层级放到底部，这样就被覆盖了，看起来隐藏了</span><br><span class="line">transform: scale(0,0) 平面变换，将元素缩放为0，但是依然占据空间，但不可交互</span><br></pre></td></tr></table></figure>

<p>透明度<br>background-color: rgba(0, 0, 0, 0.3);<br>opacity: 0.3;<br>transparent是颜色的一种，这种颜色叫透明色。</p>
<p><strong>rgba()和 opacity 的透明效果有什么不同</strong> </p>
<p>rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的 </p>
<p>所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明 效果！） </p>
<h3 id="设置placeholder样式"><a href="#设置placeholder样式" class="headerlink" title="设置placeholder样式"></a>设置placeholder样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">placeholder（如果是在手机客户端webview 只使用－webkit内核方式即可。）</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>::-webkit-input-placeholder,</span><br><span class="line">textarea::-webkit-input-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>:-moz-placeholder,</span><br><span class="line">textarea:-moz-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>::-moz-placeholder,</span><br><span class="line">textarea::-moz-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">input</span>:-ms-input-placeholder,</span><br><span class="line">textarea:-ms-input-placeholder &#123;</span><br><span class="line">  color: <span class="number">#666</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="link与-import的区别"><a href="#link与-import的区别" class="headerlink" title="link与@import的区别"></a>link与@import的区别</h3><ol>
<li>@import是CSS提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载CSS文件，还可以定义RSS，rel连接属性等；</li>
<li>加载页面时，link引入的CSS被同时加载，@import引入的CSS将在页面加载完毕后加载；</li>
<li>link标签作为HTML元素，不存在兼容性问题，而@import是CSS2.1才有的语法，故老版本浏览器（IE5之前）不能识别；</li>
<li>可以通过JS操作DOM，来插入link标签改变样式；由于DOM方法是基于文档的，无法使用@import方式插入样式；</li>
<li><code>link</code>引入的样式权重大于<code>@import</code>引入的样式。</li>
</ol>
<p>建议使用link的方式引入CSS</p>
<h3 id="display：table和本身的table有什么区别"><a href="#display：table和本身的table有什么区别" class="headerlink" title="display：table和本身的table有什么区别"></a>display：table和本身的table有什么区别</h3><p>Display:table和本身table是相对应的，区别在于，display：table的css声明能够让一个html元素和它的子节点像table元素一样，使用基于表格的css布局，使我们能够轻松定义一个单元格的边界，背景等样式，而不会产生因为使用了table那样的制表标签导致的语义化问题。</p>
<p>之所以现在逐渐淘汰了table系表格元素，是因为用div+css编写出来的文件比用table边写出来的文件小，而且table必须在页面完全加载后才显示，div则是逐行显示，table的嵌套性太多，没有div简洁</p>
<h3 id="如何实现小于12px的字体效果"><a href="#如何实现小于12px的字体效果" class="headerlink" title="如何实现小于12px的字体效果"></a>如何实现小于12px的字体效果</h3><blockquote>
<p><code>transform:scale()</code>这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个<code>display:inline-block</code>;</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transform: scale(0.7);</span><br></pre></td></tr></table></figure>

<h3 id="自定义浏览器滚动条样式"><a href="#自定义浏览器滚动条样式" class="headerlink" title="自定义浏览器滚动条样式"></a>自定义浏览器滚动条样式</h3><p><a href="https://daotin.netlify.app/sxemmx.html">https://daotin.netlify.app/sxemmx.html</a></p>
<h3 id="如何设置input输入框的宽度随文字的输入长度而改变？"><a href="#如何设置input输入框的宽度随文字的输入长度而改变？" class="headerlink" title="如何设置input输入框的宽度随文字的输入长度而改变？"></a>如何设置input输入框的宽度随文字的输入长度而改变？</h3><p><a href="https://daotin.netlify.app/winm4g.html#%E6%96%B9%E6%B3%95">https://daotin.netlify.app/winm4g.html#%E6%96%B9%E6%B3%95</a></p>
<h3 id="position定位的"><a href="#position定位的" class="headerlink" title="position定位的"></a>position定位的</h3><p>absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出</p>
<h3 id="盒子中根据内容撑开，但盒子高度比行内元素高度高"><a href="#盒子中根据内容撑开，但盒子高度比行内元素高度高" class="headerlink" title="盒子中根据内容撑开，但盒子高度比行内元素高度高"></a>盒子中根据内容撑开，但盒子高度比行内元素高度高</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;thumb&quot; style=&quot;width: 500px;&quot;&gt;</span><br><span class="line">  &lt;img src=&quot;imgs/1.jpg&quot; style=&quot;width: 100%;height: auto&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>原因：基线问题，img是行内块元素，一种类似text的元素，在结束的时候，会在末尾加上一个空白符，在块元素里默认有3px或者4px空白（基线对齐所导致）</p>
<p><img src="img/css/%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E6%92%91%E5%BC%80.png" alt="行内元素撑开"></p>
<h1 id="css3"><a href="#css3" class="headerlink" title="css3"></a>css3</h1><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><a href="https://www.imooc.com/article/68238">https://www.imooc.com/article/68238</a></p>
<img src="https://img.html.cn/upload/image/445/883/226/1575271471430989.jpg" alt="1.jpg" style="zoom:50%;" />

<p><strong>标准盒子模型</strong></p>
<p>标准盒模型又称W3C标准盒模型，其中标准盒模型的 width 等于 content 的宽度，标准盒模型的 height 等于 content 的高度。<br><code>标准盒大小计算公式：width(content) + padding + border + margin</code> </p>
<p><strong>怪异盒模型/IE盒子模型</strong></p>
<p>怪异盒模型又称IE盒子模型，其中怪异盒子模型的 width 等于 content + padding + border 的宽度，怪异盒子模型的 height 等于 content + padding + border 的高度。<br><code>怪异盒大小的计算公式：width(content + padding + border) + margin</code></p>
<p><strong>box-sizing 常用的属性有哪些？分别有什么作用</strong></p>
<ul>
<li><code>box-sizing: content-box;</code> 默认的标准(W3C)盒模型元素效果</li>
<li><code>box-sizing: border-box;</code> 触发怪异(IE)盒模型元素的效果</li>
<li><code>box-sizing: inherit;</code> 继承父元素 <code>box-sizing</code> 属性的值</li>
</ul>
<h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>文本阴影：text-shadow </p>
<p>color  length  lenth opacity  [ inset(阴影向内) ] </p>
<p>颜色 水平偏移量  垂直偏移量  模糊度  （缩展量）</p>
<p>边框阴影 ：border-shadow</p>
<p>box-shadow：[inset(阴影向内)]  水平偏移量  垂直偏移量  模糊度  （缩展量）  颜色</p>
<h2 id="边框圆角box-radius"><a href="#边框圆角box-radius" class="headerlink" title="边框圆角box-radius"></a>边框圆角box-radius</h2><p> 四个属性值，分别表示左上角、右上角、右下角、左下角的圆角大小（<strong>顺时针方向</strong>） </p>
<p> 三个属性值，第一个值表示左上角，第二个值表示右上角和左下角（对角），第三个值表示右下角。 </p>
<p> 两个属性值，第一个值表示左上角和右下角，第二个值表示右上角和左下角 </p>
<p> 斜杠二组值：第一组值表示水平半径，第二组值表示垂直半径，每组值也可以同时设置1到4个值，规则与上面相同。 border-radius:100px/40px;</p>
<p><strong>outline :</strong><a href="c_outlinecolor.html"> <strong>outline-color</strong> </a>||<a href="c_outlinestyle.html"><strong>outline-style</strong> </a>||<a href="c_outlinewidth.html"> <strong>outline-width</strong> </a></p>
<p>设置或检索对象外的线条轮廓。outline画在<a href="c_border.html">border</a>外面，并且不一定是矩形</p>
<h2 id="边框图像"><a href="#边框图像" class="headerlink" title="边框图像"></a>边框图像</h2><p>border-image-source: url(images/border.png);<br>border-image-slice: 27;上、右、下、左侧边缘裁剪27像素，图像被分割为九个区域：四个角、四条边以及一个中间区域。<br>border-image-width: 10px;指定图像边界的宽度：<br>border-image-repeat: round/stretch/repeat;</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>background:color url  repeat position  attachment</strong></p>
<p>设置背景颜色会填充content,padding。</p>
<p>连写的时候没有顺序要求，url为必写项  </p>
<ul>
<li><p><strong>background-position:left top</strong></p>
</li>
<li><p><strong>background-attachment :</strong> <strong>scroll</strong> | <strong>fixed</strong>  </p>
<p><strong>scroll :</strong> 　背景图像是随对象内容滚动<br><strong>fixed :</strong> 　背景图像固定 </p>
</li>
<li><p><strong>background-clip</strong>：padding-box/content-box/border-box;  修改背景颜色区域/规定背景的绘制区域。</p>
</li>
<li><p><strong>background-origin:</strong> border-box;修改背景图片所在区域</p>
</li>
<li><p>**background-position:**center center;图片水平垂直居中</p>
</li>
</ul>
<p>background-size<br>cover 会使“最大”边，进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。<br>contain 会使“最小”边，进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。</p>
<h2 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h2><p>background-image：linear-gradient();radial-gradient()<br>repeating-linear-gradient   repeating-radial-gradient</p>
<h2 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h2><h2 id="css3媒体查询"><a href="#css3媒体查询" class="headerlink" title="css3媒体查询"></a>css3媒体查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@media screen and (max-width:600px) &#123;   </span><br><span class="line">body &#123;      background-color: blue;   &#125;&#125;</span><br><span class="line">@media screen and (min-width:900px) &#123;  </span><br><span class="line">body &#123;      background-color: red;   &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><p><a href="http://www.animate.net.cn/1853.html">http://www.animate.net.cn/1853.html</a></p>
<h3 id="过渡transition"><a href="#过渡transition" class="headerlink" title="过渡transition"></a>过渡transition</h3><p>第一种叫过渡（transition）动画，就是从初始状态过渡到结束状态这个过程中所产生的动画。所谓的状态就是指大小、位置、颜色、变形（transform）等等这些属性。css过渡只能定义首和尾两个状态，所以是最简单的一种动画。</p>
<p><strong>参数</strong></p>
<ul>
<li>property – 什么属性将用动画表现，例如, opacity。</li>
<li>duration –  过渡的时间 </li>
<li>transition-delay – 设置过渡延时</li>
<li>timing-function  – 过渡的速度<ul>
<li>匀速linear  逐渐降速ease 加速ease-in 降速ease-out  先加速后减速ease-in-out</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">transform 和 transition 属性实现简单旋转效果的例子：</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;transition: transform 3s ease-in&quot;</span> </span></span><br><span class="line"><span class="tag">  <span class="attr">onclick</span>=<span class="string">&quot;this.style.transform=&#x27;rotate(360deg)&#x27;&quot;</span>&gt;</span></span><br><span class="line">点击这个方块，能让它旋转起来。</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键帧动画"><a href="#关键帧动画" class="headerlink" title="关键帧动画"></a>关键帧动画</h3><p>第二种叫做关键帧（keyframes）动画。不同于第一种的过渡动画只能定义首尾两个状态，关键帧动画可以定义多个状态，或者用关键帧来说的话，过渡动画只能定义第一帧和最后一帧这两个关键帧，而关键帧动画则可以定义任意多的关键帧，因而能实现更复杂的动画效果。</p>
<p>关键帧动画的定义方式也比较特殊，它使用了一个关键字 @keyframes 来定义动画。具体格式为：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> 动画名称&#123;</span><br><span class="line">   时间点 &#123;元素状态&#125;</span><br><span class="line">   时间点 &#123;元素状态&#125;</span><br><span class="line">   …</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<ul>
<li>animation-name:动画名称</li>
<li>animation-duration: 动画完成一个周期所花费的秒，默认为0</li>
<li>animation-timing-function: 动画的速度，默认ease</li>
<li>animation-delay：动画延时，默认为0</li>
<li>animation-iteration-count: 动画播放次数，默认为1，infinite无限次</li>
<li>animation-direction：动画是否再下一个周期逆向播放</li>
<li>animation-play-state：动画是否正在运行或暂停，默认是running，paused</li>
<li>animation-fill-mode：动画时间之外的状态    </li>
</ul>
<p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5821d8e8b8bb59a5387d17dd3100ad21.png" alt="QQ截图20131102123530"></p>
<p> 这段代码定义了一个名为demo,且有5个关键帧的动画。0% ，10% 等这些表示的是时间点，是相对于整个动画的持续时间来说的，时间点之后的花括号里则是元素的状态属性集合，描述了这个元素在这个时间点的状态，动画发生时，就是从第一个状态到第二个状态进行过渡，然后从第二个状态到第三个状态进行过渡，直到最后一个状态。一般来说，0%和100%这两个关键帧是必须要定义的。</p>
<p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/6e21739e7cb9ee141063b0bceb541fa2.png" alt="QQ截图20131102123530"></p>
<p>注意，为了达到最佳的浏览器兼容效果，在实际书写代码的时候，还必须加上各大浏览器的私有前缀</p>
<p><img src="http://wangzhanmeng.oss-cn-beijing.aliyuncs.com/images/animate.net.cn/2017/10/5e08c5fe40dbf1178ed6283aba8f5843.png" alt="QQ截图20131102123530"></p>
<h3 id="转化transform"><a href="#转化transform" class="headerlink" title="转化transform"></a>转化transform</h3><p>CSS**<code>transform</code>**属性允许你旋转，缩放，倾斜或平移给定元素。</p>
<p>示例：<a href="https://www.vps5.com/example?pid=2959">https://www.vps5.com/example?pid=2959</a></p>
<ul>
<li><p>transform: rotate(360deg);旋转   </p>
</li>
<li><p>transform: skew(45deg);倾斜      </p>
</li>
<li><p>transform: scale(1.5);盒子扩大1.5倍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如何实现小于12px的字体效果</span><br><span class="line">transform:scale()这个属性只可以缩放可以定义宽高的元素，而行内元素是没有宽高的，我们可以加上一个display:inline-block;</span><br><span class="line"></span><br><span class="line">transform: scale(0.7);</span><br></pre></td></tr></table></figure></li>
<li><p>transform: translate(400px) 向左移动400px    translate(-50%,-50%) 作用是，往上（x轴）,左（y轴）移动自身长宽的 50%</p>
</li>
</ul>
<h3 id="3D"><a href="#3D" class="headerlink" title="3D"></a><strong>3D</strong></h3><p><strong>3D 转换方法</strong></p>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">matrix3d(<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>, <em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>,<em>n</em>)</td>
<td align="left">定义 3D 转换，使用 16 个值的 4x4 矩阵。</td>
</tr>
<tr>
<td align="left">translate3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td align="left">定义 3D 转化。</td>
</tr>
<tr>
<td align="left">translateX(<em>x</em>)</td>
<td align="left">定义 3D 转化，仅使用用于 X 轴的值。</td>
</tr>
<tr>
<td align="left">scale3d(<em>x</em>,<em>y</em>,<em>z</em>)</td>
<td align="left">定义 3D 缩放转换。</td>
</tr>
<tr>
<td align="left">scaleX(<em>x</em>)</td>
<td align="left">定义 3D 缩放转换，通过给定一个 X 轴的值。</td>
</tr>
<tr>
<td align="left">rotate3d(<em>x</em>,<em>y</em>,<em>z</em>,<em>angle</em>)</td>
<td align="left">定义 3D 旋转。</td>
</tr>
<tr>
<td align="left">rotateX(<em>angle</em>)</td>
<td align="left">定义沿 X 轴的 3D 旋转。</td>
</tr>
</tbody></table>
<p><strong>3D 转换属性</strong></p>
<ul>
<li><p><a href="https://www.w3school.com.cn/cssref/pr_transform.asp">transform</a>：向元素应用 2D 或 3D 转换</p>
</li>
<li><p><a href="https://www.w3school.com.cn/cssref/pr_transform-origin.asp">transform-origin</a>：变形的原点，允许你改变被转换元素的位置。默认情况，变形的原点在元素的中心点，或者是元素X轴和Y轴的50%处。</p>
<p>示例：<a href="https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html">https://www.w3school.com.cn/example/css3/demo_css3_transform-origin.html</a></p>
</li>
<li><p><a href="https://www.w3school.com.cn/cssref/pr_transform-style.asp">transform-style</a>：规定<strong>被嵌套元素</strong>如何在 3D 空间中显示。</p>
<p>设置transform-style的值为flat，则该元素的所有<strong>子元素</strong>都将被平展到该元素的2D平面中呈现</p>
<p>设置transform-style的值为preserve-3d，它表示不执行平展操作，他的所有子元素位于3D空间中</p>
<p>示例：<a href="https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style">https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_transform-style</a></p>
</li>
<li><p><a href="https://www.w3school.com.cn/cssref/pr_perspective.asp">perspective</a>：定义 3D 元素的景深，当为元素定义 perspective 属性时，其<strong>子元素</strong>会获得透视效果，而不是元素本身（透视效果是写在父亲身上，而不是元素本身）。</p>
<p>用来设置用户和元素3D空间Z平面之间的距离。值越小，用户与3D空间Z平面距离越近，视觉效果更令人印象深刻；反之，值越大，用户与3D空间Z平面距离越远，视觉效果就很小。</p>
<p>示例：<a href="https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1">https://www.w3school.com.cn/tiy/t.asp?f=eg_css3_perspective1</a></p>
</li>
<li><p><a href="https://www.w3school.com.cn/cssref/pr_perspective-origin.asp">perspective-origin</a>：perspective属性的源点角度</p>
</li>
<li><p><a href="https://www.w3school.com.cn/cssref/pr_backface-visibility.asp">backface-visibility</a>：定义元素在不面对屏幕时是否可见。</p>
</li>
</ul>
<h1 id="预编译器"><a href="#预编译器" class="headerlink" title="预编译器"></a>预编译器</h1><h2 id="less、scss-sass区别"><a href="#less、scss-sass区别" class="headerlink" title="less、scss/sass区别"></a>less、scss/sass区别</h2><h3 id="less、scss-sass"><a href="#less、scss-sass" class="headerlink" title="less、scss/sass"></a>less、scss/sass</h3><p>scss/sass是动态样式语言，比css多出很多功能（如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等），更方便阅读和维护。</p>
<p>less也是动态样式语言，一样也比css多处很多功能（如变量，继承，运算， 函数）， Less 既可以在客户端上运行，也可在服务端运行 ( Node.js)。</p>
<p>scss和sass的关系<br>Sass是缩排语法，对于习惯css的web开发者来说很不直观，还是有点学习成本，也不能将css代码加入到sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，<strong>只是用{}取代了原来的缩进</strong>，更容易阅读。</p>
<h3 id="Sass-Scss与Less区别"><a href="#Sass-Scss与Less区别" class="headerlink" title="Sass/Scss与Less区别"></a>Sass/Scss与Less区别</h3><h4 id="编译环境"><a href="#编译环境" class="headerlink" title="编译环境"></a>编译环境</h4><p>sass的安装需要Ruby环境，是在服务端处理的，而less是需要引入less.js来处理less代码输出css到浏览器，也可以在开发环节使用less，然后编译成css文件，直接放到项目中，也有 Less.app、SimpleLess、CodeKit.app这样的工具，也有在线编译地址。在一般前端项目里面使用 yarn add less yarn add less-loader添加到对应的项目里面。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>1、less、scss的变量符不一样</p>
<p>less是@、scss是$、css变量是两根连词线（- -）</p>
<p>2、变量作用域不一样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** Less-作用域*/</span><br><span class="line">@color: #00c; /* 蓝色 */</span><br><span class="line">#header &#123;</span><br><span class="line">  @color: #c00; /* red */</span><br><span class="line">  border: 1px solid @color; /* 红色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  border: 1px solid @color; /* 蓝色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Less-作用域编译后*/</span><br><span class="line">#header&#123;border:1px solid #cc0000;&#125;</span><br><span class="line">#footer&#123;border:1px solid #0000cc;&#125;</span><br><span class="line"></span><br><span class="line">/**scss-作用域*/</span><br><span class="line">$color: #00c; /* 蓝色 */</span><br><span class="line"></span><br><span class="line">#header &#123;</span><br><span class="line"></span><br><span class="line">  $color: #c00; /* red */</span><br><span class="line">  border: 1px solid $color; /* 红色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#footer &#123;</span><br><span class="line">  border: 1px solid $color; /* 蓝色边框 */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Sass-作用域编译后*/</span><br><span class="line"></span><br><span class="line">#header&#123;border:1px solid #c00&#125;</span><br><span class="line">#footer&#123;border:1px solid #c00&#125;</span><br><span class="line"></span><br><span class="line">/** 我们可以看出来，less和scss中的变量会随着作用域的变化而不一样。</span><br><span class="line">*/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>less没有输出设置<br>scss提供四种输出选项：nested, compact, compressed 和 expanded。<br>有四种选择，默认为nested</p>
<p>nested：嵌套缩进的css代码<br>expanded：展开的多行css代码<br>compact：简洁格式的css代码<br>compressed：压缩后的css代码</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>less不支持条件语句<br>scss语句支持if{}else{}、for{}循环语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** if else */</span><br><span class="line">@if lightness($color) &gt; 30% &#123;</span><br><span class="line">	/**	do....*/</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">	/**	do....*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**	循环*/</span><br><span class="line">@for $i from 1 to 10 &#123;</span><br><span class="line">  	.border-#&#123;$i&#125; &#123;</span><br><span class="line">    	border: #&#123;$i&#125;px solid red;</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="引入外部css"><a href="#引入外部css" class="headerlink" title="引入外部css"></a>引入外部css</h4><p><code>scss</code>引用的外部文件命名必须以_开头, 如下例所示:其中<code>_test1.scss</code>、<code>_test2.scss</code>、<code>_test3.scss</code>文件分别设置的h1 h2 h3。文件名如果以下划线<code>_</code>开头的话，<code>sass</code>会认为该文件是一个引用文件，不会将其编译为css文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 源代码：</span><br><span class="line">@import &quot;_test1.scss&quot;;</span><br><span class="line">@import &quot;_test2.scss&quot;;</span><br><span class="line">@import &quot;_test3.scss&quot;;</span><br><span class="line"></span><br><span class="line">// 编译后：</span><br><span class="line">h1 &#123;</span><br><span class="line">  font-size: 17px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h2 &#123;</span><br><span class="line">  font-size: 17px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">h3 &#123;</span><br><span class="line">  font-size: 17px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>less</code>引用外部文件和<code>css</code>中的<code>@import</code>没什么差异。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>sass/scss或是less，都可以看作为一种基于css之上的高级语言，其目的是使得css开发更灵活和更强大，sass的功能比less强大,基本可以说是一种真正的编程语言了，less则相对清晰明了,易于上手,对编译环境要求比较宽松，在实际开发中更倾向于选择less。但如果认真深入scss之后还是建议切换到scss，因为更加强大，更好用。</p>
<h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a><strong>scss</strong></h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li><p>数字，1, 2, 13, 10px</p>
</li>
<li><p>字符串，有引号字符串与无引号字符串，”foo”, ‘bar’, baz</p>
</li>
<li><p>颜色，blue, #04a3f9, rgba(255,0,0,0.5)</p>
</li>
<li><p>布尔型，true, false    </p>
<p>$a: true;$b: false;  只有自身是false和null才会返回false，其他一切都将返回true</p>
</li>
<li><p>空值，null     </p>
<p>$value: null;  由于它代表空，所以不能够使用它与任何类型进行算数运算</p>
</li>
<li><p>数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif</p>
</li>
<li><p>maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)</p>
</li>
</ul>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$blue : #1875e7;　</span><br><span class="line"></span><br><span class="line">div &#123;</span><br><span class="line">  color : $blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果变量需要镶嵌在字符串之中，就必须需要写在**#{}插值表达式**之中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$side : left;</span><br><span class="line"></span><br><span class="line">.rounded &#123;</span><br><span class="line">  border-#&#123;$side&#125;-radius: 5px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>Sass变量的作用域只能在当前层级上有效果。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$fontColor: #EEEEEE;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  $myColor: green;   // 只在 body 里头有用，局部作用域</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>可以使用!global关键词来设置变量为全局变量。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 此时body和a内自涂颜色都为green。</span><br><span class="line">$fontColor: #EEEEEE;</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">  $myColor: green !global;</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#123;</span><br><span class="line">  color: $fontColor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的全局变量我们一般定义在同一个文件，如：globals.scss，然后我们使用 @include来引入该文件。</p>
<h3 id="计算功能"><a href="#计算功能" class="headerlink" title="计算功能"></a><strong>计算功能</strong></h3><p>SASS允许在代码中使用算式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    margin: (14px/2);</span><br><span class="line">    top: 50px + 100px;</span><br><span class="line">    right: $var * 10%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a><strong>嵌套</strong></h3><p>SASS允许选择器嵌套。比如，下面的CSS代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div h1 &#123;</span><br><span class="line">　　　　color : red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　div &#123;</span><br><span class="line">　　　　hi &#123;</span><br><span class="line">　　　　　　color:red;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>属性也可以嵌套，比如border-color属性，可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　p &#123;</span><br><span class="line">　　　　border: &#123;</span><br><span class="line">　　　　　　color: red;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p>在嵌套的代码块内，可以<strong>使用&amp;引用父元素</strong>。比如a:hover伪类，可以写成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">　　a &#123;</span><br><span class="line">　　　　&amp;:hover &#123; color: #ffb3ff; &#125;</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong></p>
<p>SASS共有两种注释风格。</p>
<ul>
<li>标准的CSS注释 /* comment */ ，会保留到编译后的文件。</li>
</ul>
<ul>
<li>单行注释 // comment，只保留在SASS源文件中，编译后被省略。</li>
</ul>
<ul>
<li><p>在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*!</span><br><span class="line">　　　　重要注释！</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="条件语句-1"><a href="#条件语句-1" class="headerlink" title="条件语句"></a><strong>条件语句</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@if可以用来判断：</span><br><span class="line">p &#123;</span><br><span class="line">    @if 1 + 1 == 2 &#123; border: 1px solid; &#125;</span><br><span class="line">    @if 5 &lt; 3 &#123; border: 2px dotted; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配套的还有@else命令：</span><br><span class="line">@if lightness($color) &gt; 30% &#123;</span><br><span class="line">    　　　　background-color: #000;</span><br><span class="line">&#125; @else &#123;</span><br><span class="line">        background-color: #fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="代码的重用"><a href="#代码的重用" class="headerlink" title="代码的重用"></a><strong>代码的重用</strong></h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a><strong>继承</strong></h4><p>SASS允许一个选择器，继承另一个选择器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.class1 &#123;</span><br><span class="line">	border: 1px solid #ddd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class2要继承class1，就要使用@extend命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.class2 &#123;</span><br><span class="line">    @extend .class1;</span><br><span class="line">    font-size:120%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a><strong>Mixin</strong></h4><p>Mixin有点像C语言的宏（macro），是可以重用的代码块。</p>
<p>使用@mixin命令，定义一个代码块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin left &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-left: 10px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用@include命令，调用这个mixin。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">　　@include left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mixin的强大之处，在于可以指定参数和缺省值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@mixin left($value: 10px) &#123;</span><br><span class="line">    float: left;</span><br><span class="line">    margin-right: $value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用的时候，根据需要加入参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">	@include left(20px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="使用-each-循环"><a href="#使用-each-循环" class="headerlink" title="使用@each 循环"></a>使用@each 循环</h4><p>1.循环一个 list: 类名为 icon-10px 、icon-12px、icon-14px 写他们的字体大小写法就可以如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/988e776c0c83446cb62ad369a18fac21~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>2.循环一个 map：类名为 icon-primary、icon-success、icon-secondary 等，但是他们的值又都是变量，写法如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89edd2eb57d94eb485b93c74a711de46~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<h4 id="map-get"><a href="#map-get" class="headerlink" title="map-get"></a>map-get</h4><p>map-get(map,key) 函数的作用是根据 key 参数，返回 key 在 map 中对应的 value 值。如果 key 不存在 map 中，将返回 null 值。此函数包括两个参数：</p>
<p>map：定义好的 map。 </p>
<p>key：需要遍历的 key。</p>
<p>假设要获取 facebook 键值对应的值 #3b5998，我们就可以使用 map-get() 函数来实现：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70c01074ab404f0f81fa65e945d03d70~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>使用&amp;嵌套覆盖原有样式</p>
<p>当一个元素的样式在另一个容器中有其他指定的样式时，可以使用嵌套选择器让他们保持在同一个地方。<code>.no-opacity &amp;</code>相当于<code>.no-opacity .foo</code>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/105bd1160dbd4a8287154408cd243d41~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<p>map-merge</p>
<p>合并两个 map 形成一个新的 map 类型，即将 <em>map2</em> 添加到 <em>map1</em>的尾部</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$font-sizes</span>: (<span class="string">&quot;small&quot;</span>: <span class="number">12px</span>, <span class="string">&quot;normal&quot;</span>: <span class="number">18px</span>, <span class="string">&quot;large&quot;</span>: <span class="number">24px</span>)</span><br><span class="line"><span class="variable">$font-sizes2</span>: (<span class="string">&quot;x-large&quot;</span>: <span class="number">30px</span>, <span class="string">&quot;xx-large&quot;</span>: <span class="number">36px</span>)</span><br><span class="line">map-merge(<span class="variable">$font-sizes</span>, <span class="variable">$font-sizes2</span>)</span><br><span class="line">结果: <span class="string">&quot;small&quot;</span>: <span class="number">12px</span>, <span class="string">&quot;normal&quot;</span>: <span class="number">18px</span>, <span class="string">&quot;large&quot;</span>: <span class="number">24px</span>,<span class="string">&quot;x-large&quot;</span>: <span class="number">30px</span>, <span class="string">&quot;xx-large&quot;</span>: <span class="number">36px</span></span><br></pre></td></tr></table></figure>

<p>@content</p>
<p><code>@content</code> 用在 <code>mixin</code> 里面的，当定义一个 <code>mixin</code> 后，并且设置了 <code>@content</code>； <code>@include</code> 的时候可以传入相应的内容到 <code>mixin</code> 里面</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7369e9cb63e4343a56474f9a1568ede~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="img"></p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="常识-1"><a href="#常识-1" class="headerlink" title="常识"></a>常识</h2><h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">变量的命名规则和规范：由字母、数字、下划线、$符号组成，不能以数字开头</span><br><span class="line">驼峰命名法。首字母小写，后面单词的首字母需要大写</span><br></pre></td></tr></table></figure>

<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a><strong>堆栈</strong></h3><p><strong>栈：</strong></p>
<ul>
<li>存储基础数据类型</li>
<li>栈会开辟一个内存</li>
<li>按值访问</li>
<li>存储的值大小固定</li>
<li>由系统自动分配内存空间</li>
<li>空间小，运行效率高</li>
<li>先进后出，后进先出</li>
</ul>
<p><strong>堆:</strong></p>
<ul>
<li>存储引用数据类型</li>
<li>堆共用同一个内存</li>
<li>按引用访问</li>
<li>存储的值大小不定，可动态调整</li>
<li>主要用来存放对象</li>
<li>空间大，但是运行效率相对较低</li>
<li>无序存储，可根据引用直接获取</li>
</ul>
<p><strong>区别</strong></p>
<ul>
<li>栈由系统自动分配，而堆是人为申请开辟</li>
<li>栈由系统自动分配，速度较快，而堆一般速度比较慢</li>
<li>栈是连续的空间，而堆是不连续的空间</li>
</ul>
<h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a><strong>对象序列化</strong></h3><p>百度：序列化(Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程</p>
<p>前端：对象序列化是指将对象的状态转换为字符串</p>
<p><code>var obj = &#123;x:1, y:2&#125;;</code></p>
<p>当这句代码运行时，对象obj的内容会存储在一块内存中，而obj本身存储的只是这块内存的地址的映射而已。简单的说，对象obj就是我们的程序在电脑通电时在内存中维护的一种东西，如果我们程序停止了或者电脑断电了，对象obj将不复存在。那么如何把对象obj的内容保存在磁盘上呢（也就是说在没电时继续保留着）？这时就需要把对象obj序列化，也就是说把obj的内容转换成一个字符串的形式，然后再保存在磁盘上。另外，我们又怎么通过HTTP协议把对象obj的内容发送到客户端呢？没错，还是需要先把对象obj序列化，然后客户端根据接收到的字符串再反序列化（也就是将字符串还原为对象）解析出相应的对象。这也正是”百度百科—序列化“中描述的两个作用——存储、传输。</p>
<img src="https://pic4.zhimg.com/80/v2-9400de90d5635c8fd8252239244e36e3_720w.jpg" alt="img" style="zoom:50%;" />

<p><img src="https://pic3.zhimg.com/80/v2-75ede02a69c207a5dd8a534ef02e132a_720w.jpg" alt="img"></p>
<p>可以看到，exampleStr和exampleObj2中并没有 y:undefined 的内容。这说明：JSON的语法是JavaScript语法的子集，它并不能表示JavaScript中的所有值，对于JSON语法不支持的属性，序列化后会将其省略。</p>
<p>其详细规则如下：</p>
<p>①对于JavaScript中的五种原始类型，JSON语法支持数字、字符串、布尔值、null四种，不支持undefined；</p>
<p>②NaN、Infinity和-Infinity序列化的结果是null；</p>
<p>③JSON语法不支持函数；</p>
<p>④除了RegExp、Error对象，JSON语法支持其他所有对象；</p>
<p>⑤日期对象序列化的结果是ISO格式的字符串，但JSON.parse()依然保留它们字符串形态，并不会将其还原为日期对象；</p>
<p>⑥JSON.stringify()只能序列化对象的可枚举的自有属性；</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>局部变量无法共享和长久的保存，而全局变量可能造成变量污染，当我们希望有一种机制既可以长久的保存变量又不会造成全局污染。闭包就是指有权访问另一个函数<a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>中的变量的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outterFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = outterFn()</span><br><span class="line">fn()</span><br></pre></td></tr></table></figure>

<p>需求：实现变量a 自增</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Add()());<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(Add()());<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(Add()());<span class="comment">//11</span></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p>因为没有将闭包函数作为对象引用出去，所以执行之后，会被销毁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = Add();<span class="comment">//将函数a赋值给全局变量c时，a会执行一次</span></span><br><span class="line"><span class="built_in">console</span>.log(cc());</span><br><span class="line"><span class="built_in">console</span>.log(cc());</span><br><span class="line"><span class="built_in">console</span>.log(cc());</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将函数Add赋值给全局变量c时，Add会执行一次，并返回闭包函数，此时<strong>全局变量c的值为闭包函数的引用</strong>，此时函数Add虽然已执行完，但因为内部包含<a href="https://so.csdn.net/so/search?q=%E9%97%AD%E5%8C%85%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">闭包函数</a>，所以函数 Add 的执行期上下文会继续保留在内存中，不会被JS的<a href="https://so.csdn.net/so/search?q=%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6&spm=1001.2101.3001.7020">垃圾回收机制</a>回收</p>
<h4 id="闭包的优缺点"><a href="#闭包的优缺点" class="headerlink" title="闭包的优缺点"></a>闭包的优缺点</h4><p>闭包的优点</p>
<ol>
<li>可以减少全局变量的定义，避免全局变量的污染</li>
<li>能够读取函数内部的变量</li>
<li>在内存中维护一个变量，可以用做缓存</li>
</ol>
<p>闭包的缺点</p>
<ul>
<li><p>造成内存泄露</p>
<p>闭包会使函数中的变量一直保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。</p>
<p>解决方法——使用完变量后，手动将它赋值为null；</p>
</li>
<li><p>闭包可能在父函数外部，改变父函数内部变量的值。</p>
</li>
<li><p>造成性能损失。由于闭包涉及跨作用域的访问，所以会导致性能损失。</p>
</li>
</ul>
<h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h4><h5 id="模拟两人对话"><a href="#模拟两人对话" class="headerlink" title="模拟两人对话"></a>模拟两人对话</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function person(name) &#123;</span><br><span class="line">    function say(content) &#123;</span><br><span class="line">        console.log(name + &#x27;:&#x27; + content)</span><br><span class="line">    &#125;</span><br><span class="line">    return say</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = person(&quot;张三&quot;)//</span><br><span class="line">b = person(&quot;李四&quot;)</span><br><span class="line">a(&quot;在干啥？&quot;)</span><br><span class="line">b(&quot;没干啥。&quot;)</span><br><span class="line">a(&quot;出去玩吗？&quot;)</span><br><span class="line">b(&quot;去哪啊？&quot;)</span><br><span class="line"></span><br><span class="line">张三:在干啥？</span><br><span class="line">李四:没干啥。</span><br><span class="line">张三:出去玩吗？</span><br><span class="line">李四:去哪啊？</span><br></pre></td></tr></table></figure>

<h5 id="使setTimeout支持传参"><a href="#使setTimeout支持传参" class="headerlink" title="使setTimeout支持传参"></a>使setTimeout支持传参</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function func(param)&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        alert(param)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f1 = func(1);</span><br><span class="line">setTimeout(f1,1000);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="封装私有变量"><a href="#封装私有变量" class="headerlink" title="封装私有变量"></a>封装私有变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//用闭包定义能访问私有函数和私有变量的公有函数。</span><br><span class="line">var counter = (function () &#123;</span><br><span class="line">    var privateCounter = 0; //私有变量</span><br><span class="line">    function change(val) &#123;</span><br><span class="line">        privateCounter += val;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">        increment: function () &#123;</span><br><span class="line">            change(1);</span><br><span class="line">        &#125;,</span><br><span class="line">        decrement: function () &#123;</span><br><span class="line">            change(-1);</span><br><span class="line">        &#125;,</span><br><span class="line">        value: function () &#123;</span><br><span class="line">            return privateCounter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">console.log(counter.value());//0</span><br><span class="line">counter.increment();</span><br><span class="line">console.log(counter.value());//1</span><br><span class="line">counter.increment();</span><br><span class="line">console.log(counter.value());//2</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p><a href="https://segmentfault.com/a/1190000019250357">https://segmentfault.com/a/1190000019250357</a></p>
<h4 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h4><p><strong>（1）对象是单个实物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p>
<p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。<strong>所谓”构造函数”，就是专门用来生成实例对象的函数</strong>。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>将一个事物所有的状态（属性），行为（方法）封装成一个对象</p>
<h5 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h5><p>封装的对象生成不同的单个对象</p>
<h5 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h5><h4 id="简单方式创建"><a href="#简单方式创建" class="headerlink" title="简单方式创建"></a>简单方式创建</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">或</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">//为对象添加方法，属性</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line">person.name = <span class="string">&quot;TOM&quot;</span>;</span><br><span class="line">person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以这样</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;TOM&quot;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式创建对象简单，但也存在一些问题：创建出来的对象无法实现对象的重复利用，并且没有一种固定的约束，操作起来可能会出现这样或者那样意想不到的问题。如下面这种情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> <span class="built_in">Object</span>;</span><br><span class="line">c[a]=a;</span><br><span class="line">c[b]=b;</span><br><span class="line"><span class="built_in">console</span>.log(c[a],a);<span class="comment">//&#123;&#125; &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(c[a]===a); <span class="comment">//输出什么 false</span></span><br></pre></td></tr></table></figure>

<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> createPerson = <span class="function"><span class="keyword">function</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 声明一个中间对象，该对象就是工厂模式的模子</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 依次添加我们需要的属性与方法</span></span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建两个实例</span></span><br><span class="line"><span class="keyword">var</span> perTom = createPerson(<span class="string">&#x27;TOM&#x27;</span>, <span class="number">20</span>);</span><br><span class="line"><span class="keyword">var</span> PerJake = createPerson(<span class="string">&#x27;Jake&#x27;</span>, <span class="number">22</span>);</span><br></pre></td></tr></table></figure>

<p>缺点：1.无法识别对象类型； 2.每个对象都有自己的 <strong>sayName</strong> 函数，函数不能共享，造成内存浪费</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> per1 = createPerson(<span class="string">&quot;张三&quot;</span>, <span class="number">30</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> per2 = createPerson(<span class="string">&quot;李四&quot;</span>, <span class="number">40</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(per1 <span class="keyword">instanceof</span> createPerson);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(per2 <span class="keyword">instanceof</span> createPerson);<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(per1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(per2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>构造函数模式和工厂模式存在一下不同之处</strong>：</p>
<ul>
<li>没有显示的创建对象（new Object() 或者 var a = {}）</li>
<li>直接将属性和方法赋给this对象</li>
<li>没有return语句</li>
<li>函数共享</li>
</ul>
<h5 id="new-命令的机制"><a href="#new-命令的机制" class="headerlink" title="new 命令的机制"></a><strong>new 命令的机制</strong></h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 先一本正经的创建一个构造函数，其实该函数与普通函数并无区别</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将构造函数以参数形式传入</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">New</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 声明一个中间对象，该对象为最终返回的实例</span></span><br><span class="line">  <span class="keyword">const</span> res = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (func.prototype !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将实例的原型指向构造函数的原型</span></span><br><span class="line">    res.__proto__ = func.prototype;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>,);</span><br><span class="line">  <span class="comment">// ret为构造函数执行的结果，这里通过apply，将构造函数内部的this指向修改为指向实例对象res</span></span><br><span class="line">  <span class="keyword">const</span> ret = func.apply(res, <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>));</span><br><span class="line">  <span class="comment">// 当我们在构造函数中明确指定了返回对象时，那么new的执行结果就是该返回对象(即在构造函数中明确写了return this;)</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> ret === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> ret === <span class="string">&quot;function&quot;</span>) &amp;&amp; ret !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果没有明确指定返回对象，则默认返回res，这个res就是实例对象</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过new声明创建实例，这里的p1，实际接收的正是new中返回的res</span></span><br><span class="line"><span class="keyword">const</span> person1 = New(Person, <span class="string">&#x27;tom&#x27;</span>, <span class="number">20</span>);<span class="comment">//等同于New Person</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.getName());</span><br><span class="line"><span class="comment">// 当然，这里也可以判断出实例的类型了</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li>
<li>将这个空对象赋值给构造函数内部的<code>this</code>关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><img src="https://img2018.cnblogs.com/blog/850375/201907/850375-20190708151322530-1608157973.png" alt="img" style="zoom:67%;" />

<blockquote>
<p>①所有<code>引用类型</code>都有一个<code>__proto__(隐式原型)</code>属性，属性值是一个普通的对象<br>②所有<code>函数</code>都有一个<code>prototype(原型)</code>属性，属性值是一个普通的对象<br>③所有<code>引用类型的__proto__</code>属性<code>指向构造函数的prototype</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Array</span>.prototype;) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>所有对象都有自己的原型对象（prototype）。原型对象的所有属性和方法，都能被实例对象共享。当我们访问对象的属性或者方法时，会优先访问实例对象自身的属性和方法。</strong></p>
<blockquote>
<p>当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的<code>__proto__</code>隐式原型上查找，即它的构造函数的<code>prototype</code>，如果还没有找到就会再在构造函数的<code>prototype</code>的<code>__proto__</code>中查找，这样一层一层向上查找就会形成一个链式结构，我们称为<code>原型链</code>。</p>
</blockquote>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的。</p>
<img src="https://img-blog.csdn.net/20180620134143385?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 67%;" />

<img src="https://img-blog.csdn.net/20180620155400807?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpYW9lcm1pbmdu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述" style="zoom: 67%;" />

<p><code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(<span class="built_in">Object</span>.prototype)</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.__proto__ === <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><p>当一个实例对象被创建时，这个构造函数 将会把它的属性prototype赋给实例对象的内部属性__proto__。<strong>proto是指向构造函数原型对象的指针。</strong></p>
<h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h5><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">P.prototype.constructor === P <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">P</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> P();</span><br><span class="line"></span><br><span class="line">p.constructor === P <span class="comment">// true</span></span><br><span class="line">p.constructor === P.prototype.constructor <span class="comment">// true</span></span><br><span class="line">p.hasOwnProperty(<span class="string">&#x27;constructor&#x27;</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性。</p>
<h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>判断是否是数组 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>判断某个对象是否是某个构造函数的实例 </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> a()</span><br><span class="line"><span class="comment">//判断实例的构造函数</span></span><br><span class="line"><span class="built_in">console</span>.log(b <span class="keyword">instanceof</span> a) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="继承-2"><a href="#继承-2" class="headerlink" title="继承"></a>继承</h4><p><a href="https://blog.csdn.net/qq_42926373/article/details/83149347">https://blog.csdn.net/qq_42926373/article/details/83149347</a></p>
<p>首先创建一个构造函数，并为其设置私有属性和公有属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个人类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="built_in">this</span>.sleep = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在睡觉！&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型方法</span></span><br><span class="line">Person.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27;正在吃：&#x27;</span> + food);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h5><p>重点圈起来：将父类实例赋值给子类原型对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br></pre></td></tr></table></figure>

<h5 id="构造继承"><a href="#构造继承" class="headerlink" title="构造继承"></a>构造继承</h5><p>重点圈起来：执行父构造，将This指向本身，拉取父私有属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构造函数指向</span></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure>

<h5 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h5><p>重点圈起来：构造继承与原型继承组合。注意注释区域，切勿在继承时使用此方法重写或添加方法，否则将会修改整个原型，导致崩塌。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">    Super.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型继承</span></span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line"><span class="comment">// 构造函数指向</span></span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure>

<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p>this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。</p>
<h4 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h4><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码将一个对象赋值给变量<code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 5</span><br><span class="line">    [[writable]]: true</span><br><span class="line">    [[enumerable]]: true</span><br><span class="line">    [[configurable]]: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面。</p>
<p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123; foo: function () &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var f = function () &#123;&#125;;</span><br><span class="line">var obj = &#123; f: f &#125;;</span><br><span class="line"></span><br><span class="line">// 单独执行</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">// obj 环境执行</span><br><span class="line">obj.f()</span><br></pre></td></tr></table></figure>

<p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供。</p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var f = function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x = 1;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 单独执行</span><br><span class="line">f() // 1</span><br><span class="line"></span><br><span class="line">// obj 环境执行</span><br><span class="line">obj.f() // 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>。</p>
<h4 id="类型指向"><a href="#类型指向" class="headerlink" title="类型指向"></a>类型指向</h4><p><a href="https://blog.csdn.net/m0_65450343/article/details/123109326">https://blog.csdn.net/m0_65450343/article/details/123109326</a></p>
<h5 id="全局作用域中的this"><a href="#全局作用域中的this" class="headerlink" title="全局作用域中的this"></a>全局作用域中的this</h5><p> 在严格模式下，在全局作用域中，this指向window对象 </p>
<h5 id="全局作用域中函数中的this"><a href="#全局作用域中函数中的this" class="headerlink" title="全局作用域中函数中的this"></a>全局作用域中函数中的this</h5><ul>
<li>在非严格模式下: this的指向依旧是window对象</li>
<li>在严格模式下:this的指向是undefined</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"> </span><br><span class="line">console.log(&quot;严格模式&quot;);</span><br><span class="line">console.log(&#x27;在全局作用域中函数中的this&#x27;);</span><br><span class="line">function f1()&#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="对象方法中的this"><a href="#对象方法中的this" class="headerlink" title="对象方法中的this"></a>对象方法中的this</h5><p>在严格模式下，<strong>对象的函数中的this指向调用函数的对象实例</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&quot;在对象的函数中的this&quot;);</span><br><span class="line">var o = new Object();</span><br><span class="line">o.a = &#x27;o.a&#x27;;</span><br><span class="line">o.f5 = function()&#123;</span><br><span class="line">    return this.a;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o.f5());</span><br></pre></td></tr></table></figure>

<p><strong>特殊情况</strong></p>
<ul>
<li>```js<br>const obj = {<br>  name() {<pre><code>console.log(this) //obj
function fn() &#123;
  console.log(this) //window
&#125;
fn()
</code></pre>
  }<br>}<br>obj.name()<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如何让函数fn也能使用当前obj这个对象了</span><br><span class="line"></span><br><span class="line">1. 将this赋值给that</span><br><span class="line"></span><br><span class="line">2. 使用箭头函数</span><br><span class="line"></span><br></pre></td></tr></table></figure>
   const obj = {<pre><code> name() &#123;
   console.log(this) //obj
   const fn = () =&gt; &#123;
     console.log(this) //window
   &#125;
   fn()
 &#125;
</code></pre>
   }<br>   obj.name()   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">- 将对象中方法赋值给变量</span><br><span class="line"></span><br><span class="line">  ```js</span><br><span class="line">  const a = &#123;</span><br><span class="line">    a: 10,</span><br><span class="line">    b: &#123;</span><br><span class="line">      a: 12,</span><br><span class="line">      fn: function () &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  const j = a.b.fn</span><br><span class="line">  a.b.fn()//12</span><br><span class="line">  j()//window</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="构造函数的this"><a href="#构造函数的this" class="headerlink" title="构造函数的this"></a><strong>构造函数的this</strong></h5><p>this指向构造函数的实例对象</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">function constru() &#123;</span><br><span class="line">  this.a = &#x27;constru.a&#x27;;</span><br><span class="line">  this.b = &#x27;constru.b.old&#x27;;</span><br><span class="line">  this.c = &#x27;constru.c&#x27;;</span><br><span class="line">  this.f2 = function () &#123;</span><br><span class="line">    console.log(this);<span class="comment">//&#123; a: &#x27;constru.a&#x27;, b: &#x27;o2.b&#x27;, c: &#x27;constru.c&#x27;, f2: [λ] &#125;</span></span><br><span class="line">    return this.b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">const o2 = new constru();</span><br><span class="line">o2.b = &#x27;o2.b&#x27;;</span><br><span class="line">console.log(o2.f2());<span class="comment">//o2.b </span></span><br></pre></td></tr></table></figure>

<h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h5><p><strong>超时调用（<code>setTimeout</code>回调）的代码都是在全局作用域环境中执行的</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//window</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn()</span><br></pre></td></tr></table></figure>

<p>如果定时器中放<a href="https://so.csdn.net/so/search?q=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">箭头函数</a> ，则会将this指向所在的对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;</span><br><span class="line">  <span class="attr">fn</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>);<span class="comment">//obj</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">a.fn()</span><br></pre></td></tr></table></figure>

<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数体内的<code>this</code>对象，就是定义<strong>该函数时所在的作用域指向的对象</strong>，而不是使用时所在的作用域指向的对象。<strong>箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象)，此处指父级作用域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//call绑定并执行了一次</span></span><br><span class="line"><span class="keyword">const</span> f = foo.call(&#123; <span class="attr">id</span>: <span class="number">111</span> &#125;);        <span class="comment">// 设置foo的id为1</span></span><br><span class="line"></span><br><span class="line">f.call(&#123; <span class="attr">id</span>: <span class="number">2</span> &#125;)()();     <span class="comment">// id: 111</span></span><br><span class="line">f().call(&#123; <span class="attr">id</span>: <span class="number">3</span> &#125;)()      <span class="comment">// id: 111</span></span><br><span class="line">f()().call(&#123; <span class="attr">id</span>: <span class="number">4</span> &#125;)      <span class="comment">// id: 111</span></span><br><span class="line"><span class="comment">//上面代码之中，只有一个this，就是函数foo的this。所以t1、t2、t3都输出同样的结果。</span></span><br></pre></td></tr></table></figure>

<p>因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。所以箭头函数的this指向是创建它所在的对象，不会改变。</p>
<h5 id="React中this指向"><a href="#React中this指向" class="headerlink" title="React中this指向"></a>React中this指向</h5><p><a href="https://blog.csdn.net/weixin_58207509/article/details/121185142">https://blog.csdn.net/weixin_58207509/article/details/121185142</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    state = &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;hello react&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    handleClick () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">&#x27;8888&#x27;</span>) <span class="comment">// 这里的this是？</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    render () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>, <span class="string">&#x27;render里的this&#x27;</span>) <span class="comment">// 这里的this是？</span></span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>点我&lt;/button+&gt;</span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      )</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">ReactDOM.render(<span class="tag">&lt;<span class="name">App</span>&gt;</span><span class="tag">&lt;/<span class="name">App</span>&gt;</span>, document.getElementById(&#x27;root&#x27;))</span></span><br></pre></td></tr></table></figure>

  <img src="https://img-blog.csdnimg.cn/5b50b6fb880042a2beca398c77872cd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5o2n6bKc6Iqx55qE5ZSQ6ICB6bit,size_19,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 50%;" /> 

<p>render方法中的this指向当前react组件。</p>
<p>事件处理程序中的this指向的是undefined</p>
<p><strong>分析原因</strong></p>
<ul>
<li><p>class的内部，开启了局部严格模式use strict，所以this不会指向window而是undefined</p>
</li>
<li><p>onClick={this.fn}中，this.fn的调用并不是通过类的实例调用的，所以值是undefined</p>
</li>
</ul>
<ul>
<li>render函数是被组件实例调用的，因此render函数中的this指向当前组件</li>
</ul>
<h4 id="call、apply、bind"><a href="#call、apply、bind" class="headerlink" title="call、apply、bind"></a>call、apply、bind</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h5><p>他们的作用都是<strong>改变函数内部的this</strong>。这三个函数都是Function原型中的方法（所有的函数都是Function的</p>
<p>实例），也就是说<strong>只有函数才可以直接调用这些方法</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDate</span>(<span class="params">month, day</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.year + <span class="string">&#x27;-&#x27;</span> + month + <span class="string">&#x27;-&#x27;</span> + day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">year</span>: <span class="number">2022</span> &#125;</span><br><span class="line">getDate.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">8</span>)    <span class="comment">//undefined-3-8</span></span><br><span class="line">getDate.call(obj, <span class="number">3</span>, <span class="number">8</span>)     <span class="comment">//2022-3-8</span></span><br><span class="line">getDate.apply(obj, [<span class="number">6</span>, <span class="number">8</span>])  <span class="comment">//2022-6-8</span></span><br><span class="line">getDate.bind(obj)           <span class="comment">//bind 只是修改this指向，并不会调用</span></span><br><span class="line"><span class="keyword">const</span> getDateNew = getDate.bind(obj)</span><br><span class="line">getDateNew(<span class="number">1</span>, <span class="number">1</span>)					<span class="comment">//2022-1-1</span></span><br></pre></td></tr></table></figure>

<h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a><strong>参数</strong></h5><p>参数：三个函数的第一个参数都是需要绑定的 this。</p>
<ul>
<li><p>call： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。</p>
<p>foo.call(this, arg1,arg2, … ,argn );</p>
</li>
<li><p>bind： 可以有n个参数，从第二个参数开始的所有参数都是原函数的参数。</p>
<p>foo.bind(this, arg1,arg2, … ,argn)</p>
</li>
<li><p>apply：只有两个参数，并且第二个参数必须为数组，数组中的所有元素一一对应原函数的参数。 </p>
<p>foo.apply(this, [ arg1,arg2, … ,argn ] );</p>
</li>
</ul>
<p><strong>call/apply 修改完this指向后，会立即调用原函数，但是 bind 只是修改this指向，并不会调用，调用后返回已经绑定好this的函数。</strong></p>
<h5 id="场景"><a href="#场景" class="headerlink" title="场景"></a><strong>场景</strong></h5><ul>
<li>处理伪数组 (最常用)</li>
<li>继承</li>
<li>取数组最大最小值</li>
<li>合并数组</li>
</ul>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在函数原型上增加call1方法</span><br><span class="line">Function.prototype.call1 = function(context, ...rest) &#123;</span><br><span class="line">let newContext = context || window</span><br><span class="line">  newContext.fn = this  // 将调用call函数的对象添加到context的属性中</span><br><span class="line">  </span><br><span class="line">  let result = newContext.fn(...rest)  //  // 执行该属性</span><br><span class="line"></span><br><span class="line">  delete newContext.fn  // 删除该属性</span><br><span class="line"></span><br><span class="line">  return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在函数原型上增加apply1方法</span><br><span class="line">Function.prototype.apply = function(thisArg, args) &#123;</span><br><span class="line">    if (typeof this !== &#x27;function&#x27;) &#123; </span><br><span class="line">        throw new TypeError(&#x27;Error&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">    thisArg = thisArg || window</span><br><span class="line">    thisArg.fn = this</span><br><span class="line">    let result</span><br><span class="line">    if(args) &#123;</span><br><span class="line">        result = thisArg.fn(...args)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = thisArg.fn()</span><br><span class="line">    &#125;</span><br><span class="line">    delete thisArg.fn</span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Function.prototype.bind = function(thisArg) &#123;</span><br><span class="line">    if(typeof this !== &#x27;function&#x27;)&#123;</span><br><span class="line">        throw new TypeError(this + &#x27;must be a function&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    // 存储函数本身</span><br><span class="line">    const _this  = this;</span><br><span class="line">    // 去除thisArg的其他参数 转成数组</span><br><span class="line">    const args = [...arguments].slice(1)</span><br><span class="line">    // 返回一个函数</span><br><span class="line">    const bound = function() &#123;</span><br><span class="line">        // 可能返回了一个构造函数，我们可以 new F()，所以需要判断</span><br><span class="line">        if (this instanceof bound) &#123;</span><br><span class="line">            return new _this(...args, ...arguments)</span><br><span class="line">        &#125;</span><br><span class="line">        // apply修改this指向，把两个函数的参数合并传给thisArg函数，并执行thisArg函数，返回执行结果</span><br><span class="line">        return _this.apply(thisArg, args.concat(...arguments))</span><br><span class="line">    &#125;</span><br><span class="line">    return bound</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>高阶组件即<code>高阶函数</code>。React遵循函数式开发，而高阶组件这个概念其实是React社区繁衍出来的概念。</p>
<p>在这里我们要谨记这一句话，<strong>组件 = 函数</strong>。</p>
<blockquote>
<p>高阶函数：一个函数，接受一个或多个函数作为参数并返回一个函数 。</p>
<p>高阶组件：一个函数，接受一个或多个组件作为参数并返回一个组件 。</p>
</blockquote>
<h4 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a><strong>实际应用场景</strong></h4><h5 id="vue-防抖按钮"><a href="#vue-防抖按钮" class="headerlink" title="vue:防抖按钮"></a>vue:防抖按钮</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// NewButton.vue</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#123; Button &#125; from &#x27;element-ui&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;Button&#x27;,</span><br><span class="line">  components: &#123; &#x27;el-button&#x27;: Button &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      timer: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    click() &#123;</span><br><span class="line">      // 实现防抖</span><br><span class="line">      const that = this</span><br><span class="line">      clearTimeout(that.timer)</span><br><span class="line">      that.timer = setTimeout(function() &#123;</span><br><span class="line">        that.$emit(&#x27;click&#x27;)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">      ;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  render(createElement) &#123;</span><br><span class="line">    return createElement(</span><br><span class="line">      &#x27;el-button&#x27;,</span><br><span class="line">      &#123;</span><br><span class="line">        on: &#123; click: this.click &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#x27;按钮&#x27;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用新组件的时候</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.vue</span></span><br><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">NewButton</span> @<span class="attr">click</span>=<span class="string">&quot;click&quot;</span> /&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> NewButton <span class="keyword">from</span> <span class="string">&quot;./Button&quot;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">components</span>: &#123; NewButton &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="attr">methods</span>: &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="function"><span class="title">click</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="built_in">console</span>.log(<span class="string">&#x27;一秒的防抖效果&#x27;</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h5 id="react-权限按钮"><a href="#react-权限按钮" class="headerlink" title="react:权限按钮"></a>react:权限按钮</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React, &#123; FC &#125; from &#x27;react&#x27;;</span><br><span class="line">import &#123; useAccess &#125; from &#x27;../../../hooks/useAccess&#x27;;</span><br><span class="line">import &#123; message &#125; from &#x27;antd&#x27;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 权限高阶组件，使用示例：</span><br><span class="line"> * </span><br><span class="line"> * import WithAccess from &#x27;@components/WithAccess&#x27;;</span><br><span class="line"> * </span><br><span class="line"> * const WithAccessBtn = WithAccess(你的组件, 可选&#x27;button&#x27; | &#x27;menu&#x27; 默认为button);</span><br><span class="line"> * </span><br><span class="line"> * &lt;WithAccessBtn permission=&#x27;permission&#x27; /&gt;</span><br><span class="line"> * </span><br><span class="line"> * @param Comp 组件</span><br><span class="line"> * @param type 鉴权类型 按钮：button，菜单：menu</span><br><span class="line"> * @returns </span><br><span class="line"> */</span><br><span class="line">const WithAccess = (Comp, type = &#x27;button&#x27;) =&gt; &#123;</span><br><span class="line">  const Access = props =&gt; &#123;</span><br><span class="line">    const &#123; getPermission &#125; = useAccess();</span><br><span class="line">    const &#123; permission, name, icon, onClick &#125; = props;</span><br><span class="line">    //showVisible是否展示, available是否有权限</span><br><span class="line">    const &#123; showVisible, available &#125; = getPermission(permission, type) || &#123;&#125;;</span><br><span class="line">    let initProps = props</span><br><span class="line">    console.log(props);</span><br><span class="line">    const config = () =&gt; &#123;</span><br><span class="line">      if (available === 0) &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          onClick: () =&gt; &#123;</span><br><span class="line">            message.info(&#x27;按钮没有权限&#x27;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return showVisible ? &lt;Comp &#123;...initProps&#125; &#123;...config()&#125;&gt;&#123;name&#125;&lt;/Comp&gt; : null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return Access;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default WithAccess;</span><br></pre></td></tr></table></figure>

<p>使用高阶组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import usePermissionModel from &quot;../../hox/access&quot;;</span><br><span class="line">import WithAccess from &#x27;./components&#x27;</span><br><span class="line">import &#123; Button, message &#125; from &#x27;antd&#x27;;</span><br><span class="line">import &#123; LaptopOutlined &#125; from &quot;@ant-design/icons&quot;;</span><br><span class="line"></span><br><span class="line">const WithAccessBtnYes = WithAccess(Button)</span><br><span class="line">const WithAccessBtnNo = WithAccess(Button)</span><br><span class="line">export default function AHooks(props) &#123;</span><br><span class="line">  const &#123; menus, set &#125; = usePermissionModel();</span><br><span class="line">  console.log(menus, set)</span><br><span class="line">  return &lt;div&gt;</span><br><span class="line">    &lt;WithAccessBtnYes permission=&#x27;account:authorization:yes&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnYes&gt;</span><br><span class="line">    &lt;WithAccessBtnNo permission=&#x27;account:authorization:no&#x27; name=&#x27;按钮&#x27; icon=&#123;&lt;LaptopOutlined /&gt;&#125; onClick=&#123;() =&gt; &#123; message.success(&#x27;按钮有权限&#x27;) &#125;&#125;&gt;&lt;/WithAccessBtnNo&gt;</span><br><span class="line">  &lt;/div&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="位置获取"><a href="#位置获取" class="headerlink" title="位置获取"></a>位置获取</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><p><img src="https://img-blog.csdnimg.cn/20210203195542730.png" alt="在这里插入图片描述"></p>
<ul>
<li>视口/浏览器窗口可视区域：<strong>不包括浏览器的 UI，菜单栏等</strong>——即指你正在浏览的文档的那一部分。视口大小是可变的<code>document.documentElement.clientWidth</code></li>
</ul>
<h4 id="获取鼠标当前位置（事件对象）"><a href="#获取鼠标当前位置（事件对象）" class="headerlink" title="获取鼠标当前位置（事件对象）"></a>获取鼠标当前位置（事件对象）</h4><ul>
<li><p>offsetX、offsetY：  鼠标的当前位置 相对于 目标节点的内填充边顶部、内填充边左部的位置。<strong>内填充边意思是不包含border，但包含padding</strong>，类似于padding-box。</p>
</li>
<li><p>clientX、clientY： 鼠标当前位置 相对于 <strong>视口</strong>顶部、浏览器可视区域左部 的位置；</p>
</li>
<li><p>pageY、pageX：     鼠标当前位置 相对于 <strong>页面/文档</strong>顶部、<strong>页面/文档</strong>左部的位置；</p>
</li>
<li><p>screenY、screenX：鼠标当前位置 相对于 <strong>屏幕</strong>顶部、屏幕左部的位置；</p>
</li>
</ul>
<p><img src="https://yqfile.alicdn.com/img_0dd0fbe280de6112d9c8bb8b0ab8acab.jpeg" alt="img_0dd0fbe280de6112d9c8bb8b0ab8acab.jpe"></p>
<h4 id="获取元素当前位置"><a href="#获取元素当前位置" class="headerlink" title="获取元素当前位置"></a>获取元素当前位置</h4><ul>
<li><p>Element.getBoundingClientRect()   获取元素相对于<strong>视口</strong>的位置 </p>
<p>width、height：元素自身的宽高</p>
<p>top、bottom、left、right：分别是该元素的元素框（盒模型）上下左右位置距视口的距离。</p>
</li>
</ul>
<img src="https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect/element-box-diagram.png" alt="DOMRect object that is the smallest rectangle containing the entire element." style="zoom:33%;" />



<ul>
<li><p>clientHeight：内容+padding（上下）</p>
<p>clientWidth：内容+padding（左右）</p>
</li>
<li><p>offsetTop：从边框border（不包含）距离父元素的高度距离</p>
<p>offsetLeft：从边框border（不包含）距离父元素的宽度距离</p>
<p>offsetHeight：内容+padding+border</p>
<p>offsetWidth： 内容+padding+border</p>
</li>
<li><p>scrolleft/top：读取或设置<strong>元素滚动条</strong>到<strong>元素</strong>左边的距离。</p>
</li>
<li><p>scrollWidth/height 总的宽/高（显示+隐藏的）</p>
</li>
</ul>
<h4 id="获取浏览器宽高"><a href="#获取浏览器宽高" class="headerlink" title="获取浏览器宽高"></a>获取浏览器宽高</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.outerWidth/Height获取浏览器显示区域，包括所有界面元素（如工具栏）</span><br><span class="line"><span class="built_in">window</span>.innerWidth/Height获取浏览器显示区域，不包括工具栏等的高度</span><br></pre></td></tr></table></figure>

<p><img src="https://www.w3cplus.com/sites/default/files/blogs/2017/1711/window-scroll-1.png" alt="视口宽高、位置与滚动高度"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">JQ</span><br><span class="line">获取页面的文档高度(包括滚动出去的宽高)   </span><br><span class="line">$(<span class="built_in">document</span>).height();   </span><br><span class="line">获取页面的文档宽度 ：</span><br><span class="line">$(<span class="built_in">document</span>).width(); </span><br><span class="line">JQ</span><br><span class="line">获取浏览器显示区域（可视区域）的高度 ：   </span><br><span class="line">$(<span class="built_in">window</span>).height()=<span class="built_in">window</span>.innerHeight;   </span><br><span class="line">获取浏览器显示区域（可视区域）的宽度 ：</span><br><span class="line">$(<span class="built_in">window</span>).width()=<span class="built_in">window</span>.innerWidth</span><br><span class="line">获取滚动条到顶部的垂直高度 (即网页被卷上去的高度)  </span><br><span class="line">$(<span class="built_in">document</span>).scrollTop();   </span><br><span class="line">获取滚动条到左边的垂直宽度 ：</span><br><span class="line">$(<span class="built_in">document</span>).scrollLeft(); </span><br></pre></td></tr></table></figure>

<h4 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h4><p><code>window.scrollTo(options)</code>方法,<code>options</code>是一个对象，有三个属性：<br><code>top</code>，<code>left</code> ，<code>behavior</code> 类型String,表示滚动行为,支持参数 <code>smooth</code>(平滑滚动),<code>instant</code>(瞬间滚动),默认值auto（等同于<code>instant</code>）</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h4><p>mouseup事件在释放按下的鼠标键时触发。</p>
<p>mousedown事件在按下鼠标键时触发。</p>
<p>mousemove事件当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次代码。 </p>
<p>mouseover事件和mouseenter事件，都是鼠标进入一个节点时触发。</p>
<p>两者的区别是，mouseover事件会冒泡，mouseenter事件不会。子节点的mouseover事件会冒泡到父节点，进而触发父节点的mouseover事件。mouseenter事件就没有这种效果，所以进入子节点时，不会触发父节点的监听</p>
<p>mouseout事件和mouseleave事件，都是鼠标离开一个节点时触发。</p>
<p>两者的区别是，mouseout事件会冒泡，mouseleave事件不会。子节点的mouseout事件会冒泡到父节点，进而触发父节点的mouseout事件。mouseleave事件就没有这种效果，所以离开子节点时，不会触发父节点的监听函数。</p>
<h4 id="拖拉事件"><a href="#拖拉事件" class="headerlink" title="拖拉事件"></a>拖拉事件</h4><p><a href="https://blog.csdn.net/u012060033/article/details/89787009">https://blog.csdn.net/u012060033/article/details/89787009</a></p>
<p>拖拉指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p>
<p>拖拉的对象有好几种，包括Element节点、图片、链接、选中的文字等等。在HTML网页中，除了Element节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让Element节点可拖拉，可以将该节点的draggable属性设为true。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div draggable=&quot;true&quot;&gt;</span><br><span class="line">  此区域可拖拉</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>draggable属性可用于任何Element节点，但是图片（img元素）和链接（a元素）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为false，防止拖拉。</p>
<p>注意，一旦某个Element节点的draggable属性设为true，就无法再用鼠标选中该节点内部的文字或子节点了。</p>
<p>当Element节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件：</p>
<ul>
<li>drag事件：拖拉过程中，在被拖拉的节点上持续触发。</li>
<li>dragstart事件：拖拉开始时在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li>
<li>dragend事件：拖拉结束时（释放鼠标键或按下escape键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragStart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。</li>
<li>dragenter事件：拖拉进入当前节点时，在当前节点上触发，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li>
<li>dragover事件：拖拉到当前节点上方时，在当前节点上持续触发，该事件的target属性是当前节点。该事件与dragenter事件基本类似，默认会重置当前的拖拉事件的效果（DataTransfer对象的dropEffect属性）为none，即不允许放下被拖拉的节点，所以如果允许在当前节点drop数据，通常会使用preventDefault方法，取消重置拖拉效果为none。</li>
<li>dragleave事件：拖拉离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。在视觉上显示拖拉离开当前节点，就在这个事件的监听函数中设置。</li>
<li>drop事件：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下Escape键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li>
</ul>
<p>关于拖拉事件，有以下几点注意事项。</p>
<ul>
<li><p>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</p>
</li>
<li><p>将文件从操作系统拖拉进浏览器，不会触发dragStart和dragend事件。</p>
</li>
<li><p>dragenter和dragover事件的监听函数，用来指定可以放下（drop）拖拉的数据。由于网页的大部分区域不适合作为drop的目标节点，所以这两个事件的默认设置为当前节点不允许drop。如果想要在目标节点上drop拖拉的数据，首先必须阻止这两个事件的默认行为，或者取消这两个事件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div ondragover=&quot;return false&quot;&gt;</span><br><span class="line">&lt;div ondragover=&quot;event.preventDefault()&quot;&gt;</span><br></pre></td></tr></table></figure>

<p> 上面代码中，如果不取消拖拉事件或者阻止默认行为，就不可能在div节点上drop被拖拉的节点。 </p>
</li>
</ul>
<h3 id="属性获取"><a href="#属性获取" class="headerlink" title="属性获取"></a>属性获取</h3><ul>
<li><p>js获取css属性值</p>
<ul>
<li>jquery方法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//jquery方法</span><br><span class="line">const jq_width = $(&#x27;.box&#x27;).css(&#x27;width&#x27;);</span><br><span class="line">const jq_lineHeight = $(&#x27;.box&#x27;).css(&#x27;line-height&#x27;);</span><br><span class="line">console.log(jq_width,jq_lineHeight);//200px 150px</span><br></pre></td></tr></table></figure>

<ul>
<li>然后我们再用js原生方法去获取</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原生style.css方法</span></span><br><span class="line"><span class="keyword">const</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.box&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> js_width = box.style.width;</span><br><span class="line"><span class="keyword">const</span> js_lineHeight = box.style.lineHeight;</span><br><span class="line"><span class="built_in">console</span>.log(js_width,js_lineHeight);<span class="comment">//   50px</span></span><br><span class="line"><span class="comment">//在这里我们会发现style.css方法只能获取到写在标签上的属性 style = &quot;line-height:150px&quot; 不能获取写在&lt;style&gt;``&lt;/style&gt;中的css属性</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用<code>window.getComputedStyle</code>这个方法获取所有经过浏览器计算过的样式</li>
</ul>
</li>
<li><p>elementNode.getAttribute(name)：方法通过名称获取属性的值。</p>
<p>elementNode.setAttribute(name, value)：方法创建或改变某个新属性。</p>
<p>elementNode.removeAttribute(name)：方法通过名称删除属性的值。</p>
</li>
</ul>
<h3 id="节点元素获取"><a href="#节点元素获取" class="headerlink" title="节点元素获取"></a>节点元素获取</h3><blockquote>
<p>getElementsBy方法都是伪数组arguments</p>
</blockquote>
<blockquote>
<p>判断当前的子节点是否是元素节点    if (node.nodeType === 1)</p>
</blockquote>
<p>parentNode    父元素        childNodes  所有子节点    children    所有的子元素</p>
<p>lastChild    获取最后一个子节点    lastElementChild     获取最后一个子元素</p>
<p>nextSibling  下一个兄弟节点        nextElementSibling    下一个兄弟元素</p>
<p>previousSibling   上一个兄弟节点     previousElementSibling    上一个兄弟元素</p>
<h2 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h2><h3 id="事件流阶段"><a href="#事件流阶段" class="headerlink" title="事件流阶段"></a>事件流阶段</h3><blockquote>
<p><code>W3C</code>中定义事件的发生经历三个阶段：捕获阶段（<code>capturing</code>）、目标阶段（<code>targetin</code>）、冒泡阶段（<code>bubbling</code>）</p>
</blockquote>
<ul>
<li>冒泡型事件：当你使用事件冒泡时，子级元素先触发，父级元素后触发</li>
<li>捕获型事件：当你使用事件捕获时，父级元素先触发，子级元素后触发</li>
<li><code>DOM</code>事件流：同时支持两种事件模型：捕获型事件和冒泡型事件</li>
<li>阻止冒泡：在<code>W3c</code>中，使用<code>stopPropagation()</code>方法；在IE下设置<code>cancelBubble = true</code></li>
<li>阻止捕获：阻止事件的默认行为，例如<code>click - &lt;a&gt;</code>后的跳转。在<code>W3c</code>中，使用<code>preventDefault()</code>方法，在<code>IE</code>下设置<code>window.event.returnValue = false</code></li>
</ul>
<p>监听事件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">.addEventListener(&#x27;click&#x27;, fn, false);//false(默认)是事件冒泡，true是事件捕获</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">e.stopPropagation();阻止事件冒泡  e.preventDefault()阻止事件默认行为。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在jQuery中使用return false时，相当于同时使用event.preventDefault和event.stopPropagation，它会阻止冒泡也会阻止默认行为。 但是使用原生js写时，return false只会阻止默认行为。</span><br></pre></td></tr></table></figure>

<h3 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h3><p>简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</p>
<p>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</p>
<p>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。可以大量节省内存占用，减少事件注册</p>
<h3 id="事件对象event"><a href="#事件对象event" class="headerlink" title="事件对象event"></a>事件对象event</h3><ul>
<li><code>target</code>是事件触发的真实元素</li>
<li><code>currentTarget</code>是事件绑定的元素</li>
<li>事件处理函数中的<code>this</code>指向是中为<code>currentTarget</code>。</li>
<li><code>currentTarget</code>和<code>target</code>，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）<ul>
<li>当事件是子元素触发时，<code>currentTarget</code>为绑定事件的元素，<code>target</code>为子元素<ul>
<li>若绑定父元素，点击子元素冒泡触发事件，e.target指向子元素           </li>
</ul>
</li>
<li>当事件是元素自身触发时，<code>currentTarget</code>和<code>target</code>为同一个元素。</li>
</ul>
</li>
</ul>
<p>e.type点击对象的事件类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;a&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    alert(event.type); <span class="comment">// &quot;click&quot;</span></span><br><span class="line">  &#125;); </span><br></pre></td></tr></table></figure>

<h3 id="加载事件"><a href="#加载事件" class="headerlink" title="加载事件"></a>加载事件</h3><ul>
<li>当 DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片。(譬如如果有async加载的脚本就不一定完成)</li>
<li>当 onload 事件触发时，页面上所有的DOM，样式表，脚本，图片都已经加载完成了。</li>
</ul>
<p>顺序是：<code>DOMContentLoaded -&gt; load</code></p>
<p>页面加载完成有两种事件:</p>
<ul>
<li><p>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</p>
</li>
<li><p>onload，指示页面包含图片等文件在内的所有元素都加载完成。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当页面加载完成执行</span></span><br><span class="line">  <span class="comment">// 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>onunload</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onunload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当用户退出页面时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="addEventListener自定义事件"><a href="#addEventListener自定义事件" class="headerlink" title="addEventListener自定义事件"></a>addEventListener自定义事件</h3><h4 id="背景-2"><a href="#背景-2" class="headerlink" title="背景"></a>背景</h4><p>在js事件中，我们首先想到的是click、dblclick、mouseover、mouseout、mouseenter、mouseleave、mousedown、mouseup、mousemove、wheel、contextmenu（点击鼠标右键时）这些常用的事件，在给第三方提供sdk使用时，这些预定义的事件有时无法满足我们的需求。</p>
<p>由于第三方sdk运行环境未知，而且可能会导致事件冲突的问题，这时候就需要我们自定义事件避免问题的发生。</p>
<h4 id="自定义事件构造器"><a href="#自定义事件构造器" class="headerlink" title="自定义事件构造器"></a>自定义事件构造器</h4><ul>
<li><p>new Event(type[, options]);</p>
<ul>
<li><p><strong>type</strong> —— 事件类型，</p>
<p>自定义事件名称，可以是像这样 <code>&quot;click&quot;</code> 的字符串，或者我们自己的像这样 <code>&quot;my-event&quot;</code> 的参数。</p>
</li>
<li><p><strong>options</strong> —— 具有两个可选属性的对象：</p>
<ul>
<li><code>bubbles: true/false</code> —— 如果为 <code>true</code>，那么事件会冒泡。</li>
<li><code>cancelable: true/false</code> —— 如果为 <code>true</code>，那么“默认行为”就会被阻止。稍后我们会看到对于自定义事件，它意味着什么。</li>
</ul>
<p>默认情况下，以上两者都为 false：<code>&#123;bubbles: false, cancelable: false&#125;</code>。</p>
</li>
</ul>
</li>
<li><p>new CustomEvent</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;elem&quot;</span>&gt;Hello <span class="keyword">for</span> John!&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="comment">// 事件附带给处理程序的其他详细信息</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  elem.addEventListener(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    alert(event.detail.name);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">  elem.dispatchEvent(<span class="keyword">new</span> CustomEvent(<span class="string">&quot;hello&quot;</span>, &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">detail</span>: &#123; <span class="attr">name</span>: <span class="string">&quot;John&quot;</span> &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;));</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>从技术上讲，<a href="https://dom.spec.whatwg.org/#customevent">CustomEvent</a> 和 <code>Event</code> 一样。除了一点不同。</p>
<p>在第二个参数（对象）中，我们可以为我们想要与事件一起传递的任何自定义信息添加一个附加的属性 <code>detail</code>。</p>
</blockquote>
<h4 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent"></a>dispatchEvent</h4><p>事件对象被创建后，我们应该使用 elem.dispatchEvent(event) 调用在元素上“运行”它。</p>
<p>然后，处理程序会对它做出反应，就好像它是一个常规的浏览器事件一样。如果事件是用 bubbles 标志创建的，那么它会冒泡。</p>
<p>在下面这个示例中，click 事件是用 JavaScript 初始化创建的。处理程序工作方式和点击按钮的方式相同：</p>
<p><button id="elem" onclick="alert('Click!');">Autoclick</button></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  let event = new Event(&quot;click&quot;);</span><br><span class="line">  elem.dispatchEvent(event);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>event.isTrusted</strong></p>
<p>有一种方法可以区分“真实”用户事件和通过脚本生成的事件。</p>
<p>对于来自真实用户操作的事件，<code>event.isTrusted</code> 属性为 <code>true</code>，对于脚本生成的事件，<code>event.isTrusted</code> 属性为 <code>false</code></p>
</blockquote>
<h4 id="冒泡示例"><a href="#冒泡示例" class="headerlink" title="冒泡示例"></a>冒泡示例</h4><p>我们可以创建一个名为 “hello” 的冒泡事件，并在 document 上捕获它。</p>
<p>我们需要做的就是将 bubbles 设置为 true：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;h1 id=<span class="string">&quot;elem&quot;</span>&gt;Hello <span class="keyword">from</span> the script!&lt;/h1&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 在 document 上捕获...</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;hello&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123; <span class="comment">// (1)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">	alert(<span class="string">&quot;Hello from &quot;</span> + event.target.tagName); <span class="comment">// Hello from H1</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// ...在 elem 上 dispatch！</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">let</span> event = <span class="keyword">new</span> Event(<span class="string">&quot;hello&quot;</span>, &#123;<span class="attr">bubbles</span>: <span class="literal">true</span>&#125;); <span class="comment">// (2)</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">elem.dispatchEvent(event);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 在 document 上的处理程序将被激活，并显示消息。</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p>navigator.userAgent用来<strong>区分设备和浏览器</strong></p>
<p>userAgent 属性是一个只读的字符串，声明了浏览器用于 HTTP 请求的用户代理头的值。</p>
<ul>
<li><p>打印</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="built_in">document</span>.write(<span class="string">&quot;用户代理: &quot;</span> + navigator.userAgent);&lt;/script&gt;</span><br><span class="line">输出结果:</span><br><span class="line">用户代理: Mozilla/<span class="number">5.0</span> (Linux; Android) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">88.0</span><span class="number">.4324</span><span class="number">.109</span> Safari/<span class="number">537.36</span> CrKey/<span class="number">1.54</span><span class="number">.248666</span></span><br></pre></td></tr></table></figure></li>
<li><p>属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">navigator.appVersion 浏览器的版本号 </span><br><span class="line"></span><br><span class="line">navigator.appName 浏览器的名称 </span><br><span class="line"></span><br><span class="line">navigator.language 浏览器使用的语言 </span><br><span class="line"></span><br><span class="line">navigator.platform 浏览器使用的平台 </span><br><span class="line"></span><br><span class="line">navigator.userAgent 浏览器的user-agent信息</span><br></pre></td></tr></table></figure></li>
<li><p>判断终端和环境</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ua = navigator.userAgent.toLowerCase();</span><br><span class="line"><span class="comment">//终端</span></span><br><span class="line"><span class="keyword">let</span> isAndroid = ua.indexOf(<span class="string">&#x27;Android&#x27;</span>) &gt; -<span class="number">1</span> || u.indexOf(<span class="string">&#x27;Linux&#x27;</span>) &gt; -<span class="number">1</span></span><br><span class="line"><span class="keyword">let</span> isIOS = !!ua.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>)</span><br><span class="line"><span class="comment">//环境</span></span><br><span class="line">ua.match(<span class="regexp">/weibo/i</span>) == <span class="string">&quot;weibo&quot;</span></span><br><span class="line">ua.indexOf(<span class="string">&#x27;qq/&#x27;</span>)!= -<span class="number">1</span></span><br><span class="line">ua.match(<span class="regexp">/MicroMessenger/i</span>)==<span class="string">&quot;micromessenger&quot;</span>   <span class="comment">//微信</span></span><br></pre></td></tr></table></figure></li>
<li><p>判断pc和手机端</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> IsPC = <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">  <span class="keyword">var</span> userAgentInfo = navigator.userAgent;</span><br><span class="line">  <span class="keyword">var</span> Agents = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;Android&quot;</span>, <span class="string">&quot;iPhone&quot;</span>, <span class="string">&quot;SymbianOS&quot;</span>, <span class="string">&quot;Windows Phone&quot;</span>, <span class="string">&quot;iPad&quot;</span>, <span class="string">&quot;iPod&quot;</span>);  </span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> v = <span class="number">0</span>; v &lt; Agents.length; v++) &#123;  </span><br><span class="line">      <span class="keyword">if</span> (userAgentInfo.indexOf(Agents[v]) &gt; <span class="number">0</span>) &#123; flag = <span class="literal">false</span>; <span class="keyword">break</span>; &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> flag;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>isIPhoneX</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">isIPhoneX</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> u = navigator.userAgent;</span><br><span class="line">   <span class="keyword">var</span> isIOS = !!u.match(<span class="regexp">/\(i[^;]+;( U;)? CPU.+Mac OS X/</span>); <span class="comment">//ios终端</span></span><br><span class="line">   <span class="keyword">if</span> (isIOS) &#123;</span><br><span class="line">     <span class="keyword">if</span> ((<span class="built_in">window</span>.screen.height == <span class="number">812</span> &amp;&amp; <span class="built_in">window</span>.screen.width == <span class="number">375</span>) || (<span class="built_in">window</span>.screen.width === <span class="number">414</span> &amp;&amp; <span class="built_in">window</span>.screen.height === <span class="number">896</span>)) &#123;<span class="comment">//有底部小黑条</span></span><br><span class="line">       <span class="comment">//是iphoneX(375*812) iphoneXR(414*896) iphoneXS max(414*896)  iphone11(414*896) iphone pro max(414*896)</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有底部小黑条</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>在web应用程序中使用文件</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images">https://developer.mozilla.org/zh-CN/docs/Web/API/File/Using_files_from_web_applications#example.3a_using_object_urls_to_display_images</a></p>
<p><code>Content-Type:multipart/form-data</code> ： 需要在表单中进行文件上传时，就需要使用该格</p>
<h3 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h3><h3 id="Error对象"><a href="#Error对象" class="headerlink" title="Error对象"></a>Error对象</h3><h4 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h4><h5 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h5><p><code>SyntaxError</code>对象是解析代码时发生的语法错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 变量名错误</span><br><span class="line">var 1a;</span><br><span class="line">// Uncaught SyntaxError: Invalid or unexpected token</span><br><span class="line"></span><br><span class="line">// 缺少括号</span><br><span class="line">console.log &#x27;hello&#x27;);</span><br><span class="line">// Uncaught SyntaxError: Unexpected string</span><br></pre></td></tr></table></figure>

<h5 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h5><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误。</p>
<h5 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h5><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。</p>
<h5 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h5><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new 123</span><br><span class="line">// Uncaught TypeError: number is not a func</span><br><span class="line"></span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br><span class="line">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></pre></td></tr></table></figure>

<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数。</p>
<h5 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h5><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数。</p>
<h5 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h5><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> err1 = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err2 = <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">&#x27;出错了，变量超出有效范围！&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> err3 = <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;出错了，变量类型无效！&#x27;</span>);</span><br><span class="line"></span><br><span class="line">err1.message <span class="comment">// &quot;出错了！&quot;</span></span><br><span class="line">err2.message <span class="comment">// &quot;出错了，变量超出有效范围！&quot;</span></span><br><span class="line">err3.message <span class="comment">// &quot;出错了，变量类型无效！&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.message = message || <span class="string">&#x27;默认信息&#x27;</span>;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;UserError&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>

<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> UserError(<span class="string">&#x27;这是自定义的错误！&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;x 必须为正数&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>
<p><code>throw</code>也可以抛出自定义错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function UserError(message) &#123;</span><br><span class="line">  this.message = message || &#x27;默认信息&#x27;;</span><br><span class="line">  this.name = &#x27;UserError&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">throw new UserError(&#x27;出错了！&#x27;);</span><br><span class="line">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例。</p>
<p><code>throw</code><strong>可以抛出任何类型的值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 抛出一个字符串</span><br><span class="line">throw &#x27;Error！&#x27;;</span><br><span class="line">// Uncaught Error！</span><br><span class="line"></span><br><span class="line">// 抛出一个数值</span><br><span class="line">throw 42;</span><br><span class="line">// Uncaught 42</span><br><span class="line"></span><br><span class="line">// 抛出一个布尔值</span><br><span class="line">throw true;</span><br><span class="line">// Uncaught true</span><br></pre></td></tr></table></figure>

<h4 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h4><p>一旦发生错误，程序就中止执行了。JavaScript 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;出错了!&#x27;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.name + <span class="string">&quot;: &quot;</span> + e.message);</span><br><span class="line">  <span class="built_in">console</span>.log(e.stack);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），JavaScript 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。</p>
<h4 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h4><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>
<h3 id="FormData表单对象"><a href="#FormData表单对象" class="headerlink" title="FormData表单对象"></a>FormData表单对象</h3><p><a href="https://wangdoc.com/javascript/bom/form">https://wangdoc.com/javascript/bom/form</a></p>
<h4 id="表单FormData对象"><a href="#表单FormData对象" class="headerlink" title="表单FormData对象"></a>表单FormData对象</h4><p>每一个控件都会生成一个键值对，所有的键值对都会提交到服务器。提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p>
<p>点击<code>submit</code>控件，就可以提交表单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>表单里面的<code>&lt;button&gt;</code>元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;button&gt;提交&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">formElement.submit();</span><br></pre></td></tr></table></figure>

<p><strong>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程</strong></p>
<p>FormData 首先是一个构造函数，用来生成实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var formdata = new FormData(form);</span><br><span class="line"></span><br><span class="line">// 获取某个控件的值</span><br><span class="line">formData.get(&#x27;username&#x27;) // &quot;&quot;</span><br><span class="line"></span><br><span class="line">// 设置某个控件的值</span><br><span class="line">formData.set(&#x27;username&#x27;, &#x27;张三&#x27;);</span><br><span class="line"></span><br><span class="line">formData.get(&#x27;username&#x27;) // &quot;张三&quot;</span><br></pre></td></tr></table></figure>

<h4 id="FormData-实例方法"><a href="#FormData-实例方法" class="headerlink" title="FormData 实例方法"></a>FormData 实例方法</h4><p>创建表单：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;advForm&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>广告名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;advName&quot;</span>  <span class="attr">value</span>=<span class="string">&quot;xixi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>广告类别：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;advType&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span>&gt;</span>轮播图<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span>&gt;</span>轮播图底部广告<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;3&quot;</span>&gt;</span>热门回收广告<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;4&quot;</span>&gt;</span>优品精选广告<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过表单元素作为参数，实现对formData的初始化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获得表单按钮元素</span></span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line"><span class="comment">//为按钮添加点击事件</span></span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//根据ID获得页面当中的form表单元素</span></span><br><span class="line">    <span class="keyword">var</span> form=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#advForm&quot;</span>);</span><br><span class="line">    <span class="comment">//将获得的表单元素作为参数，对formData进行初始化</span></span><br><span class="line">    <span class="keyword">var</span> formdata=<span class="keyword">new</span> FormData(form);</span><br><span class="line">    <span class="comment">//通过get方法获得name为advName元素的value值</span></span><br><span class="line">    <span class="built_in">console</span>.log(formdata.get(<span class="string">&quot;advName&quot;</span>));<span class="comment">//xixi</span></span><br><span class="line">    <span class="comment">//通过get方法获得name为advType元素的value值</span></span><br><span class="line">    <span class="built_in">console</span>.log(formdata.get(<span class="string">&quot;advType&quot;</span>));<span class="comment">//1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.querySelector(<span class="string">&quot;#btn&quot;</span>);</span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> formdata=<span class="keyword">new</span> FormData(<span class="built_in">document</span>.getElementById(<span class="string">&quot;advForm&quot;</span>));</span><br><span class="line">    <span class="keyword">var</span> xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.open(<span class="string">&quot;post&quot;</span>,<span class="string">&quot;http://127.0.0.1/adv&quot;</span>);</span><br><span class="line">    xhr.send(formdata);</span><br><span class="line">    xhr.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(xhr.status==<span class="number">200</span>)&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li>
<li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li>
<li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li>
<li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li>
<li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li>
<li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li>
<li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li>
</ul>
<h4 id="自动校验"><a href="#自动校验" class="headerlink" title="自动校验"></a>自动校验</h4><p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 必填 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">required</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须符合正则表达式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">pattern</span>=<span class="string">&quot;banana|cherry&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 字符串长度必须为6个字符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">minlength</span>=<span class="string">&quot;6&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;6&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数值必须在1到10之间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">min</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须填入 Email 地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 必须填入 URL --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;URL&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p>
<h3 id="File对象"><a href="#File对象" class="headerlink" title="File对象"></a>File对象</h3><p><a href="https://wangdoc.com/javascript/bom/arraybuffer">https://wangdoc.com/javascript/bom/arraybuffer</a></p>
<p><a href="https://wangdoc.com/javascript/bom/file">https://wangdoc.com/javascript/bom/file</a></p>
<h4 id="blob对象"><a href="#blob对象" class="headerlink" title="blob对象"></a>blob对象</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob">https://developer.mozilla.org/zh-CN/docs/Web/API/Blob</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/97768916">https://zhuanlan.zhihu.com/p/97768916</a></p>
<p><code>Blob</code> 对象表示一个不可变、原始数据的类文件对象。它的数据可以按文本或二进制的格式进行读取</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410d77d17b~tplv-t2oaga2asx-watermark.awebp" alt="plain-type-blob"></p>
<p>如你所见，myBlob 对象含有两个属性：size 和 type。其中 size 属性用于表示数据的大小（以字节为单位），type 是 MIME 类型的字符串。Blob 表示的不一定是 JavaScript 原生格式的数据。比如 File 接口基于 Blob，继承了 blob 的功能并将其扩展使其支持用户系统上的文件。</p>
<p><code>Blob</code> 由一个可选的字符串 <code>type</code>（通常是 MIME 类型）和 <code>blobParts</code> 组成：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/6/2/172734410c51dbed~tplv-t2oaga2asx-watermark.awebp" alt="blob-structure"></p>
<p>Blob 构造函数的语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var aBlob = new Blob(blobParts, options);</span><br></pre></td></tr></table></figure>

<p>blobParts数组：</p>
<ul>
<li><p>arraybuffer</p>
<p>response 是一个包含二进制数据的 JavaScript ArrayBuffer。</p>
</li>
<li><p>ArrayBufferView</p>
</li>
<li><p>blob</p>
<p>response 是一个包含二进制数据的 Blob 对象 。</p>
</li>
<li><p>document</p>
<p>response 是一个 HTML Document 或 XML XMLDocument，这取决于接收到的数据的 MIME 类型。DOMStrings 会被编码为 UTF-8。</p>
</li>
</ul>
<p>options：一个可选的对象，包含以下两个属性：</p>
<ul>
<li>type —— 默认值为 <code>&quot;&quot;</code>，它代表了将会被放入到 blob 中的数组内容的 MIME 类型。</li>
<li>endings —— 默认值为 <code>&quot;transparent&quot;</code>，用于指定包含行结束符 <code>\n</code> 的字符串如何被写入。 它是以下两个值中的一个： <code>&quot;native&quot;</code>，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，或者 <code>&quot;transparent&quot;</code>，代表会保持 blob 中保存的结束符不变。</li>
</ul>
<h5 id="file对象"><a href="#file对象" class="headerlink" title="file对象"></a>file对象</h5><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/File">https://developer.mozilla.org/zh-CN/docs/Web/API/File</a></p>
<p>File 对象是来自用户在一个 <input> 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象</p>
<p><strong>File 对象是特殊类型的 Blob，且可以用在任意的 Blob 类型的 context 中</strong></p>
<h4 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h4><ul>
<li><p>Clipboard.JS：Selection 与 execCommand API</p>
<p>运行<code>ClipboardJS.isSupported()</code>来检查是否支持<code>clipboard.js</code></p>
<p>点击按钮两次才执行</p>
<p><a href="https://juejin.cn/post/6906635620752293902#heading-0">https://juejin.cn/post/6906635620752293902#heading-0</a></p>
</li>
<li><p>图像写入剪切板</p>
<p><a href="https://juejin.cn/post/6909237803050074126#heading-0">https://juejin.cn/post/6909237803050074126#heading-0</a></p>
</li>
<li><p>base64,file和Blob的转换</p>
<p><a href="https://juejin.cn/post/6844903862873112583">https://juejin.cn/post/6844903862873112583</a></p>
</li>
<li><p>阮一峰：剪贴板操作 Clipboard API 教程</p>
<p><a href="http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html">http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html</a></p>
</li>
</ul>
<h5 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h5><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;大家好，我是阿宝哥&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span> <span class="attr">data-clipboard-action</span>=<span class="string">&quot;copy&quot;</span> <span class="attr">data-clipboard-target</span>=<span class="string">&quot;#foo&quot;</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;success&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">    </span></span><br><span class="line"><span class="javascript">  clipboard.on(<span class="string">&#x27;error&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(e);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 <code>input</code> 元素之外，复制的目标还可以是 <code>div</code> 或 <code>textarea</code> 元素。在以上示例中，我们复制的目标是通过 <strong><a href="https://link.juejin.cn/?target=https://developer.mozilla.org/zh-CN/docs/Web/Guide/HTML/Using_data_attributes">data-* 属性</a></strong> 来指定。此外，我们也可以在实例化 clipboard 对象时，设置复制的目标：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-target.html</span></span><br><span class="line"><span class="keyword">let</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">target</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如果需要设置复制的文本，我们也可以在实例化 clipboard 对象时，设置复制的文本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// https://github.com/zenorocha/clipboard.js/blob/master/demo/function-text.html</span></span><br><span class="line"><span class="keyword">let</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">&#x27;.btn&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">text</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;大家好，我是阿宝哥&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="图像-1"><a href="#图像-1" class="headerlink" title="图像"></a>图像</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将base64转换为blob对象</span></span><br><span class="line"><span class="comment">//https://juejin.cn/post/6844903862873112583</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = dataurl.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> bstr = atob(arr[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">var</span> n = bstr.length;</span><br><span class="line">  <span class="keyword">var</span> u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">  <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">    u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//转换成file对象</span></span><br><span class="line">  <span class="comment">//return new File([u8arr], filename, &#123; type: mime &#125;);</span></span><br><span class="line">  <span class="comment">//转换成成blob对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Blob([u8arr], &#123; <span class="attr">type</span>: mime &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> imageBlob = dataURLtoFile(src);</span><br><span class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> ClipboardItem(&#123;</span><br><span class="line">    [imageBlob.type]: imageBlob,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//检测浏览器是否支持clipboard-write</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">askWritePermission</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; state &#125; = <span class="keyword">await</span> navigator.permissions.query(&#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&quot;clipboard-write&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">return</span> state === <span class="string">&quot;granted&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (askWritePermission()) &#123;</span><br><span class="line">    navigator.clipboard.write([item]);</span><br><span class="line">    alert(<span class="string">&quot;成功复制到剪切板&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;不支持复制&quot;</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Chrome 浏览器规定，navigator.clipboard只有 HTTPS 协议的页面才能使用这个 API。不过，开发环境（<code>localhost</code>）允许使用非加密协议。</strong></p>
<h2 id="WEB存储"><a href="#WEB存储" class="headerlink" title="WEB存储"></a>WEB存储</h2><h3 id="cookie对象"><a href="#cookie对象" class="headerlink" title="cookie对象"></a>cookie对象</h3><p><a href="https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg">https://mp.weixin.qq.com/s/D7tWeUPsUfYsA97au5soNg</a></p>
<p><a href="https://wangdoc.com/javascript/bom/cookie">https://wangdoc.com/javascript/bom/cookie</a></p>
<p>Cookie 是服务器保存在浏览器的一小段文本信息，一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过 4KB。超过限制以后，Cookie 将被忽略，不会被设置。浏览器每次向服务器发出请求，就会自动附上这段信息。</p>
<p>用户可以设置浏览器不接受Cookie，也可以设置不向服务器发送 Cookie。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">window.navigator.cookieEnabled // true</span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>属性返回当前网页的 Cookie。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document.cookie // &quot;id=foo;key=bar&quot;</span><br></pre></td></tr></table></figure>

<p>Cookie 的目的就是区分用户，以及放置状态信息，它的使用场景主要如下。</p>
<ul>
<li>对话（session）管理：保存登录状态、购物车等需要记录的信息。</li>
<li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>追踪用户：记录和分析用户行为。</li>
</ul>
<p>每个 Cookie 都有以下几方面的元数据。</p>
<ul>
<li>Cookie 的名字</li>
<li>Cookie 的值（真正的数据写在这里面）</li>
<li>到期时间（超过这个时间会失效）</li>
<li>所属域名（默认为当前域名）</li>
<li>生效的路径（默认为当前网址）</li>
</ul>
<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>用户访问网址<code>www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为<code>www.example.com</code>，生效路径为根路径<code>/</code>。</p>
<p>如果 Cookie 的生效路径设为<code>/forums</code>，那么这个 Cookie 只有在访问<code>www.example.com/forums</code>及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p>
<p>Cookie 是按照域名区分的，<code>foo.com</code>只能读取自己放置的 Cookie，无法读取其他网站（比如<code>bar.com</code>）放置的 Cookie。一般情况下，一级域名也不能读取二级域名留下的 Cookie，比如<code>mydomain.com</code>不能读取<code>subdomain.mydomain.com</code>设置的 Cookie。但是有一个例外，设置 Cookie 的时候（不管是一级域名设置的，还是二级域名设置的），明确将<code>domain</code>属性设为一级域名，则这个域名下面的各级域名可以共享这个 Cookie。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Set-Cookie: name=value; domain=mydomain.com</span><br></pre></td></tr></table></figure>

<p>上面示例中，设置 Cookie 时，<code>domain</code>属性设为<code>mydomain.com</code>，那么各级的子域名和一级域名都可以读取这个 Cookie。</p>
<p>注意，区分 Cookie 时不考虑协议和端口。也就是说，<code>http://example.com</code>设置的 Cookie，可以被<code>https://example.com</code>或<code>http://example.com:8080</code>读取。</p>
<h4 id="cookie读写"><a href="#cookie读写" class="headerlink" title="cookie读写"></a>cookie读写</h4><h5 id="读写流程"><a href="#读写流程" class="headerlink" title="读写流程"></a>读写流程</h5><ul>
<li>在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li>
<li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口</li>
</ul>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly </span><br></pre></td></tr></table></figure>

<h5 id="HTTP-头对-cookie-的读写"><a href="#HTTP-头对-cookie-的读写" class="headerlink" title="HTTP 头对 cookie 的读写"></a><strong>HTTP 头对 cookie 的读写</strong></h5><p>HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly </span><br></pre></td></tr></table></figure>

<p>那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>username=jimu; domain=jimu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>height=180; domain=me.jimu.com</span><br><span class="line"><span class="attribute">Set-Cookie</span><span class="punctuation">: </span>weight=80; domain=me.jimu.com </span><br></pre></td></tr></table></figure>

<h5 id="前端对-cookie-的读写"><a href="#前端对-cookie-的读写" class="headerlink" title="前端对 cookie 的读写"></a><strong>前端对 cookie 的读写</strong></h5><p>前端可以自己创建 cookie，如果服务端创建的 cookie 没加<code>HttpOnly</code>，那恭喜你也可以修改他给的 cookie。</p>
<p>调用<code>document.cookie</code>可以创建、修改 cookie，和 HTTP 一样，一次<code>document.cookie</code>能且只能操作一个 cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&#x27;username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct</span></span><br></pre></td></tr></table></figure>

<p>调用<code>document.cookie</code>也可以读到 cookie，也和 HTTP 一样，能读到所有的非<code>HttpOnly</code>cookie。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.cookie);</span><br><span class="line"><span class="comment">// username=jimu; height=180; weight=80 </span></span><br></pre></td></tr></table></figure>

<h3 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h3><ul>
<li><p>localStorage - 用于长久保存整个网站的数据，保存的数据没有过期时间，直到手动去除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储 localStorage.sitename = &quot;菜鸟教程&quot;; </span></span><br><span class="line"><span class="comment">// 查找 document.getElementById(&quot;result&quot;).innerHTML =localStorage.sitename;</span></span><br><span class="line"><span class="comment">//移除 localStorage 中的 &quot;sitename&quot; :</span></span><br><span class="line"><span class="built_in">localStorage</span>.removeItem(<span class="string">&quot;sitename&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>sessionStorage - 用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">不管是 <span class="built_in">localStorage</span>，还是 sessionStorage，可使用的API都相同，常用的有如下几个（以<span class="built_in">localStorage</span>为例）：</span><br><span class="line"></span><br><span class="line">- 保存数据：<span class="built_in">localStorage</span>.setItem(key,value);</span><br><span class="line">- 读取数据：<span class="built_in">localStorage</span>.getItem(key);</span><br><span class="line">- 删除单个数据：<span class="built_in">localStorage</span>.removeItem(key);</span><br><span class="line">- 删除所有数据：<span class="built_in">localStorage</span>.clear();</span><br><span class="line">- 得到某个索引的key：<span class="built_in">localStorage</span>.key(index);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="cookie和storage区别"><a href="#cookie和storage区别" class="headerlink" title="cookie和storage区别"></a>cookie和storage区别</h3><ul>
<li><p>生命周期：</p>
<p>Cookie：可设置失效时间，否则默认为关闭浏览器后失效</p>
<p>Localstorage:除非被手动清除，否则永久保存</p>
<p>Sessionstorage：仅在当前网页会话下有效，关闭页面或浏览器后就会被清除</p>
</li>
<li><p>存放数据：</p>
<p>Cookie：4k左右</p>
<p>Localstorage和sessionstorage：可以保存5M的信息</p>
</li>
<li><p>http请求：</p>
<p>cookie数据始终在同源的http请求中携带（即使不需要），会在浏览器和服务器间来回传递</p>
<p>其他两个：仅在客户端即浏览器中保存，不参与和服务器的通信</p>
</li>
<li><p>易用性：</p>
<p>Cookie：需要程序员自己封装，原生的cookie接口不友好</p>
<p>其他两个：即可采用原生接口，亦可再次封装</p>
</li>
<li><p>应用场景</p>
<p>每次http请求都会携带cookie信息，这样子浪费了带宽，所以cookie应该尽可能的少用（识别用户登陆来说，cookie还是比storage好用），此外cookie还需要指定作用域，<strong>不可以跨域调用</strong></p>
<p>Cookie 不是一种理想的客户端存储机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端存储建议使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p>
</li>
</ul>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>设置属性（setAttribute）,属性名为’data-‘开头的，可以使用dataset来获取值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setAttribute(&#x27;data-age&#x27;, value);      dataset[&#x27;age&#x27;]</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">属性length,返回类的数量</span><br><span class="line">classList.item(index)返回元素中索引值对应的类名。索引值从 <span class="number">0</span> 开始。</span><br><span class="line">classList.remove/add/toggle(<span class="string">&#x27;active&#x27;</span>)</span><br><span class="line">classList.contains(<span class="string">&#x27;active&#x27;</span>)判断当前ClassList中有没有active</span><br><span class="line">classList.toggle(<span class="string">&#x27;active&#x27;</span>, <span class="string">&#x27;&#x27;</span>);toggle函数的第二个参数<span class="literal">true</span>为添加 <span class="literal">false</span>删除</span><br></pre></td></tr></table></figure>

<h1 id="jquery"><a href="#jquery" class="headerlink" title="jquery"></a>jquery</h1><h2 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h2><ul>
<li><p>$([selector,[context]])</p>
<p>$()将在当前的 HTML document中查找 DOM 元素；如果指定了 context 参数，如一个 DOM 元素集或 jQuery 对象，那就会在这个  context 中查找。</p>
<h5 id="jQuery-代码"><a href="#jQuery-代码" class="headerlink" title="jQuery 代码:"></a>jQuery 代码:</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;input:radio&quot;</span>, <span class="built_in">document</span>.forms[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//在文档的第一个表单中，查找所有的单选按钮(即: type 值为 radio 的 input 元素)。</span></span><br></pre></td></tr></table></figure></li>
<li><p>```js<br>//DOM文档载入完成后执行的函数<br>$(function(){<br>  // 文档就绪<br>});</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ## this</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">当你用的是jquery时，就用$(this)，如果是JS，就用this</span><br><span class="line">jquery对象$(this)[0]等同于JS里的元素this</span><br><span class="line">console.log($(this)[0]==this) //true</span><br><span class="line"></span><br><span class="line">JS里的元素只要包上$()就是jquery对象了，而jquery的对象只要加上[0]或者.get(0)，就是js元素了</span><br><span class="line">$(this).get(0)与$(this)[0]等价。</span><br><span class="line">console.log($(this)[0]==$(this).get(0)) //true</span><br></pre></td></tr></table></figure></li>
<li><p>each(callback),每次执行传递进来的函数时，函数中的this关键字都指向一个不同的DOM元素</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;img&quot;).each(function(i)&#123;</span><br><span class="line">   this.src = &quot;test&quot; + i + &quot;.jpg&quot;;</span><br><span class="line"> &#125;);</span><br><span class="line">//this是js的this</span><br></pre></td></tr></table></figure>

<ul>
<li><p>size()/length当前匹配的元素个数</p>
</li>
<li><p>get(index)取得其中一个匹配的元素</p>
<h5 id="HTML-代码"><a href="#HTML-代码" class="headerlink" title="HTML 代码:"></a>HTML 代码:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img src=&quot;test1.jpg&quot;/&gt; &lt;img src=&quot;test2.jpg&quot;/&gt;</span><br></pre></td></tr></table></figure>

<h5 id="jQuery-代码-1"><a href="#jQuery-代码-1" class="headerlink" title="jQuery 代码:"></a>jQuery 代码:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;img&quot;).get(0);</span><br></pre></td></tr></table></figure></li>
<li><p>index(一个DOM选择器/ jQuery 选择器)</p>
<p>搜索匹配的元素，并返回相应元素的索引值，从0开始计数。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>foo<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;bar&quot;</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;baz&quot;</span>&gt;</span>baz<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">$(&#x27;li&#x27;).index(document.getElementById(&#x27;bar&#x27;)); //1，传递一个DOM对象，返回这个对象在原先集合中的索引位置</span><br><span class="line">$(&#x27;#bar&#x27;).index(&#x27;li&#x27;); //1，传递一个选择器，返回#bar在所有li中的索引位置</span><br><span class="line">$(&#x27;#bar&#x27;).index(); //1，不传递参数，返回这个元素在同辈中的索引位置。</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ul>
<li><p>attr(name|key,value)返回或设置被选元素的属性值。removeAttr</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(&#123; <span class="attr">src</span>: <span class="string">&quot;test.jpg&quot;</span>, <span class="attr">alt</span>: <span class="string">&quot;Test Image&quot;</span> &#125;);<span class="comment">//为所有图像设置src和alt属性。</span></span><br><span class="line">$(<span class="string">&quot;img&quot;</span>).attr(<span class="string">&quot;src&quot;</span>,<span class="string">&quot;test.jpg&quot;</span>);<span class="comment">//为所有图像设置src属性。</span></span><br></pre></td></tr></table></figure></li>
<li><p>removeAttr(name)从每一个匹配的元素中删除一个属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&quot;img&quot;</span>).removeAttr(<span class="string">&quot;src&quot;</span>);</span><br><span class="line"><span class="comment">//将文档中图像的src属性删除</span></span><br></pre></td></tr></table></figure></li>
<li><p>addClass(class|fn)为每个匹配的元素添加指定的类名。removeClass</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;ul li:last&#x27;</span>).addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index,<span class="keyword">class</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;item-&#x27;</span> + $(<span class="built_in">this</span>).index();</span><br><span class="line">&#125;);<span class="comment">//给li加上不同的class</span></span><br></pre></td></tr></table></figure></li>
<li><p>toggleClass(class|fn)如果存在（不存在）就删除（添加）一个类。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="built_in">this</span>).toggleClass(<span class="string">&quot;highlight&quot;</span>, count++ % <span class="number">3</span> == <span class="number">0</span>);</span><br><span class="line">&#125;);<span class="comment">//每点击三下加上一次 &#x27;highlight&#x27; 类</span></span><br></pre></td></tr></table></figure></li>
<li><p>html()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回p元素的内容。取得第一个匹配元素的html内容。</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).html();</span><br><span class="line"><span class="comment">//设置所有 p 元素的内容</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).html(<span class="string">&quot;Hello &lt;b&gt;world&lt;/b&gt;!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>text()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回p元素的文本内容。</span></span><br><span class="line">$(<span class="string">&#x27;p&#x27;</span>).text();</span><br><span class="line"><span class="comment">//设置所有 p 元素的文本内容</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).text(<span class="string">&quot;Hello world!&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>val()</p>
</li>
</ul>
<h2 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h2><ul>
<li><p>css</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取得第一个段落的color样式属性的值。</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;color&quot;</span>);</span><br><span class="line"><span class="comment">//将所有段落的字体颜色设为红色并且背景为蓝色。</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(&#123; <span class="string">&quot;color&quot;</span>: <span class="string">&quot;#ff0011&quot;</span>, <span class="string">&quot;background&quot;</span>: <span class="string">&quot;blue&quot;</span> &#125;);</span><br><span class="line"><span class="comment">//将所有段落字体设为红色</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).css(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>height()</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取第一段的高</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).height();</span><br><span class="line"><span class="comment">//把所有段落的高设为 20:</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).height(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//以 10 像素的幅度增加 p 元素的高度</span></span><br><span class="line"> $(<span class="string">&quot;button&quot;</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">&quot;p&quot;</span>).height(<span class="function"><span class="keyword">function</span>(<span class="params">n,c</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//n,c索引位置和元素旧的高度值</span></span><br><span class="line">    <span class="keyword">return</span> c+<span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h2><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><ul>
<li><p>prev + next匹配所有紧接在 prev 元素后的 next 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//匹配所有跟在 label 后面的 input 元素</span></span><br><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Newsletter:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span></span><br><span class="line">    </span><br><span class="line">$(<span class="string">&quot;label + input&quot;</span>)</span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span>, <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span> ]</span><br></pre></td></tr></table></figure></li>
<li><p>prev ~ siblings匹配 prev 元素之后的所有 siblings 元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">label</span>&gt;</span>Name:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">label</span>&gt;</span>Newsletter:<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;newsletter&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span></span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span></span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;form ~ input&quot;</span>)</span><br><span class="line">[ <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;none&quot;</span> /&gt;</span></span> ]</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><ul>
<li><p>:first获取第一个元素–&gt;last</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;li:first&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>:not去除所有与给定选择器匹配的元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找所有未选中的 input 元素</span></span><br><span class="line">&lt;input name=<span class="string">&quot;apple&quot;</span> /&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;flower&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span> /&gt;</span></span></span><br><span class="line">$(<span class="string">&quot;input:not(:checked)&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>:even()匹配所有索引值为偶数的元素，从 0 开始计数–&gt;:odd()</p>
</li>
<li><p>:eq()匹配一个给定索引值的元素,从 0 开始计数</p>
</li>
<li><p>:gt()匹配所有大于给定索引值的元素,从 0 开始计数–&gt;:It()</p>
</li>
</ul>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><h3 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h3><h3 id="表单-1"><a href="#表单-1" class="headerlink" title="表单"></a>表单</h3><h2 id="文档处理"><a href="#文档处理" class="headerlink" title="文档处理"></a>文档处理</h2><h3 id="内部插入"><a href="#内部插入" class="headerlink" title="内部插入"></a>内部插入</h3><ul>
<li><p>append()向每个匹配的元素内部追加内容。</p>
</li>
<li><p>appendTo()把所有匹配的元素追加到另一个指定的元素元素集合中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;I would like to say: &lt;/p&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).appendTo(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I would like to say: <span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>I would like to say: <span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>prepend()向每个匹配的元素内部前置内容。–&gt;prependTo()</p>
</li>
</ul>
<h3 id="外部插入"><a href="#外部插入" class="headerlink" title="外部插入"></a>外部插入</h3><ul>
<li>after()在每个匹配的元素之后插入内容。–&gt;before</li>
<li>insertAfter–&gt;insertBefore</li>
</ul>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul>
<li>replaceWith(content|fn)将所有匹配的元素替换成指定的HTML或DOM元素。</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li>empty()删除匹配的元素集合中所有的子节点。</li>
<li>remove()从DOM中删除所有匹配的元素。</li>
</ul>
<h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><p>is(expr|obj|ele|fn)根据选择器、DOM元素或 jQuery 对象来检测匹配元素集合，如果其中至少有一个元素符合这个给定的表达式就返回true。</p>
<p>map(fn)将一组元素转换成其他数组（不论是否是元素数组）用这个函数来建立一个列表，不论是值、属性还是CSS样式，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;p&quot;).append( $(&quot;input&quot;).map(function()&#123;</span><br><span class="line">  return $(this).val();</span><br><span class="line">&#125;).get().join(&quot;, &quot;) );get()jQuery转DOM对象</span><br><span class="line"></span><br><span class="line">$.map(arr|obj,callback)将一个数组中的元素转换到另一个数组中。array:待转换数组。将原数组中每个元素加 4 转换为一个新数组。</span><br><span class="line">$.map( [0,1,2], function(n)&#123;</span><br><span class="line">  return n + 4;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>children(expr),取得一个包含匹配的元素集合中每一个元素的所有子元素的元素集合。expr用以过滤子元素的表达式</p>
<p>find(expr|obj|ele),搜索所有与指定表达式匹配的元素。这个函数是找出正在处理的元素的后代元素的好方法。与$(“p span”)相同。</p>
<p>next(expr),取得一个包含匹配的元素集合中每一个元素紧邻的后面同辈元素的元素集合。</p>
<p>nextAll(expr),查找当前元素之后所有的同辈元素。</p>
<p>prev(expr)取得一个包含匹配的元素集合中每一个元素紧邻的前一个同辈元素的元素集合。</p>
<p>siblings(expr)取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合。可以用可选的表达式进行筛选。</p>
<h2 id="事件-2"><a href="#事件-2" class="headerlink" title="事件"></a>事件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.one(type,[data],fn)  为每一个匹配元素的特定事件（像click）绑定一个一次性的事件处理函数。在每个对象上，这个事件处理函数只会被执行一次。 其他规则与bind()函数相同(bind()的事件函数只能针对已经存在的元素进行事件的设置)。</span><br><span class="line"></span><br><span class="line">**type:**添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。</span><br><span class="line">**data:**作为event.data属性值传递给事件对象的额外数据对象</span><br><span class="line">**fn:**每当事件触发时执行的函数。</span><br><span class="line"></span><br><span class="line">2.live(type,[data],fn) 给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的 </span><br><span class="line">3.on(events,[selector],[data],fn)  在选择元素上绑定一个或多个事件的事件处理函数。</span><br><span class="line">事件委托即事件冒泡</span><br><span class="line">// 在body元素上绑定click事件处理函数handler，如果这个click事件是由其后代的P元素触发的，就执行handlerp</span><br><span class="line">$(document.body).on(&quot;click&quot;, &quot;p&quot;, handler);</span><br><span class="line">e.stopPaptration();//为了不让点击p 使得他们的父级的事件也触发了，就阻止冒泡</span><br></pre></td></tr></table></figure>

<p>trigger(type,[data])在每一个匹配的元素上触发某类事件。</p>
<p>hover([over,]out)</p>
<p>over:鼠标移到元素上要触发的函数</p>
<p>out:鼠标移出元素要触发的函数</p>
<p>toggle([speed],[easing],[fn])用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。如果元素是可见的，切换为隐藏的；如果元素是隐藏的，切换为可见的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(&quot;td&quot;).toggle(</span><br><span class="line">  function () &#123;</span><br><span class="line">    $(this).addClass(&quot;selected&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  function () &#123;</span><br><span class="line">    $(this).removeClass(&quot;selected&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">);//对表格的切换一个类</span><br><span class="line">$(&#x27;td).toggle();//对表格切换显示/隐藏</span><br></pre></td></tr></table></figure>

<p>change([data],fn)当元素的值发生改变时，会发生 change 事件。</p>
<p>unload([[data],fn])在当用户离开页面时，会发生 unload 事件。</p>
<p>会发出 unload 事件：</p>
<ul>
<li>点击某个离开页面的链接  </li>
<li>在地址栏中键入了新的 URL  </li>
<li>使用前进或后退按钮  </li>
<li>关闭浏览器  </li>
<li>重新加载页面 </li>
</ul>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h2><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><table>
<thead>
<tr>
<th>^</th>
<th>表示匹配行首的文本(以谁开始)</th>
</tr>
</thead>
<tbody><tr>
<td>$</td>
<td>表示匹配行尾的文本(以谁结束)</td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td>当前位置的左右两侧，只能有一侧是字母数字或下划线</td>
</tr>
</tbody></table>
<h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><h4 id="常用元字符串"><a href="#常用元字符串" class="headerlink" title="常用元字符串"></a>常用元字符串</h4><table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>匹配数字</td>
</tr>
<tr>
<td>\D</td>
<td>匹配任意非数字的字符</td>
</tr>
<tr>
<td>\w</td>
<td>匹配字母或数字或下划线</td>
</tr>
<tr>
<td>\W</td>
<td>匹配任意不是字母，数字，下划线</td>
</tr>
<tr>
<td>\s</td>
<td>匹配任意的空白符（包括空格、制表符、换页符）</td>
</tr>
<tr>
<td>\S</td>
<td>匹配任意不是空白符的字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意单个字符</td>
</tr>
</tbody></table>
<h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table>
<thead>
<tr>
<th>限定符</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>表达式尽可能的多匹配，最少可以不匹配，相当于 <strong>{0, }</strong></td>
<td></td>
</tr>
<tr>
<td>+</td>
<td>表达式尽可能的多匹配，至少匹配1次，相当于 <strong>{1, }</strong></td>
<td>“zo+”与“zo”和“zoo”匹配，但与“z”不匹配。+ 等效于 {1,}</td>
</tr>
<tr>
<td>?</td>
<td>表达式尽可能匹配1次，也可以不匹配，相当于 <strong>{0, 1}</strong></td>
<td>“do(es)?”匹配“do”或“does”中的“do”。? 等效于 {0,1}。</td>
</tr>
<tr>
<td>{n}</td>
<td>表达式固定重复n次</td>
<td>“o{2}”与“Bob”中的“o”不匹配，但与“food”中的两个“o”匹配。</td>
</tr>
<tr>
<td>{n,}</td>
<td>表达式尽可能的多匹配，至少重复n次</td>
<td>“o{2,}”不匹配“Bob”中的“o”，而匹配“foooood”中的所有 o。“o{1,}”等效于“o+”。“o{0,}”等效于“o*”</td>
</tr>
<tr>
<td>{n,m}</td>
<td>表达式尽可能重复m次，至少重复n次</td>
<td>“o{1,3}”匹配“fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：您不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td><strong>{n, m}?</strong></td>
<td>表达式尽量只匹配n次，最多重复m次。</td>
<td></td>
</tr>
<tr>
<td><strong>{m, n}+</strong></td>
<td>表达式尽可能重复n次，至少重复m次。</td>
<td></td>
</tr>
</tbody></table>
<ul>
<li><p>贪婪模式:在限定符之后的表达式能够匹配成功的情况下，不定次数的限定符总是<strong>尽可能的多匹配</strong>。如果之后的表达式匹配失败，限定符可适当“让出”能够匹配的字符，以使整个表达式匹配成功。这种模式就叫“贪婪模式”。</p>
<ul>
<li>限定符之后添加加号(+),总是尽可能多的匹配</li>
</ul>
</li>
<li><p>非贪婪匹配模式:正则表达式去匹配时，会尽量少的匹配符合条件的内容 也就是说，一旦发现匹配符合要求，立马就匹配成功，而不会继续匹配下去(除非有<code>g</code>，开启下一组匹配)</p>
<ul>
<li>限定符之后添加问号(?),总是尽可能少的匹配</li>
</ul>
</li>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 前瞻/先行断言：</span><br><span class="line">exp1(?=exp2) 查找exp2前面的exp1</span><br><span class="line">// 后顾：</span><br><span class="line">(?&lt;=exp2)exp1 查找exp2后面的exp1</span><br><span class="line">// 负前瞻：</span><br><span class="line">exp1(?!exp2) 查找后面不是exp2的exp1</span><br><span class="line">// 负后顾：</span><br><span class="line">(?&lt;!exp2)exp1 查找前面不是exp2的exp1</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li><p>转义符</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td>\r, \n</td>
<td>代表回车和换行符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\</td>
<td>代表 “&quot; 本身</td>
</tr>
</tbody></table>
</li>
<li><p><strong>有特殊用处的标点符号，在前面加 “\” 后，就代表该符号本身</strong></p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>匹配 ^ 符号本身</td>
</tr>
<tr>
<td>\ $</td>
<td>匹配 $ 符号本身</td>
</tr>
<tr>
<td>\ .</td>
<td>匹配小数点（.）本身</td>
</tr>
</tbody></table>
</li>
<li><p>方括号 [ ] 包含一系列字符，能够匹配其中任意一个字符。**[^]  匹配除中括号以内的内容**</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>可匹配</th>
</tr>
</thead>
<tbody><tr>
<td><strong>[ab5@]</strong></td>
<td>匹配 “a” 或 “b” 或 “5” 或 “@”</td>
</tr>
<tr>
<td><strong>[^abc]</strong></td>
<td>匹配 “a”,”b”,”c” 之外的任意一个字符</td>
</tr>
<tr>
<td><strong>[f-k]</strong></td>
<td>匹配 “f”~”k” 之间的任意一个字母</td>
</tr>
<tr>
<td><strong>[^A-F0-3]</strong></td>
<td>匹配 “A”<del>“F”,”0”</del>“3” 之外的任意一个字符</td>
</tr>
</tbody></table>
</li>
<li><p>| 选择左右两边的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱。</p>
<p>eg：gr(a|e)y匹配gray和grey</p>
</li>
<li><p>() 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\(</code> 和 <code>\)</code>。</p>
</li>
</ul>
<h2 id="JavaScript-中使用正则表达式"><a href="#JavaScript-中使用正则表达式" class="headerlink" title="JavaScript 中使用正则表达式"></a>JavaScript 中使用正则表达式</h2><h3 id="创建正则对象"><a href="#创建正则对象" class="headerlink" title="创建正则对象"></a>创建正则对象</h3><p>方式1：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;i&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;\d&#x27;</span>, <span class="string">&#x27;gi&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>方式2：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/i</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d/gi</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td>全局匹配</td>
</tr>
<tr>
<td>gi</td>
<td>全局匹配+忽略大小写</td>
</tr>
</tbody></table>
<h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 匹配日期</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2015-10-10&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(dateStr));</span><br></pre></td></tr></table></figure>

<h3 id="正则提取"><a href="#正则提取" class="headerlink" title="正则提取"></a>正则提取</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 提取工资</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;张三：1000，李四：5000，王五：8000。&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\d+/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 提取email地址</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> array = str.match(<span class="regexp">/\w+@\w+\.\w+(\.\w+)?/g</span>);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 分组提取  </span></span><br><span class="line"><span class="comment">// 3. 提取日期中的年部分  2015-5-10</span></span><br><span class="line"><span class="keyword">var</span> dateStr = <span class="string">&#x27;2016-1-5&#x27;</span>;</span><br><span class="line"><span class="comment">// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(dateStr)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 提取邮件中的每一部分</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w+)@(\w+)\.(\w+)(\.\w+)?/</span>;</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;123123@xx.com&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="正则替换"><a href="#正则替换" class="headerlink" title="正则替换"></a>正则替换</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 替换所有空白</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;   123AD  asadf   asadfasf  adf &quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/\s/g</span>,<span class="string">&quot;xx&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 替换所有,|，</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc,efg,123，abc,123，a&quot;</span>;</span><br><span class="line">str = str.replace(<span class="regexp">/,|，/g</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br></pre></td></tr></table></figure>

<h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[正则表达式]文本框输入内容控制</span><br><span class="line"> 整数或者小数：^[0-9]+.&#123;0,1&#125;[0-9]&#123;0,2&#125;$</span><br><span class="line"> 只能输入数字：&quot;^[0-9]*$&quot;。</span><br><span class="line"> 只能输入n位的数字：&quot;^d&#123;n&#125;$&quot;。</span><br><span class="line"> 只能输入至少n位的数字：&quot;^d&#123;n,&#125;$&quot;。</span><br><span class="line"> 只能输入m~n位的数字：。&quot;^d&#123;m,n&#125;$&quot;</span><br><span class="line"> 只能输入零和非零开头的数字：&quot;^(0|[1-9][0-9]*)$&quot;。</span><br><span class="line"> 只能输入有两位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;2&#125;)?$&quot;。</span><br><span class="line"> 只能输入有1~3位小数的正实数：&quot;^[0-9]+(.[0-9]&#123;1,3&#125;)?$&quot;。</span><br><span class="line"> 只能输入非零的正整数：&quot;^+?[1-9][0-9]*$&quot;。</span><br><span class="line"> 只能输入非零的负整数：&quot;^-[1-9][]0-9&quot;*$。</span><br><span class="line"> 只能输入长度为3的字符：&quot;^.&#123;3&#125;$&quot;。</span><br><span class="line"> 只能输入由26个英文字母组成的字符串：&quot;^[A-Za-z]+$&quot;。</span><br><span class="line"> 只能输入由26个大写英文字母组成的字符串：&quot;^[A-Z]+$&quot;。</span><br><span class="line"> 只能输入由26个小写英文字母组成的字符串：&quot;^[a-z]+$&quot;。</span><br><span class="line"> 只能输入由数字和26个英文字母组成的字符串：&quot;^[A-Za-z0-9]+$&quot;。</span><br><span class="line"> 只能输入由数字、26个英文字母或者下划线组成的字符串：&quot;^w+$&quot;。</span><br><span class="line"> 验证是否含有^%&amp;&#x27;,;=?$&quot;等字符：&quot;[^%&amp;&#x27;,;=?$x22]+&quot;。</span><br><span class="line"> 只能输入汉字：&quot;^[u4e00-u9fa5]&#123;0,&#125;$&quot;</span><br><span class="line"> 验证Email地址：&quot;^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$&quot;。</span><br><span class="line"> 验证InternetURL：&quot;^http://([w-]+.)+[w-]+(/[w-./?%&amp;=]*)?$&quot;。</span><br><span class="line"> 验证电话号码：&quot;^((d&#123;3,4&#125;-)|d&#123;3.4&#125;-)?d&#123;7,8&#125;$&quot;正确格式为：&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX&quot;。</span><br><span class="line"> 验证身份证号（15位或18位数字）：&quot;^d&#123;15&#125;|d&#123;18&#125;$&quot;。</span><br><span class="line"> 验证一年的12个月：&quot;^(0?[1-9]|1[0-2])$&quot;正确格式为：&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;12&quot;。</span><br><span class="line"> 验证一个月的31天：&quot;^((0?[1-9])|((1|2)[0-9])|30|31)$&quot;正确格式为；&quot;01&quot;～&quot;09&quot;和&quot;1&quot;～&quot;31&quot;。</span><br><span class="line"> 匹配中文字符的正则表达式： [u4e00-u9fa5]</span><br><span class="line"> 匹配双字节字符(包括汉字在内)：[^x00-xff]</span><br><span class="line"> 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</span><br><span class="line"> String.prototype.len=function()&#123;return this.replace(/[^x00-xff]/g,&quot;aa&quot;).length;&#125;</span><br><span class="line"> 匹配空行的正则表达式：n[s| ]*r</span><br><span class="line"> 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;/(.*)&gt;|&lt;(.*)/&gt;</span><br><span class="line"> 匹配首尾空格的正则表达式：(^s*)|(s*$)</span><br><span class="line"> 匹配Email地址的正则表达式：w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*</span><br><span class="line"> 匹配网址URL的正则表达式：http://([w-]+.)+[w-]+(/[w- ./?%&amp;=]*)?</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="限制el-input只能输入两位小数"><a href="#限制el-input只能输入两位小数" class="headerlink" title="限制el-input只能输入两位小数"></a>限制el-input只能输入两位小数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.ruleForm[name] = (&#x27;&#x27; + value) // 第一步：转成字符串</span><br><span class="line"></span><br><span class="line">    .replace(/[^\d^\.]+/g, &#x27;&#x27;) // 第二步：把不是数字，不是小数点的过滤掉</span><br><span class="line"></span><br><span class="line">    .replace(/^0+(\d)/, &#x27;$1&#x27;) // 第三步：第一位0开头，0后面为数字，则过滤掉，取后面的数字.$1是与正则表达式中的第 1 个子表达式相匹配的文本</span><br><span class="line"></span><br><span class="line">   .replace(/^\./, &#x27;0.&#x27;) // 第四步：如果输入的第一位为小数点，则替换成 0. 实现自动补全</span><br><span class="line"></span><br><span class="line">   .match(/^\d*(\.?\d&#123;0,2&#125;)/g)[0] || &#x27;&#x27; // 第五步：最终匹配得到结果 以数字开头，只有一个小数点，	而且小数点后面只能有0到2位小数</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>利用正则表达式获取括号里面的内容 或者 包括括号与内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.获取括号的内容，包换括号</span><br><span class="line">var str=&quot;123&#123;456&#125;hhh[789]zzz[yyy]bbb(90ba)kkk&quot;;</span><br><span class="line">var regex1 = /\((.+?)\)/g;   // () 小括号</span><br><span class="line">var regex2 = /\[(.+?)\]/g;   // [] 中括号</span><br><span class="line">var regex3 = /\&#123;(.+?)\&#125;/g;  // &#123;&#125; 花括号，大括号</span><br><span class="line"> </span><br><span class="line">// 输出是一个数组</span><br><span class="line">console.log(str.match(regex1)); //[&#x27;(90ba)&#x27;]</span><br><span class="line">console.log(str.match(regex2));//[&#x27;[789]&#x27;, &#x27;[yyy]&#x27;]</span><br><span class="line">console.log(str.match(regex3));//[&#x27;&#123;456&#125;&#x27;]</span><br><span class="line"></span><br><span class="line">2.获取括号的内容，不包含括号 </span><br><span class="line">var str2=&quot;123&#123;456&#125;hhh[789]zzz[yyy]bbb(90ba)kkk&quot;;</span><br><span class="line">var regex11 = /(?&lt;=\()(.+?)(?=\))/g;   // () 小括号</span><br><span class="line">var regex22 = /(?&lt;=\[)(.+?)(?=\])/g;   // [] 中括号</span><br><span class="line">var regex33 = /(?&lt;=\&#123;)(.+?)(?=\&#125;)/g;  // &#123;&#125; 花括号，大括号</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">// 输出是一个数组</span><br><span class="line">console.log(str2.match(regex11)); //[&#x27;90ba&#x27;]</span><br><span class="line">console.log(str2.match(regex22));//[&#x27;789&#x27;, &#x27;yyy&#x27;]</span><br><span class="line">console.log(str2.match(regex33));//[&#x27;456&#x27;]</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>网络</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>scss</tag>
        <tag>es5</tag>
        <tag>jq</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title>项目构建</title>
    <url>/2023/05/30/01-%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="网站搭建"><a href="#网站搭建" class="headerlink" title="网站搭建"></a>网站搭建</h1><h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p><a href="https://juejin.cn/post/6887135998099062792">https://juejin.cn/post/6887135998099062792</a></p>
<p><a href="https://blog.csdn.net/Charissa2017/article/details/105886521">https://blog.csdn.net/Charissa2017/article/details/105886521</a></p>
<p>Nginx是一款轻量级的Web服务器，具有内存占用少，启动极快，高并发能力强的优势，采用事件驱动的异步非阻塞处理方式框架，IO性能好，时常用于服务端的反向代理和负载均衡。 </p>
<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>正向代理是什么东东？反向代理又是啥？<br> <em><strong>「「正向代理」」</strong></em><br> <strong>「「举个栗子」」</strong> 因为防火墙的原因， 直接访问谷歌是无法访问的， 这时可以借助梯子，即vpn，那么这个vpn(代理)就是代替客户端去访问服务器，然后将数据返回给客户端。服务器并不知道目标客户端，只是与vpn建立联系。<br> <em><strong>「「反向代理」」</strong></em><br> <strong>「「举个栗子」」</strong> 你（客户端）去租房时，真正的房东（服务器）将房租给二手房东（代理服务器），而你通过二手房东租到的房子，也就是你与二手房东建立联系， 租到房子，并非真正的房东。<br> 一句话： <strong>正向代理 “代理”客户端， 反向代理“代理”服务器</strong></p>
<h3 id="nginx文件"><a href="#nginx文件" class="headerlink" title="nginx文件"></a>nginx文件</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p> <code>ps aux|grep nginx</code> 查看 配置文件conf目录 </p>
<p> nginx配置文件的基本结构 </p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de06e2d89ea345dcac78a3da6d509ebc~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">「「main」」:nginx的全局配置，对全局生效。</span><br><span class="line">「「events」」:配置影响nginx服务器或与用户的网络连接。</span><br><span class="line">「「http」」：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。</span><br><span class="line">「「server」」：配置虚拟主机的相关参数，一个http中可以有多个server。</span><br><span class="line">「「location」」：配置请求的路由，以及各种页面的处理情况。</span><br><span class="line">「「upstream」」：配置后端服务器具体地址，负载均衡配置不可或缺的部分。</span><br></pre></td></tr></table></figure>

<h5 id="server"><a href="#server" class="headerlink" title="server"></a>server</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name  localhost;</span><br><span class="line">  root   html;</span><br><span class="line">  index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">include /etc/nginx/conf.d/*.conf;</span><br><span class="line"><span class="comment">##引入/etc/nginx/conf.d中的server配置</span></span><br><span class="line"><span class="comment">## /etc/nginx/conf.d/index.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">  <span class="comment">#端口号</span></span><br><span class="line">  listen 80;</span><br><span class="line">  <span class="comment">#域名或者ip</span></span><br><span class="line">  <span class="comment">#server_name 121.40.61.99;</span></span><br><span class="line">  server_name tomorrowlm.xyz;</span><br><span class="line">  <span class="comment">#文件的路径</span></span><br><span class="line">  root /root/www;</span><br><span class="line">  <span class="comment">#配置默认访问的页面</span></span><br><span class="line">  index index.html;</span><br><span class="line">  <span class="comment">#配置多个项目</span></span><br><span class="line">  <span class="comment">#location注意要和项目中配置的base一样</span></span><br><span class="line">  location /vue-demo &#123;</span><br><span class="line"> 	try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /vue-demo/index.html;</span><br><span class="line">  &#125;</span><br><span class="line">  location /react-demo &#123;</span><br><span class="line">  	try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /react-demo/index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># location / &#123;</span></span><br><span class="line"><span class="comment">#   #当输入错误路径时，跳转到index.html页面</span></span><br><span class="line"><span class="comment">#   try_files $uri $uri/ =404 /index.html;</span></span><br><span class="line"><span class="comment">#  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#点击刷新后，页面就会显示（404）,使用try_files（进行内部重定向）</span></span><br><span class="line">try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /react-demo/index.html;</span><br><span class="line"><span class="comment">#$uri  请求文件的路径</span></span><br><span class="line"><span class="comment">#$uri/ 请求目录的路径</span></span><br><span class="line"></span><br><span class="line">try_files是nginx中http_core核心模块所带的指令，主要是能替代一些rewrite的指令，提高解析效率。</span><br><span class="line">当用户请求 http://localhost/example 时，这里的 <span class="variable">$uri</span> 就是 /example。 </span><br><span class="line">try_files 会到硬盘里尝试找这个文件。如果存在名为 /<span class="variable">$root</span>/example（其中 <span class="variable">$root</span> 是项目代码安装目录）的文件，就直接把这个文件的内容发送给用户。 </span><br><span class="line">显然，目录中没有叫 example 的文件。然后就看 <span class="variable">$uri</span>/，增加了一个 /，也就是看有没有名为 /<span class="variable">$root</span>/example/ 的目录。 </span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置代理</span></span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name name1;</span><br><span class="line">  root /root/www;</span><br><span class="line">  <span class="comment">#配置默认访问的页面</span></span><br><span class="line">  index index.html;</span><br><span class="line">  autoindex on;</span><br><span class="line">  <span class="comment">#实现公用80端口 部署多个网站</span></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:4300;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 4300;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root /root/www;</span><br><span class="line">  autoindex on;</span><br><span class="line">  location /vue-demo &#123;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name name2;</span><br><span class="line">  root /root/www;</span><br><span class="line">  <span class="comment">#配置默认访问的页面</span></span><br><span class="line">  index index.html;</span><br><span class="line">  autoindex on;</span><br><span class="line">  <span class="comment">#实现公用80端口 部署多个网站</span></span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://localhost:4400;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 4400;</span><br><span class="line">  server_name localhost;</span><br><span class="line">  root /root/www;</span><br><span class="line">  autoindex on;</span><br><span class="line">  location /vue-demo &#123;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nginx默认监听的就是80端口， 也可以监听其他端口号</p>
<p>server_name就是你服务器的名称，可以精准匹配，也可以使用通配符或正则匹配，没有顺序，一般是先到先得。</p>
<p>root 你项目文件存放路径， 一般是放在html下面，也可放在其他地方， 如/var/local/marking-h5,n那么就改为 <code>root /var/local/marking-h5</code>（build打包后的dist文件在服务器上的路径）</p>
<p>index 你的项目入口， 通常是index.html.</p>
<h4 id="其他文件"><a href="#其他文件" class="headerlink" title="其他文件"></a>其他文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/run 		nginx.pid</span><br><span class="line">/etc/nginx 	nginx配置</span><br><span class="line">/root 		页面</span><br><span class="line">/var/<span class="built_in">log</span>/nginx/access.log 	报错信息</span><br></pre></td></tr></table></figure>

<h3 id="nginx命令"><a href="#nginx命令" class="headerlink" title="nginx命令"></a>nginx命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx 							<span class="comment">#打开 nginx</span></span><br><span class="line">nginx -t   				        <span class="comment">#测试配置文件是否有语法错误</span></span><br><span class="line">nginx -s reopen					<span class="comment">#重启Nginx</span></span><br><span class="line">nginx -s reload					<span class="comment">#重新加载Nginx配置文件，然后以优雅的方式重启Nginx</span></span><br><span class="line">nginx -s stop  					<span class="comment">#强制停止Nginx服务</span></span><br><span class="line">nginx -s quit  					<span class="comment">#停止Nginx服务（即处理完所有请求后再停止服务）</span></span><br><span class="line">systemctl start nginx			<span class="comment">#开启防火墙</span></span><br><span class="line">service nginx start				<span class="comment">#启动nginx</span></span><br><span class="line">nginx [-?hvVtq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">-?,-h           : 打开帮助信息</span><br><span class="line">-v              : 显示版本信息并退出</span><br><span class="line">-V              : 显示版本和配置选项信息，然后退出</span><br><span class="line">-t              : 检测配置文件是否有语法错误，然后退出</span><br><span class="line">-q              : 在检测配置文件期间屏蔽非错误信息</span><br><span class="line">-s signal       : 给一个 nginx 主进程发送信号：stop（强制停止）, quit（优雅退出）, reopen（重启）, reload（重新加载配置文件）</span><br><span class="line">-p prefix       : 设置前缀路径（默认是：/usr/share/nginx/）</span><br><span class="line">-c filename     : 设置配置文件（默认是：/etc/nginx/nginx.conf）</span><br><span class="line">-g directives   : 设置配置文件外的全局指令</span><br></pre></td></tr></table></figure>

<p>tip:</p>
<ul>
<li><p>nginx: [error] open() “/run/nginx.pid” failed (2: No such file or directory)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx -c /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="PM2"><a href="#PM2" class="headerlink" title="PM2"></a>PM2</h2><p>PM2是node进程管理工具，可以利用它来简化很多node应用管理的繁琐任务，如性能监控、自动重启、负载均衡等，而且使用非常简单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pm2 start ./bin/www --watch --name my-api</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法</span><br><span class="line">$ npm install pm2 -g     # 命令行安装 pm2 </span><br><span class="line">$ pm2 start app.js --name my-api # 命名进程</span><br><span class="line">$ pm2 list               # 显示所有进程状态</span><br><span class="line">$ pm2 monit              # 监视所有进程</span><br><span class="line">$ pm2 logs               #  显示所有进程日志</span><br><span class="line">$ pm2 stop all           # 停止所有进程</span><br><span class="line">$ pm2 restart all        # 重启所有进程</span><br><span class="line">$ pm2 reload all         # 0秒停机重载进程 (用于 NETWORKED 进程)</span><br><span class="line">$ pm2 stop 0             # 停止指定的进程</span><br><span class="line">$ pm2 restart 0          # 重启指定的进程</span><br><span class="line">$ pm2 startup            # 产生 init 脚本 保持进程活着</span><br><span class="line">$ pm2 web                # 运行健壮的 computer API endpoint (http://localhost:9615)</span><br><span class="line">$ pm2 delete 0           # 杀死指定的进程</span><br><span class="line">$ pm2 delete all         # 杀死全部进程</span><br></pre></td></tr></table></figure>

<h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p><a href="https://help.aliyun.com/document_detail/50775.html">https://help.aliyun.com/document_detail/50775.html</a></p>
<p><a href="https://www.jianshu.com/p/175558881f19">https://www.jianshu.com/p/175558881f19</a></p>
<h1 id="前端⼯程化"><a href="#前端⼯程化" class="headerlink" title="前端⼯程化"></a><strong>前端⼯程化</strong></h1><h2 id="构建历史"><a href="#构建历史" class="headerlink" title="构建历史"></a>构建历史</h2><p><a href="https://mp.weixin.qq.com/s/vhkAhBJ2mok43lIlHpu8Gg">https://mp.weixin.qq.com/s/vhkAhBJ2mok43lIlHpu8Gg</a></p>
<p><img src="img/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/%E6%9E%84%E5%BB%BA%E5%8E%86%E5%8F%B2.webp" alt="构建历史"></p>
<p>前端模块化/构建工具从最开始的基于浏览器<strong>运行时</strong>加载的 <code>RequireJs/Sea.js</code> 到将所有资源组装依赖打包 <code>webpack</code>/<code>rollup</code>/<code>parcel</code>的<code>bundle</code>类模块化构建工具，再到现在的<code>bundleless</code>基于浏览器原生 ES 模块的 <code>snowpack</code>/<code>vite</code>，前端的模块化/构建工具发展到现在已经快 10 年了。</p>
<ul>
<li><p> Grunt</p>
</li>
<li><p>browserify</p>
<p><code>browserify</code>致力于在浏览器端使用<code>CommonJs</code>，他使用跟 <code>NodeJs</code> 一样的模块化语法，然后将所有依赖文件编译到一个<code>bundle</code>文件，在浏览器通过<code>&lt;script&gt;</code>标签使用的，并且支持 npm 库。</p>
</li>
<li><p>Gulp</p>
</li>
<li><p>webpack</p>
<p><code>webpack1</code>支持<code>CommonJs</code>和<code>AMD</code>模块化系统，优化依赖关系，支持分包，支持多种类型 script、image、file、css/less/sass/stylus、mocha/eslint/jshint 的打包，丰富的插件体系。<code>webpack</code>的概念更偏向于工程化</p>
<p>以上的 3 个库 <code>Grunt/Gulp/browserify</code> 都是偏向于工具，而 <code>webpack</code>将以上功能都集成到一起，相比于工具它的功能大而全。</p>
</li>
<li><p>rollup</p>
<p><code>rollup</code>编译<code>ES6</code>模块，提出了<code>Tree-shaking</code>，根据<code>ES module</code>静态语法特性，删除未被实际使用的代码，支持导出多种规范语法，并且导出的代码非常简洁，如果看过 <code>vue</code> 的<code>dist</code> 目录代码就知道导出的 <code>vue</code> 代码完全不影响阅读。</p>
<p><code>rollup</code>的插件系统支持：<code>babel</code>、<code>CommonJs</code>、<code>terser</code>、<code>typescript</code>等功能。</p>
<p>相比于<code>browserify</code>的<code>CommonJs</code>，<code>rollup</code>专注于<code>ES module</code>。<br>相比于<code>webpack</code>大而全的前端工程化，<code>rollup</code>专注于纯<code>javascript</code>，大多被用作打包<code>tool</code>工具或<code>library</code>库。</p>
<p>react、vue 等库都使用<code>rollup</code>打包项目，并且下面说到的<code>vite</code>也依赖<code>rollup</code>用作生产环境打包 js。</p>
</li>
<li><p>snowpack 和 vite</p>
<p>因为 <code>snowpack</code> 和 <code>vite</code> 比较类似，都是<code>bundleless</code>所以一起拿来说。<code>bundleless</code>类运行时打包工具的启动速度是毫秒级的，因为不需要打包任何内容，只需要起两个<code>server</code>，一个用于页面加载，另一个用于<code>HMR</code>的<code>WebSocket</code>，当浏览器发出原生的<code>ES module</code>请求，<code>server</code>收到请求只需编译当前文件后返回给浏览器不需要管依赖。<code>bundleless</code>工具在<strong>生产环境</strong>打包的时候依然<code>bundle</code>构建所以依赖视图的方式，vite 是利用 <code>rollup</code> 打包生产环境的 js 的。</p>
</li>
</ul>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="Webpack与Vite对⽐"><a href="#Webpack与Vite对⽐" class="headerlink" title="Webpack与Vite对⽐"></a>Webpack与Vite对⽐</h3><p>Vite特点： 轻量、按需打包rollup 、HMR (热渲染依赖）</p>
<p>Webpack：由于需要预先编译打包所以启动速度慢，但⽣态成熟。</p>
<p>对⽐</p>
<p>webpack :强调对web开发的⽀持，尤其是内置了HMR的⽀持，插件系统⽐较强⼤，对各种模块系统兼容性最佳</p>
<p>(amd,cjs,umd,esm等，兼容性好的有点过分了，这实际上有利有弊,导致⾯向webpack编程），有丰富的⽣态，缺</p>
<p>点是产物不够⼲净，产物不⽀持⽣成esm格式， 插件开发上⼿较难，不太适合库的开发。</p>
<p>rollup: 强调对库开发的⽀持，基于ESM模块系统，对tree shaking有着良好的⽀持，产物⾮常⼲净，⽀持多种输出</p>
<p>格式，适合做库的开发，插件api⽐较友好，缺点是对cjs⽀持需要依赖插件，且⽀持效果不佳需要较多的hack，不</p>
<p>⽀持HMR，做应⽤开发时需要依赖各种插件。</p>
<p>esbuild: 强调性能，内置了对css、图⽚、react、typescript等内置⽀持，编译速度特别快（是webpack和rollup速</p>
<p>度的100倍+),缺点是⽬前插件系统较为简单，⽣态不如webpack和rollup成熟。</p>
<h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。</p>
<p><strong>网页中常见的静态资源</strong></p>
<p><strong>js</strong>–js，jax，coffee，ts(TypeScript,需要编译为js)</p>
<p><strong>css</strong>– css,less,sass</p>
<p><strong>image</strong>–jpg,png,gif,bmp,svg</p>
<p><strong>字体文件(Fonts)</strong>–svg,ttf,eot,woff,woff2</p>
<p><strong>模板文件</strong>–ejs,jade,vue(这是在webpack中定义的组件的方式)</p>
<img src="https://zhaoda.net/webpack-handbook/images/what-is-webpack.png" alt="什么是webpack" style="zoom: 33%;" />

<p><strong>特点</strong>：</p>
<ul>
<li><p>模块化开发</p>
<p>在没有各个 webpack 搭建的脚手架（create-react-app、vue-cli 等等）之前，我们通过在 HTML5 文件里引入一个个 Javascript 文件来进行开发，这就可能导致并行请求数量过多、存在重复代码等问题。</p>
<p>而通过 webpack，<strong>我们可以使用 import、require 来进行模块化开发</strong>。</p>
<p><strong>在 webpack 中一切皆模块</strong>，js、css、图片、字体都是模块，而且支持<strong>静态解析、按需打包、动态加载、代码分离</strong>等功能，帮助我们优化代码，提升性能。</p>
</li>
<li><p>新语法</p>
<p>Javascript、CSS 的语法规范在不断更新，但是浏览器的兼容性却不能同步的更新，开发者可以通过 webpack 预处理器进行编译，<strong>自由的使用 JS、CSS 等语言的新语法</strong>。</p>
<p>webpack 使用 <a href="https://webpack.docschina.org/concepts/loaders">loader </a>对文件进行预处理。你可以构建包括 JavaScript 在内的任何静态资源，如 Less、Sass、ES6、TypeScript。</p>
</li>
<li><p>主流框架脚手架</p>
<p>Vue 脚手架 <code>vue-cli</code>、React 脚手架 <code>creact-react-app</code>、Taro 脚手架 <code>taro-cli</code> 都是使用 webpack，开发者掌握 webpack 后，可以自由配置脚手架，根据项目需要，调整 webpack 配置，以提高项目性能。</p>
</li>
</ul>
<h3 id="文件搭建"><a href="#文件搭建" class="headerlink" title="文件搭建"></a>文件搭建</h3><p><a href="https://juejin.cn/post/6844903968405979144">https://juejin.cn/post/6844903968405979144</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">npm install webpack</span><br></pre></td></tr></table></figure>

<p>webpack.base.conf.js  ==&gt; webpack基本配置；</p>
<p>webpack.dev.conf.js  ==&gt; webpack开发环境配置；</p>
<p>webpack.prod.conf.js  ==&gt; webpack生产环境配置；</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><h4 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entry: path.resolve(__dirname, &quot;./src/main.js&quot;),</span><br></pre></td></tr></table></figure>

<h4 id="output"><a href="#output" class="headerlink" title="output"></a>output</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    <span class="comment">//指定打包好的文件，输出到哪个目录中去</span></span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&quot;./dist&quot;</span>),</span><br><span class="line">    <span class="comment">//输出文件名</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;js/bundle.[hash].js&quot;</span>,<span class="comment">//打包同步代码</span></span><br><span class="line">	chunkFilename：<span class="string">&quot;js/bundle.chunk.[hash].js&quot;</span>,<span class="comment">//打包异步代码，动态导入</span></span><br><span class="line">    <span class="comment">//静态文件打包存放的目录.静态文件是指 img 的src ,link ，script 标签等所指向的文件。静态资源最终访问路径 = 				output.publicPath + 资源loader或插	件等配置路径</span></span><br><span class="line">    <span class="attr">publicPath</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h4 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h4><p>webpack5 提供了模式选择，包括开发模式、生产模式、空模式，并对不同模式做了对应的内置优化。可通过配置模式让项目性能更优。</p>
<h4 id="devtool"><a href="#devtool" class="headerlink" title="devtool"></a>devtool</h4><p><strong><code>Sourcemap</code> 本质上是一个信息文件</strong>，<strong>关联编译后的代码和源码的，通过一个个行列号的映射</strong>。比如编译后代码的第 3 行第 4 列，对应着源码里的第 8 行第 5 列这种，这叫做一个mapping。</p>
<p>mapping里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射。简单说 <code>Sourcemap</code> 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 <code>bug</code> 的位置。</p>
<p><img src="https://img-blog.csdnimg.cn/20200806173010859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDU5OTEwOQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h4><p><strong>防止</strong>将某些 <code>import</code> 的包打包到 bundle 中，而是在运行时(runtime)再去从外部获取这些*扩展依赖(external dependencies)*。</p>
<p>例如，从 CDN 引入 <a href="https://jquery.com/">jQuery</a>，而不是把它打包</p>
<img src="https://img-blog.csdnimg.cn/20200427100329777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNzAyNDMw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" />





<p>通过script方式引入后，在文件中直接使用。这里是没有问题的，如果你使用了eslint，它会提示你该变量未定义。但是如果你想在文件中使用import $ from ‘jquery’;不好意思不行，因为你没有npm install jquery，那么如何让我们像安装了jquery一样使用这个东西呢？这就需要配置externals配置</p>
<h4 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h4><p>该配置是为了解决前后端联调时出现的跨域问题，将后端域名下的请求代理到本地，从而避免跨域请求；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    &#x27;/mgr&#x27;: &#123;</span><br><span class="line">      target: &#x27;https://api.douban.com&#x27;,</span><br><span class="line">      ws: true,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      pathRewrite:&#123;</span><br><span class="line">        &#x27;^/mgr&#x27;: &#x27;&#x27;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>接口是<code>https://api.douban.com/v2/music/search?q=周杰伦</code></p>
<p>调用时就可以将接口写成这样<code>/mgr/v2/music/search?q=周杰伦</code></p>
<p>那这个pathRewrite到底是干嘛用的,为什么有时候需要写,有时候不需要写</p>
<p>其实很简单,用代理, 首先你得有一个标识, 告诉node, 我接口只要是’/mgr’开头的才用代理.所以你的接口就要这么写 /mgr/xx/xx. 最后代理的路径就是 <a href="http://xxx.xx.com/mgr/xx/xx">http://xxx.xx.com/mgr/xx/xx</a>.</p>
<p>可是不对啊, 我正确的接口路径里面没有/mgr啊. 所以就需要 pathRewrite,用<code>&#39;^/mgr&#39;:&#39;&#39;</code>, 把’/mgr’去掉, 这样既能有正确标识, 又能在请求接口的时候去掉mgr</p>
<h4 id="Resolve"><a href="#Resolve" class="headerlink" title="Resolve"></a>Resolve</h4><p>resolve用来解析模块路径，帮助 webpack 找到 bundle 中以require/import引入的模块代码</p>
<ul>
<li>extensions：extensions扩展名选项在resolve追踪到的文件如果没有扩展名时，会尝试在其提供的扩展名选项里进行匹配</li>
<li>alias：通过 <code>resolve.alias</code> 来自定义模块路径的映射</li>
<li>symlinks：用于配置 npm link 是否生效，禁用可提升编译速度。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js </span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">  	<span class="attr">extensions</span>: [<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>, <span class="string">&#x27;.wasm&#x27;</span>],<span class="comment">//</span></span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.resolve(__dirname, <span class="string">&#x27;./src&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="optimization"><a href="#optimization" class="headerlink" title="optimization"></a>optimization</h4><p>optimization 用于自定义 webpack 的内置优化配置，一般用于生产模式提升性能，常用配置项如下：</p>
<ul>
<li>minimize：是否需要压缩 bundle；</li>
<li>minimizer：配置压缩工具，如 TerserPlugin、OptimizeCSSAssetsPlugin；</li>
<li>splitChunks：拆分 bundle；</li>
<li>runtimeChunk：是否需要将所有生成 chunk 之间共享的运行时文件拆分出来。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">runtimeChunk</span>: <span class="string">&#x27;single&#x27;</span>,<span class="comment">//针对下面多个入口文件，相同的模块是不会共享的解决方案,</span></span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="comment">// 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释</span></span><br><span class="line">      <span class="comment">// `...`,</span></span><br><span class="line">      <span class="keyword">new</span> CssMinimizerPlugin(),</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">splitChunks</span>: &#123;<span class="comment">// 代码分割,提取模块。但是有多个入口文件的话。文件中引入相同的模块是不会共享</span></span><br><span class="line">      <span class="comment">// include all types of chunks</span></span><br><span class="line">      <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">      <span class="comment">// 重复打包问题</span></span><br><span class="line">      <span class="attr">cacheGroups</span>:&#123;</span><br><span class="line">        <span class="attr">vendors</span>:&#123; <span class="comment">//node_modules里的代码</span></span><br><span class="line">          <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          chunks: <span class="string">&quot;all&quot;</span>,</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;vendors&#x27;</span>, <span class="comment">//chunks name</span></span><br><span class="line">          <span class="attr">priority</span>: <span class="number">10</span>, <span class="comment">//优先级</span></span><br><span class="line">          <span class="attr">enforce</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<h4 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h4><p><strong>webpack默认只能打包处理 JS类型的文件，无法处理其他的非JS类型的文件</strong>。</p>
<h5 id="使用-loader"><a href="#使用-loader" class="headerlink" title="使用 loader"></a>使用 loader</h5><p>在你的应用程序中，有两种使用 loader 的方式：</p>
<ul>
<li><a href="https://www.webpackjs.com/concepts/loaders/#configuration">配置方式</a>（推荐）：在 <strong>webpack.config.js</strong> 文件中指定 loader。</li>
<li><a href="https://www.webpackjs.com/concepts/loaders/#inline">内联方式</a>：在每个 <code>import</code> 语句中显式指定 loader。</li>
</ul>
<h5 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h5><ul>
<li><code>test</code> 属性，识别出哪些文件会被转换。</li>
<li><code>use</code> 属性，定义出在进行转换时，应该使用哪个 loader</li>
<li><code>type</code>，资源模块类型</li>
<li>generator</li>
</ul>
<h5 id="资源模块类型"><a href="#资源模块类型" class="headerlink" title="资源模块类型"></a>资源模块类型</h5><p><a href="https://blog.csdn.net/qq_41887214/article/details/121631683">https://blog.csdn.net/qq_41887214/article/details/121631683</a></p>
<p>资源模块(asset module)是一种模块类型，它允许使用资源文件（字体，图标等）而<strong>无需配置额外 loader</strong>。</p>
<ul>
<li><p>asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。</p>
</li>
<li><p>asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现。</p>
</li>
<li><p>asset/source 导出资源的源代码。之前通过使用 raw-loader 实现。</p>
</li>
<li><p>asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现。</p>
</li>
</ul>
<h5 id="css"><a href="#css" class="headerlink" title="css"></a>css</h5><p><code>js</code>代码里如果使用<code>import</code>导入一个样式文件<code>style.less</code>(代码如下),<code>webpack</code>碰到<code>.less</code>后缀的文件不知所措.因为它默认只能处理以<code>.js</code>和<code>.json</code>结尾的文件.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//js文件</span><br><span class="line">import &quot;./style.less&quot;;</span><br></pre></td></tr></table></figure>

<p>有了<code>loader</code>的赋能,<code>webpack</code>便有能力处理<code>.less</code>文件.</p>
<p>比如上面的配置代码,项目中一旦碰到导入以<code>.less</code>为后缀的样式文件,<code>webpack</code>会先将文件内容发送给<code>less-loader</code>处理,<code>less-loader</code>将所有<code>less</code>语法的样式转变成普通的<code>css</code>样式.</p>
<p>普通的<code>css</code>样式继续发送给<code>css-loader</code>处理,<code>css-loader</code>最主要的功能是解析<code>css</code>语法中的<code>@import</code>和图片路径,处理完后导入的<code>css</code>合并在了一起.</p>
<p>合并后的<code>css</code>文件再继续传递,发送给<code>html-loader</code>处理,它最终将样式内容插入到了<code>html</code>头部的<code>style</code>标签下,页面也因此添加了样式.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//loader加载器模块配置</span></span><br><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.less$/</span>,<span class="comment">//使用正则匹配</span></span><br><span class="line">      use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>],<span class="comment">//从后往前调用的</span></span><br><span class="line">    &#125;, <span class="comment">//如果想要启用 CSS 模块化，可以为 css-loader 添加 modules 参数即可</span></span><br><span class="line">  ],</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><strong><code>loader</code>在上面配置<code>use</code>数组中的执行顺序是<code>从后往前</code></strong></p>
<h5 id="img"><a href="#img" class="headerlink" title="img"></a>img</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      test: /\.(png|svg|jpg|jpeg|gif)$/i,</span><br><span class="line">      type: &#x27;asset/resource&#x27;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在<code>css</code>加入img</p>
<p>在<code>js</code>中加入img</p>
<h5 id="font"><a href="#font" class="headerlink" title="font"></a>font</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: /\.(woff|woff2|eot|ttf|otf)$/i,</span><br><span class="line">    type: &#x27;asset/resource&#x27;,</span><br><span class="line">    generator: &#123;</span><br><span class="line">    filename: &#x27;fonts/[name]_[hash][ext]&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="加载数据"><a href="#加载数据" class="headerlink" title="加载数据"></a>加载数据</h5><p>JSON 文件，CSV、TSV 和 XML，可以使用 <a href="https://github.com/theplatapi/csv-loader">csv-loader</a> 和 <a href="https://github.com/gisikw/xml-loader">xml-loader</a></p>
<h5 id="自定义输出文件名"><a href="#自定义输出文件名" class="headerlink" title="自定义输出文件名"></a>自定义输出文件名</h5><p>1.output.assetModuleFilename</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">    <span class="attr">assetModuleFilename</span>: <span class="string">&#x27;images/[hash][ext][query]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.png$/</span>,</span><br><span class="line">        type: <span class="string">&#x27;asset/resource&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.generator</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/index.js&#x27;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span>,</span><br><span class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">+   assetModuleFilename: <span class="string">&#x27;images/[hash][ext][query]&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.png$/</span>,</span><br><span class="line">        type: <span class="string">&#x27;asset/resource&#x27;</span>,</span><br><span class="line">       <span class="attr">generator</span>: &#123;</span><br><span class="line">         <span class="attr">filename</span>: <span class="string">&#x27;images/[hash][ext][query]&#x27;</span></span><br><span class="line">       &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用此配置，所有 png 文件都将被发送到输出目录中的 images 目录中。</p>
<p>Rule.generator.filename 与 output.assetModuleFilename 相同，并且仅适用于 asset 和 asset/resource 模块类型。</p>
<p>但Rule.generator.filename 优先级高于 output.assetModuleFilename</p>
<h5 id="自定义loader"><a href="#自定义loader" class="headerlink" title="自定义loader"></a><strong>自定义loader</strong></h5><p><a href="https://zhuanlan.zhihu.com/p/397174187">https://zhuanlan.zhihu.com/p/397174187</a></p>
<p>背景：项目团队要为每个项目部署监控系统,一旦生产环境下<code>js</code>出现异常,要将报错信息及时上传到后台日志服务器.</p>
<p>在项目文件夹下创建一个文件<code>error-loader.js</code>,编写下面的测试代码(代码如下).</p>
<p><code>loader</code>本质上是一个函数,参数<code>content</code>是一段字符串,存储着文件的内容,最后将<code>loader</code>函数导出就可以提供给<code>webpack</code>使用了.</p>
<p><code>webpack</code>的配置文件在设置<code>rules</code>时(代码如下),只需要将<code>use</code>里的<code>loader</code>指向上面导出的<code>loader</code>函数的文件路径,这样<code>webpack</code>就能顺利引用<code>loader</code>了.另外我们还可以添加<code>options</code>属性给<code>loader</code>函数传参.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//error-loader.js</span><br><span class="line">//loader函数</span><br><span class="line">module.exports = function (content)&#123;</span><br><span class="line">  console.log(this.query); // &#123; name: &#x27;hello&#x27; &#125;</span><br><span class="line">  return content;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//webpack.config.js</span><br><span class="line">//webpack配置</span><br><span class="line">module.exports = &#123;</span><br><span class="line">   module:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test:/\.js$/,</span><br><span class="line">        use:[</span><br><span class="line">          &#123;</span><br><span class="line">            loader:path.resolve(__dirname,&quot;./error-loader.js&quot;),</span><br><span class="line">            options:&#123;</span><br><span class="line">              name:&quot;hello&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目一旦启动打包,<code>webpack</code>检测到<code>.js</code>文件,它就会把文件的代码字符串传递给<code>error-loader.js</code>导出的<code>loader</code>函数执行.</p>
<p>我们上面编写的<code>loader</code>函数并没有对代码字符串<code>content</code>做任何操作,直接返回了结果.那么我们自定义<code>loader</code>的目的就是为了对<code>content</code>源代码做各种数据操作,再将操作完的结果返回.</p>
<p>比如我们可以使用正则表达式将<code>content</code>中所有的<code>console.log</code>语句全部去掉,那么最后我们生成的打包文件里就不会包含<code>console.log</code>.</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="webpack-1"><a href="#webpack-1" class="headerlink" title="webpack"></a><strong>webpack</strong></h4><p>一个模块打包器，根据entry指示webpack应该使用哪个模块，来<strong>作为构建其内部依赖图的开始</strong>。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<br>每个依赖项随即被处理，最后输出到output字段指定的文件中</p>
<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a><strong>webpack-dev-server</strong></h4><p>webpack-dev-server：一个服务器插件，相当于webpack+apache，启动一个web服务并实时更新修改<br><strong>启动webpack-dev-server后，在目标文件夹中是看不到编译后的文件的，实时编译后的文件都保存到了内存当中。</strong></p>
<p><strong>区别</strong></p>
<ul>
<li>webpack不会实时更新修改，就只是一个打包工具，webpack-dev-server会实时自动更新修改</li>
<li>webpack打包输出路径，output字段为path，webpack-dev-server打包输出路径，output字段为publicPath(此值为空时默认是项目根目录，  contentBase:’src’,//指定托管的根目录)</li>
<li>webpack打包输出的文件，是真的存在于物理地址path中，而webpack-dev-server打包输出的文件，是保存在内存中的，在项目目录中是找不到的。</li>
</ul>
<p>模块热更新(Hot Module Replacement)是指在浏览器运行过程中，替换、添加或删除模块，而无需重新加载整个页面。</p>
<h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>webpack-dev-server实现了自动编译刷新浏览器，让编译出来的bundle.js托关于服务器根路径（电脑内存）中去。</p>
<p>html-webpack-plugin会创建一个在内存中生成一个html的插件，帮我们自动引入在内存中打包好的bundle.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性</span><br><span class="line">title 生成html的标题</span><br><span class="line">filename 生成html的文件名，默认是index.html，可以添加路径比如：src/index.html</span><br><span class="line">template 模版的路径</span><br><span class="line">templateParameters 模版需要的参数</span><br><span class="line">inject</span><br><span class="line"></span><br><span class="line">inject有四个值： true body head false</span><br><span class="line"></span><br><span class="line">true 默认值，script标签位于html文件的 body 底部</span><br><span class="line"></span><br><span class="line">body script标签位于html文件的 body 底部</span><br><span class="line"></span><br><span class="line">head script标签位于html文件的 head中</span><br><span class="line"></span><br><span class="line">false 不插入生成的js文件，这个几乎不会用到的</span><br><span class="line"></span><br><span class="line">favicon html的favicon路径</span><br><span class="line">meta 插入的meta标签内容 例如 meta: &#123;viewport: &#x27;width=device-width, initial-scale=1, shrink-to-fit=no&#x27;&#125;</span><br><span class="line">minify 使用minify会对生成的html文件进行压缩</span><br><span class="line">hash 对所有css 和 js文件追加webpack生成的hash值</span><br><span class="line">cache 缓存，只有内容变化的时候生成新文件</span><br><span class="line">showErrors 是否把错误输出到html文件</span><br><span class="line">chunks chunks主要用于多入口文件，当你有多个入口文件，那就回编译后生成多个打包后的文件，那么chunks 就能选择你要使用那些js文件</span><br><span class="line">excludeChunks 排除掉一些js</span><br><span class="line">xhtml 一个布尔值，默认值是 false ，如果为 true ,则以兼容 xhtml 的模式引用文件。</span><br><span class="line">chunksSortMode script的顺序，默认四个选项： none auto dependency &#123;function&#125;</span><br><span class="line"></span><br><span class="line">&#x27;dependency&#x27; 不用说，按照不同文件的依赖关系来排序。</span><br><span class="line"></span><br><span class="line">&#x27;auto&#x27; 默认值，插件的内置的排序方式，具体顺序....</span><br><span class="line"></span><br><span class="line">&#x27;none&#x27; 无序？</span><br><span class="line"></span><br><span class="line">&#123;function&#125; 提供一个函数？</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="webpack-manifest-plugin"><a href="#webpack-manifest-plugin" class="headerlink" title="webpack-manifest-plugin"></a>webpack-manifest-plugin</h4><p>webpack 通过 manifest，可以追踪所有模块到输出 bundle 之间的映射。通过 <a href="https://github.com/shellscape/webpack-manifest-plugin"><code>WebpackManifestPlugin</code></a> 插件，可以将 manifest 数据提取为一个 json 文件以供使用。</p>
<h4 id="cross-env"><a href="#cross-env" class="headerlink" title="cross-env"></a><strong>cross-env</strong></h4><p><strong>1、什么是cross-env?</strong></p>
<p>它是运行跨平台设置和使用环境变量的脚本。</p>
<p><strong>2、为什么需要cross-env?</strong></p>
<p>针对相同的语句和命令，我们希望这条语句能够同时在 Windows 和 Linux 上使用。</p>
<p>这个问题主要是因为不同的操作系统平台对 Shell 脚本的支持情况不一样导致的。</p>
<p>例如，如果你希望在 Windows 中使用命令<code>NODE_ENV=production</code> 来设置环境变量的话，大多数Windows 命令提示符都没有办法进行操作。</p>
<p>同样的，Windows 和 POSIX 命令使用环境变量的方式也有所不同。</p>
<p>对于POSIX，您可以使用：<code>$ENV_VAR</code> ，但是在 Windows 上需要使用 <code>%ENV_VAR%</code> 来设置环境变量。</p>
<p>上面的情况就是针对不同的操作系统平台，设置环境变量中使用的变量引用是不同的。</p>
<p>例如，我们常常用到的设置环境变量。</p>
<p>针对不同的操作系统环境</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">windows</span><br><span class="line">set NODE_ENV=production</span><br><span class="line">linux</span><br><span class="line">export NODE_ENV=production</span><br></pre></td></tr></table></figure>

<p><strong>process</strong></p>
<ul>
<li><p>process</p>
<p>在node中，有全局变量process表示的是当前的node进程。</p>
</li>
</ul>
<ul>
<li><p>process.env</p>
<p>process.env 属性返回的是一个包含用户环境信息的对象，它是区分开发环境或正式环境的依据。<strong>打开终端，输入node,输入process，就可以看到对应的描述信息</strong></p>
</li>
</ul>
<p><strong>cross-env添加自定义变量</strong></p>
<p><a href="https://blog.csdn.net/qq_43277404/article/details/120902111">https://blog.csdn.net/qq_43277404/article/details/120902111</a></p>
<h4 id="PWA"><a href="#PWA" class="headerlink" title="PWA"></a>PWA</h4><p><a href="https://www.jianshu.com/p/7845a13a67d7">https://www.jianshu.com/p/7845a13a67d7</a></p>
<p><a href="https://carljin.com/how-to-add-pwa-on-existed-project">https://carljin.com/how-to-add-pwa-on-existed-project</a></p>
<p>PWA化主要解决了两大问题： 1）使web app有沉浸式体验，也就是更靠近原生体验。如：去掉浏览器的地址栏和底部工具栏；在桌面上生成图标，方便再次进入。 2）提供独立于浏览器的缓存，并且可以接收服务器的推送。如：在没有网络，或者网络状态较差的时候，仍可访问缓存在本地的数据.</p>
<h2 id="编译优化"><a href="#编译优化" class="headerlink" title="编译优化"></a>编译优化</h2><p><a href="https://jelly.jd.com/article/61179aa26bea510187770aa3">https://jelly.jd.com/article/61179aa26bea510187770aa3</a></p>
<p><a href="https://www.psvmc.cn/article/2022-08-25-vue-cli-optimization.html">https://www.psvmc.cn/article/2022-08-25-vue-cli-optimization.html</a></p>
<h3 id="编译分析插件"><a href="#编译分析插件" class="headerlink" title="编译分析插件"></a>编译分析插件</h3><h4 id="webpack-bundle-analyzer"><a href="#webpack-bundle-analyzer" class="headerlink" title="webpack-bundle-analyzer"></a>webpack-bundle-analyzer</h4><p><code>webpack-bundle-analyzer</code>可以生成代码分析报告，可以直观地分析打包出的文件有哪些，及它们的大小、占比情况、各文件 Gzipped 后的大小、模块包含关系、依赖项等</p>
<p><img src="https://image.psvmc.cn/blog/20220825103408.png" alt="image-20220825103406352"></p>
<p><code>npm i -D webpackbar webpack-bundle-analyzer</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; BundleAnalyzerPlugin &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> BundleAnalyzerPlugin(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//package.json</span></span><br><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">   <span class="string">&quot;analyz&quot;</span>: <span class="string">&quot;webpack-bundle-analyzer --port 8888 ./build/stats.json&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新版的 vue-cli 也内置了webpack-bundle-analyzer  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;analyz&quot;</span>: <span class="string">&quot;vue-cli-service build --report&quot;</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<ul>
<li><p>analyzerMode：server / static / json / disabled</p>
<p>默认值：server。 在server 模式下，分析器将启动 HTTP 服务器以显示 bundle 报告。 在 static 模式下，将生成带有 bundle 报告的单个 HTML 文件。 在 json 模式下，将生成带有捆绑报告的单个 JSON 文件。 在 disable 模式下，您可以使用此插件通过将 generateStatsFile 设置为 true 来生成 Webpack Stats JSON 文件。</p>
</li>
<li><p>analyzerHost：默认值：127.0.0.1。 在 server 模式下用于启动 HTTP 服务器的主机。</p>
</li>
<li><p>analyzerPort：默认值：8888。在 server 模式下用于启动 HTTP 服务器的端口</p>
</li>
<li><p>reportFilename：默认值：report.html。 在 static 模式下生成的捆绑报告文件的路径。 它可以是绝对路径，也可以是相对于 bundle 文件输出目录的路径（在 webpack 配置中是 output.path）。</p>
</li>
<li><p>defaultSizes：stat / parsed / gzip</p>
<p>默认值：parsed。 默认情况下在报告中显示的模块大小。</p>
<p>stat：这是文件的“输入”大小，在进行任何转换（如缩小）之前。之所以称为“stat size”，是因为它是从 Webpack 的 stats 对象中获取的。</p>
<p>parsed：这是文件的“输出”大小。 如果你使用的是 Uglify 之类的 Webpack 插件，那么这个值将反映代码的缩小后的大小。</p>
<p>gzip：这是通过 gzip 压缩运行解析的包/模块的大小。</p>
</li>
<li><p>openAnalyzer：默认值：true。 在默认浏览器中自动打开报告。</p>
</li>
<li><p>genarateStatsFile：默认值：false。 如果为 true，将在 bundle 输出目录中生成 webpack stats JSON 文件</p>
</li>
</ul>
<h4 id="webpackbar"><a href="#webpackbar" class="headerlink" title="webpackbar"></a>webpackbar</h4><p><code>webpackbar</code>提供了友好的编译进度提示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const WebpackBar = require(&#x27;webpackbar&#x27;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  // ...</span><br><span class="line">  plugins: [</span><br><span class="line">    new WebpackBar(),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="speed-measure-webpack-plugin"><a href="#speed-measure-webpack-plugin" class="headerlink" title="speed-measure-webpack-plugin"></a>speed-measure-webpack-plugin</h4><p>优化 webpack 构建速度，首先需要知道是哪些插件、哪些 loader 耗时长，方便我们针对性的优化。通过 <a href="https://www.npmjs.com/package/speed-measure-webpack-plugin">speed-measure-webpack-plugin </a>插件进行构建速度分析，可以看到各个 loader、plugin 的构建时长，后续可针对耗时 loader、plugin 进行优化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -D speed-measure-webpack-plugin</span><br></pre></td></tr></table></figure>

<h3 id="构建速度优化"><a href="#构建速度优化" class="headerlink" title="构建速度优化"></a>构建速度优化</h3><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h5><p>Webpack 中几种缓存方式：</p>
<ul>
<li><code>cache-loader</code></li>
<li><code>hard-source-webpack-plugin</code></li>
</ul>
<p>以上这些缓存方式都有首次启动时的开销，即它们会让 “冷启动” 时间会更长，但是二次启动能够节省很多时间</p>
<h6 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h6><p>babel-loader的options设置中增加cacheDirectory属性，属性值为true。表示：开启babel缓存，第二次构建时会读取之前的缓存，构建速度会更快一点。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">    <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">cacheDirectory</span>: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="cache-loader"><a href="#cache-loader" class="headerlink" title="cache-loader"></a>cache-loader</h6><p><a href="https://webpack.docschina.org/loaders/cache-loader/">https://webpack.docschina.org/loaders/cache-loader/</a></p>
<p>在一些性能开销较大的 loader 之前添加 cache-loader，将结果缓存中磁盘中。默认保存在 node_modueles/.cache/cache-loader 目录下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    //...</span><br><span class="line">    </span><br><span class="line">    module: &#123;</span><br><span class="line">        //我的项目中,babel-loader耗时比较长，所以我给它配置了`cache-loader`</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: /\.jsx?$/,</span><br><span class="line">                use: [&#x27;cache-loader&#x27;,&#x27;babel-loader&#x27;]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你跟我一样，只打算给 babel-loader 配置 cache 的话，也可以不使用 cache-loader，给 babel-loader 增加选项 cacheDirectory。</p>
<h6 id="持久化缓存"><a href="#持久化缓存" class="headerlink" title="持久化缓存"></a>持久化缓存</h6><p>通过配置 <a href="https://webpack.docschina.org/configuration/cache/#root">webpack 持久化缓存 </a><code>cache: filesystem</code>，来缓存生成的 webpack 模块和 chunk，改善构建速度。</p>
<p>简单来说，通过 <code>cache: filesystem</code> 可以将构建过程的 webpack 模板进行缓存，大幅提升二次构建速度、打包速度，当构建突然中断，二次进行构建时，可以直接从缓存中拉取，可提速 <strong>90%</strong> 左右。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">cache</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;filesystem&#x27;</span>, <span class="comment">// 使用文件缓存</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="hard-source-webpack-plugin"><a href="#hard-source-webpack-plugin" class="headerlink" title="hard-source-webpack-plugin"></a>hard-source-webpack-plugin</h6><blockquote>
<p>HardSourceWebpackPlugin 和 speed-measure-webpack-plugin 不能一起使用</p>
</blockquote>
<h5 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h5><h6 id="cache-loader-1"><a href="#cache-loader-1" class="headerlink" title="cache-loader"></a>cache-loader</h6><p>Vue-Cli自带<strong>cache-loader</strong> ，会默认为 <code>Vue/Babel/TypeScript</code> 编译开启。文件会缓存在 <code>node_modules/.cache</code> 中。</p>
<p> <strong><code>cache-loader</code></strong> 进行以下两个的缓存了</p>
<ul>
<li>babel-loader 的 cacheDirectory 标志</li>
<li>vue-loader 的 cacheDirectory 标志</li>
</ul>
<h6 id="hard-source-webpack-plugin-1"><a href="#hard-source-webpack-plugin-1" class="headerlink" title="hard-source-webpack-plugin"></a>hard-source-webpack-plugin</h6><blockquote>
<p>这个插件能正常使用的版本是<code>webpack5</code>以下的版本。</p>
</blockquote>
<p><code>npm install --save-dev hard-source-webpack-plugin</code></p>
<p>为模块提供中间缓存，缓存路径是：<code>node_modules/.cache/hard-source</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HardSourceWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;hard-source-webpack-plugin&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.plugin.push(</span><br><span class="line">      <span class="comment">// 为模块提供中间缓存，缓存路径是：node_modules/.cache/hard-source</span></span><br><span class="line">      <span class="keyword">new</span> HardSourceWebpackPlugin(&#123;</span><br><span class="line">        <span class="attr">root</span>: process.cwd(),</span><br><span class="line">        <span class="attr">directories</span>: [],</span><br><span class="line">        <span class="attr">environmentHash</span>: &#123;</span><br><span class="line">          <span class="attr">root</span>: process.cwd(),</span><br><span class="line">          <span class="attr">directories</span>: [],</span><br><span class="line">          <span class="attr">files</span>: [<span class="string">&#x27;package.json&#x27;</span>, <span class="string">&#x27;yarn.lock&#x27;</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="comment">// 配置了files的主要原因是解决配置更新，cache不生效了的问题，配置后有包的变化，plugin会重新构建一部分cache</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="hash缓存"><a href="#hash缓存" class="headerlink" title="hash缓存"></a>hash缓存</h5><p><strong>防止编译文件名字重复，部署版本的时候，浏览器使用缓存文件。同时，如果编译时文件未改动，不会改变文件名和文件的</strong></p>
<p>hash、chunkhash、contenthash</p>
<p>hash是一整个项目，一次打包，只有一个hash值，是项目级的</p>
<p>chunhash是从入口entry出发，到它的依赖，以及依赖的依赖，依赖的依赖的依赖，等等，一直下去，所打包构成的代码块(模块的集合)叫做一个chunk，也就是说，入口文件和它的依赖的模块构成的一个代码块，被称为一个chunk。</p>
<p>contenthash是哈希只跟内容有关系，内容不变，哈希值不变。与chunkhash的区别可以举上面contenthash的例子，同时可以说明contenthash跟内容有关，但是chunkhash会考虑很多因素，比如模块路径、模块名称、模块大小、模块id等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">      filename: &#x27;[name].[contenthash].js&#x27;, // contenthash 只有在内容发生改变才会变</span><br><span class="line">      path: path.resolve(__dirname, &#x27;dist&#x27;), //输出路径   __dirname 代表当前文件的绝对路径</span><br><span class="line">      clean: true, //在生成文件之前清空 output 目录</span><br><span class="line">    &#125;,</span><br><span class="line">vue-cli    </span><br><span class="line">configureWebpack -&gt; </span><br><span class="line">config.output.filename = `js/[name].[contenthash].js`;</span><br><span class="line">config.output.chunkFilename = `js/[name].[contenthash].js`;</span><br></pre></td></tr></table></figure>

<p>在提取css时我们也可以这么命名文件名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// css 提取</span><br><span class="line">plugins: [</span><br><span class="line">  new MiniCssExtractPlugin(&#123;</span><br><span class="line">     filename: &#x27;css/[name].[contenthash:10].css&#x27;,</span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="dll"><a href="#dll" class="headerlink" title="dll"></a>dll</h5><p>将我们项目中的依赖使用dll插件进行动态链接，这样依赖就不会进行编译，从而极大地提高编译速度</p>
<blockquote>
<p> webpack5 开箱即用的持久缓存是比 dll 更优的解决方案</p>
</blockquote>
<p>将dll和缓存进行对比可以发现：</p>
<table>
<thead>
<tr>
<th>缓存</th>
<th>DLL</th>
</tr>
</thead>
<tbody><tr>
<td>把常用的文件存储到内存或硬盘中</td>
<td>把公共代码打包为dll文件放到硬盘中</td>
</tr>
<tr>
<td>再次打包时，直接取读取缓存</td>
<td>再次打包时，读取dll文件，不重新打包</td>
</tr>
<tr>
<td>加载时间减少</td>
<td>打包时间减少</td>
</tr>
</tbody></table>
<p>autodll-webpack-plugin</p>
<h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>将文件解析任务分解成多个子进程并发执行，发挥多核 CPU 电脑的威力。子进程处理完任务后再将结果发送给主进程。所以可以大大提升 Webpack 的项目构建速度</p>
<h5 id="happypack"><a href="#happypack" class="headerlink" title="happypack"></a>happypack</h5><p><a href="https://github.com/amireh/happypack">happypack </a>同样是用来设置多线程，但是在 webpack5 就不要再使用 <a href="https://github.com/amireh/happypack">happypack </a>了，官方也已经不再维护了，推荐使用 thread-loader。</p>
<p><code>npm install happypack -D</code></p>
<p><strong>HappyPack</strong> 参数</p>
<ul>
<li><code>id: String</code> 用唯一的标识符 id 来代表当前的 HappyPack 是用来处理一类特定的文件.</li>
<li><code>loaders: Array</code> 用法和 webpack Loader 配置中一样.</li>
<li><code>threads: Number</code> 代表开启几个子进程去处理这一类型的文件，默认是3个，类型必须是整数。</li>
<li><code>verbose: Boolean</code> 是否允许 HappyPack 输出日志，默认是 true。</li>
<li><code>threadPool: HappyThreadPool</code> 代表共享进程池，即多个 HappyPack 实例都使用同一个共享进程池中的子进程去处理任务，以防止资源占用过多。</li>
<li><code>verboseWhenProfiling: Boolean</code> 开启<code>webpack --profile</code> ,仍然希望HappyPack产生输出。</li>
<li><code>debug: Boolean</code> 启用debug 用于故障排查。默认 <code>false</code>。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提升 Webpack 构建速度</span></span><br><span class="line"><span class="keyword">const</span> HappyPack = <span class="built_in">require</span>(<span class="string">&#x27;happypack&#x27;</span>);</span><br><span class="line"><span class="comment">//安装 OS 模块 这个主要是拿到当前电脑的CPU核数</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&#x27;os&#x27;</span>);</span><br><span class="line"><span class="comment">//这个是设置共享线程池中的数量 size 控制设置数量 类型 只能是 整数类型</span></span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123; <span class="attr">size</span>: os.cpus().length &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">//把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行</span></span><br><span class="line">        loader: <span class="string">&#x27;happypack/loader?id=happyBabel&#x27;</span>,</span><br><span class="line">        <span class="comment">//排除node_modules 目录下的文件</span></span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">            <span class="attr">test</span>: <span class="regexp">/\.(css|less)$/</span>,</span><br><span class="line">            use: <span class="string">&#x27;happypack/loader?id=styles&#x27;</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">       <span class="comment">//用id来标识 happypack处理那里类文件</span></span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;happyBabel&#x27;</span>,</span><br><span class="line">      <span class="comment">//用法和loader 的配置一样</span></span><br><span class="line">      <span class="attr">loaders</span>: [&#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader?cacheDirectory=true&#x27;</span>,</span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="comment">//共享进程池</span></span><br><span class="line">      <span class="attr">threadPool</span>: happyThreadPool,</span><br><span class="line">      <span class="comment">//允许 HappyPack 输出日志</span></span><br><span class="line">      <span class="attr">verbose</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;styles&#x27;</span>,</span><br><span class="line">        <span class="attr">loaders</span>: [ <span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>, <span class="string">&#x27;less-loader&#x27;</span> ]，</span><br><span class="line">        <span class="comment">//共享进程池</span></span><br><span class="line">        <span class="attr">threadPool</span>: happyThreadPool,</span><br><span class="line">    &#125;);</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vue</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//把对.js 的文件处理交给id为happyBabel 的HappyPack 的实例执行</span><br><span class="line">// config.module.rule(&#x27;js&#x27;).test(/\.js$/)</span><br><span class="line">//   .include.add(&#x27;/src/&#x27;).end()</span><br><span class="line">//   .exclude.add(&#x27;/node_modules/&#x27;).end()</span><br><span class="line">//   .use().loader(&#x27;happypack/loader?id=happyBabel&#x27;).end()</span><br></pre></td></tr></table></figure>

<h5 id="thread-loader"><a href="#thread-loader" class="headerlink" title="thread-loader"></a>thread-loader</h5><ul>
<li><p><strong>Webpack</strong></p>
<p>npm install –save-dev thread-loader</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        include: path.resolve(&#x27;src&#x27;),</span><br><span class="line">        use: [</span><br><span class="line">          &quot;thread-loader&quot;,</span><br><span class="line">          // 耗时的 loader （例如 babel-loader）</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>Vue-Cli已经内置<code>thread-loader</code>，<strong>thread-loader</strong> 会在多核 CPU 的机器上为 <code>Babel/TypeScript</code> 转译开启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  parallel: true,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Type: <code>boolean</code></p>
</li>
<li><p>Default: <code>require(&#39;os&#39;).cpus().length &gt; 1</code></p>
<p>是否为 Babel 或 TypeScript 使用 <code>thread-loader</code>。</p>
<p>该选项在系统的 CPU 有多于一个内核时自动启用，仅作用于生产构建。</p>
</li>
</ul>
</li>
</ul>
<h4 id="缩小文件检索解析范围"><a href="#缩小文件检索解析范围" class="headerlink" title="缩小文件检索解析范围"></a>缩小文件检索解析范围</h4><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><ul>
<li>为避免无用的检索与递归遍历，可以使用alias指定引用时候的模块</li>
</ul>
<h5 id="extensions"><a href="#extensions" class="headerlink" title="extensions"></a>extensions</h5><ul>
<li><p>extensions 表示需要解析的文件类型列表。</p>
<p>根据项目中的文件类型，定义 extensions，以覆盖 webpack 默认的 extensions，加快解析速度。</p>
<p>由于 webpack 的解析顺序是从左到右，因此要将使用频率高的文件类型放在左侧，如下我将 <code>tsx</code> 放在最左侧</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    resolve: &#123;</span><br><span class="line">        extensions: [&#x27;.tsx&#x27;, &#x27;.js&#x27;], // 因为我的项目只有这两种类型的文件，如果有其他类型，需要添加进去。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="noParse"><a href="#noParse" class="headerlink" title="noParse"></a>noParse</h5><ul>
<li>noParse，对不依赖本地代码的第三方依赖不进行解析，比如CDN引用的第三方依赖。</li>
</ul>
<h5 id="include"><a href="#include" class="headerlink" title="include"></a>include</h5><ul>
<li>为 loader 指定 include，减少 loader 应用范围，仅应用于最少数量的必要模块，。</li>
</ul>
<h4 id="import优化"><a href="#import优化" class="headerlink" title="import优化"></a>import优化</h4><p>运用这个插件能在代码使用了import语法的情况下，大大提高代码的编译速度。</p>
<p>安装 <code>babel-plugin-dynamic-import-node</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-dynamic-import-node</span><br></pre></td></tr></table></figure>

<p><strong>vue-cli3</strong></p>
<p>修改babel.config.js文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  presets: [&quot;@vue/cli-plugin-babel/preset&quot;],</span><br><span class="line">  env: &#123;</span><br><span class="line">    development: &#123;</span><br><span class="line">      plugins: [&quot;dynamic-import-node&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>vue.cli2</strong></p>
<p>.babelrc文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">        &quot;test&quot;: &#123;</span><br><span class="line">                 &quot;plugins&quot;: []</span><br><span class="line">                &#125;,</span><br><span class="line">        &quot;development&quot;:&#123;</span><br><span class="line">                       &quot;presets&quot;: [&quot;env&quot;, &quot;stage-2&quot;],</span><br><span class="line">                       &quot;plugins&quot;: [&quot;dynamic-import-node&quot;]</span><br><span class="line">                      &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<h3 id="打包-上线运行优化"><a href="#打包-上线运行优化" class="headerlink" title="打包/上线运行优化"></a>打包/上线运行优化</h3><p>某些 utility, plugin 和 loader 都只用于生产环境。例如，在开发环境下使用 <code>TerserPlugin</code> 来 minify(压缩) 和 mangle(混淆破坏) 代码是没有意义的。通常在开发环境下，应该排除以下这些工具：</p>
<ul>
<li><code>TerserPlugin</code></li>
<li><code>[fullhash]</code>/<code>[chunkhash]</code>/<code>[contenthash]</code></li>
</ul>
<h4 id="代码分离"><a href="#代码分离" class="headerlink" title="代码分离"></a>代码分离</h4><p><a href="https://www.cnblogs.com/Mr-Hou88888/p/16217467.html">https://www.cnblogs.com/Mr-Hou88888/p/16217467.html</a></p>
<p><a href="https://blog.csdn.net/qq_41887214/article/details/121646392">https://blog.csdn.net/qq_41887214/article/details/121646392</a></p>
<p>代码分离code splitting是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，加快打包速度，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。</p>
<h5 id="多入口起点"><a href="#多入口起点" class="headerlink" title="多入口起点"></a>多入口起点</h5><p><a href="https://webpack.docschina.org/concepts/entry-points/">入口起点(entry points)</a></p>
<p><strong>src/index.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;Hello world!&#x27;);</span><br></pre></td></tr></table></figure>

<p><strong>src/another-module.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">&#x27;lodash&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(_.join([<span class="string">&#x27;another&#x27;</span>, <span class="string">&#x27;module&#x27;</span>, <span class="string">&#x27;chunk&#x27;</span>], <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>这个模块依赖了 lodash ，需要安装一下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install lodash</span><br></pre></td></tr></table></figure>

<p><strong>webpack.config.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#123; // 配置多入口文件</span><br><span class="line">    index: &#x27;./src/index.js&#x27;,</span><br><span class="line">    another: &#x27;./src/another_module.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">   output: &#123;</span><br><span class="line">      filename: &#x27;bundle.js&#x27;,</span><br><span class="line">      path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<code>webpack</code>命令，可以看到报错了￣□￣｜｜<br><img src="https://img-blog.csdnimg.cn/7736ca9d1e3a4738a8a710ca4c5b280c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU6JmO5oiY55S75oif,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#x27;./src/index.js&#x27;,</span><br><span class="line">    another: &#x27;./src/another_module.js&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].bundle.js&#x27;, // 对应多个出口文件名</span><br><span class="line">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行<code>webpack</code>命令，可以看到不报错了，并且<code>dist</code>输出了两个js文件<br><img src="https://img-blog.csdnimg.cn/241a1e7365fa4194bda5983701ffefc6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5LqU6JmO5oiY55S75oif,size_20,color_FFFFFF,t_70,g_se,x_16#pic_left" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/e3ccdb777a174904a05e6ef578246135.png" alt="在这里插入图片描述"></p>
<p>文件<code>another.bundle.js</code>来源于<code>entry.another</code>，即<code>src/another.js</code>，文件大小为<code>554kb</code>，因为被<code>lodash</code>被打包进去了</p>
<p>文件<code>index.bundle.js</code>来源于<code>entry.index</code>，即<code>src/index.js</code>，文件大小为<code>1.21kb</code></p>
<p>但是，如果我们的其他入口也需要使用<code>lodash</code>呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">src/index.js</span><br><span class="line">import _ from &#x27;lodash&#x27;</span><br><span class="line"></span><br><span class="line">console.log(_.join([&#x27;index&#x27;, &#x27;module&#x27;, &#x27;chunk&#x27;], &#x27; &#x27;));</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/8dfaf53d4d524d02865d6fbab9f6a21b.png" alt="在这里插入图片描述"></p>
<p><code>lodash</code>在两个引用文件中都被打包了，我们期望<code>lodash</code>应该是公用的</p>
<p>配置 <code>dependOn option</code> 选项，这样可以在多个 chunk 之间共享模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line"> mode: &#x27;development&#x27;,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: &#123;</span><br><span class="line">      import: &#x27;./src/index.js&#x27;, // 启动时需加载的模块</span><br><span class="line">      dependOn: &#x27;common_chunk&#x27;, // 当前入口所依赖的入口</span><br><span class="line">    &#125;,</span><br><span class="line">    another: &#123;</span><br><span class="line">      import: &#x27;./src/another_module.js&#x27;,</span><br><span class="line">      dependOn: &#x27;common_chunk&#x27;,</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    common_chunk: &#x27;lodash&#x27; // 当上面两个模块有lodash这个模块时，就提取出来并命名为shared chunk</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].bundle.js&#x27;, // 对应多个出口文件名</span><br><span class="line">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行<code>webpack</code>命令，可以看到打包结果<br><img src="https://img-blog.csdnimg.cn/a1f0a2554c7e48c899c98cbf0dcbadaa.png" alt="在这里插入图片描述"></p>
<p>已经提取出来<code>common_chunk.bundle.js</code>，即为提取打包了<code>lodash</code>公用模块</p>
<p><code>index.bundle.js</code> <code>another.bundle.js</code>体积也变小</p>
<h5 id="分离-Vendor"><a href="#分离-Vendor" class="headerlink" title="分离 Vendor"></a>分离 Vendor</h5><p>chunk-vendors.js ：顾名思义，chunk-vendors.js 是捆绑所有不是自己的模块，而是来自其他方的模块的捆绑包，它们称为第三方模块或供应商模块。</p>
<p>通常，它意味着（仅和）来自项目 /node_modules 目录的所有模块，会将所有 /node_modules 中的第三方包打包到 chunk-vendors.js 中。</p>
<p>将所有的第三方包集中到一个文件，自然也会出现文件过大的问题。</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMzLnpoaW1nLmNvbS84MC92Mi1mMmMwZDBlM2VhMTUxYzA1ODJhODQ0MmY1MTE3NWFjZV83MjB3LnBuZw?x-oss-process=image/format,png" alt="img" style="zoom: 50%;" />

<p>可以看到，当前只有一个 chunk 也就是 app.js ，他是一个 entry chunk 。因为我们的 <a href="https://so.csdn.net/so/search?q=webpack&spm=1001.2101.3001.7020">webpack</a> 配置是这样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">     app: <span class="string">&#x27;./src/main.js&#x27;</span>, <span class="comment">// entry chunk</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.js 包含了我们的第三方库 vue 和 axios ，以及我们的业务代码 src 。</p>
<p>分离 Vendor，最简单方法就是：加一个 entry ( <a href="https://link.zhihu.com/?target=https://github.com/lyyourc/webpack-code-splitting-demo/commit/6324e8a591b0c2b1fe5cd6c288a2cdfe56e17550">File Changes</a> )：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    vendor: [<span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;axios&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMxLnpoaW1nLmNvbS84MC92Mi0zOGJmMDAwYmIxZTk3NjY1NGFmNjIxYmRmOWZjOTc1OF83MjB3LnBuZw?x-oss-process=image/format,png" alt="img" style="zoom:50%;" />

<p>虽然 vendor.js 这个 entry chunk 包含了我们想要的 vue 和 axios ，但是细心的同学会发现， app.js 也包含了他们！为什么！？</p>
<p>其实这是很正常的事情：每个 entry 都包含了他自己的依赖，这样他才能作为一个入口，独立地跑起来。</p>
<p>很难受，事实上我们并不想 app.js 还包含了 vue 和 axios 。如果可以把他们俩相同的依赖提取出来就好了，就像这样：</p>
<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS84MC92Mi0xMmFjNzAxMTQ1OGExZTVkZTVlODMxNmMyOWFkMjc0Zl83MjB3LnBuZw?x-oss-process=image/format,png" alt="img" style="zoom:33%;" />

<h6 id="SplitChunksPlugin"><a href="#SplitChunksPlugin" class="headerlink" title="SplitChunksPlugin"></a>SplitChunksPlugin</h6><p><a href="https://webpack.docschina.org/plugins/split-chunks-plugin/">SplitChunksPlugin</a> 插件可以将公共的依赖模块提取到已有的 chunk 中，或者提取到一个新生成的 chunk。让我们使用这个插件，将之前的示例中重复的 lodash 模块去除：</p>
<p><strong>webpack.config.js</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123; // 多入口</span><br><span class="line">    index: &#x27;./src/index.js&#x27;,</span><br><span class="line">    another: &#x27;./src/another_module.js&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &#x27;[name].bundle.js&#x27;, // 对应多个出口文件名</span><br><span class="line">    path: path.resolve(__dirname, &#x27;./dist&#x27;),</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123; // 代码分割</span><br><span class="line">      // include all types of chunks</span><br><span class="line">      chunks: &#x27;all&#x27; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <a href="https://webpack.docschina.org/plugins/split-chunks-plugin/#optimization-splitchunks"><code>optimization.splitChunks</code></a> 配置选项之后，现在应该可以看出，<code>index.bundle.js</code> 和 <code>another.bundle.js</code> 中已经移除了重复的依赖模块。需要注意的是，插件将 <code>lodash</code> 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小<br><img src="https://img-blog.csdnimg.cn/450bc002e5774d68be21edc94cc2184c.png" alt="在这里插入图片描述"></p>
<h6 id="CommonsChunkPlugin-已废弃"><a href="#CommonsChunkPlugin-已废弃" class="headerlink" title="CommonsChunkPlugin(已废弃)"></a>CommonsChunkPlugin(已废弃)</h6><p>现在，修改我们的 webpack 配置文件（ <a href="https://link.zhihu.com/?target=https://github.com/lyyourc/webpack-code-splitting-demo/commit/4af7b5be5d503a59ac43209747ec2b740d39ebb2">File Changes</a> ）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">&#x27;vendor&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>但是！随着业务的增长，我们依赖的第三方库代码很可能会越来越多，这时候我们的 webpack.config.js 就变成这样了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">&#x27;./src/main.js&#x27;</span>,</span><br><span class="line">    vendor: [</span><br><span class="line">      <span class="string">&#x27;vue&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;axio&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vue-router&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;vuex&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;element-ui&#x27;</span>,</span><br><span class="line">      <span class="comment">// 很长很长</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>vendor entry 会变成很长很长，更糟糕的是，我们每次引入了新的第三方库，都需要在 vendor 手动增加对应的包名。</p>
<h5 id="动态导入懒加载"><a href="#动态导入懒加载" class="headerlink" title="动态导入懒加载"></a>动态导入懒加载</h5><ul>
<li><a href="https://webpack.js.org/api/module-methods/#import-1">import()</a> 为动态加载脚本，webpack 会生成类似以上动态创建 <code>script</code> 标签的代码</li>
<li>import 里的注释为特殊含义的魔法注释，如果不设置 webpackChunkName，加载的脚本将被按数字次序命名</li>
</ul>
<p>如果我们想「按需加载」路由组件的话，只要改几行代码就好了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//index.js</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//文件会等5秒后加载，实现懒加载</span></span><br><span class="line">  <span class="comment">// webpackChunkName: &quot;dynamicImport&quot;：这是webpack动态导入模块命名的方式。</span></span><br><span class="line">  <span class="comment">//浏览器看到的文件名：dynamicImport.chunk-test.js。output.chunkFilename配置命名格式</span></span><br><span class="line">  <span class="keyword">const</span> add = <span class="function">() =&gt;</span> <span class="keyword">import</span>(</span><br><span class="line">    <span class="comment">/* webpackChunkName: &quot;dynamicImport&quot; */</span></span><br><span class="line">    <span class="string">&#x27;./dynamicImport.js&#x27;</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//dynamicImport.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态import使用最多的一个场景是懒加载（比如路由懒加载）</p>
<ul>
<li>封装一个component.js，返回一个component对象；</li>
<li>我们可以在一个按钮点击时，加载这个对象；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ef265174fb2cf73bcd39f09acbdd1fe9.png" alt="image-20220331133000083" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/img_convert/d65bddfda4dda030182bab97c9d68150.png" alt="image-20220331133028694" style="zoom:50%;" /></p>
<blockquote>
<p>如果你用了 Babel ，就需要装上这个插件@babel/plugin-syntax-dynamic-import：<a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import">babel plugin syntax dynamic import</a> 来解析 import() 语法。</p>
</blockquote>
<h5 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h5><p>在声明 import 时，使用下面这些内置指令，可以让 webpack 输出 “resource hint(资源提示)”，来告知浏览器：</p>
<ul>
<li><strong>prefetch</strong>(预获取)：将来某些导航下可能需要的资源。只会缓存资源不会解析</li>
<li><strong>preload</strong>(预加载)：当前导航下可能需要资源。会缓存资源并解析</li>
</ul>
<h6 id="prefetch"><a href="#prefetch" class="headerlink" title="prefetch"></a>prefetch</h6><p>下面这个 prefetch 的简单示例中，有一个 <code>HomePage</code> 组件，其内部渲染一个 <code>LoginButton</code> 组件，然后在点击后按需加载 <code>LoginModal</code> 组件。</p>
<p><strong>LoginButton.js</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">import</span>(<span class="comment">/* webpackPrefetch: true */</span> <span class="string">&#x27;./path/to/LoginModal.js&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这会生成 <code>&lt;link rel=&quot;prefetch&quot; href=&quot;login-modal-chunk.js&quot;&gt;</code> 并追加到页面头部，指示着浏览器在闲置时间预取 <code>login-modal-chunk.js</code> 文件。</p>
<blockquote>
<p>只要父 chunk 完成加载，webpack 就会添加 prefetch hint(预取提示)。</p>
</blockquote>
<h6 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h6><p>与 prefetch 指令相比，preload 指令有许多不同之处：</p>
<ul>
<li>preload chunk 会在父 chunk 加载时，以并行方式开始加载。prefetch chunk 会在父 chunk 加载结束后开始加载。</li>
<li>preload chunk 具有中等优先级，并立即下载。prefetch chunk 在浏览器闲置时下载。</li>
<li>preload chunk 会在父 chunk 中立即请求，用于当下时刻。prefetch chunk 会用于未来的某个时刻。</li>
<li>浏览器支持程度不同。</li>
</ul>
<h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><h5 id="动态导入"><a href="#动态导入" class="headerlink" title="动态导入"></a>动态导入</h5><p>如果你用了 Babel ，就需要装上这个插件@babel/plugin-syntax-dynamic-import：<a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/babel-plugin-syntax-dynamic-import">babel plugin syntax dynamic import</a> 来解析 import() 语法。</p>
<figure class="highlight erlang"><table><tr><td class="code"><pre><span class="line">// .babelrc </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [<span class="string">&quot;syntax-dynamic-import&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="console移除"><a href="#console移除" class="headerlink" title="console移除"></a>console移除</h5><p>babel-plugin-transform-remove-console插件，配置在babel.config.js中，vue-cli5实测可行，vue-cli3,4也可行。（尝试后，谷歌浏览器控制台仅websocket的打印输出未清除，其他打印输出都是清除干净了的）</p>
<p>下载依赖</p>
<p>npm install babel-plugin-transform-remove-console -D<br>or<br>yarn add babel-plugin-transform-remove-console -D</p>
<p>babel.config.js中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const proPlugins = [];</span><br><span class="line">// 判断环境</span><br><span class="line">if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;</span><br><span class="line">  proPlugins.push(&#x27;transform-remove-console&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  plugins: [...proPlugins],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="辅助代码"><a href="#辅助代码" class="headerlink" title="辅助代码"></a>辅助代码</h5><p>Babel 为编译的每个文件都插入了辅助代码，使代码体积过大！默认情况下会被添加到每一个需要它的文件中。可以将这些辅助代码作为一个独立模块，来避免重复引入。</p>
<p>@babel/plugin-transform-runtiome:禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 @babel/plugin-transform-runtiome 并且使所有辅助代码从这里引用</p>
<p>先下载包：</p>
<p>npm i @babel/plugin-transform-runtime -D</p>
<p><img src="https://img-blog.csdnimg.cn/dfbd95540c7441a7b04f45b1f54e1c0a.png" alt="img"></p>
<h4 id="资源模块"><a href="#资源模块" class="headerlink" title="资源模块"></a>资源模块</h4><p>使用 <a href="https://webpack.docschina.org/guides/asset-modules/">webpack 资源模块 </a>(asset module) 代替旧的 assets loader（如 <code>file-loader</code>/<code>url-loader</code>/<code>raw-loader</code> 等），减少 loader 配置数量。</p>
<p>配置方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    rules: [</span><br><span class="line">       &#123;</span><br><span class="line">        test: /\.(png|svg|jpg|jpeg|gif)$/i,</span><br><span class="line">        include: [</span><br><span class="line">          paths.appSrc,</span><br><span class="line">        ],</span><br><span class="line">        type: &#x27;asset/resource&#x27;,</span><br><span class="line">      &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SourceMap"><a href="#SourceMap" class="headerlink" title="SourceMap"></a>SourceMap</h4><p>最佳选择是 <code>eval-cheap-module-source-map</code>详细区分可至 <a href="https://webpack.docschina.org/configuration/devtool/">webpack devtool </a>查看。</p>
<h4 id="css抽离"><a href="#css抽离" class="headerlink" title="css抽离"></a>css抽离</h4><p>mini-css-extract-plugin插件会将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件，并且支持 CSS 和 SourceMaps 的按需加载</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">&quot;mini-css-extract-plugin&quot;</span>);</span><br><span class="line">plugins: [</span><br><span class="line">	<span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      <span class="attr">filename</span>: <span class="string">&quot;css/[name].[hash].css&quot;</span>, <span class="comment">// 定义抽离的入口文件的文件名</span></span><br><span class="line">      <span class="attr">chunkFilename</span>: <span class="string">&quot;css/[name].[hash].css&quot;</span>, <span class="comment">// 定义非入口块文件的名称，如动态导入的文件</span></span><br><span class="line">    &#125;)</span><br><span class="line">],</span><br></pre></td></tr></table></figure>

<h4 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);</span><br><span class="line">+ const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /.(css|less)$/,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;less-loader&quot;],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">+ optimization: &#123;</span><br><span class="line">+   minimizer: [</span><br><span class="line">+     new CssMinimizerPlugin(),</span><br><span class="line">+   ],</span><br><span class="line">+ &#125;,</span><br><span class="line">  plugins: [new MiniCssExtractPlugin()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这将仅在<code>mode: production</code> <code>生产环境</code>开启 CSS 优化</p>
<p>如果还想在<code>开发环境</code>下启用 CSS 优化，<code>optimization.minimize</code> 设置为 <code>true</code></p>
<h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><p>前端将文件打包成 <code>.gz</code> 文件，然后通过 <code>nginx</code> 的配置，让浏览器直接解析 <code>.gz</code> 文件，可以大大提升文件加载的速度，浏览器可以直接解析 <code>.gz</code> 文件并解压。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用gzip压缩(需要配置nginx,可以看出压缩后的文件大小明显变化)</span><br><span class="line">highlighter- PHP</span><br><span class="line"></span><br><span class="line">const CompressionWebpackPlugin = require(&#x27;compression-webpack-plugin&#x27;)</span><br><span class="line">chainWebpack(config) &#123;</span><br><span class="line">  // 生产模式下启用gzip压缩 需要配置nginx支持gzip</span><br><span class="line">    if (process.env.NODE_ENV === &#x27;production&#x27;) &#123;</span><br><span class="line">      config.plugin(&#x27;CompressionWebpackPlugin&#x27;).use(CompressionWebpackPlugin, [</span><br><span class="line">        &#123;</span><br><span class="line">          filename: &#x27;[path][base].gz&#x27;,</span><br><span class="line">          algorithm: &#x27;gzip&#x27;,</span><br><span class="line">          test: new RegExp(&#x27;\\.(js|css)$&#x27;),</span><br><span class="line">          // 只处理大于xx字节 的文件，默认：0</span><br><span class="line">          threshold: 10240,</span><br><span class="line">          // 示例：一个1024b大小的文件，压缩后大小为768b，minRatio : 0.75</span><br><span class="line">          minRatio: 0.8, // 默认: 0.8</span><br><span class="line">          // 是否删除源文件，默认: false</span><br><span class="line">          deleteOriginalAssets: false</span><br><span class="line">        &#125;</span><br><span class="line">      ])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h4><h5 id="terser-webpack-plugin"><a href="#terser-webpack-plugin" class="headerlink" title="terser-webpack-plugin"></a><a href="https://links.jianshu.com/go?to=https://webpack.docschina.org/plugins/terser-webpack-plugin/">terser-webpack-plugin</a></h5><blockquote>
<h2 id="关于-source-maps-说明"><a href="#关于-source-maps-说明" class="headerlink" title="关于 source maps 说明"></a>关于 source maps 说明</h2><p><strong>只对 <a href="https://links.jianshu.com/go?to=https://webpack.docschina.org/configuration/devtool/"><code>devtool</code></a> 选项的 <code>source-map</code>，<code>inline-source-map</code>，<code>hidden-source-map</code> 和 <code>nosources-source-map</code> 有效</strong>。<br> 为何如此？</p>
<ul>
<li><code>eval</code> 会包裹 modules，通过 <code>eval(&quot;string&quot;)</code>，而 minimizer 不会处理字符串。</li>
<li><code>cheap</code> 不存在列信息，minimizer 只产生单行，只会留下一个映射。<br> 使用支持的 <code>devtool</code> 值可以生成 source dmap。</li>
</ul>
</blockquote>
<p>parallel</p>
<p>使用多进程并发运行以提高构建速度。 并发运行的默认数量： <code>os.cpus().length - 1 </code>。并发运行可以显著提高构建速度，因此强烈建议添加此配置。对于实际环境，可以使用<code>is-wsl</code>插件来判断是否支持多进程。d</p>
<h5 id="webpack-2"><a href="#webpack-2" class="headerlink" title="webpack"></a>webpack</h5><p>terser-webpack-plugin和uglifyjs-webpack-plugin(不推荐)</p>
<blockquote>
<p>不再维护 uglify-es ，并且 uglify-js 不支持 ES6 +。</p>
<p>terser 是 uglify-es 的一个分支，主要保留了与 uglify-es 和 uglify-js@3 的 API 和 CLI 兼容性。</p>
</blockquote>
<p>webpack5 自带最新的 <code>terser-webpack-plugin</code>，无需手动安装。</p>
<p><code>terser-webpack-plugin</code> 默认开启了 <code>parallel: true</code> 配置，并发运行的默认数量： <code>os.cpus().length - 1</code> ，使用多进程并发运行压缩以提高构建速度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">optimization</span>: &#123;</span><br><span class="line">    <span class="attr">minimizer</span>: [</span><br><span class="line">      <span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js(\?.*)?$/i</span>,</span><br><span class="line">        parallel: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">extractComments</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">sourceMap</span>: config.build.productionSourceMap,</span><br><span class="line">        <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">          <span class="attr">output</span>: &#123;</span><br><span class="line">            <span class="comment">// 是否输出可读性较强的代码，即会保留空格和制表符，默认为输出，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line">            <span class="attr">beautify</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否保留代码中的注释，默认为保留，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line">            <span class="attr">comments</span>: <span class="literal">false</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">compress</span>: &#123;</span><br><span class="line">            <span class="comment">// 是否在UglifyJS删除没有用到的代码时输出警告信息，默认为输出，可以设置为false关闭这些作用不大的警告</span></span><br><span class="line">            <span class="attr">warnings</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="comment">// 是否删除代码中所有的console语句，默认为不删除，开启后，会删除所有的console语句</span></span><br><span class="line">            <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">drop_debugger</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 是否内嵌虽然已经定义了，但是只用到一次的变量，比如将 var x = 1; y = x, 转换成 y = 5, 默认为不转换，为了达到更好的压缩效果，可以设				置为false</span></span><br><span class="line">            <span class="attr">collapse_vars</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 是否提取出现了多次但是没有定义成变量去引用的静态值，比如将 x = &#x27;xxx&#x27;; y = &#x27;xxx&#x27;  转换成var a = &#x27;xxxx&#x27;; x = a; y = a; 默认为				不转换，为了达到更好的压缩效果，可以设置为false</span></span><br><span class="line">            <span class="attr">reduce_vars</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pure_funcs</span>: [<span class="string">&#x27;console.log&#x27;</span>] <span class="comment">// 移除console</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;),</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vue-cli"><a href="#vue-cli" class="headerlink" title="vue-cli"></a>vue-cli</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">config.optimization.minimize(<span class="literal">true</span>)<span class="comment">// 开启压缩js代码</span></span><br><span class="line">config.optimization.splitChunks(&#123; <span class="comment">// 开启代码分割</span></span><br><span class="line">    <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&quot;terser-webpack-plugin&quot;</span>)</span><br><span class="line"><span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    </span><br><span class="line">    config.optimization.minimize(<span class="literal">true</span>);<span class="comment">// 开启压缩js代码</span></span><br><span class="line">    config.optimization.minimize(<span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">                <span class="attr">terserOptions</span>:&#123;</span><br><span class="line">                  <span class="attr">compress</span>:&#123;</span><br><span class="line">                    <span class="attr">warnings</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">drop_debugger</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">pure_funcs</span>: [<span class="string">&quot;console.log&quot;</span>]</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;));</span><br><span class="line">    config.optimization.splitChunks(&#123;<span class="comment">// 开启代码分割</span></span><br><span class="line">        <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="img压缩"><a href="#img压缩" class="headerlink" title="img压缩"></a>img压缩</h4><p>image-minimizer-webpack-plugin:用来压缩图片的插件 </p>
<p>npm i image-minimizer-webpack-plugin imagemin -D<br>还有剩下包需要下载，有两种模式：</p>
<p>无损压缩<br>npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo -D<br>有损压缩<br>npm install imagemin-gifsicle imagemin-mozjpeg imagemin-pngquant imagemin-svgo -D</p>
<h4 id="配置CDN"><a href="#配置CDN" class="headerlink" title="配置CDN"></a>配置CDN</h4><p>线上使用 cdn ,如何库有问题，项目就会有问题，除非公司有自己的 cdn 库，不过这确实也是一种优化方案，效果也还不错。它的配置也很简单，在 externals 中配置，例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">// 配置 cdn，这里将 vue，vue-router 和 axios 三个包配置成 cdn 引入</span></span><br><span class="line">      <span class="comment">// 其中 Vue，VueRouter 等名称是该库暴露在全局中的变量名</span></span><br><span class="line">      config.externals = &#123;</span><br><span class="line">        <span class="attr">vue</span>: <span class="string">&#x27;Vue&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;vue-router&#x27;</span>: <span class="string">&#x27;VueRouter&#x27;</span>,</span><br><span class="line">        <span class="attr">axios</span>: <span class="string">&#x27;axios&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>public/index.html</code> 模板文件中引入 cdn 地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1.0&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="comment">&lt;!-- 引入 cdn 地址 --&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue/2.5.10/vue.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/vue-router/3.0.1/vue-router.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.18.0/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>我这里使用的是 bootcdn 的地址，需要注意版本问题。</p>
<p>也可以<strong>借助 HtmlWebpackPlugin 插件</strong>来方便插入 cdn 的引入。</p>
<p>使用 cdn 引入的方式虽然能极大改善网页加载速度，但我还是不会用这个功能，项目还不需要非得这样的优化，也怕 cdn 不稳定。</p>
<p>借助 HtmlWebpackPlugin 插件来方便插入 cdn 的引入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生产环境标记</span></span><br><span class="line"><span class="keyword">const</span> IS_PRODUCTION = process.env.NODE_ENV === <span class="string">&quot;production&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">// 生产配置</span></span><br><span class="line"><span class="keyword">const</span> cdn_production = &#123;</span><br><span class="line">  <span class="attr">js</span>: [<span class="string">&quot;/librarys/vue@2.6.11/vue.min.js&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 开发配置</span></span><br><span class="line"><span class="keyword">const</span> cdn_development = &#123;</span><br><span class="line">  <span class="attr">js</span>: [<span class="string">&quot;/librarys/vue@2.6.11/vue.js&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">configureWebpack</span>: &#123;</span><br><span class="line">    <span class="attr">externals</span>: &#123;</span><br><span class="line">      <span class="attr">vue</span>: <span class="string">&quot;Vue&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.plugin(<span class="string">&quot;html&quot;</span>).tap(<span class="function"><span class="params">args</span> =&gt;</span> &#123;</span><br><span class="line">      args[<span class="number">0</span>].cdn = IS_PRODUCTION ? cdn_production : cdn_development;</span><br><span class="line">      <span class="keyword">return</span> args;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>index.html中添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;% for (var i in htmlWebpackPlugin.options.cdn&amp;&amp;htmlWebpackPlugin.options.cdn.js) &#123; %&gt;</span><br><span class="line">  &lt;script src=&quot;&lt;%= htmlWebpackPlugin.options.cdn.js[i] %&gt;&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<h4 id="插件按需加载"><a href="#插件按需加载" class="headerlink" title="插件按需加载"></a>插件按需加载</h4><p><strong>1. lodash</strong></p>
<p>类似 <code>import &#123; throttle &#125; from &#39;lodash&#39;</code> 就属于有副作用的引用，会将整个 lodash 文件进行打包。</p>
<p>优化方式是使用 <code>import &#123; throttle &#125; from &#39;lodash-es&#39;</code> 代替 <code>import &#123; throttle &#125; from &#39;lodash&#39;</code>， <a href="https://www.npmjs.com/package/lodash-es">lodash-es </a>将 <a href="https://lodash.com/">Lodash </a>库导出为 <a href="http://www.ecma-international.org/ecma-262/6.0/">ES </a>模块，支持基于 ES modules 的 tree shaking，实现按需引入。</p>
<p><strong>2. ant-design</strong></p>
<p><a href="https://ant.design/docs/react/getting-started-cn">ant-design </a>默认支持基于 ES modules 的 tree shaking，对于 js 部分，直接引入 <code>import &#123; Button &#125; from &#39;antd&#39;</code> 就会有按需加载的效果。</p>
<p>假如项目中仅引入少部分组件，<code>import &#123; Button &#125; from &#39;antd&#39;</code> 也属于有副作用，webpack不能把其他组件进行tree-shaking。这时可以<strong>缩小引用范围</strong>，将引入方式修改为 <code>import &#123; Button &#125; from &#39;antd/lib/button&#39;</code> 来进一步优化。</p>
<h4 id="未引用代码移除"><a href="#未引用代码移除" class="headerlink" title="未引用代码移除"></a>未引用代码移除</h4><h5 id="Tree-Shaking-已经配置"><a href="#Tree-Shaking-已经配置" class="headerlink" title="Tree Shaking(已经配置)"></a>Tree Shaking(已经配置)</h5><p>tree shaking<code>是一个术语，用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块语法的 静态结构 特性，例如</code>import<code>和</code>export</p>
<blockquote>
<p><strong>Tree Shaking 只支持 ESM 的引入方式，不支持 Common JS 的引入方式。</strong></p>
<ul>
<li>ESM: export + import</li>
<li>Common JS: module.exports + require</li>
</ul>
</blockquote>
<p>sideEffects 有三种情况</p>
<ul>
<li><p>sideEffects:true 所有文件都有副作用，全都不可 tree-shaking</p>
</li>
<li><p>sideEffects:false 有这些文件有副作用，所有其他文件都可以 tree-shaking，但会保留这些文件</p>
</li>
<li><p>sideEffects:[] 部分 tree-shaking , 除了数组外都 tree-shaking</p>
</li>
</ul>
<p>“side effect(副作用)” 的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。</p>
<p>如果你的代码确实有一些副作用，可以改为提供一个数组：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;your-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: [<span class="string">&quot;./src/some-side-effectful-file.js&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有导入文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 <code>css-loader</code> 并 import 一个 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;your-project&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;sideEffects&quot;</span>: [<span class="string">&quot;./src/some-side-effectful-file.js&quot;</span>, <span class="string">&quot;*.css&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"> rules: [</span><br><span class="line">     &#123;</span><br><span class="line">         test: /\.css$/i,</span><br><span class="line">         use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>],</span><br><span class="line">         sideEffects: <span class="literal">true</span></span><br><span class="line">     &#125;</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>

<h5 id="IgnorePlugin"><a href="#IgnorePlugin" class="headerlink" title="IgnorePlugin"></a>IgnorePlugin</h5><ol>
<li>这是webpack内置插件</li>
<li>这个插件的作用是：忽略第三方包指定目录，让这些指定目录不要被打包进去</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//虽然我设置了语言为中文，但是在打包的时候，是会将所有语言都打包进去的。这样就导致包很大，打包速度又慢</span><br><span class="line">plugins:[</span><br><span class="line">	new Webpack.IgnorePlugin(/\.\/locale/,/moment/),//moment这个库中，如果引用了./locale/目录的内容，就忽略掉，不会打包进去</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="css-1"><a href="#css-1" class="headerlink" title="css"></a>css</h5><p>打包时把没有用的 CSS 代码摇走，可以大幅减少打包后的 CSS 文件大小。使用 <a href="https://github.com/FullHuman/purgecss/tree/main/packages/purgecss-webpack-plugin">purgecss-webpack-plugin </a>对 CSS Tree Shaking。</p>
<h3 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h3><h4 id="autoprefixer兼容css"><a href="#autoprefixer兼容css" class="headerlink" title="autoprefixer兼容css"></a>autoprefixer兼容css</h4><p>webpak 引入autoprefixer，自动加上各种前缀让不同的浏览器得以支持</p>
<h3 id="tip"><a href="#tip" class="headerlink" title="tip"></a>tip</h3><p>报错hardsource:a3a09f18: Could not freeze ./node_modules/mini-css-extract-plugin/dist/loader.js</p>
<p><a href="https://blog.csdn.net/weixin_43840202/article/details/124006937">https://blog.csdn.net/weixin_43840202/article/details/124006937</a></p>
<h2 id="babel-1"><a href="#babel-1" class="headerlink" title="babel"></a>babel</h2><p><a href="https://zhuanlan.zhihu.com/p/498461706">https://zhuanlan.zhihu.com/p/498461706</a></p>
<p><a href="https://juejin.cn/post/7051555571451265038#heading-10">https://juejin.cn/post/7051555571451265038#heading-10</a></p>
<p><a href="https://mp.weixin.qq.com/s/qT0y0JlDP7bxESRKip-f5w">https://mp.weixin.qq.com/s/qT0y0JlDP7bxESRKip-f5w</a></p>
<p><strong>Babel 是一个 JavaScript 编译器</strong></p>
<p>Babel 是一个工具链，主要用于将采用 <strong>ECMAScript 2015+</strong> 语法编写的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。</p>
<p>简单来说就是把 JavaScript 中 es2015+ 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。比如在代码中使用了 ES6 的箭头函数，但是这种写法会在 IE 浏览器中报错，为了让代码能在IE中运行，就需要将代码编译成IE支持的写法，这就是babel的主要工作。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fcaf4480c3284c3eac918a7a609840de~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img"></p>
<p>babel 在转译的时候，会将源代码分成 syntax 和 api 两部分来处理：</p>
<ul>
<li>syntax：类似于展开对象、optional chain、let、const 等语法</li>
<li>api：类似于 [1,2,3].includes 等函数、方法</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>babel的主要工作流程分为三个阶段，解析(parse)，转换(transform)，生成(generate)</p>
<p>如下图所示:</p>
<p><img src="https://pic3.zhimg.com/80/v2-a3a077624a45f1a521d9025c1a3908ee_720w.webp" alt="img"></p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a><strong>解析</strong></h4><p>通过 <code>@babel/parser</code> 把源代码字符串转成抽象语法树(AST)，在解析过程中主要是两个阶段：<strong>词法分析</strong>和<strong>语法分析</strong></p>
<h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a><strong>词法分析</strong></h5><p>词法分析阶段把字符串形式的代码解析成一个个具有实际意义的语法单元组成的数据，这种数据被称之为<strong>令牌</strong>（tokens）流。</p>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a><strong>语法分析</strong></h5><p>语法解析器把 Tokens 转换为抽象语法树 AST</p>
<p>被解析语法当中具备实际意义的最小单元，举个例子：’2008年奥运会在北京举行’，这句话不论词性主谓等关系，会把这句话拆分成： 2018年、奥运会、在、北京、举行，这就是分词，把整句话拆分成有意义的最小颗粒，这些最小颗粒不能再继续拆分，否则会失去表达意义。</p>
<p>JavaScript 中常见的语法单元如下：</p>
<ul>
<li><strong>空白</strong>：JS中连续的空格、换行、缩进等这些如果不在字符串里，就没有任何实际逻辑意义，所以把连续的空白符直接组合在一起作为一个语法单元。</li>
<li><strong>注释</strong>：行注释或块注释，虽然对于人类来说有意义，但是对于计算机来说知道这是个“注释”就行了，并不关心内容，所以直接作为一个不可再拆的语法单元</li>
<li><strong>字符串</strong>：对于机器而言，字符串的内容只是会参与计算或展示，里面再细分的内容也是没必要分析的</li>
<li><strong>数字</strong>：JS语言里就有16、10、8进制以及科学表达法等数字表达语法，数字也是个具备含义的最小单元</li>
<li><strong>标识符</strong>：没有被引号扩起来的连续字符，可包含字母、_、$、及数字（数字不能作为开头）。标识符可能代表一个变量，或者true、false这种内置常量、也可能是if、return、function这种关键字</li>
<li><strong>运算符</strong>：+、-、*、/、&gt;、&lt;等等</li>
<li><strong>括号</strong>：(…)可能表示运算优先级、也可能表示函数调用，分词阶段并不关注是哪种语义，只把“(”或“)”当做一种基本语法单元</li>
<li>还有其他：如中括号、大括号、分号、冒号、点等等不再一一列举</li>
</ul>
<h5 id="什么是-AST（Abstract-Syntax-Tree）"><a href="#什么是-AST（Abstract-Syntax-Tree）" class="headerlink" title="什么是 AST（Abstract Syntax Tree）?"></a>什么是 AST（Abstract Syntax Tree）?</h5><p>抽象语法树 ，它是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>举例：</p>
<p>console.log(‘你好，babel’)解析成 AST 后的 json格式如下（转换可通过<a href="https://link.zhihu.com/?target=https://astexplorer.net/%23/KJ8AjD6maa%E8%BF%9B%E8%A1%8C%E5%9C%A8%E7%BA%BF%E8%BD%AC%E6%8D%A2%EF%BC%89">https://astexplorer.net/#/KJ8AjD6maa进行在线转换）</a>:</p>
<p><img src="https://pic3.zhimg.com/80/v2-b8003e85738e6f268651401939a825d2_720w.webp" alt="img"></p>
<p><img src="https://pic1.zhimg.com/80/v2-a7de0caef59a84518ef334f6752b16a0_720w.webp" alt="img"></p>
<p>类似于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;type&quot;: &quot;Program&quot;,</span><br><span class="line">    &quot;start&quot;: 0,</span><br><span class="line">    &quot;end&quot;: 23,</span><br><span class="line">    &quot;body&quot;: [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于这样的结构叫做节点，一个 AST 是由单个或者多个这样的节点构成的，节点内部还可以有子节点，构成一棵语法树。详细请见：<a href="https://link.zhihu.com/?target=https://juejin.cn/post/6844904035271573511">https://juejin.cn/post/6844904035271573511</a></p>
<h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><p>通过<code>@babel/traverse</code>遍历抽象语法树(AST),并调用Babel配置文件中的插件,对抽象语法树(AST)进行增删改</p>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>通过<code>@babel/generator</code>把转换后的抽象语法书(AST)生成目标代码</p>
<h3 id="babel插件"><a href="#babel插件" class="headerlink" title="babel插件"></a>babel插件</h3><h4 id="babel-core"><a href="#babel-core" class="headerlink" title="babel/core"></a>babel/core</h4><p>是 babel的核心，主要作用就是根据我们的配置文件转换代码，配置文件一般是.babelrc(静态文件)或 babel.config.js(可编程)，主要作用如下：</p>
<ul>
<li>加载和处理配置(config)</li>
<li>加载插件</li>
<li>调用 <code>Parser</code> 进行语法解析，生成 <code>AST</code></li>
<li>调用 <code>Traverser</code> 遍历AST，并使用<code>访问者模式</code>应用’插件’对 AST 进行转换</li>
<li>生成代码，包括SourceMap转换和源代码生成</li>
</ul>
<p><strong>核心周边</strong></p>
<ul>
<li><p><strong>Parser(</strong> <code>@babel/parser</code> <strong>)</strong> ： 将源代码解析为 AST 。</p>
</li>
<li><p><strong>Traverser(</strong> <code>@babel/traverse</code> <strong>)</strong> ： 对 AST 进行遍历，<code>转换插件</code>会通过它获取感兴趣的AST节点，对节点继续操作</p>
</li>
<li><p><strong>Generator(</strong> <code>@babel/generator</code> <strong>)</strong> ： 将 AST 转换为源代码</p>
<ul>
<li><p>babel-loader: 负责 es6 语法转化</p>
</li>
<li><p>babel-preset-env: 包含 es6、7 等版本的语法转化<strong>规则</strong></p>
</li>
</ul>
</li>
</ul>
<p><strong>babel的插件分类</strong></p>
<ul>
<li><p>语法插件：</p>
<p>语法插件仅允许 babel 解析语法，不做转换操作；当添加语法插件后，使得babel能够解析更多的语法</p>
<p>例如：当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如 func<code>(param1, param2,)</code> 就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。</p>
<p>但最近的 JS 提案中已经允许了这种新的写法(让代码 diff 更加清晰)。为了避免 babel 报错，就需要增加语法插件 <code>babel-plugin-syntax-trailing-function-commas</code></p>
</li>
<li><p>转译插件：</p>
<p>当添加转译插件后，会将源代码进行转译输出。</p>
<p>例如：箭头函数 <code>(a) =&gt; a</code> 就会转化为 <code>function (a) &#123;return a&#125;</code>。完成这个工作的插件叫做 <code>babel-plugin-transform-es2015-arrow-functions</code>。</p>
</li>
</ul>
<h4 id="babel-loader-1"><a href="#babel-loader-1" class="headerlink" title="babel-loader"></a>babel-loader</h4><p>负责 es6 语法转化</p>
<h4 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel/preset-env"></a>babel/preset-env</h4><p>包含 es6、7 等版本的语法转化<strong>规则</strong></p>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h4><p>babel只负责语法转换，比如将ES6的语法转换成ES5。但如果有些对象、方法，浏览器本身不支持，比如：</p>
<ol>
<li>全局对象：Promise、WeakMap 等。</li>
<li>全局静态函数：Array.from、Object.assign 等。</li>
<li>实例方法：比如 Array.prototype.includes 等。</li>
</ol>
<p>此时，需要引入@babel/polyfill来模拟实现这些对象、方法。需要安装在生产依赖中</p>
<p>主要缺点：</p>
<ol>
<li>使用 babel-polufill 导致打出来的包体积比较大，因为 babel-polyfill 是一个整体，把所有方法都会加到原型链上。比如使用了 Array.from，但它会把 Object.defineProperty也给加上，属于一种浪费，要解决这个问题，可以通过单独使用 core-js 的某个类库解决，core-js 是分开的</li>
<li>babel-polyfill 会污染全局变量，给很多的原型链上作出修改，所以会比较倾向于使用 babel-plugin-transform-runtime</li>
</ol>
<p>注意：如果代码中使用了较高版本的 js实例方法， 比如 [1,2,3].includes(1),此时还是需要使用 polyfill</p>
<h4 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h4><p>提供各种 helper 函数</p>
<h4 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="headerlink" title="babel-plugin-transform-runtime"></a>babel-plugin-transform-runtime</h4><p><a href="https://blog.windstone.cc/es6/babel/@babel/plugin-transform-runtime.html">https://blog.windstone.cc/es6/babel/@babel/plugin-transform-runtime.html</a></p>
<p>该插件会开启对 Babel 注入的<code>helper code</code>（<code>helper</code>可译为辅助函数）的复用，以节省代码体积。</p>
<p>Babel 使用了一些很小的<code>helpers</code>作为通用函数比如<code>_extend</code>。默认情况下，这些<code>helpers</code>会被添加到需要的每一个文件里。这种代码重复有时是不需要的，尤其是你的应用分散在多个文件里。这也是<code>@babel/plugin-transform-runtime</code>插件出现的原因：所有的<code>helpers</code>将引用<code>@babel/runtime</code>模块以避免在编译输出文件里的代码重复。<code>@babel/runtime</code>将编译到构建输出文件里。</p>
<p>@babel/runtime: 提供各种 helper 函数</p>
<p>@babel/plugin-transform-runtime: 自动引入 helper 函数</p>
<h3 id="预设"><a href="#预设" class="headerlink" title="预设"></a>预设</h3><p>插件只对单个功能进行转换，当配置插件比较多时，就可以封装成预设（presets）以此来简化插件的使用，预设简单说就是一组原先设定好的插件，<strong>是一组插件的集合</strong>，比如 @babel/preset-react 包含以下插件：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=https://babel.docschina.org/docs/en/babel-plugin-syntax-jsx">@babel/plugin-syntax-jsx</a></li>
<li><a href="https://link.zhihu.com/?target=https://babel.docschina.org/docs/en/babel-plugin-transform-react-jsx">@babel/plugin-transform-react-jsx</a></li>
<li><a href="https://link.zhihu.com/?target=https://babel.docschina.org/docs/en/babel-plugin-transform-react-display-name">@babel/plugin-transform-react-display-name</a></li>
</ul>
<p>比如 es2015 是一套规范，包含很多转译插件。如果每次要开发者一个个添加并安装，配置文件很长不说，<code>npm install</code> 的时间也会很长，为了解决这个问题，babel 还提供了一组插件的集合。因为常用，所以不必重复定义 &amp; 安装。</p>
<h4 id="常见的preset-分为以下几种"><a href="#常见的preset-分为以下几种" class="headerlink" title="常见的preset 分为以下几种"></a>常见的preset 分为以下几种</h4><p>官网常推荐的 详见：<a href="https://link.zhihu.com/?target=https://babel.docschina.org/docs/en/babel-preset-env/">https://babel.docschina.org/docs/en/babel-preset-env/</a></p>
<p>@babel/preset-env。主要可以根据配置的目标浏览器或者运行环境来自动将ES2015+的代码转换为es5。</p>
<p>@babel/preset-react 。react框架需要的</p>
<p>@babel/preset-flow flow需要的。Flow 是一个静态类型检测工具，进行类型检查，类似于ts</p>
<p>@babel/preset-typescript typescript。需要的</p>
<p>执行顺序原则如下：</p>
<ul>
<li>Plugin 会运行在 Preset 之前。</li>
<li>Plugin 会从前到后顺序执行。</li>
<li>Preset 的顺序则从后向前。</li>
</ul>
<p>preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 <code>[&#39;es2015&#39;, &#39;stage-0&#39;]</code>。这样必须先执行 <code>stage-0</code> 才能确保 babel 不报错。因为低一级的 stage 会包含所有高级 stage 的内容</p>
<h4 id="babel-preset-env-1"><a href="#babel-preset-env-1" class="headerlink" title="@babel/preset-env"></a>@babel/preset-env</h4><p>可以根据配置的目标浏览器或者运行环境来自动将 ES5+的代码转换为 ES5</p>
<h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2><p>ESM:<strong>基于浏览器 ES 模块的构建工具</strong></p>
<p><code>browserify</code>、<code>webpack</code>、<code>rollup</code>、<code>parcel</code>这些工具的思想都是递归循环依赖，然后组装成依赖树，优化完依赖树后生成代码。<br>但是这样做的缺点就是慢，需要遍历完所有依赖，即使 <code>parcel</code> 利用了多核，<code>webpack</code> 也支持多线程，在打包大型项目的时候依然慢可能会用上几分钟，存在性能瓶颈。所以基于浏览器原生 <code>ESM</code> 的运行时打包工具出现：</p>
<img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KOX4hTlQXTbleCqnlwT3QxxE7A7GaFjOJ9bGmRejeprrVZd4jHaxNg7bKGY1RzegqGjylYtd1bgHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom: 50%;" />



<img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KOX4hTlQXTbleCqnlwT3QxxwicEgiabd0Lyq1DRK3MY3f4HBPeFUUW8UfkYz1ndLs1qUC5hGIeWibJiaw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:50%;" />

<p>仅打包屏幕中用到的资源，而不用打包整个项目，开发时的体验相比于 <code>bundle</code>类的工具只能用极速来形容。（实际生产环境打包依然会构建依赖方式打包）</p>
<h3 id="snowpack-和-vite"><a href="#snowpack-和-vite" class="headerlink" title="snowpack 和 vite"></a><strong>snowpack 和 vite</strong></h3><p>因为 <code>snowpack</code> 和 <code>vite</code> 比较类似，都是<code>bundleless</code>所以一起拿来说，区别可以看一下 vite 和 snowpack 区别，这里就不赘述了。</p>
<p><strong><code>bundleless</code>类运行时打包工具的启动速度是毫秒级的，因为不需要打包任何内容，只需要起两个<code>server</code>，一个用于页面加载，另一个用于<code>HMR</code>的<code>WebSocket</code>，当浏览器发出原生的<code>ES module</code>请求，<code>server</code>收到请求只需编译当前文件后返回给浏览器不需要管依赖。</strong></p>
<p><code>bundleless</code>工具在<strong>生产环境</strong>打包的时候依然<code>bundle</code>构建所以依赖视图的方式，vite 是利用 <code>rollup</code> 打包生产环境的 js 的。</p>
<p>原理拿 <code>vite</code> 举例：</p>
<p><code>vite</code>在启动服务器后，会预先以所有 html 为入口，使用 <code>esbuild</code> 编译一遍，把所有的 <code>node_modules</code> 下的依赖编译并缓存起来，例如<code>vue</code>缓存为单个文件。</p>
<p>当打开在浏览器中输入链接，渲染<code>index.html</code>文件的时候，利用浏览器自带的<code>ES module</code>来请求文件。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KOX4hTlQXTbleCqnlwT3QxxrDGiahKicLRZibLobH3LGnAJQvXcCeYqtwzaD64kt1stl5IibxMyEGibIIQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>vite 收到一个<code>src/main.js</code>的 <code>http</code> 文件请求，使用<code>esbuild</code>开始编译<code>main.js</code>，这里不进行<code>main.js</code>里面的依赖编译。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KOX4hTlQXTbleCqnlwT3Qxxxve0C3nXWCUXGIwPdjaHRf3d97yosF7qQKzWHBlFgxxia6daSapT0Rw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>浏览器获取到并编译<code>main.js</code>后，再次发出 2 个请求，一个是 <code>vue</code> 的请求，因为前面已经说了 vue 被预先缓存下来，直接返回缓存给浏览器，另一个是<code>App.vue</code>文件，这个需要<code>@vitejs/plugin-vue</code>来编译，编译完成后返回结果给浏览器（<code>@vitejs/plugin-vue</code>会在脚手架创建模板的时候自动配置）。</p>
<p>因为是基于浏览器的<code>ES module</code>，所以编译过程中需要把一些 <code>CommonJs</code>、<code>UMD</code> 的模块都转成 <code>ESM</code>。</p>
<p><code>Vite</code> 同时利用 <code>HTTP</code> 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 <code>304 Not Modified</code> 进行协商缓存，而依赖模块请求则会通过 <code>Cache-Control: max-age=31536000,immutable</code> 进行强缓存，因此一旦被缓存它们将不需要再次请求，即使缓存失效只要服务没有被杀死，编译结果依然保存在程序内存中也会很快返回。</p>
<p>上面多次提到了<code>esbuild</code>，<code>esbuild</code>使用 <code>go</code> 语言编写，所以在 <code>i/o</code> 和运算运行速度上比解释性语言 <code>NodeJs</code> 快得多，<code>esbuild</code> 号称速度是 <code>node</code> 写的其他工具的 10~100 倍。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RQueXibgo0KOX4hTlQXTbleCqnlwT3QxxmicFUNGNHhqjbRswiagtkGumy3w2rrZ48Mh3jDVX1WzaHhm4tUty8wkQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><code>ES module</code> 依赖运行时编译的概念 + <code>esbuild</code> + 缓存 让 <code>vite</code> 的速度远远甩开其他构建工具。</p>
<h2 id="vite"><a href="#vite" class="headerlink" title="vite"></a>vite</h2><p><a href="https://juejin.cn/post/7004784113706090526">https://juejin.cn/post/7004784113706090526</a></p>
<p>vite配置多入口，多页面应用：<a href="https://juejin.cn/post/6985500915969032222">https://juejin.cn/post/6985500915969032222</a></p>
<ul>
<li>@vitejs/plugin-vue，通过@vitejs/plugin-vue这个插件来支持Vue</li>
</ul>
<h1 id="微前端"><a href="#微前端" class="headerlink" title="微前端"></a>微前端</h1><h2 id="single-spa"><a href="#single-spa" class="headerlink" title="single-spa"></a>single-spa</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Single-spa 从现代框架组件生命周期中获得灵感，将生命周期应用于整个应用程序。 它脱胎于 Canopy 使用 React + React-router 替换 AngularJS + ui-router 的思考，避免应用程序被束缚。</p>
<p>Single-spa 包括以下内容:</p>
<ol>
<li><p><a href="https://zh-hans.single-spa.js.org/docs/building-applications">Applications</a>，每个应用程序本身就是一个完整的 SPA (某种程度上)。 每个应用程序都可以<strong>响应 url 路由事件</strong>，并且必须知道如何<strong>从 DOM 中初始化、挂载和卸载自己</strong>。 传统 SPA 应用程序和 Single SPA 应用程序的主要区别在于，它们必须能够与其他应用程序共存，而且它们<strong>没有各自的 html 页面</strong>。</p>
<p>例如，React 或 Angular spa 就是应用程序。 当激活时，它们监听 url 路由事件并将内容放在 DOM上。 当它们处于非活动状态时，它们不侦听 url 路由事件，并且完全从 DOM 中删除。</p>
</li>
<li><p>一个 <a href="https://zh-hans.single-spa.js.org/docs/configuration">single-spa-config</a>配置, 这是html页面和向Single SPA注册应用程序的JavaScript。每个应用程序都注册了三件东西</p>
<ul>
<li>A name</li>
<li>A function (加载应用程序的代码)</li>
<li>A function (确定应用程序何时处于活动状态/非活动状态)</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>主题</th>
<th>应用程序</th>
<th>沙箱</th>
<th>公共模块</th>
</tr>
</thead>
<tbody><tr>
<td>路由</td>
<td>有多个路由</td>
<td>无路由</td>
<td>无路由</td>
</tr>
<tr>
<td>API</td>
<td>声明API</td>
<td>必要的API</td>
<td>没有single-spa API</td>
</tr>
<tr>
<td>渲染UI</td>
<td>渲染UI</td>
<td>渲染UI</td>
<td>不直接渲染UI</td>
</tr>
<tr>
<td>生命周期</td>
<td>single-spa管理生命周期</td>
<td>自定义管理生命周期</td>
<td>没有生命周期</td>
</tr>
<tr>
<td>什么时候使用</td>
<td>核心构建模块</td>
<td>仅在多个框架中需要</td>
<td>共享通用逻辑时使用</td>
</tr>
</tbody></table>
<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="创建类型"><a href="#创建类型" class="headerlink" title="创建类型"></a>创建类型</h4><p><a href="https://zh-hans.single-spa.js.org/docs/separating-applications">https://zh-hans.single-spa.js.org/docs/separating-applications</a></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ol>
<li>创建一个 html 文件:</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;single-spa-config.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个single-spa-config。查看<a href="https://zh-hans.single-spa.js.org/docs/configuration">文档</a>以获取更多详细信息。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//main.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> singleSpa <span class="keyword">from</span> <span class="string">&#x27;single-spa&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;app1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* loading 是一个返回 promise 的函数，用于 加载/解析 应用代码。</span></span><br><span class="line"><span class="comment"> * 它的目的是为延迟加载提供便利 —— single-spa 只有在需要时才会下载应用程序的代码。</span></span><br><span class="line"><span class="comment"> * 在这个示例中，在 webpack 中支持 import ()并返回 Promise，但是 single-spa 可以使用任何返回 Promise 的加载函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./app1/app1.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Single-spa 配置顶级路由，以确定哪个应用程序对于指定 url 是活动的。</span></span><br><span class="line"><span class="comment"> * 您可以以任何您喜欢的方式实现此路由。</span></span><br><span class="line"><span class="comment"> * 一种有用的约定是在url前面加上活动应用程序的名称，以使顶层路由保持简单。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> activeWhen = <span class="string">&#x27;/app1&#x27;</span>;</span><br><span class="line"></span><br><span class="line">singleSpa.registerApplication(&#123; name, app, activeWhen &#125;);</span><br><span class="line"></span><br><span class="line">singleSpa.start();</span><br></pre></td></tr></table></figure>

<ol>
<li>创建一个应用程序。查看<a href="https://zh-hans.single-spa.js.org/docs/building-applications">文档</a>以获取更多详细信息。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//app1.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> domEl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">        .resolve()</span><br><span class="line">        .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            domEl = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">            domEl.id = <span class="string">&#x27;app1&#x27;</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(domEl);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">        .resolve()</span><br><span class="line">        .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 在这里通常使用框架将ui组件挂载到dom。请参阅https://single-spa.js.org/docs/ecosystem.html。</span></span><br><span class="line">            domEl.textContent = <span class="string">&#x27;App 1 is mounted!&#x27;</span></span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">        .resolve()</span><br><span class="line">        .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 在这里通常是通知框架把ui组件从dom中卸载。参见https://single-spa.js.org/docs/ecosystem.html</span></span><br><span class="line">            domEl.textContent = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注册应用的生命周期"><a href="#注册应用的生命周期" class="headerlink" title="注册应用的生命周期"></a>注册应用的生命周期</h3><p>在一个 single-spa 页面，注册的应用会经过下载(loaded)、初始化(initialized)、被挂载(mounted)、卸载(unmounted)和unloaded（被移除）等过程。single-spa会通过“生命周期”为这些过程提供钩子函数。</p>
<p>生命周期函数是 single-spa 在注册的应用上调用的一系列函数，single-spa 会在各应用的主文件中，查找对应的函数名并进行调用。</p>
<p>注:</p>
<ul>
<li><code>bootstrap</code>, <code>mount</code>, and <code>unmount</code>的实现是必须的，<code>unload</code>则是可选的</li>
<li>生命周期函数必须有返回值，可以是Promise或者<code>async</code>函数</li>
<li>如果导出的是函数数组而不是单个函数，这些函数会被依次调用，对于promise函数，会等到resolve之后再调用下一个函数</li>
<li>如果 single-spa <a href="https://zh-hans.single-spa.js.org/docs/api#start">未启动</a>，各个应用会被下载，但不会被初始化、挂载或卸载。</li>
</ul>
<blockquote>
<p><strong>注</strong></p>
<p>在<a href="https://zh-hans.single-spa.js.org/docs/ecosystem">single-spa 生态</a>中有各个主流框架对于生命周期函数的实现，这些文档有助于理解这些helper执行的操作，也有助于你自己实现生命周期函数。</p>
</blockquote>
<h4 id="生命周期参数"><a href="#生命周期参数" class="headerlink" title="生命周期参数"></a>生命周期参数</h4><p>生命周期函数使用”props” 传参，这个对象包含single-spa相关信息和其他的自定义属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;</span><br><span class="line">    name,        <span class="comment">// 应用名称</span></span><br><span class="line">    singleSpa,   <span class="comment">// singleSpa实例</span></span><br><span class="line">    mountParcel, <span class="comment">// 手动挂载的函数</span></span><br><span class="line">    customProps  <span class="comment">// 自定义属性</span></span><br><span class="line">  &#125; = props;     <span class="comment">// Props 会传给每个生命周期函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内置参数"><a href="#内置参数" class="headerlink" title="内置参数"></a>内置参数</h4><p>每个生命周期函数的入参都会保证有如下参数：</p>
<ul>
<li><code>name</code>: 注册到 single-spa 的应用名称</li>
<li><code>singleSpa</code>: 对singleSpa 实例的引用, 方便各应用和类库调用singleSpa提供的API时不再导入它。 可以解决有多个webpack配置文件构建时无法保证只引用一个singleSpa实例的问题。</li>
<li><code>mountParcel</code>: <a href="https://zh-hans.single-spa.js.org/docs/parcels-api.html#mountparcel">mountParcel 函数</a>.</li>
</ul>
<h4 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h4><p>除single-spa提供的内置参数外，还可以指定自定义参数，在调用各个生命周期函数时传入。指定方法是在调用<code>registerApplication</code>时，传入第4个参数。</p>
<p>root.application.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">singleSpa.registerApplication(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">  activeWhen,</span><br><span class="line">  app,</span><br><span class="line">  <span class="attr">customProps</span>: &#123; <span class="attr">authToken</span>: <span class="string">&quot;d83jD63UdZ6RS6f70D0&quot;</span> &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">singleSpa.registerApplication(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">  activeWhen,</span><br><span class="line">  app,</span><br><span class="line">  <span class="attr">customProps</span>: <span class="function">(<span class="params">name, location</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">authToken</span>: <span class="string">&quot;d83jD63UdZ6RS6f70D0&quot;</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>app1.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(props.authToken); <span class="comment">// 可以在 app1 中获取到authToken参数</span></span><br><span class="line">  <span class="keyword">return</span> reactLifecycles.mount(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>可能使用到的场景：</p>
<ul>
<li>各个应用共享一个公共的 access token</li>
<li>下发初始化信息，如渲染目标</li>
<li>传递对事件总线（event bus）的引用，方便各应用之间进行通信</li>
</ul>
<p>注意如果没有提供自定义参数，则<code>props.customProps</code>默认会返回一个空对象。</p>
<h4 id="下载-load"><a href="#下载-load" class="headerlink" title="下载(load)"></a>下载(load)</h4><p>注册的应用会被懒加载，这指的是该应用的代码会从服务器端下载并执行。注册的应用在<a href="https://zh-hans.single-spa.js.org/docs/configuration#activity-function">activity function</a> 第一次返回真值(truthy value)时，下载动作会发生。在下载过程中，建议尽可能执行少的操作，可以在<code>bootstrap</code>生命周期之后再执行各项操作。若确实有在下载时需要执行的操作，可将代码放入子应用入口文件中，但要放在各导出函数的外部。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;The registered application has been loaded!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">props</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>这个生命周期函数会在应用<strong>第一次</strong>挂载前<strong>执行一次</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">    .resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// One-time initialization code goes here</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;bootstrapped!&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h4><p>每当应用的<a href="https://zh-hans.single-spa.js.org/docs/configuration#activity-function">activity function</a>返回真值，但该应用处于未挂载状态时，挂载的生命周期函数就会被调用。调用时，函数会根据URL来确定当前被激活的路由，创建DOM元素、监听DOM事件等以向用户呈现渲染的内容。任何子路由的改变（如<code>hashchange</code>或<code>popstate</code>等）不会再次触发<code>mount</code>，需要各应用自行处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">    .resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do framework UI rendering here</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;mounted!&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h4><p>每当应用的<a href="https://zh-hans.single-spa.js.org/docs/configuration#activity-function">activity function</a>返回假值，但该应用已挂载时，卸载的生命周期函数就会被调用。卸载函数被调用时，会清理在挂载应用时被创建的DOM元素、事件监听、内存、全局变量和消息订阅等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">    .resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do framework UI unrendering here</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;unmounted!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h4><p>“移除”生命周期函数的实现是可选的，它只有在<a href="https://zh-hans.single-spa.js.org/docs/api#unloadapplication">unloadApplication</a>被调用时才会触发。如果一个已注册的应用没有实现这个生命周期函数，则假设这个应用无需被移除。</p>
<p>移除的目的是各应用在移除之前执行部分逻辑，一旦应用被移除，它的状态将会变成NOT_LOADED，下次激活时会被重新初始化。</p>
<p>移除函数的设计动机是对所有注册的应用实现“热下载”，不过在其他场景中也非常有用，比如想要重新初始化一个应用，且在重新初始化之前执行一些逻辑操作时。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unload</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span></span><br><span class="line">    .resolve()</span><br><span class="line">    .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Hot-reloading implementation goes here</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;unloaded!&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h4><p>默认情况下，所有注册的应用遵循<a href="https://zh-hans.single-spa.js.org/docs/api#setbootstrapmaxtime">全局超时配置</a>，但对于每个应用，也可以通过在主入口文件导出一个<code>timeouts</code>对象来重新定义超时时间。如：</p>
<p>app-1.main-entry.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bootstrap</span>(<span class="params">props</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mount</span>(<span class="params">props</span>) </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">unmount</span>(<span class="params">props</span>) </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> timeouts = &#123;</span><br><span class="line">  <span class="attr">bootstrap</span>: &#123;</span><br><span class="line">    <span class="attr">millis</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="attr">dieOnTimeout</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">warningMillis</span>: <span class="number">2500</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mount</span>: &#123;</span><br><span class="line">    <span class="attr">millis</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="attr">dieOnTimeout</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">warningMillis</span>: <span class="number">2500</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">unmount</span>: &#123;</span><br><span class="line">    <span class="attr">millis</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="attr">dieOnTimeout</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">warningMillis</span>: <span class="number">2500</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">unload</span>: &#123;</span><br><span class="line">    <span class="attr">millis</span>: <span class="number">5000</span>,</span><br><span class="line">    <span class="attr">dieOnTimeout</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">warningMillis</span>: <span class="number">2500</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>注意<code>millis</code>指的是最终控制台输出警告的毫秒数，<code>warningMillis</code>指的是将警告打印到控制台(间隔)的毫秒数。</p>
<h4 id="切换应用时过渡"><a href="#切换应用时过渡" class="headerlink" title="切换应用时过渡"></a>切换应用时过渡</h4><p>如果你想为应用在挂载和卸载时加一些过渡效果(动画效果等)，则需要将其和<code>bootstrap</code>, <code>mount</code>, 和 <code>unmount</code>等生命周期函数关联。这个<a href="https://github.com/frehner/singlespa-transitions">single-spa 过渡</a>仓库是个小demo，展示了生命周期之间切换时如何过渡。</p>
<p>对于已经挂载的应用，各个页面之间的过渡效果可由应用本身自行处理，如基于React创建的项目可使用using <a href="https://github.com/reactjs/react-transition-group">react-transition-group</a>实现过渡效果。</p>
<p><a href="https://github.com/single-spa/zh-hans.single-spa.js.org/blob/master/website/versioned_docs/version-5.x/building-applications.md">Edit this page</a></p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><a href="https://zh-hans.single-spa.js.org/docs/api">https://zh-hans.single-spa.js.org/docs/api</a></p>
<h4 id="registerApplication注册"><a href="#registerApplication注册" class="headerlink" title="registerApplication注册"></a>registerApplication注册</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">singleSpa.registerApplication(&#123;</span><br><span class="line">  name: &#x27;myApp&#x27;,</span><br><span class="line">  app: () =&gt; import(&#x27;src/myApp/main.js&#x27;),</span><br><span class="line">  activeWhen: [&#x27;/myApp&#x27;, (location) =&gt; location.pathname.startsWith(&#x27;/some/other/path&#x27;)],</span><br><span class="line">  customProps: &#123;</span><br><span class="line">    some: &#x27;value&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">singleSpa.registerApplication(&#123;</span><br><span class="line">  name: &#x27;myApp&#x27;,</span><br><span class="line">  app: () =&gt; import(&#x27;src/myApp/main.js&#x27;),</span><br><span class="line">  activeWhen: [&#x27;/myApp&#x27;, (location) =&gt; location.pathname.startsWith(&#x27;/some/other/path&#x27;)],</span><br><span class="line">  customProps: (name, location) =&gt; (&#123;</span><br><span class="line">    some: &#x27;value&#x27;,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h6 id="name"><a href="#name" class="headerlink" title="name"></a>name</h6><p><code>registerApplication</code>的第一个参数表示应用名称，<code>name</code>必须是string类型</p>
<h6 id="Loading-Function-or-Application"><a href="#Loading-Function-or-Application" class="headerlink" title="Loading Function or Application"></a>Loading Function or Application</h6><p><code>registerApplication</code>的第二个参数可以是一个Promise类型的 <a href="https://zh-hans.single-spa.js.org/docs/configuration#loading-function">加载函数</a>，也可以是一个已经被解析的应用。</p>
<p><strong>加载函数</strong></p>
<p>registerApplication的第二个参数必须是返回promise的函数((或<a href="https://ponyfoo.com/articles/understanding-javascript-async-await">“async function”</a>方法)。这个函数没有入参，会在应用第一次被下载时调用。返回的Promise resolve之后的结果必须是一个可以被解析的应用。常见的实现方法是使用import加载：() =&gt; import(‘/path/to/application.js’)</p>
<p> <strong>Application</strong></p>
<p>你可以选择将一个已经被解析过的应用作为<code>registerApplication</code>的第二个参数，这个应用其实是一个<strong>包含各个生命周期函数的对象</strong>。我们既可以从另外一个文件中引入该对象，也可以在single-spa的配置文件中定义这个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> application = &#123;</span><br><span class="line">  <span class="attr">bootstrap</span>: <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(), <span class="comment">//bootstrap function</span></span><br><span class="line">  <span class="attr">mount</span>: <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(), <span class="comment">//mount function</span></span><br><span class="line">  <span class="attr">unmount</span>: <span class="function">() =&gt;</span> <span class="built_in">Promise</span>.resolve(), <span class="comment">//unmount function</span></span><br><span class="line">&#125;</span><br><span class="line">registerApplication(<span class="string">&#x27;applicationName&#x27;</span>, application, activityFunction)</span><br></pre></td></tr></table></figure>

<h5 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h5><p><code>registerApplication</code>的第三个参数需要是一个纯函数，<code>window.location</code>会作为第一个参数被调用，当函数返回的值为真(true)值时，应用会被激活。通常情况下，Activity function会根据<code>window.location</code>/后面的path来决定该应用是否需要被激活。</p>
<p>另外一种场景是single-spa根据顶级路由查找应用，而每个应用会处理自身的子路由。 在以下场景，single-spa会调用应用的activity function</p>
<p>在以下情况下，single-spa将调用每个应用的活动函数：</p>
<ul>
<li><code>hashchange</code> or <code>popstate</code>事件触发时</li>
<li><code>pushState</code> or <code>replaceState</code>被调用时</li>
<li>在single-spa上手动调用[<code>triggerAppChange</code>] 方法</li>
<li><code>checkActivityFunctions</code>方法被调用时</li>
</ul>
<p>路径前缀会匹配url，允许以下每一种前缀：</p>
<ul>
<li><p>‘/app1’</p>
<p>✅ <a href="https://app.com/app1">https://app.com/app1</a></p>
<p>✅ <a href="https://app.com/app1/anything/everything">https://app.com/app1/anything/everything</a></p>
<p>🚫 <a href="https://app.com/app2">https://app.com/app2</a></p>
</li>
<li><p>‘/users/:userId/profile’</p>
<p>✅ <a href="https://app.com/users/123/profile">https://app.com/users/123/profile</a></p>
<p>✅ <a href="https://app.com/users/123/profile/sub-profile/">https://app.com/users/123/profile/sub-profile/</a></p>
<p>🚫 <a href="https://app.com/users//profile/sub-profile/">https://app.com/users//profile/sub-profile/</a></p>
<p>🚫 <a href="https://app.com/users/profile/sub-profile/">https://app.com/users/profile/sub-profile/</a></p>
</li>
<li><p>‘/pathname/#/hash’</p>
<p>✅ <a href="https://app.com/pathname/#/hash">https://app.com/pathname/#/hash</a></p>
<p>✅ <a href="https://app.com/pathname/#/hash/route/nested">https://app.com/pathname/#/hash/route/nested</a></p>
<p>🚫 <a href="https://app.com/pathname#/hash/route/nested">https://app.com/pathname#/hash/route/nested</a></p>
<p>🚫 <a href="https://app.com/pathname#/another-hash">https://app.com/pathname#/another-hash</a></p>
</li>
<li><p>[‘/pathname/#/hash’, ‘/app1’]</p>
<p>✅ <a href="https://app.com/pathname/#/hash/route/nested">https://app.com/pathname/#/hash/route/nested</a></p>
<p>✅ <a href="https://app.com/app1/anything/everything">https://app.com/app1/anything/everything</a></p>
<p>🚫 <a href="https://app.com/pathname/app1">https://app.com/pathname/app1</a></p>
<p>🚫 <a href="https://app.com/app2">https://app.com/app2</a></p>
</li>
</ul>
<h5 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h5><p><code>registerApplication</code>函数可选的第四个参数是 <a href="https://zh-hans.single-spa.js.org/docs/building-applications/#custom-props">custom props</a>。这个参数会传递给 single-spa 的 <code>lifecycle</code> 函数。自定义属性可以是一个对象，也可以是一个返回Object的函数。如果自定属性是一个函数，函数的参数是应用的名字（application name)和当前<code>window.location</code>。</p>
<h4 id="start"><a href="#start" class="headerlink" title="start"></a>start</h4><p><a href="https://zh-hans.single-spa.js.org/docs/api#start"><code>start()方法</code></a> <strong>必须</strong>被single-spa配置文件的js调用，这时应用才会被真正挂载。在<code>start</code>被调用之前，应用先被下载，但不会初始化/挂载/卸载。<code>start</code>方法可以协助我们更好提升应用的性能。举个例子，我们可能会马上注册一个应用(为了立刻下载代码)，但不能马上就在DOM节点上挂载该应用，而是需要等一个AJAX请求(可能会获取用户的登录信息)完成后，再根据结果进行挂载。这种情况下，最佳实践是先调用<code>registerApplication</code>，等AJAX请求完成后再调用<code>start</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//single-spa-config.js</span><br><span class="line">import &#123; start &#125; from &#x27;single-spa&#x27;;</span><br><span class="line"> /*在注册应用之前调用start意味着single-spa可以立即安装应用，无需等待单页应用的任何初始设置。*/</span><br><span class="line">start();</span><br><span class="line">// 注册应用。。。。</span><br></pre></td></tr></table></figure>

<h3 id="tip-1"><a href="#tip-1" class="headerlink" title="tip"></a>tip</h3><h4 id="公共模块"><a href="#公共模块" class="headerlink" title="公共模块"></a>公共模块</h4><p><a href="https://zh-hans.single-spa.js.org/docs/recommended-setup#%E6%A6%82%E8%BF%B0">https://zh-hans.single-spa.js.org/docs/recommended-setup#%E6%A6%82%E8%BF%B0</a></p>
<h4 id="同时注册两个路由"><a href="#同时注册两个路由" class="headerlink" title="同时注册两个路由??"></a>同时注册两个路由??</h4><p>emm…也是可以的。 如果你能用正确的方式来实现，这件事并不可怕。一旦你正确实现了，这将非常非常厉害。一种实现方式是为每个app创建一个<code>&lt;div id=&quot;app name&quot;&gt;&lt;/div&gt;</code>，这样这两个应用就不会同时修改相同的DOM节点了。[考虑一个path变动，同时有两个应用被激活的场景，译者注]</p>
<div>需要一个id，这个id的以single-spa-application前缀开头，后面接着你的应用的名字。比如，如果你的应用名字叫做app-name，就创建一个id为 single-spa-application:app-name的div。

<p>一个多应用的的例子看着就像这样：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;single-spa-application:app-name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;single-spa-application:other-app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h1 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h1><h2 id="husky-lint-staged"><a href="#husky-lint-staged" class="headerlink" title="husky + lint-staged"></a>husky + lint-staged</h2><p>使用<code>husky</code> + <code>lint-staged</code>助力团队编码规范, husky&amp;lint-staged 安装推荐使用 <code>mrm</code>, 它将根据 <code>package.json</code> 依赖项中的代码质量工具来安装和配置 husky 和 lint-staged，因此请确保在此之前安装并配置所有代码质量工具，如 <code>Prettier 和 ESlint</code></p>
<h3 id="首先安装-mrm"><a href="#首先安装-mrm" class="headerlink" title="首先安装 mrm"></a>首先安装 mrm</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i mrm -D --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p><code>husky</code> 是一个为 git 客户端增加 <code>hook</code> 的工具。安装后，它会自动在仓库中的 <code>.git/</code> 目录下增加相应的钩子；比如 <code>pre-commit</code> 钩子就会在你执行 <code>git commit</code> 的触发。</p>
<p>那么我们可以在 <code>pre-commit</code> 中实现一些比如 <code>lint 检查</code>、<code>单元测试</code>、<code>代码美化</code>等操作。当然，<code>pre-commit</code> 阶段执行的命令当然要保证其速度不要太慢，每次 commit 都等很久也不是什么好的体验。</p>
<p><code>lint-staged</code>，一个仅仅过滤出 Git 代码暂存区文件(被 <code>git add</code> 的文件)的工具；这个很实用，因为我们如果对整个项目的代码做一个检查，可能耗时很长，如果是老项目，要对之前的代码做一个代码规范检查并修改的话，这可能就麻烦了呀，可能导致项目改动很大。</p>
<p>所以这个 <code>lint-staged</code>，对团队项目和开源项目来说，是一个很好的工具，它是对个人要提交的代码的一个规范和约束</p>
<h3 id="安装-lint-staged"><a href="#安装-lint-staged" class="headerlink" title="安装 lint-staged"></a>安装 lint-staged</h3><blockquote>
<p><code>mrm</code> 安装 <code>lint-staged</code> 会<code>自动</code>把 <code>husky</code> 一起安装下来</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npx mrm lint-staged</span><br></pre></td></tr></table></figure>

<h2 id="TS"><a href="#TS" class="headerlink" title="TS"></a>TS</h2><p><a href="https://blog.csdn.net/weixin_50763257/article/details/125755802">https://blog.csdn.net/weixin_50763257/article/details/125755802</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/285270177">https://zhuanlan.zhihu.com/p/285270177</a></p>
<ul>
<li><p>npm install -g typescript</p>
</li>
<li><p>tsc –init  <em>//生成 tsconfig.json</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;outDir&quot;: &quot;./built/&quot;,</span><br><span class="line">        &quot;sourceMap&quot;: true,</span><br><span class="line">        &quot;strict&quot;: true,</span><br><span class="line">        &quot;noImplicitReturns&quot;: true,</span><br><span class="line">        &quot;module&quot;: &quot;es2015&quot;,</span><br><span class="line">        &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">        &quot;target&quot;: &quot;es5&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;include&quot;: [</span><br><span class="line">        &quot;./src/**/*&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="alias-1"><a href="#alias-1" class="headerlink" title="alias"></a>alias</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;compilerOptions&quot;: &#123;</span><br><span class="line">   &quot;paths&quot;: &#123;</span><br><span class="line">     &quot;@/*&quot;:[&quot;src/*&quot;]</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<h3 id="d-ts声明文件"><a href="#d-ts声明文件" class="headerlink" title=".d.ts声明文件"></a>.d.ts声明文件</h3><p>声明文件也叫做描述文件，以d.ts结尾的文件名，比如xxx.d.ts)。声明文件主要是ts编译器用的。</p>
<p>开发中 ts 不可避免要引用其它第三方的 js库。这时TS就对引入的JS文件里变量的具体类型不明确了，为了告诉TS变量的类型，因此就有了.d.ts (d即declare)，ts的声明文件。</p>
<h3 id="tip-2"><a href="#tip-2" class="headerlink" title="tip"></a>tip</h3><ul>
<li><p>在script 标签中引入ts后，会产生JSX语法错误</p>
<p>  “jsx”: “preserve”,  </p>
</li>
<li><p>找不到模块“XXX.vue”或其相应的类型声明</p>
<ul>
<li><p>在根目录中创建 shims.d.ts文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">declare module &#x27;*.vue&#x27; &#123;</span><br><span class="line">    import &#123; ComponentOptions &#125; from &#x27;vue&#x27;</span><br><span class="line">    const componentOptions: ComponentOptions</span><br><span class="line">    export default componentOptions</span><br><span class="line">&#125;</span><br><span class="line">declare module &#x27;*&#x27;   </span><br></pre></td></tr></table></figure></li>
<li><p>也可以修改tsconfig.json 中替换 declare module ‘*’ </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;noImplicitAny&quot;: false,</span><br><span class="line">&quot;allowJs&quot;: true,</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="路由文件"><a href="#路由文件" class="headerlink" title="路由文件"></a>路由文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当设置 true 的时候该路由不会在侧边栏出现 如401，login等页面，或者如一些编辑页面/edit/1</span><br><span class="line">hidden: true // (默认 false)</span><br><span class="line"></span><br><span class="line">//当设置 noRedirect 的时候该路由在面包屑导航中不可被点击</span><br><span class="line">redirect: &#x27;noRedirect&#x27;</span><br><span class="line"></span><br><span class="line">// 当你一个路由下面的 children 声明的路由大于1个时，自动会变成嵌套的模式--如组件页面</span><br><span class="line">// 只有一个时，会将那个子路由当做根路由显示在侧边栏--如引导页面</span><br><span class="line">// 若你想不管路由下面的 children 声明的个数都显示你的根路由</span><br><span class="line">// 你可以设置 alwaysShow: true，这样它就会忽略之前定义的规则，一直显示根路由</span><br><span class="line">alwaysShow: true</span><br><span class="line"></span><br><span class="line">name: &#x27;router-name&#x27; // 设定路由的名字，一定要填写不然使用&lt;keep-alive&gt;时会出现各种问题</span><br><span class="line">meta: &#123;</span><br><span class="line">  roles: [&#x27;admin&#x27;, &#x27;editor&#x27;] // 设置该路由进入的权限，支持多个权限叠加</span><br><span class="line">  title: &#x27;title&#x27; // 设置该路由在侧边栏和面包屑中展示的名字</span><br><span class="line">  icon: &#x27;svg-name&#x27; // 设置该路由的图标，支持 svg-class，也支持 el-icon-x element-ui 的 icon</span><br><span class="line">  noCache: true // 如果设置为true，则不会被 &lt;keep-alive&gt; 缓存(默认 false)</span><br><span class="line">  breadcrumb: false //  如果设置为false，则不会在breadcrumb面包屑中显示(默认 true)</span><br><span class="line">  affix: true // 如果设置为true，它则会固定在tags-view中(默认 false)</span><br><span class="line"></span><br><span class="line">  // 当路由设置了该属性，则会高亮相对应的侧边栏。</span><br><span class="line">  // 这在某些场景非常有用，比如：一个文章的列表页路由为：/article/list</span><br><span class="line">  // 点击文章进入文章详情页，这时候路由为/article/1，但你想在侧边栏高亮文章列表的路由，就可以进行如下设置</span><br><span class="line">  activeMenu: &#x27;/article/list&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="scp2自动化部署"><a href="#scp2自动化部署" class="headerlink" title="scp2自动化部署"></a>scp2自动化部署</h2><p><a href="https://blog.csdn.net/weixin_41305441/article/details/107108429">https://blog.csdn.net/weixin_41305441/article/details/107108429</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> client = <span class="built_in">require</span>(<span class="string">&#x27;scp2&#x27;</span>);</span><br><span class="line"><span class="comment">// const ora = require(&#x27;ora&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(123,ora);</span></span><br><span class="line"><span class="keyword">const</span> server = &#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">//服务器IP</span></span><br><span class="line">  <span class="attr">port</span>: <span class="number">22</span>, <span class="comment">//服务器端口</span></span><br><span class="line">  <span class="attr">username</span>: <span class="string">&#x27;root&#x27;</span>, <span class="comment">//服务器ssh登录用户名</span></span><br><span class="line">  <span class="attr">password</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">//服务器ssh登录密码</span></span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">//服务器web目录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const loading = ora(&#x27;正在部署至 &#x27; + server.host)</span></span><br><span class="line"><span class="comment">// loading.start()</span></span><br><span class="line">client.scp(<span class="string">&#x27;dist/&#x27;</span>, server, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// loading.stop()</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;部署失败&#x27;</span>);</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;部署成功&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="axios构建"><a href="#axios构建" class="headerlink" title="axios构建"></a>axios构建</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>增post    删delete    改put    查get</p>
<p>OPTIONS请求方法的主要用途有两个：</p>
<p>1、获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。</p>
<p>2、当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起OPTIONS请求，即CORS预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。</p>
<h3 id="重复调用"><a href="#重复调用" class="headerlink" title="重复调用"></a>重复调用</h3><p><a href="https://www.jb51.net/article/221311.htm">https://www.jb51.net/article/221311.htm</a></p>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><h4 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Toast, Dialog &#125; <span class="keyword">from</span> <span class="string">&#x27;vant&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; VueAxios &#125; <span class="keyword">from</span> <span class="string">&#x27;./axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//单例模式，即同一时间只会存在一个 Toast</span></span><br><span class="line">Toast.allowMultiple();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 axios 实例</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: process.env.VUE_APP_API_BASE_URL, <span class="comment">// api base_url</span></span><br><span class="line">  <span class="comment">//代理</span></span><br><span class="line">  <span class="comment">// baseURL: &#x27;/dev&#x27;,</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">6000</span> <span class="comment">// 请求超时时间</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//code信息</span></span><br><span class="line"><span class="keyword">const</span> codeMessage = &#123;</span><br><span class="line">  <span class="number">200</span>: <span class="string">&quot;服务器成功返回请求的数据。&quot;</span>,</span><br><span class="line">  <span class="number">201</span>: <span class="string">&quot;新建或修改数据成功。&quot;</span>,</span><br><span class="line">  <span class="number">202</span>: <span class="string">&quot;一个请求已经进入后台排队（异步任务）。&quot;</span>,</span><br><span class="line">  <span class="number">204</span>: <span class="string">&quot;删除数据成功。&quot;</span>,</span><br><span class="line">  <span class="number">400</span>: <span class="string">&quot;发出的请求有错误，服务器没有进行新建或修改数据的操作。&quot;</span>,</span><br><span class="line">  <span class="number">401</span>: <span class="string">&quot;用户没有权限（令牌、用户名、密码错误）。&quot;</span>,</span><br><span class="line">  <span class="number">403</span>: <span class="string">&quot;用户得到授权，但是访问是被禁止的。&quot;</span>,</span><br><span class="line">  <span class="number">404</span>: <span class="string">&quot;发出的请求针对的是不存在的记录，服务器没有进行操作。&quot;</span>,</span><br><span class="line">  <span class="number">405</span>: <span class="string">&quot;请求方法不被允许。&quot;</span>,</span><br><span class="line">  <span class="number">406</span>: <span class="string">&quot;请求的格式不可得。&quot;</span>,</span><br><span class="line">  <span class="number">410</span>: <span class="string">&quot;请求的资源被永久删除，且不会再得到的。&quot;</span>,</span><br><span class="line">  <span class="number">422</span>: <span class="string">&quot;当创建一个对象时，发生一个验证错误。&quot;</span>,</span><br><span class="line">  <span class="number">500</span>: <span class="string">&quot;服务器发生错误，请检查服务器。&quot;</span>,</span><br><span class="line">  <span class="number">502</span>: <span class="string">&quot;网关错误。&quot;</span>,</span><br><span class="line">  <span class="number">503</span>: <span class="string">&quot;服务不可用，服务器暂时过载或维护。&quot;</span>,</span><br><span class="line">  <span class="number">504</span>: <span class="string">&quot;网关超时。&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> showLoading = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> failToast = <span class="function">(<span class="params">msg</span>) =&gt;</span> &#123;</span><br><span class="line">  Toast.fail(&#123;</span><br><span class="line">    <span class="attr">duration</span>: <span class="number">2000</span>,</span><br><span class="line">    <span class="attr">message</span>: msg</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> err = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error);</span><br><span class="line">  <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = error.response.data</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">403</span>) &#123;</span><br><span class="line">      failToast(<span class="string">&#x27;Forbidden&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (error.response.status === <span class="number">401</span> &amp;&amp; !(data.result &amp;&amp; data.result.isLogin)) &#123;</span><br><span class="line">      failToast(<span class="string">&#x27;Unauthorized&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 请求超时状态</span></span><br><span class="line">    <span class="keyword">if</span> (error.message.includes(<span class="string">&#x27;timeout&#x27;</span>)) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;超时了&#x27;</span>)</span><br><span class="line">      failToast(<span class="string">&#x27;请求超时，请检查网络是否连接正常&#x27;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 可以展示断网组件</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;断网了&#x27;</span>)</span><br><span class="line">      failToast(<span class="string">&#x27;请求失败，请检查网络是否已连接&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  showLoading &amp;&amp; showLoading.clear()</span><br><span class="line">  showLoading = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理参数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;*&#125;</span> <span class="variable">config</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> handleParams = <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(config);</span><br><span class="line">  <span class="keyword">const</span> token = Vue.ls.get(<span class="string">&#x27;token&#x27;</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123; method &#125; = config</span><br><span class="line">  config.headers.authorization =</span><br><span class="line">    <span class="string">&quot;Bearer &quot;</span> + token;</span><br><span class="line">  <span class="keyword">return</span> config</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// request interceptor</span></span><br><span class="line">service.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> handleParams(config)</span><br><span class="line">&#125;, err)</span><br><span class="line"><span class="comment">// response interceptor</span></span><br><span class="line">service.interceptors.response.use(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">  <span class="keyword">return</span> response.data</span><br><span class="line">&#125;, err)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Vue.prototype.service = service</span></span><br><span class="line"><span class="comment">// export &#123; service as axios &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> installer = &#123;</span><br><span class="line">  <span class="attr">vm</span>: &#123;&#125;,</span><br><span class="line">  <span class="function"><span class="title">install</span>(<span class="params">Vue</span>)</span> &#123;</span><br><span class="line">    Vue.use(VueAxios, service)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  installer <span class="keyword">as</span> VueAxios,</span><br><span class="line">  service <span class="keyword">as</span> axios</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="react"><a href="#react" class="headerlink" title="react"></a>react</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;../store&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; message, notification, Button, Space, Spin &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="comment">// import &#123;HashRouter&#125; from &#x27;react-router-dom&#x27;    //如果使用的是hash路由类型，使用这个</span></span><br><span class="line"><span class="comment">// const router = new HashRouter()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> BrowserRouter()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> API_BASE_URLS = &#123;</span><br><span class="line">  <span class="attr">development</span>: <span class="string">&quot;http://121.40.61.99:3600/&quot;</span>,</span><br><span class="line">  <span class="attr">production</span>: <span class="string">&quot;http://121.40.61.99:3600/&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: API_BASE_URLS[process.env.NODE_ENV],</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> codeMessage = &#123;</span><br><span class="line">  <span class="number">200</span>: <span class="string">&quot;服务器成功返回请求的数据。&quot;</span>,</span><br><span class="line">  <span class="number">201</span>: <span class="string">&quot;新建或修改数据成功。&quot;</span>,</span><br><span class="line">  <span class="number">202</span>: <span class="string">&quot;一个请求已经进入后台排队（异步任务）。&quot;</span>,</span><br><span class="line">  <span class="number">204</span>: <span class="string">&quot;删除数据成功。&quot;</span>,</span><br><span class="line">  <span class="number">400</span>: <span class="string">&quot;发出的请求有错误，服务器没有进行新建或修改数据的操作。&quot;</span>,</span><br><span class="line">  <span class="number">401</span>: <span class="string">&quot;用户没有权限（令牌、用户名、密码错误）。&quot;</span>,</span><br><span class="line">  <span class="number">403</span>: <span class="string">&quot;用户得到授权，但是访问是被禁止的。&quot;</span>,</span><br><span class="line">  <span class="number">404</span>: <span class="string">&quot;发出的请求针对的是不存在的记录，服务器没有进行操作。&quot;</span>,</span><br><span class="line">  <span class="number">405</span>: <span class="string">&quot;请求方法不被允许。&quot;</span>,</span><br><span class="line">  <span class="number">406</span>: <span class="string">&quot;请求的格式不可得。&quot;</span>,</span><br><span class="line">  <span class="number">410</span>: <span class="string">&quot;请求的资源被永久删除，且不会再得到的。&quot;</span>,</span><br><span class="line">  <span class="number">422</span>: <span class="string">&quot;当创建一个对象时，发生一个验证错误。&quot;</span>,</span><br><span class="line">  <span class="number">500</span>: <span class="string">&quot;服务器发生错误，请检查服务器。&quot;</span>,</span><br><span class="line">  <span class="number">502</span>: <span class="string">&quot;网关错误。&quot;</span>,</span><br><span class="line">  <span class="number">503</span>: <span class="string">&quot;服务不可用，服务器暂时过载或维护。&quot;</span>,</span><br><span class="line">  <span class="number">504</span>: <span class="string">&quot;网关超时。&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当前正在请求的数量</span></span><br><span class="line"><span class="keyword">let</span> requestCount = <span class="number">0</span></span><br><span class="line"><span class="comment">// 显示loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dom = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span><br><span class="line">    dom.setAttribute(<span class="string">&#x27;id&#x27;</span>, <span class="string">&#x27;loading&#x27;</span>)</span><br><span class="line">    dom.setAttribute(<span class="string">&#x27;style&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">position</span>: <span class="string">&quot;absolute&quot;</span>,</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(dom)</span><br><span class="line">    ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Spin</span> <span class="attr">tip</span>=<span class="string">&quot;努力加载中...&quot;</span> <span class="attr">delay</span>=<span class="string">&#123;2000&#125;</span> <span class="attr">size</span>=<span class="string">&quot;large&quot;</span> /&gt;</span></span>, dom)</span><br><span class="line">  &#125;</span><br><span class="line">  requestCount += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏loading</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hideLoading</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  requestCount -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (requestCount === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> loading = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;loading&#x27;</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(loading);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 异常处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> errorHandler = <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">  hideLoading();</span><br><span class="line">  <span class="keyword">if</span> (error.response) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="attr">response</span>: &#123;</span><br><span class="line">        status,</span><br><span class="line">        data</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125; = error;</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">      <span class="keyword">const</span> errorText = data || codeMessage[status];</span><br><span class="line">      <span class="keyword">if</span> (status === <span class="number">500</span>) &#123;</span><br><span class="line">        message.error(errorText);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">400</span>) &#123;</span><br><span class="line">        message.info(errorText);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="number">401</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.localStorage.removeItem(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">        <span class="built_in">localStorage</span>.removeItem(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">        <span class="built_in">window</span>.location.hash = <span class="string">&quot;user/login&quot;</span></span><br><span class="line">        message.info(errorText);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      notification.error(&#123;</span><br><span class="line">        <span class="attr">description</span>: <span class="string">&quot;您的网络发生异常，无法连接服务器&quot;</span>,</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;网络异常&quot;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error.message.includes(<span class="string">&quot;timeout&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">// 请求超时状态</span></span><br><span class="line">    notification.error(&#123;</span><br><span class="line">      <span class="attr">description</span>: <span class="string">&quot;求超时，请检查网络是否连接正常&quot;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;网络异常&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 可以展示断网组件</span></span><br><span class="line">    notification.error(&#123;</span><br><span class="line">      <span class="attr">description</span>: <span class="string">&quot;请求失败，请检查网络是否已连接&quot;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;网络异常&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;;</span><br><span class="line">request.interceptors.request.use(<span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//调用接口时 设置axios(ajax)请求头Authorization的格式为`Bearer ` +token</span></span><br><span class="line">  config.headers.authorization =</span><br><span class="line">    <span class="string">&quot;Bearer &quot;</span> + <span class="built_in">window</span>.localStorage.getItem(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">  showLoading();</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;);</span><br><span class="line">request.interceptors.response.use(</span><br><span class="line">  <span class="function">(<span class="params">resp</span>) =&gt;</span> &#123;</span><br><span class="line">    hideLoading();</span><br><span class="line">    <span class="keyword">return</span> resp;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">respError</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(respError, respError.response)</span></span><br><span class="line">    errorHandler(respError)</span><br><span class="line">    <span class="keyword">return</span> respError.response;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure>

<h2 id="国际化-i18n"><a href="#国际化-i18n" class="headerlink" title="国际化 i18n"></a>国际化 i18n</h2><p><a href="https://mp.weixin.qq.com/s/NcKVhpKNTnX6E8Ei3Y5LAw">https://mp.weixin.qq.com/s/NcKVhpKNTnX6E8Ei3Y5LAw</a></p>
<h2 id="换肤"><a href="#换肤" class="headerlink" title="换肤"></a>换肤</h2><h3 id="css-2"><a href="#css-2" class="headerlink" title="css"></a>css</h3><p><strong>使用var</strong>，var() 函数用于插入自定义的属性值</p>
<p>:root是一个<a href="https://so.csdn.net/so/search?q=%E4%BC%AA%E7%B1%BB&spm=1001.2101.3001.7020">伪类</a>，表示文档根元素(html)，所有主流浏览器均支持 :root 选择器，除了 IE8 及更早的版本。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">html</span> &#123;</span></span><br><span class="line"><span class="css">      --bg: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">      --bg-panel: <span class="number">#ebebeb</span>;</span></span><br><span class="line"><span class="css">      --<span class="attribute">color</span>-heading: <span class="built_in">rgb</span>(<span class="number">27</span>, <span class="number">168</span>, <span class="number">14</span>);</span></span><br><span class="line"><span class="css">      --<span class="attribute">color</span>-text: <span class="number">#333333</span>;</span></span><br><span class="line"><span class="css">    &#125;<span class="comment">/* 可以用 :root代替html */</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">html</span><span class="selector-attr">[data-theme=<span class="string">&#x27;dark&#x27;</span>]</span> &#123;</span></span><br><span class="line"><span class="css">      --bg: <span class="number">#333333</span>;</span></span><br><span class="line"><span class="css">      --bg-panel: <span class="number">#434343</span>;</span></span><br><span class="line"><span class="css">      --<span class="attribute">color</span>-heading: <span class="number">#0077ff</span>;</span></span><br><span class="line"><span class="css">      --<span class="attribute">color</span>-text: <span class="number">#b5b5b5</span>;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: <span class="built_in">var</span>(--bg); <span class="comment">/* background color variable */</span></span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">&quot;changeThemeToDark&quot;</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementsByClassName(<span class="string">&#x27;changeThemeToDark&#x27;</span>)[<span class="number">0</span>].addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.documentElement.setAttribute(<span class="string">&#x27;data-theme&#x27;</span>, <span class="string">&#x27;dark&#x27;</span>); <span class="comment">//set theme to light</span></span></span><br><span class="line"><span class="javascript">    &#125;);</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>lessOptions配置modifyVars,globalVars</p>
<h3 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h3><p>注入全局样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sass-loader v8-，这个选项名是 &quot;data&quot;</span><br><span class="line">sass-loader v8 中，这个选项名是 &quot;prependData&quot;</span><br><span class="line">sass-loader v10+，这个选项名是 &quot;additionalData&quot;</span><br></pre></td></tr></table></figure>

<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><a href="https://shengchangwei.github.io/optimizing-images/">https://shengchangwei.github.io/optimizing-images/</a></p>
<h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><ul>
<li>有损(<code>Lossless</code>)和无损(<code>Lossy</code>)：一般我们聊到图片的时候经常会听到别人提到有损或者无损的字眼，那么什么是有损和无损呢？无损就是图片在压缩保存后虽然占用的存储更小了，但是图像的呈现质量依然如旧；而有损则是相反，图像随着一次又一次的压缩后，质量会变得越来越差。</li>
<li>索引色(<code>Indexed color</code>)和直接色(<code>Direct color</code>)：按照不同的颜色深度可以将颜色分为索引色和直接色。索引色就是图像作者指定图片的用色总共不超过256种；而直接色则是对颜色使用没有限制，可以存在成千上万的颜色值。</li>
<li>光栅格式(<code>raster</code>)和矢量格式(<code>vector</code>)：图像根据信息的表示方式可以分为光栅图和矢量图。光栅图也叫作位图，点阵图或者像素图，图的最小单位是由一个个带颜色的像素组合而成，在 <code>Photoshop</code> 里把图片放到最大，将看到许许多多的像素方块，所以光栅图在伸缩的时候图像可能会失真；而矢量图则是以由点、线和一些几何图形为基础，通过数学计算来排列组合而成，这种图在伸缩的时候能完好的保护质量。</li>
</ul>
<h5 id="JPEG-JPG"><a href="#JPEG-JPG" class="headerlink" title="JPEG/JPG"></a>JPEG/JPG</h5><ul>
<li><p>关键字</p>
<p>有损压缩、体积小、加载快、不支持透明</p>
</li>
<li><p>优点</p>
<p>优点：JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。此外，JPG 格式以 24 位存储单个图，可以呈现多达 1600 万种颜色，足以应对大多数场景下对色彩的要求，这一点决定了它压缩前后的质量损耗并不容易被我们人类的肉眼所察觉——前提是你用对了业务场景。</p>
</li>
<li><p>缺点</p>
<p>有损压缩在在大图，如背景图、轮播图确实很难露出马脚，但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。</p>
<p>此外，JPEG 图像不支持透明度处理，透明图片需要召唤 PNG 来呈现。</p>
</li>
<li><p>应用场景</p>
<p>JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。使用 JPG 呈现大图，既可以保住图片的质量，又不会带来令人头疼的图片体积，是当下比较推崇的一种方案。</p>
</li>
</ul>
<h5 id="PNG"><a href="#PNG" class="headerlink" title="PNG"></a>PNG</h5><ul>
<li><p>关键字</p>
<p>无损压缩、质量高、体积大、<strong>支持透明</strong></p>
</li>
<li><p>优点</p>
<p>PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。</p>
<p>PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。</p>
</li>
<li><p>缺点</p>
<p>PNG 体积较大，较旧的浏览器和程序可能不支持 PNG 文件。</p>
</li>
<li><p>应用场景</p>
<p>复杂的、色彩层次丰富的图片，用 PNG 来处理的话，成本会比较高，我们一般会交给 JPG 去存储。考虑到 PNG 在处理线条和颜色对比度方面的优势，我们主要用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</p>
</li>
<li><p>扩展</p>
<ul>
<li><p>PNG-8 与 PNG-24 的选择题</p>
<p>什么时候用 PNG-8，什么时候用 PNG-24，这是一个问题。</p>
<p>理论上来说，当你追求最佳的显示效果、并且不在意文件体积大小时，是推荐使用 PNG-24 的。</p>
<p>但实践当中，为了规避体积的问题，我们一般不用PNG去处理较复杂的图像。当我们遇到适合 PNG 的场景时，也会优先选择更为小巧的 PNG-8。</p>
<p>如何确定一张图片是该用 PNG-8 还是 PNG-24 去呈现呢？好的做法是把图片先按照这两种格式分别输出，看 PNG-8 输出的结果是否会带来肉眼可见的质量损耗，并且确认这种损耗是否在我们（尤其是你的 UI 设计师）可接受的范围内，基于对比的结果去做判断。</p>
</li>
</ul>
</li>
</ul>
<h5 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h5><ul>
<li><p>关键字</p>
<p>文本文件、体积小、不失真、兼容性好</p>
</li>
<li><p>优点</p>
<p>和性能关系最密切的一点就是：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。 当然,作为矢量图，它最显著的优势还是在于图片可无限放大而不失真这一点上。这使得 SVG 即使是被放到视网膜屏幕上，也可以一如既往地展现出较好的成像品质——1 张 SVG 足以适配 n 种分辨率。此外，SVG 是文本文件。我们既可以像写代码一样定义 SVG，把它写在 HTML 里、成为 DOM 的一部分，也可以把对图形的描述写入以 .svg 为后缀的独立文件（SVG 文件在使用上与普通图片文件无异）。这使得 SVG 文件可以被非常多的工具读取和修改，具有较强的灵活性。</p>
</li>
<li><p>缺点</p>
<p>一方面是它的渲染成本比较高，这点对性能来说是很不利的。另一方面，SVG 存在着其它图片格式所没有的学习成本（它是可编程的）。</p>
</li>
<li><p>应用场景</p>
<p>SVG 是可编程的，因此可以在WEB项目中的平面图绘制，如需要绘制线，多边形，图片等。 SVG也可作为iocn图标，个人认为作为图标使用的话, 在线矢量图形库已经满足大部分的业务需求了。</p>
</li>
</ul>
<p>svg改颜色</p>
<h5 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h5><ul>
<li><p>关键字</p>
<p>文本文件、依赖编码、小图标解决方案</p>
</li>
<li><p>优点</p>
<p>base64就是一串字符串码表示的图片，在加载页面和js时一块加载出来，减少了加载图片时的http请求。加载一张图片时会发起一次http请求，http请求每次建立都会需要一定的时间，对于加载一张小图来说，下载图片所需的时间会比建立http请求的时间要短。</p>
</li>
<li><p>缺点</p>
<p>既然 Base64 这么棒，我们何不把大图也换成 Base64 呢？</p>
<p>这是因为，Base64 编码后，图片大小会膨胀为原文件的 4/3（这是由 Base64 的编码原理决定的）。如果我们把大图也编码到 HTML 或 CSS 文件中，后者的体积会明显增加，即便我们减少了 HTTP 请求，也无法弥补这庞大的体积带来的性能开销，得不偿失。 在传输非常小的图片的时候，Base64 带来的文件体积膨胀、以及浏览器解析 Base64 的时间开销，与它节省掉的 HTTP 请求开销相比，可以忽略不计，这时候才能真正体现出它在性能方面的优势。 因此，Base64 并非万全之策，我们往往在一张图片满足以下条件时会对它应用 Base64 编码：</p>
<ul>
<li><p>图片的实际尺寸很小（大家可以观察一下掘金页面的 Base64 图，几乎没有超过 2kb 的）</p>
</li>
<li><p>图片无法以雪碧图的形式与其它小图结合（合成雪碧图仍是主要的减少 HTTP 请求的途径，Base64 是雪碧图的补充）</p>
</li>
<li><p>图片的更新频率非常低（不需我们重复编码和修改文件内容，维护成本较低）</p>
</li>
</ul>
</li>
<li><p>应用场景</p>
<p>Base64应用场景往往是比较小的图片，如：页面的Logo。对于一些体积较大的图片,由于Base64的缺点不建议转成Base64的格式。</p>
<p>如果你使用vue框架，就应该知道， vue-cli创建的webpack模板默认会将10K以下的图片和字体文件转为base64。好处带来了更快的渲染，不会因为页面切换时还有加载图片的延迟感。</p>
</li>
</ul>
<h5 id="WebP"><a href="#WebP" class="headerlink" title="WebP"></a>WebP</h5><ul>
<li><p>关键字</p>
<p>年轻的全能型选手</p>
<p>WebP 是今天在座各类图片格式中最年轻的一位，它于 2010 年被提出， 是 Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。</p>
</li>
<li><p>优点</p>
<p>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。WebP 的官方介绍：</p>
<p>与 PNG 相比，WebP 无损图像的尺寸缩小了 26％。在等效的 SSIM 质量指数下，WebP 有损图像比同类<br>JPEG 图像小 25-34％。 无损 WebP 支持透明度（也称为 alpha 通道），仅需 22％ 的额外字节。<br>对于有损 RGB 压缩可接受的情况，有损 WebP 也支持透明度，与 PNG 相比，通常提供 3 倍的文件大小。图片优化是质量与性能的博弈，从这个角度看，WebP 无疑是真正的赢家。</p>
</li>
<li><p>缺点</p>
<p>WebP 纵有千般好，但它毕竟太年轻。我们知道，任何新生事物，都逃不开兼容性的大坑。此外，WebP 还会增加服务器的负担——和编码 JPG 文件相比，编码同样质量的 WebP 文件会占用更多的计算资源。</p>
</li>
<li><p>应用场景</p>
<p>现在限制我们使用 WebP 的最大问题不是“这个图片是否适合用 WebP 呈现”的问题，而是“浏览器是否允许 WebP”的问题，即我们上文谈到的兼容性问题。具体来说，一旦我们选择了 WebP，就要考虑在 Safari 等浏览器下它无法显示的问题，也就是说我们需要准备方案B，准备降级方案。</p>
</li>
</ul>
<h3 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;img</span><br><span class="line">    class=&quot;mar-r-8&quot;</span><br><span class="line">    :style=&quot;&#123;</span><br><span class="line">    width: &#x27;16px&#x27;,</span><br><span class="line">    height: &#x27;16px&#x27;,</span><br><span class="line">    filter: &#x27;drop-shadow(red 100px 0)&#x27;,</span><br><span class="line">    translate: &#x27;-100px&#x27;,</span><br><span class="line">    &#125;&quot;</span><br><span class="line">    :src=&quot;iconPeople&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>



<h2 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p><a href="https://es6.ruanyifeng.com/#docs/module-loader#package-json-%E7%9A%84-exports-%E5%AD%97%E6%AE%B5">https://es6.ruanyifeng.com/#docs/module-loader#package-json-%E7%9A%84-exports-%E5%AD%97%E6%AE%B5</a></p>
<p><a href="https://nodejs.cn/api/packages.html">https://nodejs.cn/api/packages.html</a></p>
<h4 id="main"><a href="#main" class="headerlink" title="main"></a>main</h4><p>项目发布时，默认会包括 package.json，license，README 和main 字段里指定的文件，因为 main 字段里指定的是项目的入口文件，在 browser 和 Node 环境中都可以使用。</p>
<p>如果不设置 main 字段，那么入口文件就是根目录下的 index.js。</p>
<p>比如 packageA 的 main 字段指定为 index.js。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;main&quot;: &quot;./index.js&quot;</span><br></pre></td></tr></table></figure>

<p>我们引入 packageA 时，实际上引入的就是 node_modules/packageA/index.js。</p>
<h4 id="name-1"><a href="#name-1" class="headerlink" title="name"></a>name</h4><p>项目的名称，如果是第三方包的话，其他人可以通过该名称使用 npm install 进行安装。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;name&quot;: &quot;react&quot;</span><br></pre></td></tr></table></figure>

<h4 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h4><p>一组项目的技术关键词，比如 Ant Design 组件库的 keywords 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;keywords&quot;: [</span><br><span class="line">  &quot;ant&quot;,</span><br><span class="line">  &quot;component&quot;,</span><br><span class="line">  &quot;components&quot;,</span><br><span class="line">  &quot;design&quot;,</span><br><span class="line">  &quot;framework&quot;,</span><br><span class="line">  &quot;frontend&quot;,</span><br><span class="line">  &quot;react&quot;,</span><br><span class="line">  &quot;react-component&quot;,</span><br><span class="line">  &quot;ui&quot;</span><br><span class="line"> ],</span><br></pre></td></tr></table></figure>

<h4 id="repository-homepage"><a href="#repository-homepage" class="headerlink" title="repository/homepage"></a>repository/homepage</h4><p>repository项目的仓库地址以及版本控制信息。</p>
<p>homepage项目主页的链接，通常是项目 github 链接，项目官网或文档首页。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;repository&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;git&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;git+https://github.com/jerrywu001/sandpack-vue3.git&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;homepage&quot;</span>: <span class="string">&quot;https://sandpack-vue3.netlify.app&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="bugs"><a href="#bugs" class="headerlink" title="bugs"></a>bugs</h4><p>项目 bug 反馈地址，通常是 github issue 页面的链接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;bugs&quot;: &quot;http://github.com/vuejs/core/issues&quot;</span><br></pre></td></tr></table></figure>

<h4 id="license"><a href="#license" class="headerlink" title="license"></a>license</h4><p>项目的开源许可证。项目的版权拥有人可以使用开源许可证来限制源码的使用、复制、修改和再发布等行为。常见的开源许可证有 BSD、MIT、Apache 等，它们的区别可以参考：如何选择开源许可证？</p>
<h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>在 node 支持 ES 模块后，要求 ES 模块采用 .mjs 后缀文件名。只要遇到 .mjs 文件，就认为它是 ES 模块。如果不想修改文件后缀，就可以在 package.json文件中，指定 type 字段为 module。</p>
<p>“type”: “module”<br>这样所有 .js 后缀的文件，node 都会用 ES 模块解释。</p>
<p>使用 ES 模块规范</p>
<p>$ node index.js</p>
<h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><blockquote>
<p>使用 <code>&quot;exports&quot;</code> 字段可以防止包的使用者使用包中其他未定义的入口点，指定只能引用包文件的范围</p>
<p>exports定义了自定义导出规则，<em><strong>可以理解为路径映射</strong></em>，<strong>防止其他未被定义的内容被访问</strong></p>
</blockquote>
<p>若export不起作用：<a href="https://stackoverflow.com/questions/58990498/package-json-exports-field-not-working-with-typescript">https://stackoverflow.com/questions/58990498/package-json-exports-field-not-working-with-typescript</a></p>
<h5 id="子目录别名"><a href="#子目录别名" class="headerlink" title="子目录别名"></a>子目录别名</h5><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码指定<code>src/submodule.js</code>别名为<code>submodule</code>，然后就可以从别名加载这个文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br></pre></td></tr></table></figure>

<p>如果没有指定别名，就不能用“<strong>模块+脚本名</strong>”这种形式加载脚本。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="main-的别名"><a href="#main-的别名" class="headerlink" title="main 的别名"></a>main 的别名</h5><p><code>exports</code>字段的别名如果是<code>.</code>，就代表模块的主入口，<strong>优先级高于<code>main</code>字段</strong>，并且可以直接简写成<code>exports</code>字段的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>
<h5 id="条件加载"><a href="#条件加载" class="headerlink" title="条件加载"></a>条件加载</h5><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，别名<code>.</code>的<code>require</code>条件指定<code>require()</code>命令的入口文件（即 CommonJS 的入口），<code>default</code>条件指定其他情况的入口（即 ES6 的入口）</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;include&quot;: [</span><br><span class="line">    &quot;./index.ts&quot;</span><br><span class="line">  ], //只编译的文件</span><br><span class="line">  &quot;exclude&quot;: [</span><br><span class="line">    &quot;./test.ts&quot;</span><br><span class="line">  ], //除了[]中的文件，编译其他所有文件</span><br><span class="line">  // 编译过程中一些编译的属性或者编译的配置</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    /* Visit https://aka.ms/tsconfig.json to read more about this file */</span><br><span class="line">    /* Projects */</span><br><span class="line">    // &quot;incremental&quot;: true,                              /* 启用增量编译 */</span><br><span class="line">    // &quot;composite&quot;: true,                                /* 启用允许将类型脚脚本项目与项目引用一起使用的约束 */</span><br><span class="line">    // &quot;tsBuildInfoFile&quot;: &quot;./&quot;,                          /* 指定.tsbuildinfo增量编译文件的文件夹。 */</span><br><span class="line">    // &quot;disableSourceOfProjectReferenceRedirect&quot;: true,  /* 在引用复合项目时，将禁用首选的源文件，而不是声明文件 */</span><br><span class="line">    // &quot;disableSolutionSearching&quot;: true,                 /* 在编辑时，选择一个项目退出多项目引用检查。 */</span><br><span class="line">    // &quot;disableReferencedProjectLoad&quot;: true,             /* 减少通过类型脚本自动加载的项目数量。 */</span><br><span class="line">    /* Language and Environment */</span><br><span class="line">    &quot;target&quot;: &quot;es2016&quot;, /* 为发出的JavaScript设置JavaScript语言版本，并包含兼容的库声明 */</span><br><span class="line">    // &quot;lib&quot;: [],                                        /* 指定一组描述目标运行时环境的捆绑库声明文件 */</span><br><span class="line">    // &quot;jsx&quot;: &quot;preserve&quot;,                                /* 指定生成的JSX代码 */</span><br><span class="line">    // &quot;experimentalDecorators&quot;: true,                   /* 为TC39第二阶段的草稿装饰器提供实验支持。 */</span><br><span class="line">    // &quot;emitDecoratorMetadata&quot;: true,                    /* 为源文件中的修饰声明的设计类型元数据 */</span><br><span class="line">    // &quot;jsxFactory&quot;: &quot;&quot;,                                 /* 指定针对ReactJSX发射时使用的JSX工厂函数，例如“React.createElement”或“h” */</span><br><span class="line">    // &quot;jsxFragmentFactory&quot;: &quot;&quot;,                         /* 指定用于片段的JSX片段引用例如：React.Fragment&#x27; or &#x27;Fragment. */</span><br><span class="line">    // &quot;jsxImportSource&quot;: &quot;&quot;,                            /* 指定用于在使用`jsx时导入JSX工厂函数的模块说明符：反应-jsx*`.`  */</span><br><span class="line">    // &quot;reactNamespace&quot;: &quot;&quot;,                             /* 指定为`创建元素`调用的对象。这只适用于针对`，`JSX emit。*/</span><br><span class="line">    // &quot;noLib&quot;: true,                                    /* 禁用包括任何库文件，包括默认的lib.d.ts。 */</span><br><span class="line">    // &quot;useDefineForClassFields&quot;: true,                  /* emit ECMAScript-符合标准的类字段。 */</span><br><span class="line">    /* Modules */</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;, /* 指定所生成的模块代码。 */</span><br><span class="line">    // &quot;rootDir&quot;: &quot;./&quot;,                                  /* 在源文件中指定根文件夹。 */</span><br><span class="line">    // &quot;moduleResolution&quot;: &quot;node&quot;,                       /* 指定TypeScript如何从给定的模块指定符中查找文件。 */</span><br><span class="line">    // &quot;baseUrl&quot;: &quot;./&quot;,                                  /* 指定要解析非相对模块名称的基本目录。 */</span><br><span class="line">    // &quot;paths&quot;: &#123;&#125;,                                      /* 指定一组将导入重新映射到其他查找位置的条目。 */</span><br><span class="line">    // &quot;rootDirs&quot;: [],                                   /* 在解析模块时，允许将多个文件夹视为一个文件夹。*/</span><br><span class="line">    // &quot;typeRoots&quot;: [],                                  /* 指定多个类似于`./node_modules/@的`类型的文件夹。 */</span><br><span class="line">    // &quot;types&quot;: [],                                      /* 指定要在源文件中引用的类型包名。 */</span><br><span class="line">    // &quot;allowUmdGlobalAccess&quot;: true,                     /* 允许从模块访问UMD全局文件。 */</span><br><span class="line">    // &quot;resolveJsonModule&quot;: true,                        /* 启用导入.json文件 */</span><br><span class="line">    // &quot;noResolve&quot;: true,                                /* 不允许`import`，`require`或`reference`来扩展类型应该添加到项目的文件数量。*/</span><br><span class="line">    /* JavaScript Support */</span><br><span class="line">    // &quot;allowJs&quot;: true,                                  /* 允许JavaScript文件成为您的程序的一部分。使用`检查JS`选项从这些文件中获取错误。 */</span><br><span class="line">    // &quot;checkJs&quot;: true,                                  /* 在已检查类型的JavaScript文件中启用错误报告。 */</span><br><span class="line">    // &quot;maxNodeModuleJsDepth&quot;: 1,                        /* 指定用于从`node_modules`中检查JavaScript文件的最大文件夹深度。仅适用于`允许的Js`。 */</span><br><span class="line">    /* Emit */</span><br><span class="line">    // &quot;declaration&quot;: true,                              /* 从项目中的typeScript和JavaScript文件生成.d.ts文件。 */</span><br><span class="line">    // &quot;declarationMap&quot;: true,                           /* 为d.ts文件创建源集映射。 */</span><br><span class="line">    // &quot;emitDeclarationOnly&quot;: true,                      /* 只输出d.ts文件，而不输出JavaScript文件。 */</span><br><span class="line">    // &quot;sourceMap&quot;: true,                                /* 为发出的JavaScript文件创建源映射文件。 */</span><br><span class="line">    // &quot;outFile&quot;: &quot;./&quot;,                                  /* 指定一个将所有输出捆绑到一个JavaScript文件中的文件。如果`声明`为true，则还指定一个捆绑所有.d.ts输出的文件。 */</span><br><span class="line">    // &quot;outDir&quot;: &quot;./&quot;,                                   /* 为所有发出的文件指定一个输出文件夹。 */</span><br><span class="line">    //去除注释</span><br><span class="line">    // &quot;removeComments&quot;: true,                           /* 禁用注释 */</span><br><span class="line">    // &quot;noEmit&quot;: true,                                   /* 从编译中禁用emit文件。 */</span><br><span class="line">    // &quot;importHelpers&quot;: true,                            /* 允许从每个项目的tslib中导入一次助手函数，而不是为每个文件包含它们。 */</span><br><span class="line">    // &quot;importsNotUsedAsValues&quot;: &quot;remove&quot;,               /* 为仅用于类型的导入指定发射/检查行为 */</span><br><span class="line">    // &quot;downlevelIteration&quot;: true,                       /* Emit 更兼容，但冗长和性能较差的JavaScript的迭代。 */</span><br><span class="line">    // &quot;sourceRoot&quot;: &quot;&quot;,                                 /* 为调试器指定根路径以查找引用源代码的位置。 */</span><br><span class="line">    // &quot;mapRoot&quot;: &quot;&quot;,                                    /* 指定调试器应该定位映射文件的位置，而不是生成的位置。 */</span><br><span class="line">    // &quot;inlineSourceMap&quot;: true,                          /* 在发出的JavaScript中包含源源映射文件。*/</span><br><span class="line">    // &quot;inlineSources&quot;: true,                            /* 在发出的JavaScript中的源映射中包含源代码。 */</span><br><span class="line">    // &quot;emitBOM&quot;: true,                                  /* 在输出文件的开头发出UTF-8字节顺序标记(BOM)。 */</span><br><span class="line">    // &quot;newLine&quot;: &quot;crlf&quot;,                                /* 设置发射文件的换行符。 */</span><br><span class="line">    // &quot;stripInternal&quot;: true,                            /* 禁用在其JSDoc注释中具有`@internal`的发射声明。 */</span><br><span class="line">    // &quot;noEmitHelpers&quot;: true,                            /* 禁用在编译输出中生成自定义助手函数。 */</span><br><span class="line">    // &quot;noEmitOnError&quot;: true,                            /* 如果报告了任何类型检查错误，则禁用发射文件。 */</span><br><span class="line">    // &quot;preserveConstEnums&quot;: true,                       /* 禁用擦除生成的代码中的`常数枚举`声明。 */</span><br><span class="line">    // &quot;declarationDir&quot;: &quot;./&quot;,                           /* 为生成的声明文件的输出目录。 */</span><br><span class="line">    // &quot;preserveValueImports&quot;: true,                     /* 在JavaScript输出中保留未使用的导入值，否则将被删除。 */</span><br><span class="line">    /* Interop Constraints */</span><br><span class="line">    // &quot;isolatedModules&quot;: true,                          /* 确保每个文件都可以安全地传输，而不依赖于其他导入。 */</span><br><span class="line">    // &quot;allowSyntheticDefaultImports&quot;: true,             /* 当模块没有默认导出时，允许“从y导入x”。 */</span><br><span class="line">    &quot;esModuleInterop&quot;: true, /* 发出额外的JavaScript，以简化对导入CommonJS模块的支持。这使得`允许合成默认导入`以实现类型兼容性。    */</span><br><span class="line">    // &quot;preserveSymlinks&quot;: true,                         /* 禁用对符号链接到其实际路径的解析。这与节点中的同一标志相关联。 */</span><br><span class="line">    &quot;forceConsistentCasingInFileNames&quot;: true, /* 确保进口时外壳正确。 */</span><br><span class="line">    /* Type Checking */</span><br><span class="line">    //strict为true,代表下面的都是true</span><br><span class="line">    &quot;strict&quot;: true,</span><br><span class="line">    //                                    /* Enable all strict type-checking options. */</span><br><span class="line">    //不要求必须显示的设置any</span><br><span class="line">    // &quot;noImplicitAny&quot;: true,                            /*为隐含`任何`类型的表达式和声明启用错误报告  */</span><br><span class="line">    //不强制进行null监测</span><br><span class="line">    // &quot;strictNullChecks&quot;: true,                         /* 在类型检查时，考虑`null`和`未定义`。 */</span><br><span class="line">    // &quot;strictFunctionTypes&quot;: true,                      /* 在分配函数时，请检查以确保参数和返回值与子类型兼容 */</span><br><span class="line">    // &quot;strictBindCallApply&quot;: true,                      /* 检查`绑定`、`调用`和`应用`方法的参数是否与原始函数匹配。 */</span><br><span class="line">    // &quot;strictPropertyInitialization&quot;: true,             /* 检查在构造函数中已声明但未设置的类属性。 */</span><br><span class="line">    // &quot;noImplicitThis&quot;: true,                           /* 当`this`具有类型`any`时，启用错误报告。*/</span><br><span class="line">    // &quot;useUnknownInCatchVariables&quot;: true,               /* 将catch子句变量类型化为“unknown”，而不是“any”。 */</span><br><span class="line">    // &quot;alwaysStrict&quot;: true,                             /* 确保始终发出“严格使用”信号。 */</span><br><span class="line">    // &quot;noUnusedLocals&quot;: true,                           /* 在未读取局部变量时启用错误报告。*/</span><br><span class="line">    // &quot;noUnusedParameters&quot;: true,                       /* 在未读取函数参数时引发错误 */</span><br><span class="line">    // &quot;exactOptionalPropertyTypes&quot;: true,               /* 将可选的属性类型解释为已写入的，而不是添加“未定义的”。*/</span><br><span class="line">    // &quot;noImplicitReturns&quot;: true,                        /* 为不在函数中显式返回的代码路径启用错误报告。 */</span><br><span class="line">    // &quot;noFallthroughCasesInSwitch&quot;: true,               /* 为开关语句中的故障情况启用错误报告。*/</span><br><span class="line">    // &quot;noUncheckedIndexedAccess&quot;: true,                 /* 在索引签名结果中包含“未定义的”*/</span><br><span class="line">    // &quot;noImplicitOverride&quot;: true,                       /* 确保在派生类中标记覆盖成员。 */</span><br><span class="line">    // &quot;noPropertyAccessFromIndexSignature&quot;: true,       /* 对使用索引类型声明的密钥强制使用索引访问器 */</span><br><span class="line">    // &quot;allowUnusedLabels&quot;: true,                        /* 禁用对未使用的标签的错误报告。 */</span><br><span class="line">    // &quot;allowUnreachableCode&quot;: true,                     /* 禁用对不可达代码的错误报告。 */</span><br><span class="line">    /* Completeness */</span><br><span class="line">    // &quot;skipDefaultLibCheck&quot;: true,                      /* 跳过类型检查。d.ts类型脚本中包含的ts文件。 */</span><br><span class="line">    &quot;skipLibCheck&quot;: true /* 跳过类型检查所有。d.ts文件。 */</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>files</code> 配置项值是一个<strong>数组</strong>，用来指定了待编译文件，即<strong>入口文件</strong>。<br>当入口文件依赖其他文件时，不需要将被依赖文件也指定到 <code>files</code> 中，因为<strong>编译器会自动将所有的依赖文件归纳为编译对象</strong>，即 <code>index.ts</code> 依赖 <code>user.ts</code> 时，不需要在 <code>files</code> 中指定 <code>user.ts</code> ， <code>user.ts</code> 会自动纳入待编译文件。</p>
<h3 id="browserslistrc"><a href="#browserslistrc" class="headerlink" title=".browserslistrc"></a>.browserslistrc</h3><h3 id="commitlintrc-json"><a href="#commitlintrc-json" class="headerlink" title=".commitlintrc.json"></a>.commitlintrc.json</h3><h3 id="editorconfig"><a href="#editorconfig" class="headerlink" title=".editorconfig"></a>.editorconfig</h3><p><a href="https://link.juejin.cn/?target=https://editorconfig.org/">EditorConfig</a> 主要用于统一不同 IDE 编辑器的编码风格。</p>
<p>在项目根目录下添加 <code>.editorconfig</code> 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 表示是最顶层的 EditorConfig 配置文件</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line"># 表示所有文件适用</span><br><span class="line">[*]</span><br><span class="line"># 缩进风格（tab | space）</span><br><span class="line">indent_style = space</span><br><span class="line"># 控制换行类型(lf | cr | crlf)</span><br><span class="line">end_of_line = lf</span><br><span class="line"># 设置文件字符集为 utf-8</span><br><span class="line">charset = utf-8</span><br><span class="line"># 去除行首的任意空白字符</span><br><span class="line">trim_trailing_whitespace = true</span><br><span class="line"># 始终在文件末尾插入一个新行</span><br><span class="line">insert_final_newline = true</span><br><span class="line"></span><br><span class="line"># 表示仅 md 文件适用以下规则</span><br><span class="line">[*.md]</span><br><span class="line">max_line_length = off</span><br><span class="line">trim_trailing_whitespace = false</span><br><span class="line"></span><br><span class="line"># 表示仅 ts、js、vue、css 文件适用以下规则</span><br><span class="line">[*.&#123;ts,js,vue,css&#125;]</span><br><span class="line">indent_size = 2</span><br></pre></td></tr></table></figure>

<h3 id="eslintignore"><a href="#eslintignore" class="headerlink" title=".eslintignore"></a>.eslintignore</h3><h3 id="eslintrc-js"><a href="#eslintrc-js" class="headerlink" title=".eslintrc.js"></a>.eslintrc.js</h3><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a>.gitignore</h3><h3 id="npmrc"><a href="#npmrc" class="headerlink" title=".npmrc"></a>.npmrc</h3><h3 id="prettierrc"><a href="#prettierrc" class="headerlink" title=".prettierrc"></a>.prettierrc</h3><h3 id="stylelintrc-json"><a href="#stylelintrc-json" class="headerlink" title=".stylelintrc.json"></a>.stylelintrc.json</h3><h3 id="stylelint-config-js"><a href="#stylelint-config-js" class="headerlink" title="stylelint.config.js"></a>stylelint.config.js</h3><h3 id="babel-config-js"><a href="#babel-config-js" class="headerlink" title="babel.config.js"></a>babel.config.js</h3><h1 id="vue项目搭建"><a href="#vue项目搭建" class="headerlink" title="vue项目搭建"></a>vue项目搭建</h1><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="vue脚手架"><a href="#vue脚手架" class="headerlink" title="vue脚手架"></a>vue脚手架</h3><p><a href="https://cli.vuejs.org/zh/guide/">https://cli.vuejs.org/zh/guide/</a></p>
<ul>
<li><p><strong>CLI</strong></p>
<p>CLI (<code>@vue/cli</code>) 是一个全局安装的 npm 包，提供了终端里的 <code>vue</code> 命令。它可以通过 <code>vue create</code> 快速搭建一个新项目，也可以通过 <code>vue ui</code> 通过一套图形化界面管理你的所有项目</p>
</li>
<li><p><strong>CLI 服务</strong></p>
<p>CLI 服务 (<code>@vue/cli-service</code>) 是一个开发环境依赖。它是一个 npm 包，局部安装在每个 <code>@vue/cli</code> 创建的项目中。</p>
<p>CLI 服务是构建于 <a href="http://webpack.js.org/">webpack</a> 和 <a href="https://github.com/webpack/webpack-dev-server">webpack-dev-server</a> 之上的。它包含了：</p>
<ul>
<li>加载其它 CLI 插件的核心服务；</li>
<li>一个针对绝大部分应用优化过的内部的 webpack 配置；</li>
<li>项目内部的 <code>vue-cli-service</code> 命令，提供 <code>serve</code>、<code>build</code> 和 <code>inspect</code> 命令。</li>
</ul>
</li>
</ul>
<h3 id="vue2"><a href="#vue2" class="headerlink" title="vue2"></a>vue2</h3><p><a href="https://blog.csdn.net/weixin_44882488/article/details/124220864">https://blog.csdn.net/weixin_44882488/article/details/124220864</a></p>
<ol>
<li><p>安装脚手架：<code>npm install -g @vue/cli</code>，<code>npm i -g webpack webpack-cli</code></p>
</li>
<li><p>生成项目模板-可以自定义</p>
<p>vue create 文件夹名称</p>
</li>
</ol>
<h3 id="vue3"><a href="#vue3" class="headerlink" title="vue3"></a>vue3</h3><p><a href="https://juejin.cn/post/7156957907890733063">https://juejin.cn/post/7156957907890733063</a></p>
<h4 id="1-使用-vue-cli-创建"><a href="#1-使用-vue-cli-创建" class="headerlink" title="1.使用 vue-cli 创建"></a>1.使用 vue-cli 创建</h4><p>官方文档：<a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上</span></span><br><span class="line">vue --version</span><br><span class="line"><span class="comment">## 安装或者升级你的@vue/cli</span></span><br><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="comment">## 创建</span></span><br><span class="line">vue create vue_test</span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line"><span class="built_in">cd</span> vue_test</span><br><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

<h4 id="2-使用-vite-创建"><a href="#2-使用-vite-创建" class="headerlink" title="2.使用 vite 创建"></a>2.使用 vite 创建</h4><p>官方文档：<a href="https://v3.cn.vuejs.org/guide/installation.html#vite">https://v3.cn.vuejs.org/guide/installation.html#vite</a></p>
<p>vite官网：<a href="https://vitejs.cn/">https://vitejs.cn</a></p>
<ul>
<li>什么是vite？—— 新一代前端构建工具。</li>
<li>优势如下：<ul>
<li>开发环境中，无需打包操作，可快速的冷启动。</li>
<li>轻量快速的热重载（HMR）。</li>
<li>真正的按需编译，不再等待整个应用编译完成。</li>
</ul>
</li>
<li>传统构建 与 vite构建对比图</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 创建工程</span></span><br><span class="line">npm init vite-app &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 进入工程目录</span></span><br><span class="line"><span class="built_in">cd</span> &lt;project-name&gt;</span><br><span class="line"><span class="comment">## 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">## 运行</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法：vue-cli-service build [options] [entry|pattern]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"></span><br><span class="line">  --mode        指定环境模式 (默认值：production)</span><br><span class="line">  --dest        指定输出目录 (默认值：dist)</span><br><span class="line">  --modern      面向现代浏览器带自动回退地构建应用</span><br><span class="line">  --target      app | lib | wc | wc-async (默认值：app)</span><br><span class="line">  --name        库或 Web Components 模式下的名字 (默认值：package.json 中的 &quot;name&quot; 字段或入口文件名)</span><br><span class="line">  --no-clean    在构建项目之前不清除目标目录</span><br><span class="line">  --report      生成 report.html 以帮助分析包内容</span><br><span class="line">  --report-json 生成 report.json 以帮助分析包内容</span><br><span class="line">  --watch       监听文件变化</span><br></pre></td></tr></table></figure>

<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><blockquote>
<p>可以通过传递 <code>--mode</code> 选项参数为命令行覆写默认的模式</p>
</blockquote>
<ul>
<li><code>development</code> 模式用于 <code>vue-cli-service serve</code></li>
<li><code>test</code> 模式用于 <code>vue-cli-service test:unit</code></li>
<li><code>production</code> 模式用于 <code>vue-cli-service build</code> 和 <code>vue-cli-service test:e2e</code></li>
</ul>
<p>如果你想要在构建命令中使用开发环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vue-cli-service build --mode development</span><br></pre></td></tr></table></figure>

<p>当运行 <code>vue-cli-service</code> 命令时，所有的环境变量都从对应的<a href="https://cli.vuejs.org/zh/guide/mode-and-env.html#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F">环境文件</a>中载入</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>项目根目录中放置下列<strong>环境文件</strong>来指定环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.env                <span class="comment"># 在所有的环境中被载入</span></span><br><span class="line">.env.local          <span class="comment"># 在所有的环境中被载入，但会被 git 忽略</span></span><br><span class="line">.env.[mode]         <span class="comment"># 只在指定的模式中被载入</span></span><br><span class="line">.env.[mode].<span class="built_in">local</span>   <span class="comment"># 只在指定的模式中被载入，但会被 git 忽略</span></span><br></pre></td></tr></table></figure>

<p>只有 <code>NODE_ENV</code>，<code>BASE_URL</code> 和以 <code>VUE_APP_</code> 开头的变量将通过 <code>webpack.DefinePlugin</code> 静态地嵌入到<em>客户端侧</em>的代码中</p>
<p>使用环境变量:<code>console.log(process.env.VUE_APP_SECRET)</code></p>
<h2 id="插件-2"><a href="#插件-2" class="headerlink" title="插件"></a>插件</h2><h3 id="vscode插件"><a href="#vscode插件" class="headerlink" title="vscode插件"></a>vscode插件</h3><ul>
<li><p>Volar：<a href="https://zhuanlan.zhihu.com/p/401160130">https://zhuanlan.zhihu.com/p/401160130</a></p>
<ul>
<li><p>高亮、语法提示</p>
</li>
<li><p>不再需要唯一根标签</p>
</li>
<li><p><strong>编辑器快捷分割</strong></p>
<p><img src="https://pic2.zhimg.com/80/v2-269ce3438083a0827d879138006d3da1_1440w.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<ul>
<li><code>ref sugar</code>语法快捷改动支持</li>
</ul>
<h3 id="业务工具类"><a href="#业务工具类" class="headerlink" title="业务工具类"></a>业务工具类</h3><h4 id="循环滚动列表"><a href="#循环滚动列表" class="headerlink" title="循环滚动列表"></a>循环滚动列表</h4><ul>
<li>vue-seamless-scroll</li>
</ul>
<h4 id="图片资源懒加载"><a href="#图片资源懒加载" class="headerlink" title="图片资源懒加载"></a><strong>图片资源懒加载</strong></h4><p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p>
<p>（1）安装插件</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">npm install vue-lazyload --save-dev</span><br></pre></td></tr></table></figure>

<p>（2）在入口文件 man.js 中引入并使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> VueLazyload <span class="keyword">from</span> <span class="string">&#x27;vue-lazyload&#x27;</span></span><br></pre></td></tr></table></figure>

<p>然后再 vue 中直接使用</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">Vue.<span class="keyword">use</span>(VueLazyload)</span><br></pre></td></tr></table></figure>

<p>或者添加自定义选项</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">Vue.use(VueLazyload, &#123;</span><br><span class="line"><span class="symbol">preLoad:</span> <span class="number">1.3</span>,</span><br><span class="line"><span class="symbol">error:</span> <span class="comment">&#x27;dist/error.png&#x27;,</span></span><br><span class="line"><span class="symbol">loading:</span> <span class="comment">&#x27;dist/loading.gif&#x27;,</span></span><br><span class="line"><span class="symbol">attempt:</span> <span class="number">1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<p>以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。</p>
<h4 id="展示动态图片"><a href="#展示动态图片" class="headerlink" title="展示动态图片"></a>展示动态图片</h4><ul>
<li><a href="https://svga.io/index.html">https://svga.io/index.html</a></li>
</ul>
<h4 id="PWA-1"><a href="#PWA-1" class="headerlink" title="PWA"></a>PWA</h4><ul>
<li><strong>vue/cli-plugin-pwa只能在https,或者本地生产环境使用</strong></li>
</ul>
<h3 id="框架功能类"><a href="#框架功能类" class="headerlink" title="框架功能类"></a>框架功能类</h3><ul>
<li>ant-design-vue：vue2.0使用版本1，vue3.0使用版本2</li>
<li>Muse <a href="https://www.cnblogs.com/randomlee/p/10782710.html">https://www.cnblogs.com/randomlee/p/10782710.html</a></li>
<li>vue-class-component： <strong>用类的方式编写组件</strong> ， vue2.x 对 TS 的支持并不友好，所以 vue2.x 跟 TS 的整合，通常需要基于 vue-class-component 来用基于 class（类） 的组件书写方式。 </li>
</ul>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><ul>
<li>vue-ls:用于从Vue上下文中使用本地Storage，会话Storage和内存Storage</li>
</ul>
<h2 id="tip-3"><a href="#tip-3" class="headerlink" title="tip"></a>tip</h2><ul>
<li><p>组件内部引入第三方的js文件只在当前组件生效的办法</p>
<p><a href="https://www.cnblogs.com/qianxiaox/p/13826334.html">https://www.cnblogs.com/qianxiaox/p/13826334.html</a></p>
</li>
<li><h4 id="缓存导致编译问题"><a href="#缓存导致编译问题" class="headerlink" title="缓存导致编译问题"></a>缓存导致编译问题</h4><p><code>cache-loader</code> 会默认为 Vue/Babel/TypeScript 编译开启。文件会缓存在 <code>node_modules/.cache</code> 中——如果你遇到了编译方面的问题，记得先删掉缓存目录之后再试试看。</p>
</li>
</ul>
<h1 id="react项目搭建"><a href="#react项目搭建" class="headerlink" title="react项目搭建"></a>react项目搭建</h1><h2 id="脚⼿架create-react-app"><a href="#脚⼿架create-react-app" class="headerlink" title="脚⼿架create-react-app"></a>脚⼿架create-react-app</h2><p>全局安装create-react-app</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g create-react-app</span><br></pre></td></tr></table></figure>

<p>创建⼀个项⽬</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ create-react-app your-app 注意命名⽅式</span><br><span class="line"><span class="built_in">cd</span>  your-app</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure>

<h2 id="插件-3"><a href="#插件-3" class="headerlink" title="插件"></a>插件</h2><h3 id="底层编译类"><a href="#底层编译类" class="headerlink" title="底层编译类"></a>底层编译类</h3><h4 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h4><p> react 这个包，是专门用来创建React组件、组件生命周期等这些东西的；<br> react-dom 里面主要封装了和 DOM 操作相关的包，要把组件渲染到页面上</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br></pre></td></tr></table></figure>

<p>要使用 JSX 语法，必须先运行 <code>cnpm i babel-preset-react -D</code>，然后再 <code>.babelrc</code> 中添加 语法配置；</p>
<h3 id="框架功能类-1"><a href="#框架功能类-1" class="headerlink" title="框架功能类"></a>框架功能类</h3><ul>
<li>pubsub利用JavaScript进行发布/订阅的库</li>
<li>React 中保存页面状态vue/react-&gt;<strong>keep-alive</strong>/<strong>React Activation</strong></li>
</ul>
<h3 id="样式动画类"><a href="#样式动画类" class="headerlink" title="样式动画类"></a>样式动画类</h3><h4 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS-in-JS"></a>CSS-in-JS</h4><p>CSS-in-JS就是<strong>将应用的CSS样式写在JavaScript文件里面</strong>，而不是独立为一些<code>.css</code>，<code>.scss</code>或者<code>less</code>之类的文件，这样你就可以在CSS中使用一些属于JS的诸如模块声明，变量定义，函数调用和条件判断等语言特性来提供灵活的可扩展的样式定义。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">// 用 npm 安装</span><br><span class="line">npm install @material-ui/styles</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; makeStyles &#125; <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/styles&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/Button&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useStyles = makeStyles(&#123;</span><br><span class="line">  <span class="attr">root</span>: &#123;</span><br><span class="line">    <span class="attr">background</span>: <span class="string">&#x27;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)&#x27;</span>,</span><br><span class="line">    <span class="attr">border</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">borderRadius</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">boxShadow</span>: <span class="string">&#x27;0 3px 5px 2px rgba(255, 105, 135, .3)&#x27;</span>,</span><br><span class="line">    <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">48</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="string">&#x27;0 30px&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Hook</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> classes = useStyles();</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">className</span>=<span class="string">&#123;classes.root&#125;</span>&gt;</span>Hook<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; styled &#125; <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/styles&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">&#x27;@material-ui/core/Button&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyButton = styled(Button)(&#123;</span><br><span class="line">  <span class="attr">background</span>: <span class="string">&#x27;linear-gradient(45deg, #FE6B8B 30%, #FF8E53 90%)&#x27;</span>,</span><br><span class="line">  <span class="attr">border</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="attr">borderRadius</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">boxShadow</span>: <span class="string">&#x27;0 3px 5px 2px rgba(255, 105, 135, .3)&#x27;</span>,</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">48</span>,</span><br><span class="line">  <span class="attr">padding</span>: <span class="string">&#x27;0 30px&#x27;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">StyledComponents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyButton</span>&gt;</span>Styled Components<span class="tag">&lt;/<span class="name">MyButton</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> useStyles = makeStyles(&#123;</span><br><span class="line">  <span class="comment">// style rule</span></span><br><span class="line">  <span class="attr">foo</span>: <span class="function"><span class="params">props</span> =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: props.backgroundColor,</span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="attr">bar</span>: &#123;</span><br><span class="line">    <span class="comment">// CSS property</span></span><br><span class="line">    <span class="attr">color</span>: <span class="function"><span class="params">props</span> =&gt;</span> props.color,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了示例，我们模拟了这个属性</span></span><br><span class="line">  <span class="keyword">const</span> props = &#123; <span class="attr">backgroundColor</span>: <span class="string">&#x27;black&#x27;</span>, <span class="attr">color</span>: <span class="string">&#x27;white&#x27;</span> &#125;;</span><br><span class="line">  <span class="comment">// 将 props 作为 useStyles() 的第一个属性传入</span></span><br><span class="line">  <span class="keyword">const</span> classes = useStyles(props);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">classes.foo</span>&#125; $&#123;<span class="attr">classes.bar</span>&#125;`&#125; /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="样式动画库"><a href="#样式动画库" class="headerlink" title="样式动画库"></a>样式动画库</h4><p><a href="https://zhuanlan.zhihu.com/p/361065034">https://zhuanlan.zhihu.com/p/361065034</a></p>
<ul>
<li><a href="https://react-spring.io/basics">https://react-spring.io/basics</a></li>
<li><a href="https://reactcommunity.org/react-transition-group/">https://reactcommunity.org/react-transition-group/</a></li>
<li><a href="https://motion.ant.design/components/tween-one-cn">https://motion.ant.design/components/tween-one-cn</a></li>
<li><a href="http://textillate.js.org/">http://textillate.js.org/</a></li>
<li><a href="http://react-animations.herokuapp.com/">http://react-animations.herokuapp.com/</a></li>
<li><a href="https://www.framer.com/docs/">https://www.framer.com/docs/</a></li>
</ul>
<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="拖拽react-sortable-hoc"><a href="#拖拽react-sortable-hoc" class="headerlink" title="拖拽react-sortable-hoc"></a>拖拽react-sortable-hoc</h4><p>高阶函数（Higher Order Function）=&gt; 参数或返回值为函数组件</p>
<p><code>react-sortable-hoc</code> 提供了两个特别重要的 API ，分别是<code>SortableContainer 和 SortableElement</code> 看英文的意思也知道，<code>SortableElement</code>用来装饰每个要拖拽的组件，相对于<code>SortableContainer</code> 要装饰的组件，<code>SortableElement</code> 装饰的组件是子组件。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> SortableItem = SortableElement(<span class="function">(<span class="params">props: any</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>);</span><br><span class="line"><span class="keyword">const</span> SortableList1 = SortableContainer(<span class="function">(<span class="params">&#123; items &#125;: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;items.map((item: any, index: number) =&gt; (</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">SortableItem</span> <span class="attr">key</span>=<span class="string">&#123;</span>`<span class="attr">item-</span>$&#123;<span class="attr">item</span>&#125;<span class="attr">-</span>$&#123;<span class="attr">index</span>&#125;`&#125; <span class="attr">index</span>=<span class="string">&#123;index&#125;</span> <span class="attr">value</span>=<span class="string">&#123;item&#125;</span> &gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">RuleOne</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            &gt;</span><span class="tag">&lt;/<span class="name">RuleOne</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">SortableItem</span>&gt;</span></span></span><br><span class="line"><span class="xml">        ))&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">SortableList1</span> <span class="attr">items</span>=<span class="string">&#123;submitData[</span>&#x27;<span class="attr">rule1</span>&#x27;]<span class="attr">.ruleGroup</span>&#125; <span class="attr">useDragHandle</span> <span class="attr">disableAutoscroll</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">                <span class="attr">onSortEnd</span>=<span class="string">&#123;(&#123;</span> <span class="attr">oldIndex</span>, <span class="attr">newIndex</span> &#125;<span class="attr">:</span> <span class="attr">any</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="xml">                  if (oldIndex !== newIndex) &#123;</span></span><br><span class="line"><span class="xml">                    saveRules(submitData, () =&gt; &#123;</span></span><br><span class="line"><span class="xml">                      submitData[&#x27;rule1&#x27;].ruleGroup = 				 arrayMoveImmutable(submitData[&#x27;rule1&#x27;].ruleGroup, oldIndex, newIndex)</span></span><br><span class="line"><span class="xml">                    &#125;)</span></span><br><span class="line"><span class="xml">                  &#125;</span></span><br><span class="line"><span class="xml">                &#125;&#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>array-move</code> 就一个 API，它的主要作用就是<strong>用来交换数组中元素的位置</strong>。我们用 node 进行调试 </p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引包</span></span><br><span class="line"><span class="keyword">const</span> arrayMove = <span class="built_in">require</span>(<span class="string">&#x27;array-move&#x27;</span>);</span><br><span class="line"><span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="keyword">const</span> input = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 以下三个排序实例</span></span><br><span class="line"><span class="built_in">console</span>.log(arrayMove(input, <span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"><span class="comment">//=&gt; [&#x27;a&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(arrayMove(input, -<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//=&gt; [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;b&#x27;]</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(arrayMove(input, -<span class="number">2</span>, -<span class="number">3</span>));</span><br><span class="line"><span class="comment">//=&gt; [&#x27;b&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><ul>
<li>react:usememo减少渲染</li>
<li>react,lazy路由懒加载,代码的分片</li>
</ul>
<h1 id="electron项目搭建"><a href="#electron项目搭建" class="headerlink" title="electron项目搭建"></a>electron项目搭建</h1><p><a href="https://blog.csdn.net/qq_28378665/article/details/128792446">https://blog.csdn.net/qq_28378665/article/details/128792446</a></p>
<p><a href="https://www.electron.build/configuration/configuration">https://www.electron.build/configuration/configuration</a></p>
<p><a href="https://jiangsihan.cn/archives/electron%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%93%E5%8C%85%E5%92%8C%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0">https://jiangsihan.cn/archives/electron%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%93%E5%8C%85%E5%92%8C%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm create vite@latest electron-vue3-demo -- --template vue-ts</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install electron -D</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">electron-builder打包工具：将已有的electron应用打包成msi格式和exe可执行文件的工具</span><br><span class="line">npm install electron-builder -D</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//vite 结合 electron 的库</span><br><span class="line">npm install vite-plugin-electron -D</span><br></pre></td></tr></table></figure>

<p>rimraf：快速删除文件或目录工具</p>
<p>electron-devtools-installer：electron 开发工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在打包生成的文件夹中，会有一个app.asar，它是Electron应用程序的主业务文件压缩包，要知道项目中哪些文件被pack到安装包，可以通过解压app.asar进行查看</span><br><span class="line">npm i asar -g</span><br><span class="line">asar extract app.asar ./app-folder</span><br></pre></td></tr></table></figure>



<h2 id="Vue项目转electron"><a href="#Vue项目转electron" class="headerlink" title="Vue项目转electron"></a>Vue项目转electron</h2><p><a href="https://www.bilibili.com/video/BV1SS4y1h7CL/?vd_source=f2241cf7d6cc0ae541b49e6fd828988b">https://www.bilibili.com/video/BV1SS4y1h7CL/?vd_source=f2241cf7d6cc0ae541b49e6fd828988b</a></p>
<h2 id="tip-4"><a href="#tip-4" class="headerlink" title="tip"></a>tip</h2><ul>
<li><p>打包慢 electron winCodeSign-2.6.0.7z 离线下载</p>
<p><a href="https://blog.csdn.net/qq_32682301/article/details/105234408">https://blog.csdn.net/qq_32682301/article/details/105234408</a></p>
</li>
</ul>
<h1 id="Theia"><a href="#Theia" class="headerlink" title="Theia"></a>Theia</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p><strong>Eclipse Theia 不是一个 IDE，而是一个用来开发 IDE 的框架。是Eclipse 基金会打造的云端及桌面IDE框架，该产品旨在替代微软的 Visual Studio Code</strong></p>
</blockquote>
<p>Theia 能够是一个桌面应用，也能够在浏览器和远程服务中运行。为了用同一套代码，支持桌面应用和webIDE，Theia 运行在两个独立的进程中。这个进程分别被称为前端和后端，它们经过WebSockets上的JSON-RPC消息或HTTP上的REST api进行通讯。在桌面应用中，后端和前端都在本地运行，而在远程上下文中后端将在远程主机上运行。web</p>
<p>前端和后端流程都有它们的依赖注入容器，能够贡献扩展。express</p>
<ul>
<li>前端</li>
</ul>
<p>前端进程表明客户端而且担任呈现UI的职责。在浏览器中，它简单的在渲染循环中运行，而在Electron中，它在Electron 的窗口中运行，Electron 窗口是一个基本的带有附加Electron和Node.js api的浏览器。而任何前端代码均可以假设浏览器是一个平台，而不用关联Node.js。后端</p>
<ul>
<li>后端</li>
</ul>
<p>后端进程运行在Node.js上。咱们使用express做为HTTP服务器。它可能不须要使用任何依赖浏览器做为平台的代码（DOM api）。后端应用程序的启动将首先加载全部贡献扩展的DI模块，而后得到BackendApplication的实例并在其上调用start(portNumber)。默认状况下，后台的express服务器也为前台提供代码。api</p>
<ul>
<li>平台分离</li>
</ul>
<p>在扩展程序的顶层文件夹中，咱们还有一个附加的文件夹层，能够按平台分开：浏览器</p>
<ul>
<li>common文件夹包含不依赖于任何运行时的代码。服务器</li>
<li>浏览器文件夹包含要求使用现代浏览器做为平台（DOM API）的代码。架构</li>
<li>电子浏览器文件夹包含须要DOM API以及Electron渲染器过程特定的API的前端代码。eclipse</li>
<li>节点文件夹包含（后端）代码，须要Node.js做为平台。</li>
<li>node-electron文件夹包含特定于Electron的（后端）代码。</li>
</ul>
<h3 id="Cloud-IDE-架构"><a href="#Cloud-IDE-架构" class="headerlink" title="Cloud IDE 架构"></a>Cloud IDE 架构</h3><p>Cloud IDE 主要包含 Client、Server、Container Pool 三部分。</p>
<ul>
<li>Client: 客户端也是最重要的端，将代码编辑等本地功能移植到浏览器中。</li>
<li>Server: 服务端也是控制端，包括管理数据交互及资源调度。</li>
<li>Container Pool: 运行时，用户代码真正运行的容器环境。</li>
</ul>
<p>三者之间最典型的架构如下图所示：</p>
<p><img src="https://zhaomenghuan.js.org/assets/img/cloud-ide-architecture.a0467b7b.png" alt="img"></p>
<h2 id="环境配置-1"><a href="#环境配置-1" class="headerlink" title="环境配置"></a>环境配置</h2><p><a href="https://www.cnblogs.com/fanqisoft/p/13171657.html">https://www.cnblogs.com/fanqisoft/p/13171657.html</a></p>
<p><a href="https://github.com/eclipse-theia/theia/blob/master/doc/Developing.md">https://github.com/eclipse-theia/theia/blob/master/doc/Developing.md</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">win11 - 从磁盘到项目文件的路径中不能有中文。因为一些引用路径是用的绝对路径，如果用中文，一些方法是无法识别文件路径的（PS：我猜主要还是国外的人写的，并没有适配语言）</span><br><span class="line"></span><br><span class="line">--pyenv</span><br><span class="line">		--Python 3.9.13</span><br><span class="line">--nvm</span><br><span class="line">	--node v18.14.0</span><br><span class="line">		--npm 8.3.1</span><br><span class="line">		--yarn 1.22.19</span><br><span class="line">vs 2022/2017(具体看下面配置详情，我用的是2022)</span><br><span class="line">node-gyp: v9.3.1</span><br></pre></td></tr></table></figure>

<h3 id="下载node-gyp"><a href="#下载node-gyp" class="headerlink" title="下载node-gyp"></a>下载node-gyp</h3><p>node-gyp查找VS安装路径简单解析：<a href="https://juejin.cn/post/6949529951284494344%EF%BC%88**PS%EF%BC%9A%E9%80%9A%E8%BF%87find-visualstudio.js%E6%96%87%E4%BB%B6%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8FVSINSTALLDIR%E3%80%82%E8%BF%99%E4%B8%AA%E8%83%BD%E8%AE%A9node-gyp%E6%89%BE%E5%88%B0vs%E7%9A%84%E4%BD%8D%E7%BD%AE**%EF%BC%89">https://juejin.cn/post/6949529951284494344（**PS：通过find-visualstudio.js文件，需要在配置环境用户变量VSINSTALLDIR。这个能让node-gyp找到vs的位置**）</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">环境变量-》用户变量</span><br><span class="line">VCINSTALLDIR=C:\Program Files\Microsoft Visual Studio\2022\Community\VC</span><br></pre></td></tr></table></figure>

<p>github: <a href="https://github.com/nodejs/node-gyp#on-windows">https://github.com/nodejs/node-gyp#on-windows</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm i -g node-gyp@last</span><br><span class="line"></span><br><span class="line">node-gyp configure --msvs_version=2017</span><br><span class="line">node-gyp configure --msvs_version=2022</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果项目文件中依赖的node-gyp不是最新版本，node_modules/node-gyp/lib/find-visualstudio.js文件中可能没有针对2022版本的处理。</p>
</blockquote>
<h3 id="下载pyhon"><a href="#下载pyhon" class="headerlink" title="下载pyhon"></a>下载pyhon</h3><p>配置pyenv：<a href="https://blog.csdn.net/weixin_42289080/article/details/127997003">https://blog.csdn.net/weixin_42289080/article/details/127997003</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where python</span><br><span class="line"></span><br><span class="line"># 查看当前版本</span><br><span class="line">pyenv version</span><br><span class="line"></span><br><span class="line"># 查看所有版本</span><br><span class="line">pyenv versions</span><br><span class="line"></span><br><span class="line"># 查看所有可安装的版本</span><br><span class="line">pyenv install --list</span><br><span class="line"></span><br><span class="line"># 安装指定版本</span><br><span class="line">pyenv install 3.6.5</span><br><span class="line"># 安装新版本后rehash一下</span><br><span class="line">pyenv rehash</span><br><span class="line"></span><br><span class="line"># 删除指定版本</span><br><span class="line">pyenv uninstall 3.5.2</span><br><span class="line"></span><br><span class="line"># 指定全局版本</span><br><span class="line">pyenv global 3.6.5</span><br><span class="line"></span><br><span class="line"># 指定多个全局版本, 3版本优先</span><br><span class="line"># 实际上当你切换版本后, 相应的pip和包仓库都是会自动切换过去的</span><br><span class="line">pyenv global 3.6.5 2.7.14</span><br><span class="line"></span><br><span class="line"># 创建一个3.6.5版本的虚拟环境, 命名为v365env, 然后激活虚拟环境</span><br><span class="line">$ pyenv virtualenv 3.6.5 v365env</span><br><span class="line">$ pyenv activate v365env</span><br><span class="line"># 关闭虚拟环境</span><br><span class="line">$ pyenv deactivate v365env</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种方法：</span><br><span class="line">npm config set python python3.9.13 --global</span><br><span class="line">npm config set python &quot;D:\Python27\python.exe&quot;</span><br></pre></td></tr></table></figure>

<h3 id="安装C-C-编译工具"><a href="#安装C-C-编译工具" class="headerlink" title="安装C/C++编译工具"></a>安装C/C++编译工具</h3><ul>
<li><p>安装Visual Studio软件以及 C++ 相应的编译工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2022</span><br><span class="line">npm config set msbuild_path &quot;C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe&quot;</span><br><span class="line"></span><br><span class="line">2017</span><br><span class="line">npm config set msbuild_path &quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\MSBuild\15.0\Bin\MSBuild.exe&quot;</span><br><span class="line"></span><br><span class="line">npm config set msvs_version 2022 --global</span><br></pre></td></tr></table></figure>

<p><strong>win11系统,如果SDK报错,需要安装win10SDK</strong></p>
</li>
<li><p>纯前端开发者，只需要安装C/C++编译器工具即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以管理员身份执行 npm install -global -production windows-build-tools</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="配置环境变量或者npm配置"><a href="#配置环境变量或者npm配置" class="headerlink" title="配置环境变量或者npm配置"></a>配置环境变量或者npm配置</h3><p>配置npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set VCINSTALLDIR &quot;C:\Program Files\Microsoft Visual Studio\2022\Community\VC&quot; --global</span><br><span class="line">npm config set VCINSTALLDIR &quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\Community&quot; --global</span><br><span class="line">npm config delete msvs_version --global</span><br><span class="line">npm config get msvs_version</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//.npmrc</span><br><span class="line">python=D:\software\pyenv-win-master\pyenv-win\versions\3.9.13\python.exe</span><br><span class="line">msvs_version=2022</span><br><span class="line">GYP_MSVS_VERSION=2022</span><br><span class="line">msbuild_path=C:\Program Files\Microsoft Visual Studio\2022\Community\MSBuild\Current\Bin\MSBuild.exe120</span><br></pre></td></tr></table></figure>

<h3 id="依赖下载启动问题"><a href="#依赖下载启动问题" class="headerlink" title="依赖下载启动问题"></a>依赖下载启动问题</h3><ul>
<li><p>下载慢，将资源地址设置为淘宝镜像：yarn config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org/</a></p>
</li>
<li><p>每次更改依赖后下载或者启动有问题，最好删除node_module，以及yarn的缓存（PS：我就是没有去删除yarn缓存，启动服务启动失败）</p>
</li>
<li><p>从磁盘到项目文件的路径中不能有中文。因为一些引用路径是用的绝对路径，如果用中文，一些方法是无法识别文件路径的（PS：我猜主要还是国外的人写的，并没有适配语言）</p>
</li>
<li><p><code>THEIA_ELECTRON_SKIP_REPLACE_FFMPEG=1 yarn</code>，忽略FFMPEG去下载，我的win11找不到FFMPEG的共享库</p>
</li>
<li><p>Module did not self-register drivelist</p>
<p><code>cd ./node_modules/drivelist &amp;&amp; ../.bin/electron-rebuild</code></p>
</li>
</ul>
<h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><p>由于 Theia 及其扩展是 Node.js 包，而 Theia 应用程序是包的集合，因此启动 Theia 及所选扩展的一个非常简单的方法就是创建一个 package.json。</p>
<p>参考文档：<a href="https://theia-ide.org/docs/composing_applications">Build your own IDE</a></p>
<h3 id="theia-blueprint"><a href="#theia-blueprint" class="headerlink" title="theia-blueprint"></a>theia-blueprint</h3><blockquote>
<p>整个工程使用 <a href="https://www.lernajs.cn/">Lerna</a> 配置 mono-repo构建</p>
</blockquote>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">resources：electron打包常用一些资源，像应用的图标。</span><br><span class="line">scripts：存放打包使用的脚本，像签名应用程序的脚本。</span><br><span class="line">test：存放测试脚本</span><br><span class="line">electron-builder.yml：electron-builder打包的配置文件</span><br><span class="line">webpack.config.js：webpack的相关配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">执行theia build生成文件</span><br><span class="line">lib：构建生成的Bundle包</span><br><span class="line">plugins：执行download:plugins时下载的插件包</span><br><span class="line">src-gen：theia命令自动生成的工程文件</span><br><span class="line">gen-webpack.config.js：theia自动生成的webpack配置文件，由webpack.config.js引入</span><br></pre></td></tr></table></figure>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ... others</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;prepare&quot;: &quot;yarn run clean &amp;&amp; yarn build &amp;&amp; yarn run download:plugins&quot;,</span><br><span class="line">    &quot;clean&quot;: &quot;theia clean&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;theia build --mode development&quot;,</span><br><span class="line">    &quot;start&quot;: &quot;theia start --plugins=local-dir:plugins&quot;,</span><br><span class="line">    &quot;download:plugins&quot;: &quot;theia download:plugins&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;theiaPluginsDir&quot;: &quot;plugins&quot;,</span><br><span class="line">  &quot;theiaPlugins&quot;: &#123;</span><br><span class="line">    &quot;vscode-builtin-css&quot;: &quot;https://github.com/theia-ide/vscode-builtin-extensions/releases/download/v1.39.1-prel/css-1.39.1-prel.vsix&quot;,</span><br><span class="line">    &quot;vscode-builtin-html&quot;: &quot;https://github.com/theia-ide/vscode-builtin-extensions/releases/download/v1.39.1-prel/html-1.39.1-prel.vsix&quot;,</span><br><span class="line">    &quot;vscode-builtin-javascript&quot;: &quot;https://github.com/theia-ide/vscode-builtin-extensions/releases/download/v1.39.1-prel/javascript-1.39.1-prel.vsix&quot;,</span><br><span class="line">    &quot;vscode-builtin-json&quot;: &quot;https://github.com/theia-ide/vscode-builtin-extensions/releases/download/v1.39.1-prel/json-1.39.1-prel.vsix&quot;,</span><br><span class="line">    &quot;vscode-builtin-markdown&quot;: &quot;https://github.com/theia-ide/vscode-builtin-extensions/releases/download/v1.39.1-prel/markdown-1.39.1-prel.vsix&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加了 <code>theiaPluginsDir</code> 和 <code>theiaPlugins</code> 这两个属性。<code>theiaPluginsDir</code> 是用来设置我们的插件存放地址的，<code>theiaPlugins</code> 就是我们要安装的插件了</p>
<p>运行项目之前，我们要先运行 <code>yarn prepare</code> 来准备环境，我们会在日志中看到插件的下载情况：</p>
<img src="https://filescdn.proginn.com/7c83f3432ed8a589252b317ee06d6fa7/f96f7edabdc81c2ef450b7c2d36a7910.webp" alt="img" style="zoom:50%;" />

<p>这些插件都会放在当前目录下的 <code>plugins</code> 文件夹下</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><blockquote>
<p>theia这个命令是来自devDependencies配置的@theia/cli</p>
</blockquote>
<ol>
<li><p>yarn</p>
</li>
<li><p>构建项目</p>
<p>yarn theia build</p>
<p>这个命令主要是用来生成项目代码的，包含源码，webpack 配置文件以及 webpack 打包后的文件。运行成功的结果如下：</p>
<img src="https://filescdn.proginn.com/d05291a3b98337f6c674bea4fb3fd4c5/b02c8904786bf30dcd904ebe54ad2541.webp" alt="img" style="zoom:50%;" />

<ul>
<li>lib：构建生成的Bundle包</li>
<li>plugins：执行download:plugins时下载的插件包</li>
<li>src-gen：theia命令自动生成的工程文件</li>
<li>gen-webpack.config.js：theia自动生成的webpack配置文件，由webpack.config.js引入</li>
</ul>
</li>
<li><p>运行 Theia IDE</p>
<p>yarn theia start</p>
</li>
<li></li>
</ol>
<ul>
<li><code>theia rebuild:browser</code>：构建环境切换到 <code>browser</code></li>
<li><code>theia rebuild:electron</code>：构建环境切换到 <code>electron</code></li>
</ul>
<h2 id="theia包"><a href="#theia包" class="headerlink" title="theia包"></a>theia包</h2><ul>
<li>application-manager：应用工程管理器，提供 Frontend、Backend、Webpack 代码生成</li>
<li>application-package：应用 package.json 配置解析，管理 Application、Extensions</li>
<li>cli：是一个命令行工具，用于管理基于 Theia 的应用程序，为扩展和应用程序开发提供了有用的脚本和命令</li>
<li>ffmpeg：是一个<a href="https://xie.infoq.cn/link?target=https://nodejs.org/docs/latest-v14.x/api/n-api.html">Node Native 插件</a>，用于动态链接到 Electronffmpeg.dll 并获取包含的编解码器列表</li>
<li>localization-manager：用于为不同语言创建 Theia 和 Theia 扩展的本地化</li>
<li>ovsx-client：该包用于通过其 REST API@theia/ovsx-client 进行交互。open-vsx 该包允许客户端获取扩展及其元数据、搜索注册表，并包含必要的逻辑来根据提供的支持的 API 版本确定兼容性</li>
<li>private-eslint-plugin：对 Eclipse Theia 开发有用的 @theia/eslint-plugin 贡献规则。该插件通过静态分析帮助识别开发过程中的问题，包括代码质量、潜在问题和代码异常。</li>
<li>private-ext-scripts：是一个命令行工具，用于在 Theia 包中运行共享的 npm 脚本</li>
<li>private-re-exports：用于重新导出依赖项</li>
<li>request：发送代理请求的库</li>
<li>search-in-workspace` 负责搜索模块</li>
<li>terminal` 负责终端模块等</li>
</ul>
<h1 id="Monorepo"><a href="#Monorepo" class="headerlink" title="Monorepo"></a>Monorepo</h1><p>什么是 Monorepo ?</p>
<p><code>Monorepo</code>是管理项目代码的方式之一，指在一个大的项目仓库（repo）中 管理多个模块/包（package），这种类型的项目大都在项目根目录下有一个packages文件夹，分多个项目管理。大概结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">├── packages</span><br><span class="line">|   ├── pkg1</span><br><span class="line">|   |   ├── package.json</span><br><span class="line">|   ├── pkg2</span><br><span class="line">|   |   ├── package.json</span><br><span class="line">├── package.json</span><br></pre></td></tr></table></figure>

<p>目前很很多大型项目采用这样的结构，比如：<code>Babel</code>、<code>vue3</code>和<code>vite</code>等。</p>
<p>Monorepo 的好处在哪里嘞？</p>
<ul>
<li><strong>统一管理</strong>。比如微前端项目，多个子应用可以放在同一个<code>monorepo</code>中方便管理；后端用<code>node.js</code>的项目放在<code>monorepo</code>中也可以使用同一套技术栈管理。在CI/CD等流水线过程中，方便统一迭代或升级版本，也方便做通用化的配置，适用到多个子项目当中。</li>
<li><strong>依赖提升</strong>。如果多个项目都依赖了诸如<code>react</code>、<code>vue</code>或<code>TypeScript</code>等常用库，那可以通过<code>lerna</code>或者<code>yarn workspace</code>将依赖提升到最外层，多个子模块/包复用同一个依赖，减小项目体积。</li>
</ul>
<h2 id="lerna"><a href="#lerna" class="headerlink" title="lerna"></a>lerna</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p><a href="https://gitcode.net/mirrors/lerna/lerna?utm_source=csdn_github_accelerator">https://gitcode.net/mirrors/lerna/lerna?utm_source=csdn_github_accelerator</a></p>
<p><a href="https://blog.csdn.net/a357951314/article/details/111314875">https://blog.csdn.net/a357951314/article/details/111314875</a></p>
<h4 id="lerna-init"><a href="#lerna-init" class="headerlink" title="lerna init"></a>lerna init</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lerna.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;lerna&quot;: &quot;4.0.0&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.0&quot;,</span><br><span class="line">  &quot;useWorkspaces&quot;: true,</span><br><span class="line">  &quot;npmClient&quot;: &quot;yarn&quot;,//定义我们需要的包管理工具为yarn</span><br><span class="line">  &quot;command&quot;: &#123;</span><br><span class="line">    &quot;run&quot;: &#123;</span><br><span class="line">      &quot;stream&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;root&quot;,</span><br><span class="line">  //因为mono-repo本身的这个Git仓库并不是一个项目，他是多个项目，所以他自己不能直接发布</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  //用来指定你需要管理的package的目录，默认配置是packages下面的第一级目录下的项目文件夹</span><br><span class="line">  &quot;workspaces&quot;: [</span><br><span class="line">    &quot;packages/*&quot;</span><br><span class="line">  ],</span><br><span class="line">  //如果需要添加其他目录，例如前后端一起的monorepo，可以修改为</span><br><span class="line">  &quot;packages&quot;: [</span><br><span class="line">    &quot;servers/*&quot;, &quot;frontend/*&quot;</span><br><span class="line">  ]</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;lerna&quot;: &quot;^6.6.1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="lerna-create"><a href="#lerna-create" class="headerlink" title="lerna create"></a>lerna create</h4><p><code>lerna create</code> 添加package</p>
<h4 id="lerna-add"><a href="#lerna-add" class="headerlink" title="lerna add"></a>lerna add</h4><p>执行 <code>lerna add</code> 为特定package或这所有package添加依赖</p>
<p>注意默认lerna add会在每个子package中添加依赖，执行 <code>lerna bootstrap --hoist</code>重新提取公共依赖</p>
<h4 id="lerna-run"><a href="#lerna-run" class="headerlink" title="lerna run"></a>lerna run</h4><p>我们可以使用<code>lerna run</code>指令，去运行每个包中包含有相关package script的相关命令</p>
<p>lerna run –parallel start</p>
<p><code>--parallel</code>参数就是指为项目的中需要一直的进程，打印所有子进程的输出。说得有点绕，理解为需要一直运行的就加上这个参数就可以了</p>
<h4 id="lerna-bootstrap"><a href="#lerna-bootstrap" class="headerlink" title="lerna bootstrap"></a>lerna bootstrap</h4><p>使用下面命令，可以安装所有包的<code>package.json</code>中的dependencies</p>
<h4 id="lerna-clean"><a href="#lerna-clean" class="headerlink" title="lerna clean"></a>lerna clean</h4><p>删除已经安装的子项目<code>node_modules</code></p>
<h3 id="公共的包"><a href="#公共的包" class="headerlink" title="公共的包"></a>公共的包</h3><p>我们可以将公共的包安装在根目录下的<code>package.json</code>下，例如，你是前端微服务的项目而且是使用react作为主要技术栈的，可以把<code>react</code>、<code>react-dom</code>等安装在根目录下，packages都是可以直接引用的</p>
<p>更常用的是一些项目规范的配置，例如<code>eslint</code>、<code>prettier</code>、<code>tsconfig</code>之类的，也可以直接安装在根目录下</p>
<p>把公共包提取出来的好处有：</p>
<ul>
<li>所有包用的依赖包版本都是一致的</li>
<li>做一些包的升级和像github进行包检查时，更方便地进行升级</li>
<li>安装依赖包的时间可以更少</li>
<li>需要更少的存储空间</li>
</ul>
<h3 id="项目中包与包之间的引用"><a href="#项目中包与包之间的引用" class="headerlink" title="项目中包与包之间的引用"></a>项目中包与包之间的引用</h3><p>如果我们packages里面需要进行互相引用</p>
<p>我们使用<code>lerna add</code>命令，可以为指定的包安装第三方的或者本地的包，这个指令和<code>yarn add</code>或者<code>npm install</code>实质上是类似的，下面是一些来自文档的一些例子</p>
<h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p><a href="https://blog.csdn.net/dennis_jiang/article/details/112181925">https://blog.csdn.net/dennis_jiang/article/details/112181925</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── lerna.json</span><br><span class="line">├── package.json</span><br><span class="line">└── packages</span><br><span class="line">    ├── vue1</span><br><span class="line">    │   ├── __tests__</span><br><span class="line">    │   ├── lib</span><br><span class="line">    │   ├── README.md</span><br><span class="line">    │   └── package.json</span><br><span class="line">    └── vue2</span><br><span class="line">        ├── __tests__</span><br><span class="line">        ├── lib</span><br><span class="line">        ├── README.md</span><br><span class="line">        └── package.json</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>lerna init</p>
</li>
<li><p>packages目录下创建子项目模块</p>
<blockquote>
<p>按照<code>mono-repo</code>的惯例，这几个子项目的名称最好命名为<code>@&lt;主项目名称&gt;/&lt;子项目名称&gt;</code>，这样当别人引用你的时候，你的这几个项目都可以在<code>node_modules</code>的同一个目录下面，目录名字就是<code>@&lt;主项目名称&gt;</code>，所以我们手动改下三个子项目<code>package.json</code>里面的<code>name</code></p>
</blockquote>
<p>这里我按照vue项目流程创建</p>
</li>
<li><p>lerna bootstrap</p>
<p>packages/下面的每个子项目有自己的node_modules，如果将它打开，会发现很多重复的依赖包，这会占用我们大量的硬盘空间。lerna提供了另一个强大的功能：将子项目的依赖包都提取到最顶层，我们只需要先删除子项目的node_modules再跑下面这行命令就行了：lerna bootstrap –hoist</p>
<p>lerna bootstrap –hoist虽然可以将子项目的依赖提升到顶层，但是他的方式比较粗暴：先在每个子项目运行npm install，等所有依赖都安装好后，将他们移动到顶层的node_modules。这会导致一个问题，如果多个子项目依赖同一个第三方库，但是<strong>需求的版本不同怎么办</strong>？比如我们三个子项目都依赖antd，但是他们的版本不完全一样</p>
<blockquote>
<p>vue1和vue2项目需要的element版本都是3.1.0，但是common需要的版本却是4.9.4，如果使用lerna bootstrap –hoist来进行提升，lerna会提升用的最多的版本，也就是3.1.0到顶层，然后把子项目的node_modules里面的antd都删了。也就是说common去访问element的话，也会拿到3.1.0的版本，这可能会导致common项目工作不正常</p>
</blockquote>
<p>yarn workspace可以解决前面说的版本不一致的问题。<code>lerna bootstrap --hoist</code>会把所有子项目用的最多的版本移动到顶层，而<code>yarn workspace</code> 则会检查每个子项目里面依赖及其版本，如果版本不一样则会留在子项目自己的<code>node_modules</code>里面，只有完全一样的依赖才会提升到顶层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 顶层package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;workspaces&quot;: [</span><br><span class="line">    &quot;packages/*&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// lerna.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;npmClient&quot;: &quot;yarn&quot;,</span><br><span class="line">  &quot;useWorkspaces&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用了<code>yarn workspace</code>，我们就不用<code>lerna bootstrap</code>来安装依赖了，而是像以前一样<code>yarn install</code>就行了，他会自动帮我们提升依赖，这里的<code>yarn install</code>无论在顶层运行还是在任意一个子项目运行效果都是一样的。</p>
</li>
<li><p>在顶层运行了<code>lerna run start</code>，这相当于去每个子项目下面都去执行<code>yarn run start</code>或者<code>npm run start</code>，具体是<code>yarn</code>还是<code>npm</code>，取决于你在<code>lerna.json</code>里面的这个设置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;npmClient&quot;</span>: <span class="string">&quot;yarn&quot;</span>    </span><br></pre></td></tr></table></figure>

<p>只想在其中一个子项目运行命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 顶层package.json</span><br><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start:vue&quot;: &quot;lerna --scope @mono-repo-demo/vue run start&quot;//--scope来指定在管理员子项目下运行</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>引入公共组件：lerna add @mono-repo-demo/common –scope @mono-repo-demo/vue1</p>
</li>
</ul>
<p>  common 组件写好了，我们就在vue1里面引用下他，要引用上面的组件，我们需要先在vue1的package.json里面将这个依赖加上，我们可以去手动修改他，也可以使用lerna命令：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//packages\vue\package</span><br><span class="line">&quot;dependencies&quot;: &#123;</span><br><span class="line">   &quot;@mono-repo-demo/common&quot;: &quot;^0.0.0&quot;,</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>



<h2 id="mono-repo管理electron和web"><a href="#mono-repo管理electron和web" class="headerlink" title="mono-repo管理electron和web"></a>mono-repo管理electron和web</h2><p>electron和web一致</p>
<h1 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h1><h2 id="规范的意义"><a href="#规范的意义" class="headerlink" title="规范的意义"></a>规范的意义</h2><p>每个程序员都有自己的编码习惯，最常见的莫过于：</p>
<ul>
<li>有的人写代码一行代码结尾必须加分号 <code>;</code>，有的人觉得不加分号 <code>;</code> 更好看；</li>
<li>有的人写代码一行代码不会超过 80 个字符，认为这样看起来简洁明了，有的人喜欢把所有逻辑都写在一行代码上，觉得别人看不懂的代码很牛逼；</li>
<li>有的人使用变量必然会先定义 <code>var a = 10;</code>，而粗心的人写变量可能没有定义过就直接使用 <code>b = 10;</code>；</li>
</ul>
<p>如果你写自己的项目怎么折腾都没关系，但是在公司中老板希望每个人写出的代码都要符合一个统一的规则，这样别人看源码就能够看得懂，因为源码是符合统一的编码规范制定的。</p>
<p>那么问题来了，总不能每个人写的代码老板都要一行行代码去检查吧，这是一件很蠢的事情。凡是重复性的工作，都应该被制作成工具来节约成本。这个工具应该做两件事情：</p>
<ul>
<li>提供编码规范；</li>
<li>提供自动检验代码的程序，并打印检验结果：告诉你哪一个文件哪一行代码不符合哪一条编码规范，方便你去修改代码。</li>
</ul>
<p>Lint 因此而诞生。Lint 是检验代码格式工具的一个统称，具体的工具有 <code>Jslint</code> 、 <code>Eslint</code> 等等</p>
<h2 id="检测方式"><a href="#检测方式" class="headerlink" title="检测方式"></a>检测方式</h2><p>检测可分为两种方式</p>
<ul>
<li><strong>使用编辑器的扩展</strong></li>
<li><strong>使用脚本的方式</strong></li>
</ul>
<p><strong>第一种方式其实适合个人开发，第二种方式适合团队开发。</strong></p>
<p>至于为什么这么说，就要考虑到二者的优先级问题了。上面两种方式如果同时存在的话，会有优先级的问题。</p>
<p><strong>.prettierrc 的优先级会高于在vscode全局配置settings.json中格式化配置的优先级（同理eslint）</strong></p>
<p>也就是说，如果你在一个项目中有 .prettierrc 配置文件，然后你又在settings.json也配置了格式化规则，那么当你在vscode编辑器中对一个文件点击鼠标右键[格式化文档]的时候，格式化规则会以 .prettierrc 为准</p>
<h2 id="Eslint-代码质量"><a href="#Eslint-代码质量" class="headerlink" title="Eslint(代码质量)"></a>Eslint(代码质量)</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>ESLint 是什么呢？<br>是一个开源的 JavaScript 的 linting 工具，使用 <a href="https://link.zhihu.com/?target=https://github.com/eslint/espree">espree</a> 将 JavaScript 代码解析成抽象语法树 (AST)，然后通过AST 来分析我们代码，从而给予我们两种提示：</p>
<ol>
<li><strong>代码质量问题</strong></li>
<li><strong>代码风格问题</strong>（ESLint 之类的 Linters 对于代码格式化的能力是有限的，不如 Prettier 那么专业。通过 Prettier 执行格式化代码的工作，而代码质量的控制由 ESLint 处理）</li>
</ol>
<p>获得如下收益：</p>
<ul>
<li>在执行代码之前发现并修复语法错误，减少调试耗时和潜在 bug</li>
<li>保证项目的编码风格统一，提高可维护性</li>
<li>督促团队成员在编码时遵守约定的最佳实践，提高代码质量</li>
</ul>
<p>ESLint 可以让程序员在编码的过程中发现问题而不是在执行的过程中，还可以让让程序员可以创建自己的检测规则。ESLint 的所有规则都被设计成可插拔的。为了便于人们使用，ESLint 内置了一些规则，当然，你可以在使用过程中自定义规则。所有的规则默认都是禁用的。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>生成流程：<a href="https://blog.csdn.net/shenxianhui1995/article/details/103035013">https://blog.csdn.net/shenxianhui1995/article/details/103035013</a></p>
<p>如果你想你所有项目都使用eslint，请全局安装；如果你想当前项目使用，请局部安装。</p>
<ul>
<li>全局安装：<ul>
<li> <code>npm install -g eslint</code></li>
<li><code>eslint --init</code></li>
</ul>
</li>
<li>项目安装：<ul>
<li> <code>npm install eslint --save-dev</code></li>
<li><code>./node_modules/.bin/eslint --init </code></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">? How would you like to use ESLint? (Use arrow keys) // 你想怎样使用eslint</span><br><span class="line">  To check syntax only </span><br><span class="line">  //只检查语法</span><br><span class="line">&gt; To check syntax and find problems</span><br><span class="line">  //检查语法、发现问题</span><br><span class="line">  To check syntax, find problems, and enforce code style</span><br><span class="line">  //检查语法、发现问题并执行代码样式</span><br></pre></td></tr></table></figure>

<h3 id="eslint配置"><a href="#eslint配置" class="headerlink" title="eslint配置"></a>eslint配置</h3><p><a href="https://www.cnblogs.com/jiaoshou/p/11218526.html">https://www.cnblogs.com/jiaoshou/p/11218526.html</a></p>
<ol>
<li>一般都采用.eslintrc.的配置文件进行配置, 如果放在项目的根目录中，则会作用于整个项目。如果在项目的子目录中也包含着.eslintrc文件，则对于子目录中文件的检查会忽略掉根目录中的配置，而直接采用子目录中的配置，这就能够在不同的目录范围内应用不同的检查规则，显得比较灵活。ESLint采用逐级向上查找的方式查找.eslintrc.文件，当找到带有”root”: true配置项的.eslintrc.文件时，将会停止向上查找。</li>
<li>在 package.json文件里的 eslintConfig 字段进行配置。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * 参考文档</span><br><span class="line"> * 【eslint英文文档】https://eslint.org/docs/user-guide/configuring</span><br><span class="line"> * 【eslint中文文档】http://eslint.cn/docs/rules/</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 文件内局部设置</span><br><span class="line"> * 【】eslint可以具体文件中设置特定代码的规则，常用于跳过某条语句的检测。</span><br><span class="line"> * 【】注销全部规则，在代码前新建一行，添加注销 /* eslint-disable *\/  。如果没有恢复设置的语句，则下列全部代码都会跳过检测。</span><br><span class="line"> * 【】恢复eslint，在代码前新建一行，添加注销 /* eslint-enable *\/</span><br><span class="line"> * 【】指定忽略的规则，/* eslint-disable no-alert, no-console *\/</span><br><span class="line"> * 【】在特定行禁用，// eslint-disable-line</span><br><span class="line"> * 【】在下一行禁用，// eslint-disable-next-line</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line"> /**</span><br><span class="line">  * 根目录标识</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#using-configuration-files</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#configuration-cascading-and-hierarchy</span><br><span class="line">  * 【】标识当前配置文件为最底层的文件，无需往更上一级的文件目录中进行搜索</span><br><span class="line">  * 【】默认eslint的配置文件搜索方式是，从目标文件夹进行搜索，遍历内部每一个文件夹，找到配置文件并层叠使用。再跳出本项目，往祖先文件夹进行遍历</span><br><span class="line">  * 【】注意「~/.eslintrc」的意义，「~」是指linux上的家目录，「~/.eslintrc」是指家目录下的eslint配置文件，用于私人开发者，用于整个电脑全局约束的。这个配置通过本配置项root去设置，设置了root,eslint检测时将不会再往上搜索</span><br><span class="line">  * 【】eslint的生效规则是就近使用，越近的配置项优先级越高，覆盖其他配置项。如一个项目中，可以在不同文件夹中都添加配置文件，这些规则将重叠组合生效</span><br><span class="line">  */</span><br><span class="line">  root: true,</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">  * 解析器</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#specifying-parser</span><br><span class="line">  * 【】ESLint 默认使用Espree作为其解析器</span><br><span class="line">  * 【】解析器必须是本地安装的一个 npm 模块。即必须按照在本地的node_module中</span><br><span class="line">  * 【】解析器是用于解析js代码的，怎么去理解每一个表达式，有点C++中编译器的概念，会对js进行一些语法分析，语义分析什么的，才能判断语句符不符合规范。而不是通过简单的字符串对比。</span><br><span class="line">  * 【】解析器有很多，但兼容eslint的解析器有以下几个</span><br><span class="line">  * Espree：默认解析器，一个从Esprima中分离出来的解析器，做了一些优化</span><br><span class="line">  * Esprima：js标准解析器</span><br><span class="line">  * Babel-ESLint： 一个对Babel解析器的包装，babel本身也是js解析器的一种（不然怎么能转化为兼容性代码呢？首先需要进行js解析，才能转化）。如果我们的代码需要经过babel转化，则对应使用这个解析器</span><br><span class="line">  * typescript-eslint-parser(实验) - 一个把 TypeScript 转换为 ESTree 兼容格式的解析器</span><br><span class="line">  */</span><br><span class="line">   /**</span><br><span class="line">  * 解析器配置项</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#specifying-parser-options</span><br><span class="line">  * 【】这里设置的配置项将会传递到解析器中，被解析器获取到，进行一定的处理。具体被利用到，要看解析器的源码有没有对其进行利用。这里仅仅做了参数定义，做了规定，告诉解析器的开发者可能有这些参数</span><br><span class="line">  * 【】配置项目有：</span><br><span class="line">  * &quot;sourceType&quot;: &quot;module&quot;,  // 指定JS代码来源的类型，script(script标签引入？) | module（es6的module模块），默认为script。为什么vue的会使用script呢？因为vue是通过babel-loader编译的，而babel编译后的代码就是script方式</span><br><span class="line">  * &quot;ecmaVersion&quot;: 6,     // 支持的ES语法版本，默认为5。注意只是语法，不包括ES的全局变量。全局变量需要在env选项中进行定义</span><br><span class="line">  * &quot;ecmaFeatures&quot;: &#123;     // Features是特征的意思，这里用于指定要使用其他那些语言对象</span><br><span class="line">    &quot;experimentalObjectRestSpread&quot;: true, //启用对对象的扩展</span><br><span class="line">    &quot;jsx&quot;: true,              //启用jsx语法</span><br><span class="line">    &quot;globalReturn&quot;:true,          //允许return在全局使用</span><br><span class="line">    &quot;impliedStrict&quot;:true          //启用严格校验模式</span><br><span class="line">   &#125;</span><br><span class="line">  */</span><br><span class="line"></span><br><span class="line">  parserOptions: &#123;</span><br><span class="line">   parser: &#x27;babel-eslint&#x27;,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">  * 运行环境</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#specifying-environments</span><br><span class="line">  * 【】一个环境定义了一组预定义的全局变量</span><br><span class="line">  * 【】获得了特定环境的全局定义，就不会认为是开发定义的，跳过对其的定义检测。否则会被认为改变量未定义</span><br><span class="line">  * 【】常见的运行环境有以下这些，更多的可查看官网</span><br><span class="line">  * browser - 浏览器环境中的全局变量。</span><br><span class="line">  * node - Node.js 全局变量和 Node.js 作用域。</span><br><span class="line">  * es6 - 启用除了 modules 以外的所有 ECMAScript 6 特性（该选项会自动设置 ecmaVersion 解析器选项为 6）。</span><br><span class="line">  * amd - 将 require() 和 define() 定义为像 amd 一样的全局变量。</span><br><span class="line">  * commonjs - CommonJS 全局变量和 CommonJS 作用域 (用于 Browserify/WebPack 打包的只在浏览器中运行的代码)。</span><br><span class="line">  * jquery - jQuery 全局变量。</span><br><span class="line">  * mongo - MongoDB 全局变量。</span><br><span class="line">  * worker - Web Workers 全局变量。</span><br><span class="line">  * serviceworker - Service Worker 全局变量。</span><br><span class="line">  */</span><br><span class="line">  env: &#123;</span><br><span class="line">    // browser: true, // 浏览器环境</span><br><span class="line">    node: true</span><br><span class="line">  &#125;,</span><br><span class="line"> /**</span><br><span class="line">  * 全局变量</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#specifying-globals</span><br><span class="line">  * 【】定义额外的全局，开发者自定义的全局变量，让其跳过no-undef 规则</span><br><span class="line">  * 【】key值就是额外添加的全局变量</span><br><span class="line">  * 【】value值用于标识该变量能否被重写，类似于const的作用。true为允许变量被重写</span><br><span class="line">  * 【】注意：要启用no-global-assign规则来禁止对只读的全局变量进行修改。</span><br><span class="line">  */</span><br><span class="line">  // globals: &#123;</span><br><span class="line">  //   // gTool: true, // 例如定义gTool这个全局变量，且这个变量可以被重写</span><br><span class="line">  //  &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">  * 插件</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#configuring-plugins</span><br><span class="line">  * 【】插件同样需要在node_module中下载</span><br><span class="line">  * 【】注意插件名忽略了「eslint-plugin-」前缀，所以在package.json中，对应的项目名是「eslint-plugin-vue」</span><br><span class="line">  * 【】插件的作用类似于解析器，用以扩展解析器的功能，用于检测非常规的js代码。也可能会新增一些特定的规则。</span><br><span class="line">  * 【】如 eslint-plugin-vue，是为了帮助我们检测.vue文件中 &lt;template&gt; 和 &lt;script&gt; 中的js代码</span><br><span class="line">  */</span><br><span class="line">    // plugins: [</span><br><span class="line">    //   &#x27;vue&#x27;</span><br><span class="line">    //  ],</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 规则继承</span><br><span class="line">  * http://eslint.cn/docs/user-guide/configuring#extending-configuration-files</span><br><span class="line">  *【】可继承的方式有以下几种</span><br><span class="line">  *【】eslint内置推荐规则，就只有一个，即「eslint:recommended」</span><br><span class="line">  *【】可共享的配置， 是一个 npm 包，它输出一个配置对象。即通过npm安装到node_module中</span><br><span class="line">  *  可共享的配置可以省略包名的前缀 eslint-config-，即实际设置安装的包名是 eslint-config-airbnb-base</span><br><span class="line">  *【】从插件中获取的规则，书写规则为 「plugin:插件包名/配置名」，其中插件报名也是可以忽略「eslint-plugin-」前缀。如&#x27;plugin:vue/essential&#x27;</span><br><span class="line">  *【】从配置文件中继承，即继承另外的一个配置文件，如&#x27;./node_modules/coding-standard/eslintDefaults.js&#x27;</span><br><span class="line">  */</span><br><span class="line">  extends: [</span><br><span class="line">    &#x27;plugin:vue/essential&#x27;,</span><br><span class="line">    &#x27;@vue/standard&#x27;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line"> /**</span><br><span class="line">  * 针对特定文件的配置</span><br><span class="line">  * 【】可以通过overrides对特定文件进行特定的eslint检测</span><br><span class="line">  * 【】特定文件的路径书写使用Glob格式，一个类似正则的路径规则，可以匹配不同的文件</span><br><span class="line">  * 【】配置几乎与 ESLint 的其他配置相同。覆盖块可以包含常规配置中的除了 extends、overrides 和 root 之外的其他任何有效配置选项，</span><br><span class="line">  */</span><br><span class="line">  overrides: [</span><br><span class="line">    &#123;</span><br><span class="line">      files: [</span><br><span class="line">        &#x27;**/__tests__/*.&#123;j,t&#125;s?(x)&#x27;,</span><br><span class="line">        &#x27;**/tests/unit/**/*.spec.&#123;j,t&#125;s?(x)&#x27;</span><br><span class="line">      ],</span><br><span class="line">      env: &#123;</span><br><span class="line">        jest: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  rules: &#123;</span><br><span class="line">    /**</span><br><span class="line">   * 具体规则</span><br><span class="line">   * 【】具体的规则太多，就不做介绍了，有兴趣的同学可以上eslint官网查</span><br><span class="line">   * 【】注意 xxx/aaa 这些规则是 xxx 插件自定的规则，在eslint官网是查不到的。需要到相应的插件官网中查阅</span><br><span class="line">   * 【】如 import/extensions，这是「eslint-plugin-import」自定义的规则，需要到其官网查看 https://github.com/benmosher/eslint-plugin-import</span><br><span class="line">   */</span><br><span class="line">    // &quot;indent&quot;: [&#x27;off&#x27;, 4],</span><br><span class="line">    // &#x27;no-console&#x27;: &#x27;off&#x27;,</span><br><span class="line">    // &#x27;no-debugger&#x27;: &#x27;off&#x27;,</span><br><span class="line">    &quot;no-unused-vars&quot;: [0, &#123; &quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;none&quot; &#125;],</span><br><span class="line">    &#x27;vue/no-unused-vars&#x27;: &#x27;off&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="root"><a href="#root" class="headerlink" title="root"></a>root</h4><p><strong>root：是否以当前目录为根目录。</strong> 告诉 ESLint 不要再往上级目录查找，利用此属性配置，项目级和目录级的配置都可以不受上级目录以及祖先目录的配置影响，通常项目根目录应该设置为 <code>true</code> </p>
<p>举个例子，比如这个项目 vue-project1，默认情况下 root 为 false，而且该项目上层目录下还有 eslint 配置文件的话，这个更上一层的配置就会对你的项目文件的代码产生作用，直到到达根目录才会停止。这是我们不愿意看到的，所以就需要我们在当前项目目录下设置 root: true，告诉 ESLint 这里就是根目录了，别再往上查找其他的配置文件了！</p>
<h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>使用 <code>env</code> 属性来指定要启用的环境，将其设置为 <code>true</code>，以保证在进行代码检测时不会把<a href="http://eslint.cn/docs/user-guide/configuring#specifying-environments">这些环境</a>预定义的全局变量识别成未定义的变量而报错</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;env&quot;: &#123;</span><br><span class="line">    &quot;browser&quot;: true,</span><br><span class="line">    &quot;commonjs&quot;: true,</span><br><span class="line">    &quot;es6&quot;: true,</span><br><span class="line">    &quot;jquery&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="globals"><a href="#globals" class="headerlink" title="globals"></a>globals</h4><p>ESLint会检测未声明的额外的全局变量，并发出报错，比如node环境中的process，浏览器环境下的全局变量console，以及我们通过cdn引入的jQuery定义的$等；我们可以在<code>globals</code>中进行变量声明：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;globals&quot;</span>: &#123;</span><br><span class="line">        <span class="comment">// true表示该变量可读写，false表示变量是只读</span></span><br><span class="line">        <span class="attr">&quot;$&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">&quot;console&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是node或者浏览器中的全局变量很多，如果我们一个个进行声明显得繁琐，因此就需要用到我们的<code>env</code>，这是对环境定义的一组全局变量的预设。</p>
<h4 id="parserOptions解析器"><a href="#parserOptions解析器" class="headerlink" title="parserOptions解析器"></a>parserOptions解析器</h4><p>设置解析器能帮助ESLint确定什么是解析错误。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parserOptions: &#123;</span><br><span class="line">    parser: &#x27;babel-eslint&#x27;,</span><br><span class="line">    // 指定js版本。语法上的支持    </span><br><span class="line">    ecmaVersion: 6</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>babel-ESLint: 一个对Babel解析器的包装，使其能够与ESLint兼容。</li>
<li>@typescript-eslint/parser</li>
</ul>
<h4 id="overrides"><a href="#overrides" class="headerlink" title="overrides"></a>overrides</h4><p>overrides：用指定配置覆盖指定后缀的文件的规则配置</p>
<h4 id="extends和plugins"><a href="#extends和plugins" class="headerlink" title="extends和plugins"></a>extends和plugins</h4><p>如果每条规则都需要团队协商配置还是比较繁琐的，在项目开始配置时，我们可以先使用一些业内已经成熟的、大家普遍遵循的编码规范</p>
<blockquote>
<p>需要注意的是：多个扩展中有相同的规则，以后面引入的扩展中规则为准。</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;extends&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;eslint:recommended&quot;</span>,</span><br><span class="line">        <span class="string">&quot;plugin:vue/essential&quot;</span>,</span><br><span class="line">        <span class="string">&quot;@vue/prettier&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eslint-config-standard&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>extends可以使用以下几种类型的扩展：</p>
<ul>
<li>eslint：开头的ESLint官方扩展，有两个：<code>eslint:recommended</code>（推荐规范）和<code>eslint:all</code>（所有规范）。</li>
<li>plugin：开头的扩展是插件类型扩展</li>
<li>eslint-config：开头的来自npm包，使用时可以省略<code>eslint-config-</code>，比如上面的可以直接写成<code>standard</code></li>
<li>@：开头的扩展和eslint-config一样，是在npm包上面加了一层作用域scope</li>
</ul>
<h5 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h5><ul>
<li><p><code>plugin:vue/vue3-essential</code>：Vue.js 的官方 ESLint （规则）插件</p>
</li>
<li><p><code>@vue/eslint-config-typescript/recommended</code>：专门给 Vue 使用的 TS 验证规则（<code>eslint-config-typescript</code>）</p>
<p><code>@vue/eslint-config-typescript</code> 有两套规则集，一个是 <code>@vue/eslint-config-typescript</code> ，一个就是 <code>@vue/eslint-config-typescript/recommended</code> 。其中，后者更加严格。</p>
</li>
</ul>
<h3 id="rule"><a href="#rule" class="headerlink" title="rule"></a>rule</h3><h4 id="规则配置"><a href="#规则配置" class="headerlink" title="规则配置"></a>规则配置</h4><p>在上文的配置文件中， <code>&quot;extends&quot;: &quot;eslint:recommended&quot;</code> 选项表示启用推荐规则，在推荐规则的基础上我们还可以根据需要使用 <code>rules</code> 新增自定义规则，每个规则的第一个值都是代表该规则检测后显示的错误级别：</p>
<ul>
<li><code>&quot;off&quot;</code> 或 <code>0</code> - 关闭规则</li>
<li><code>&quot;warn&quot;</code> 或 <code>1</code> - 将规则视为一个警告</li>
<li><code>&quot;error&quot;</code> 或 <code>2</code> - 将规则视为一个错误</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const a = &#123;</span><br><span class="line">  &quot;no-console&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,</span><br><span class="line">  &quot;no-debugger&quot;: process.env.NODE_ENV === &quot;production&quot; ? &quot;warn&quot; : &quot;off&quot;,</span><br><span class="line">  &quot;vue/no-v-model-argument&quot;: 0,</span><br><span class="line">  semi: 0, // 去掉结尾的分号</span><br><span class="line">  singleQuote: 0, // 单引号替代双引号</span><br><span class="line">  trailingComma: 0, // 末尾禁止添加逗号</span><br><span class="line">  &quot;no-alert&quot;: 0, //禁止使用alert confirm prompt</span><br><span class="line">  &quot;no-array-constructor&quot;: 2, //禁止使用数组构造器</span><br><span class="line">  &quot;no-bitwise&quot;: 0, //禁止使用按位运算符</span><br><span class="line">  &quot;no-caller&quot;: 1, //禁止使用arguments.caller或arguments.callee</span><br><span class="line">  &quot;no-catch-shadow&quot;: 2, //禁止catch子句参数与外部作用域变量同名</span><br><span class="line">  &quot;no-class-assign&quot;: 2, //禁止给类赋值</span><br><span class="line">  &quot;no-cond-assign&quot;: 2, //禁止在条件表达式中使用赋值语句</span><br><span class="line">  // &quot;no-console&quot;: 2,//禁止使用console</span><br><span class="line">  &quot;no-const-assign&quot;: 2, //禁止修改const声明的变量</span><br><span class="line">  &quot;no-constant-condition&quot;: 2, //禁止在条件中使用常量表达式 if(true) if(1)</span><br><span class="line">  &quot;no-continue&quot;: 0, //禁止使用continue</span><br><span class="line">  &quot;no-control-regex&quot;: 2, //禁止在正则表达式中使用控制字符</span><br><span class="line">  // &quot;no-debugger&quot;: 2,//禁止使用debugger</span><br><span class="line">  &quot;no-delete-var&quot;: 2, //不能对var声明的变量使用delete操作符</span><br><span class="line">  &quot;no-div-regex&quot;: 1, //不能使用看起来像除法的正则表达式/=foo/</span><br><span class="line">  &quot;no-dupe-keys&quot;: 2, //在创建对象字面量时不允许键重复 &#123;a:1,a:1&#125;</span><br><span class="line">  &quot;no-dupe-args&quot;: 2, //函数参数不能重复</span><br><span class="line">  &quot;no-duplicate-case&quot;: 2, //switch中的case标签不能重复</span><br><span class="line">  &quot;no-else-return&quot;: 2, //如果if语句里面有return,后面不能跟else语句</span><br><span class="line">  &quot;no-empty&quot;: 2, //块语句中的内容不能为空</span><br><span class="line">  &quot;no-empty-character-class&quot;: 2, //正则表达式中的[]内容不能为空</span><br><span class="line">  &quot;no-empty-label&quot;: 0, //禁止使用空label</span><br><span class="line">  &quot;no-eq-null&quot;: 2, //禁止对null使用==或!=运算符</span><br><span class="line">  &quot;no-eval&quot;: 1, //禁止使用eval</span><br><span class="line">  &quot;no-ex-assign&quot;: 2, //禁止给catch语句中的异常参数赋值</span><br><span class="line">  &quot;no-extend-native&quot;: 2, //禁止扩展native对象</span><br><span class="line">  &quot;no-extra-bind&quot;: 2, //禁止不必要的函数绑定</span><br><span class="line">  &quot;no-extra-boolean-cast&quot;: 2, //禁止不必要的bool转换</span><br><span class="line">  &quot;no-extra-parens&quot;: 2, //禁止非必要的括号</span><br><span class="line">  &quot;no-extra-semi&quot;: 2, //禁止多余的冒号</span><br><span class="line">  &quot;no-fallthrough&quot;: 1, //禁止switch穿透</span><br><span class="line">  &quot;no-floating-decimal&quot;: 2, //禁止省略浮点数中的0 .5 3.</span><br><span class="line">  &quot;no-func-assign&quot;: 2, //禁止重复的函数声明</span><br><span class="line">  &quot;no-implicit-coercion&quot;: 1, //禁止隐式转换</span><br><span class="line">  &quot;no-implied-eval&quot;: 2, //禁止使用隐式eval</span><br><span class="line">  &quot;no-inline-comments&quot;: 0, //禁止行内备注</span><br><span class="line">  &quot;no-inner-declarations&quot;: [2, &quot;functions&quot;], //禁止在块语句中使用声明（变量或函数）</span><br><span class="line">  &quot;no-invalid-regexp&quot;: 2, //禁止无效的正则表达式</span><br><span class="line">  &quot;no-invalid-this&quot;: 2, //禁止无效的this，只能用在构造器，类，对象字面量</span><br><span class="line">  &quot;no-irregular-whitespace&quot;: 2, //不能有不规则的空格</span><br><span class="line">  &quot;no-iterator&quot;: 2, //禁止使用__iterator__ 属性</span><br><span class="line">  &quot;no-label-var&quot;: 2, //label名不能与var声明的变量名相同</span><br><span class="line">  &quot;no-labels&quot;: 2, //禁止标签声明</span><br><span class="line">  &quot;no-lone-blocks&quot;: 2, //禁止不必要的嵌套块</span><br><span class="line">  &quot;no-lonely-if&quot;: 0, //禁止else语句内只有if语句</span><br><span class="line">  &quot;no-loop-func&quot;: 1, //禁止在循环中使用函数（如果没有引用外部变量不形成闭包就可以）</span><br><span class="line">  &quot;no-mixed-requires&quot;: [0, false], //声明时不能混用声明类型</span><br><span class="line">  &quot;no-mixed-spaces-and-tabs&quot;: [2, false], //禁止混用tab和空格</span><br><span class="line">  &quot;linebreak-style&quot;: [0, &quot;windows&quot;], //换行风格</span><br><span class="line">  &quot;no-multi-spaces&quot;: 1, //不能用多余的空格</span><br><span class="line">  &quot;no-multi-str&quot;: 2, //字符串不能用换行</span><br><span class="line">  &quot;no-multiple-empty-lines&quot;: [1, &#123; max: 2 &#125;], //空行最多不能超过2行</span><br><span class="line">  &quot;no-native-reassign&quot;: 2, //不能重写native对象</span><br><span class="line">  &quot;no-negated-in-lhs&quot;: 2, //in 操作符的左边不能有!</span><br><span class="line">  &quot;no-nested-ternary&quot;: 0, //禁止使用嵌套的三目运算</span><br><span class="line">  &quot;no-new&quot;: 1, //禁止在使用new构造一个实例后不赋值</span><br><span class="line">  &quot;no-new-func&quot;: 1, //禁止使用new Function</span><br><span class="line">  &quot;no-new-object&quot;: 2, //禁止使用new Object()</span><br><span class="line">  &quot;no-new-require&quot;: 2, //禁止使用new require</span><br><span class="line">  &quot;no-new-wrappers&quot;: 2, //禁止使用new创建包装实例，new String new Boolean new Number</span><br><span class="line">  &quot;no-obj-calls&quot;: 2, //不能调用内置的全局对象，比如Math() JSON()</span><br><span class="line">  &quot;no-octal&quot;: 2, //禁止使用八进制数字</span><br><span class="line">  &quot;no-octal-escape&quot;: 2, //禁止使用八进制转义序列</span><br><span class="line">  &quot;no-param-reassign&quot;: 2, //禁止给参数重新赋值</span><br><span class="line">  &quot;no-path-concat&quot;: 0, //node中不能使用__dirname或__filename做路径拼接</span><br><span class="line">  &quot;no-plusplus&quot;: 0, //禁止使用++，--</span><br><span class="line">  &quot;no-process-env&quot;: 0, //禁止使用process.env</span><br><span class="line">  &quot;no-process-exit&quot;: 0, //禁止使用process.exit()</span><br><span class="line">  &quot;no-proto&quot;: 2, //禁止使用__proto__属性</span><br><span class="line">  &quot;no-redeclare&quot;: 2, //禁止重复声明变量</span><br><span class="line">  &quot;no-regex-spaces&quot;: 2, //禁止在正则表达式字面量中使用多个空格 /foo bar/</span><br><span class="line">  &quot;no-restricted-modules&quot;: 0, //如果禁用了指定模块，使用就会报错</span><br><span class="line">  &quot;no-return-assign&quot;: 1, //return 语句中不能有赋值表达式</span><br><span class="line">  &quot;no-script-url&quot;: 0, //禁止使用javascript:void(0)</span><br><span class="line">  &quot;no-self-compare&quot;: 2, //不能比较自身</span><br><span class="line">  &quot;no-sequences&quot;: 0, //禁止使用逗号运算符</span><br><span class="line">  &quot;no-shadow&quot;: 0, //外部作用域中的变量不能与它所包含的作用域中的变量或参数同名</span><br><span class="line">  &quot;no-shadow-restricted-names&quot;: 2, //严格模式中规定的限制标识符不能作为声明时的变量名使用</span><br><span class="line">  &quot;no-spaced-func&quot;: 2, //函数调用时 函数名与()之间不能有空格</span><br><span class="line">  &quot;no-sparse-arrays&quot;: 2, //禁止稀疏数组， [1,,2]</span><br><span class="line">  &quot;no-sync&quot;: 0, //nodejs 禁止同步方法</span><br><span class="line">  &quot;no-ternary&quot;: 0, //禁止使用三目运算符</span><br><span class="line">  &quot;no-trailing-spaces&quot;: 0, //一行结束后面不要有空格</span><br><span class="line">  &quot;no-this-before-super&quot;: 0, //在调用super()之前不能使用this或super</span><br><span class="line">  &quot;no-throw-literal&quot;: 2, //禁止抛出字面量错误 throw &quot;error&quot;;</span><br><span class="line">  &quot;no-undef&quot;: 1, //不能有未定义的变量</span><br><span class="line">  &quot;no-undef-init&quot;: 2, //变量初始化时不能直接给它赋值为undefined</span><br><span class="line">  &quot;no-undefined&quot;: 2, //不能使用undefined</span><br><span class="line">  &quot;no-unexpected-multiline&quot;: 2, //避免多行表达式</span><br><span class="line">  &quot;no-underscore-dangle&quot;: 1, //标识符不能以_开头或结尾</span><br><span class="line">  &quot;no-unneeded-ternary&quot;: 2, //禁止不必要的嵌套 var isYes = answer === 1 ? true : false;</span><br><span class="line">  &quot;no-unreachable&quot;: 2, //不能有无法执行的代码</span><br><span class="line">  &quot;no-unused-expressions&quot;: 2, //禁止无用的表达式</span><br><span class="line">  &quot;no-unused-vars&quot;: [1, &#123; vars: &quot;all&quot;, args: &quot;after-used&quot; &#125;], //不能有声明后未被使用的变量或参数</span><br><span class="line">  &quot;no-use-before-define&quot;: 2, //未定义前不能使用</span><br><span class="line">  &quot;no-useless-call&quot;: 2, //禁止不必要的call和apply</span><br><span class="line">  &quot;no-void&quot;: 2, //禁用void操作符</span><br><span class="line">  &quot;no-var&quot;: 0, //禁用var，用let和const代替</span><br><span class="line">  &quot;no-warning-comments&quot;: [</span><br><span class="line">    1,</span><br><span class="line">    &#123; terms: [&quot;todo&quot;, &quot;fixme&quot;, &quot;xxx&quot;], location: &quot;start&quot; &#125;,</span><br><span class="line">  ], //不能有警告备注</span><br><span class="line">  &quot;no-with&quot;: 2, //禁用with</span><br><span class="line"></span><br><span class="line">  &quot;array-bracket-spacing&quot;: [2, &quot;never&quot;], //是否允许非空数组里面有多余的空格</span><br><span class="line">  &quot;arrow-parens&quot;: 0, //箭头函数用小括号括起来</span><br><span class="line">  &quot;arrow-spacing&quot;: 0, //=&gt;的前/后括号</span><br><span class="line">  &quot;accessor-pairs&quot;: 0, //在对象中使用getter/setter</span><br><span class="line">  &quot;block-scoped-var&quot;: 0, //块语句中使用var</span><br><span class="line">  &quot;brace-style&quot;: [1, &quot;1tbs&quot;], //大括号风格</span><br><span class="line">  &quot;callback-return&quot;: 0, //避免多次调用回调什么的</span><br><span class="line">  camelcase: 2, //强制驼峰法命名</span><br><span class="line">  &quot;comma-dangle&quot;: [0, &quot;never&quot;], //对象字面量项尾不能有逗号</span><br><span class="line">  &quot;comma-spacing&quot;: 0, //逗号前后的空格</span><br><span class="line">  &quot;comma-style&quot;: [2, &quot;last&quot;], //逗号风格，换行时在行首还是行尾</span><br><span class="line">  complexity: [0, 11], //循环复杂度</span><br><span class="line">  &quot;computed-property-spacing&quot;: [0, &quot;never&quot;], //是否允许计算后的键名什么的</span><br><span class="line">  &quot;consistent-return&quot;: 0, //return 后面是否允许省略</span><br><span class="line">  &quot;consistent-this&quot;: [2, &quot;that&quot;], //this别名</span><br><span class="line">  &quot;constructor-super&quot;: 0, //非派生类不能调用super，派生类必须调用super</span><br><span class="line">  curly: [2, &quot;all&quot;], //必须使用 if()&#123;&#125; 中的&#123;&#125;</span><br><span class="line">  &quot;default-case&quot;: 2, //switch语句最后必须有default</span><br><span class="line">  &quot;dot-location&quot;: 0, //对象访问符的位置，换行的时候在行首还是行尾</span><br><span class="line">  &quot;dot-notation&quot;: [0, &#123; allowKeywords: true &#125;], //避免不必要的方括号</span><br><span class="line">  &quot;eol-last&quot;: 0, //文件以单一的换行符结束</span><br><span class="line">  eqeqeq: 2, //必须使用全等</span><br><span class="line">  &quot;func-names&quot;: 0, //函数表达式必须有名字</span><br><span class="line">  &quot;func-style&quot;: [0, &quot;declaration&quot;], //函数风格，规定只能使用函数声明/函数表达式</span><br><span class="line">  &quot;generator-star-spacing&quot;: 0, //生成器函数*的前后空格</span><br><span class="line">  &quot;guard-for-in&quot;: 0, //for in循环要用if语句过滤</span><br><span class="line">  &quot;handle-callback-err&quot;: 0, //nodejs 处理错误</span><br><span class="line">  &quot;id-length&quot;: 0, //变量名长度</span><br><span class="line">  indent: [0, 2], //缩进风格</span><br><span class="line">  &quot;init-declarations&quot;: 0, //声明时必须赋初值</span><br><span class="line">  &quot;key-spacing&quot;: [0, &#123; beforeColon: false, afterColon: true &#125;], //对象字面量中冒号的前后空格</span><br><span class="line">  &quot;lines-around-comment&quot;: 0, //行前/行后备注</span><br><span class="line">  &quot;max-depth&quot;: [0, 4], //嵌套块深度</span><br><span class="line">  &quot;max-len&quot;: [0, 80, 4], //字符串最大长度</span><br><span class="line">  &quot;max-nested-callbacks&quot;: [0, 2], //回调嵌套深度</span><br><span class="line">  &quot;max-params&quot;: [0, 3], //函数最多只能有3个参数</span><br><span class="line">  &quot;max-statements&quot;: [0, 10], //函数内最多有几个声明</span><br><span class="line">  &quot;max-lines-per-function&quot;: [1, &#123; max: 200, skipBlankLines: true &#125;], // 函数最大行数</span><br><span class="line">  &quot;new-cap&quot;: 2, //函数名首行大写必须使用new方式调用，首行小写必须用不带new方式调用</span><br><span class="line">  &quot;new-parens&quot;: 2, //new时必须加小括号</span><br><span class="line">  &quot;newline-after-var&quot;: 0, //变量声明后是否需要空一行</span><br><span class="line">  &quot;object-curly-spacing&quot;: [0, &quot;never&quot;], //大括号内是否允许不必要的空格</span><br><span class="line">  &quot;object-shorthand&quot;: 0, //强制对象字面量缩写语法</span><br><span class="line">  &quot;one-var&quot;: 1, //连续声明</span><br><span class="line">  &quot;operator-assignment&quot;: [0, &quot;always&quot;], //赋值运算符 += -=什么的</span><br><span class="line">  &quot;operator-linebreak&quot;: [0, &quot;after&quot;], //换行时运算符在行尾还是行首</span><br><span class="line">  &quot;padded-blocks&quot;: 0, //块语句内行首行尾是否要空行</span><br><span class="line">  &quot;prefer-const&quot;: 0, //首选const</span><br><span class="line">  &quot;prefer-spread&quot;: 0, //首选展开运算</span><br><span class="line">  &quot;prefer-reflect&quot;: 0, //首选Reflect的方法</span><br><span class="line">  quotes: [0, &quot;single&quot;], //引号类型 `` &quot;&quot; &#x27;&#x27;</span><br><span class="line">  &quot;quote-props&quot;: [0, &quot;always&quot;], //对象字面量中的属性名是否强制双引号</span><br><span class="line">  radix: 2, //parseInt必须指定第二个参数</span><br><span class="line">  &quot;id-match&quot;: 0, //命名检测</span><br><span class="line">  &quot;require-yield&quot;: 0, //生成器函数必须有yield</span><br><span class="line">  // &#x27;semi&#x27;: [2, &#x27;always&#x27;],//语句强制分号结尾</span><br><span class="line">  &quot;semi-spacing&quot;: [0, &#123; before: false, after: true &#125;], //分号前后空格</span><br><span class="line">  &quot;sort-vars&quot;: 0, //变量声明时排序</span><br><span class="line">  &quot;space-after-keywords&quot;: [0, &quot;always&quot;], //关键字后面是否要空一格</span><br><span class="line">  &quot;space-before-blocks&quot;: [0, &quot;always&quot;], //不以新行开始的块&#123;前面要不要有空格</span><br><span class="line">  &quot;space-before-function-paren&quot;: [0, &quot;always&quot;], //函数定义时括号前面要不要有空格</span><br><span class="line">  &quot;space-in-parens&quot;: [0, &quot;never&quot;], //小括号里面要不要有空格</span><br><span class="line">  &quot;space-infix-ops&quot;: 0, //中缀操作符周围要不要有空格</span><br><span class="line">  &quot;space-return-throw-case&quot;: 0, //return throw case后面要不要加空格</span><br><span class="line">  &quot;space-unary-ops&quot;: [0, &#123; words: true, nonwords: false &#125;], //一元运算符的前/后要不要加空格</span><br><span class="line">  &quot;spaced-comment&quot;: 0, //注释风格要不要有空格什么的</span><br><span class="line">  strict: 2, //使用严格模式</span><br><span class="line">  &quot;use-isnan&quot;: 2, //禁止比较时使用NaN，只能用isNaN()</span><br><span class="line">  &quot;valid-jsdoc&quot;: 0, //jsdoc规则</span><br><span class="line">  &quot;valid-typeof&quot;: 2, //必须使用合法的typeof的值</span><br><span class="line">  &quot;vars-on-top&quot;: 2, //var必须放在作用域顶部</span><br><span class="line">  &quot;wrap-iife&quot;: [2, &quot;inside&quot;], //立即执行函数表达式的小括号风格</span><br><span class="line">  &quot;wrap-regex&quot;: 0, //正则表达式字面量用小括号包起来</span><br><span class="line">  yoda: [2, &quot;never&quot;], //禁止尤达条件</span><br><span class="line">  &quot;vue/attribute-hyphenation&quot;: 0, // 忽略属性连字</span><br><span class="line">  &quot;vue/max-attributes-per-line&quot;: [</span><br><span class="line">    2,</span><br><span class="line">    &#123; singleline: 10, multiline: &#123; max: 1, allowFirstLine: false &#125; &#125;,</span><br><span class="line">  ], // 每行最大属性</span><br><span class="line">  &quot;vue/singleline-html-element-content-newline&quot;: &quot;off&quot;, // 单行html元素内容在新的一行</span><br><span class="line">  &quot;vue/multiline-html-element-content-newline&quot;: &quot;off&quot;, // 多行html元素内容在新的一行</span><br><span class="line">  &quot;vue/html-closing-bracket-newline&quot;: &quot;off&quot;, // html右括号在新的一行</span><br><span class="line">  &quot;vue/no-v-html&quot;: &quot;off&quot;, // 不使用v-html</span><br><span class="line">  &quot;vue/html-self-closing&quot;: 0, // 忽略html标签自闭合</span><br><span class="line">  &quot;vue/require-default-prop&quot;: 0, // 不检查默认属性</span><br><span class="line">  &quot;vue/require-prop-types&quot;: 0, // 不检查默认类型</span><br><span class="line">  &quot;block-spacing&quot;: [2, &quot;always&quot;], // 块间距</span><br><span class="line">  &quot;global-require&quot;: 1, // 所有调用require()都位于模块的顶层</span><br><span class="line">  &quot;keyword-spacing&quot;: [2, &#123; before: true, after: true &#125;], // 关键字如if/function等的间距</span><br><span class="line">  &quot;no-dupe-class-members&quot;: 2, // 不允许在类成员中使用重复的参数名称</span><br><span class="line">  &quot;no-empty-pattern&quot;: 2, // 不允许空块语句</span><br><span class="line">  &quot;no-new-symbol&quot;: 2, // 防止Symbol与new 同时使用的意外错误</span><br><span class="line">  &quot;no-self-assign&quot;: 2, // 消除自我分配</span><br><span class="line">  &quot;no-unmodified-loop-condition&quot;: 2, // 查找循环条件内的引用，然后检查这些引用的变量是否在循环中被修改</span><br><span class="line">  &quot;no-unsafe-finally&quot;: 2, // 不允许return，throw，break，和continue里面的语句finally块</span><br><span class="line">  // 消除未使用的变量，函数和函数的参数</span><br><span class="line">  // vars: &#x27;all&#x27; 检查所有变量的使用情况，包括全局范围内的变量。这是默认设置。 args: &#x27;after-used&#x27; 只有最后一个参数必须使用。例如，这允许您为函数使用两个命名参数，并且只要您使用第二个参数，ESLint 就不会警告您第一个参数。这是默认设置。</span><br><span class="line">  &quot;no-useless-computed-key&quot;: 2, // 禁止不必要地使用计算属性键</span><br><span class="line">  &quot;no-useless-constructor&quot;: 2, // 在不改变类的工作方式的情况下安全地移除的类构造函数</span><br><span class="line">  &quot;no-useless-escape&quot;: 0, // 禁用不必要的转义字符</span><br><span class="line">  &quot;no-whitespace-before-property&quot;: 2, // 如果对象的属性位于同一行上，不允许围绕点或在开头括号之前留出空白</span><br><span class="line">  &quot;prefer-destructuring&quot;: [&quot;error&quot;, &#123; object: false, array: false &#125;], // 此规则强制使用解构而不是通过成员表达式访问属性。</span><br><span class="line">  &quot;template-curly-spacing&quot;: [2, &quot;never&quot;], // 不允许大括号内的空格</span><br><span class="line">  &quot;yield-star-spacing&quot;: [2, &quot;both&quot;], // 强制执行*周围 yield*表达式的间距，两侧都必须有空格</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="风格指南"><a href="#风格指南" class="headerlink" title="风格指南"></a>风格指南</h4><h5 id="max-len"><a href="#max-len" class="headerlink" title="max-len"></a>max-len</h5><p><a href="http://www.verydoc.net/eslint/00003371.html">http://www.verydoc.net/eslint/00003371.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 指定数组的元素之间要以空格隔开(, 后面)， never参数：[ 之前和 ] 之后不能带空格，always参数：[ 之前和 ] 之后必须带空格</span><br><span class="line">&quot;array-bracket-spacing&quot;: [2, &quot;never&quot;],</span><br><span class="line">// 禁止或强制在单行代码块中使用空格(禁用)</span><br><span class="line">&quot;block-spacing&quot;:[1, &quot;never&quot;],</span><br><span class="line">//强制使用一致的缩进 第二个参数为 &quot;tab&quot; 时，会使用tab，</span><br><span class="line">// if while function 后面的&#123;必须与if在同一行，java风格。</span><br><span class="line">&quot;brace-style&quot;: [2, &quot;1tbs&quot;, &#123;&quot;allowSingleLine&quot;: true&#125;],</span><br><span class="line">// 双峰驼命名格式</span><br><span class="line">&quot;camelcase&quot;: 2,</span><br><span class="line">// 控制逗号前后的空格</span><br><span class="line">&quot;comma-spacing&quot;: [2, &#123;&quot;before&quot;: false, &quot;after&quot;: true&#125;],</span><br><span class="line">// 控制逗号在行尾出现还是在行首出现 (默认行尾)</span><br><span class="line">// http://eslint.org/docs/rules/comma-style</span><br><span class="line">&quot;comma-style&quot;: [2, &quot;last&quot;],</span><br><span class="line">//&quot;SwitchCase&quot; (默认：0) 强制 switch 语句中的 case 子句的缩进水平</span><br><span class="line">// 以方括号取对象属性时，[ 后面和 ] 前面是否需要空格, 可选参数 never, always</span><br><span class="line">&quot;computed-property-spacing&quot;: [2, &quot;never&quot;],</span><br><span class="line">// 用于指统一在回调函数中指向this的变量名，箭头函数中的this已经可以指向外层调用者，应该没卵用了</span><br><span class="line">// e.g [0,&quot;that&quot;] 指定只能 var that = this. that不能指向其他任何值，this也不能赋值给that以外的其他值</span><br><span class="line">&quot;consistent-this&quot;: [1, &quot;that&quot;],</span><br><span class="line">// 强制使用命名的 function 表达式</span><br><span class="line">&quot;func-names&quot;: 0,</span><br><span class="line">// 文件末尾强制换行</span><br><span class="line">&quot;eol-last&quot;: 2,</span><br><span class="line">&quot;indent&quot;: [2, 4, &#123;&quot;SwitchCase&quot;: 1&#125;],</span><br><span class="line">// 强制在对象字面量的属性中键和值之间使用一致的间距</span><br><span class="line">&quot;key-spacing&quot;: [2, &#123;&quot;beforeColon&quot;: false, &quot;afterColon&quot;: true&#125;],</span><br><span class="line">// 强制使用一致的换行风格</span><br><span class="line">&quot;linebreak-style&quot;: [1, &quot;unix&quot;],</span><br><span class="line">// 要求在注释周围有空行 ( 要求在块级注释之前有一空行)</span><br><span class="line">&quot;lines-around-comment&quot;: [1, &#123;&quot;beforeBlockComment&quot;: true&#125;],</span><br><span class="line">// 强制一致地使用函数声明或函数表达式，方法定义风格，参数：</span><br><span class="line">// declaration: 强制使用方法声明的方式，function f()&#123;&#125; e.g [2, &quot;declaration&quot;]</span><br><span class="line">// expression：强制使用方法表达式的方式，var f = function() &#123;&#125; e.g [2, &quot;expression&quot;]</span><br><span class="line">// allowArrowFunctions: declaration风格中允许箭头函数。 e.g [2, &quot;declaration&quot;, &#123; &quot;allowArrowFunctions&quot;: true &#125;]</span><br><span class="line">&quot;func-style&quot;: 0,</span><br><span class="line">// 强制回调函数最大嵌套深度 5层</span><br><span class="line">&quot;max-nested-callbacks&quot;: [1, 5],</span><br><span class="line">// 禁止使用指定的标识符</span><br><span class="line">&quot;id-blacklist&quot;: 0,</span><br><span class="line">// 强制标识符的最新和最大长度</span><br><span class="line">&quot;id-length&quot;: 0,</span><br><span class="line">// 要求标识符匹配一个指定的正则表达式</span><br><span class="line">&quot;id-match&quot;: 0,</span><br><span class="line">// 强制在 JSX 属性中一致地使用双引号或单引号</span><br><span class="line">&quot;jsx-quotes&quot;: 0,</span><br><span class="line">// 强制在关键字前后使用一致的空格 (前后腰需要)</span><br><span class="line">&quot;keyword-spacing&quot;: 2,</span><br><span class="line">// 强制一行的最大长度</span><br><span class="line">&quot;max-len&quot;:[1, 200],</span><br><span class="line">// 强制最大行数</span><br><span class="line">&quot;max-lines&quot;: 0,</span><br><span class="line">// 强制 function 定义中最多允许的参数数量</span><br><span class="line">&quot;max-params&quot;:[1, 7],</span><br><span class="line">// 强制 function 块最多允许的的语句数量</span><br><span class="line">&quot;max-statements&quot;:[1, 200],</span><br><span class="line">// 强制每一行中所允许的最大语句数量</span><br><span class="line">&quot;max-statements-per-line&quot;: 0,</span><br><span class="line">// 要求构造函数首字母大写 （要求调用 new 操作符时有首字母大小的函数，允许调用首字母大写的函数时没有 new 操作符。）</span><br><span class="line">&quot;new-cap&quot;: [2, &#123;&quot;newIsCap&quot;: true, &quot;capIsNew&quot;: false&#125;],</span><br><span class="line">// 要求调用无参构造函数时有圆括号</span><br><span class="line">&quot;new-parens&quot;: 2,</span><br><span class="line">// 要求或禁止 var 声明语句后有一行空行</span><br><span class="line">&quot;newline-after-var&quot;: 0,</span><br><span class="line">// 禁止使用 Array 构造函数</span><br><span class="line">&quot;no-array-constructor&quot;: 2,</span><br><span class="line">// 禁用按位运算符</span><br><span class="line">&quot;no-bitwise&quot;: 0,</span><br><span class="line">// 要求 return 语句之前有一空行</span><br><span class="line">&quot;newline-before-return&quot;: 0,</span><br><span class="line">// 要求方法链中每个调用都有一个换行符</span><br><span class="line">&quot;newline-per-chained-call&quot;: 1,</span><br><span class="line">// 禁用 continue 语句</span><br><span class="line">&quot;no-continue&quot;: 0,</span><br><span class="line">// 禁止在代码行后使用内联注释</span><br><span class="line">&quot;no-inline-comments&quot;: 0,</span><br><span class="line">// 禁止 if 作为唯一的语句出现在 else 语句中</span><br><span class="line">&quot;no-lonely-if&quot;: 0,</span><br><span class="line">// 禁止混合使用不同的操作符</span><br><span class="line">&quot;no-mixed-operators&quot;: 0,</span><br><span class="line">// 不允许空格和 tab 混合缩进</span><br><span class="line">&quot;no-mixed-spaces-and-tabs&quot;: 2,</span><br><span class="line">// 不允许多个空行</span><br><span class="line">&quot;no-multiple-empty-lines&quot;: [2, &#123;&quot;max&quot;: 2&#125;],</span><br><span class="line">// 不允许否定的表达式</span><br><span class="line">&quot;no-negated-condition&quot;: 0,</span><br><span class="line">// 不允许使用嵌套的三元表达式</span><br><span class="line">&quot;no-nested-ternary&quot;: 0,</span><br><span class="line">// 禁止使用 Object 的构造函数</span><br><span class="line">&quot;no-new-object&quot;: 2,</span><br><span class="line">// 禁止使用一元操作符 ++ 和 --</span><br><span class="line">&quot;no-plusplus&quot;: 0,</span><br><span class="line">// 禁止使用特定的语法</span><br><span class="line">&quot;no-restricted-syntax&quot;: 0,</span><br><span class="line">// 禁止 function 标识符和括号之间出现空格</span><br><span class="line">&quot;no-spaced-func&quot;: 2,</span><br><span class="line">// 不允许使用三元操作符</span><br><span class="line">&quot;no-ternary&quot;: 0,</span><br><span class="line">// 禁用行尾空格</span><br><span class="line">&quot;no-trailing-spaces&quot;: 2,</span><br><span class="line">// 禁止标识符中有悬空下划线_bar</span><br><span class="line">&quot;no-underscore-dangle&quot;: 0,</span><br><span class="line">// 禁止可以在有更简单的可替代的表达式时使用三元操作符</span><br><span class="line">&quot;no-unneeded-ternary&quot;: 2,</span><br><span class="line">// 禁止属性前有空白</span><br><span class="line">&quot;no-whitespace-before-property&quot;: 0,</span><br><span class="line">// 强制花括号内换行符的一致性</span><br><span class="line">&quot;object-curly-newline&quot;: 0,</span><br><span class="line">// 强制在花括号中使用一致的空格</span><br><span class="line">&quot;object-curly-spacing&quot;: 0,</span><br><span class="line">// 强制将对象的属性放在不同的行上</span><br><span class="line">&quot;object-property-newline&quot;: 0,</span><br><span class="line">// 强制函数中的变量要么一起声明要么分开声明</span><br><span class="line">&quot;one-var&quot;: [2, &#123;&quot;initialized&quot;: &quot;never&quot;&#125;],</span><br><span class="line">// 要求或禁止在 var 声明周围换行</span><br><span class="line">&quot;one-var-declaration-per-line&quot;: 0,</span><br><span class="line">// 要求或禁止在可能的情况下要求使用简化的赋值操作符</span><br><span class="line">&quot;operator-assignment&quot;: 0,</span><br><span class="line">// 强制操作符使用一致的换行符</span><br><span class="line">&quot;operator-linebreak&quot;: [2, &quot;after&quot;, &#123;&quot;overrides&quot;: &#123;&quot;?&quot;:&quot;before&quot;, &quot;:&quot;: &quot;before&quot;&#125;&#125;],</span><br><span class="line">// 要求或禁止块内填充</span><br><span class="line">&quot;padded-blocks&quot;: 0,</span><br><span class="line">// 要求对象字面量属性名称用引号括起来</span><br><span class="line">&quot;quote-props&quot;: 0,</span><br><span class="line">// 强制使用一致的反勾号、双引号或单引号</span><br><span class="line">&quot;quotes&quot;: [2, &quot;single&quot;, &quot;avoid-escape&quot;],</span><br><span class="line">// 要求使用 JSDoc 注释</span><br><span class="line">&quot;require-jsdoc&quot;: 1,</span><br><span class="line">// 要求或禁止使用分号而不是 ASI（这个才是控制行尾部分号的，）</span><br><span class="line">&quot;semi&quot;: [2, &quot;always&quot;],</span><br><span class="line">// 强制分号之前和之后使用一致的空格</span><br><span class="line">&quot;semi-spacing&quot;: 0,</span><br><span class="line">// 要求同一个声明块中的变量按顺序排列</span><br><span class="line">&quot;sort-vars&quot;: 0,</span><br><span class="line">// 强制在块之前使用一致的空格</span><br><span class="line">&quot;space-before-blocks&quot;: [2, &quot;always&quot;],</span><br><span class="line">// 强制在 function的左括号之前使用一致的空格</span><br><span class="line">&quot;space-before-function-paren&quot;: [2, &quot;always&quot;],</span><br><span class="line">// 强制在圆括号内使用一致的空格</span><br><span class="line">&quot;space-in-parens&quot;: [2, &quot;never&quot;],</span><br><span class="line">// 要求操作符周围有空格</span><br><span class="line">&quot;space-infix-ops&quot;: 2,</span><br><span class="line">// 强制在一元操作符前后使用一致的空格</span><br><span class="line">&quot;space-unary-ops&quot;: [2, &#123;&quot;words&quot;: true, &quot;nonwords&quot;: false&#125;],</span><br><span class="line">// 强制在注释中 // 或 /* 使用一致的空格</span><br><span class="line">&quot;spaced-comment&quot;: [2, &quot;always&quot;, &#123;&quot;markers&quot;: [&quot;global&quot;, &quot;globals&quot;, &quot;eslint&quot;, &quot;eslint-disable&quot;, &quot;*package&quot;,&quot;!&quot;] &#125;],</span><br><span class="line">// 要求或禁止 Unicode BOM</span><br><span class="line">&quot;unicode-bom&quot;: 0,</span><br><span class="line">// 要求正则表达式被括号括起来</span><br><span class="line">&quot;wrap-regex&quot;: 0,</span><br></pre></td></tr></table></figure>

<h4 id="ES6相关"><a href="#ES6相关" class="headerlink" title="ES6相关"></a>ES6相关</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 要求箭头函数体使用大括号</span><br><span class="line">&quot;arrow-body-style&quot;: 2,</span><br><span class="line">// 要求箭头函数的参数使用圆括号</span><br><span class="line">&quot;arrow-parens&quot;: 2,</span><br><span class="line">&quot;arrow-spacing&quot;:[2, &#123;&quot;before&quot;: true, &quot;after&quot;: true&#125;],</span><br><span class="line">// 强制在子类构造函数中用super()调用父类构造函数，TypeScrip的编译器也会提示</span><br><span class="line">&quot;constructor-super&quot;: 0,</span><br><span class="line">// 强制 generator 函数中 * 号周围使用一致的空格</span><br><span class="line">&quot;generator-star-spacing&quot;: [2, &#123;&quot;before&quot;: true, &quot;after&quot;: true&#125;],</span><br><span class="line">// 禁止修改类声明的变量</span><br><span class="line">&quot;no-class-assign&quot;: 2,</span><br><span class="line">// 不允许箭头功能，在那里他们可以混淆的比较</span><br><span class="line">&quot;no-confusing-arrow&quot;: 0,</span><br><span class="line">// 禁止修改 const 声明的变量</span><br><span class="line">&quot;no-const-assign&quot;: 2,</span><br><span class="line">// 禁止类成员中出现重复的名称</span><br><span class="line">&quot;no-dupe-class-members&quot;: 2,</span><br><span class="line">// 不允许复制模块的进口</span><br><span class="line">&quot;no-duplicate-imports&quot;: 0,</span><br><span class="line">// 禁止 Symbol 的构造函数</span><br><span class="line">&quot;no-new-symbol&quot;: 2,</span><br><span class="line">// 允许指定模块加载时的进口</span><br><span class="line">&quot;no-restricted-imports&quot;: 0,</span><br><span class="line">// 禁止在构造函数中，在调用 super() 之前使用 this 或 super</span><br><span class="line">&quot;no-this-before-super&quot;: 2,</span><br><span class="line">// 禁止不必要的计算性能键对象的文字</span><br><span class="line">&quot;no-useless-computed-key&quot;: 0,</span><br><span class="line">// 要求使用 let 或 const 而不是 var</span><br><span class="line">&quot;no-var&quot;: 0,</span><br><span class="line">// 要求或禁止对象字面量中方法和属性使用简写语法</span><br><span class="line">&quot;object-shorthand&quot;: 0,</span><br><span class="line">// 要求使用箭头函数作为回调</span><br><span class="line">&quot;prefer-arrow-callback&quot;: 0,</span><br><span class="line">// 要求使用 const 声明那些声明后不再被修改的变量</span><br><span class="line">&quot;prefer-const&quot;: 0,</span><br><span class="line">// 要求在合适的地方使用 Reflect 方法</span><br><span class="line">&quot;prefer-reflect&quot;: 0,</span><br><span class="line">// 要求使用扩展运算符而非 .apply()</span><br><span class="line">&quot;prefer-spread&quot;: 0,</span><br><span class="line">// 要求使用模板字面量而非字符串连接</span><br><span class="line">&quot;prefer-template&quot;: 0,</span><br><span class="line">// Suggest using the rest parameters instead of arguments</span><br><span class="line">&quot;prefer-rest-params&quot;: 0,</span><br><span class="line">// 要求generator 函数内有 yield</span><br><span class="line">&quot;require-yield&quot;: 0,</span><br><span class="line">// enforce spacing between rest and spread operators and their expressions</span><br><span class="line">&quot;rest-spread-spacing&quot;: 0,</span><br><span class="line">// 强制模块内的 import 排序</span><br><span class="line">&quot;sort-imports&quot;: 0,</span><br><span class="line">// 要求或禁止模板字符串中的嵌入表达式周围空格的使用</span><br><span class="line">&quot;template-curly-spacing&quot;: 1,</span><br><span class="line">// 强制在 yield* 表达式中 * 周围使用空格</span><br><span class="line">&quot;yield-star-spacing&quot;: 2</span><br></pre></td></tr></table></figure>



<h4 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 禁止条件表达式中出现赋值操作符</span><br><span class="line">&quot;no-cond-assign&quot;: 2,</span><br><span class="line">// 禁用 console</span><br><span class="line">&quot;no-console&quot;: 0,</span><br><span class="line">// 禁止在条件中使用常量表达式</span><br><span class="line">// if (false) &#123;</span><br><span class="line">// doSomethingUnfinished();</span><br><span class="line">// &#125; //cuowu</span><br><span class="line">&quot;no-constant-condition&quot;: 2,</span><br><span class="line">// 禁止在正则表达式中使用控制字符 ：new RegExp(&quot;\x1f&quot;)</span><br><span class="line">&quot;no-control-regex&quot;: 2,</span><br><span class="line">// 数组和对象键值对最后一个逗号， never参数：不能带末尾的逗号, always参数：必须带末尾的逗号，</span><br><span class="line">// always-multiline：多行模式必须带逗号，单行模式不能带逗号</span><br><span class="line">&quot;comma-dangle&quot;: [1, &quot;always-multiline&quot;],</span><br><span class="line">// 禁用 debugger</span><br><span class="line">&quot;no-debugger&quot;: 2,</span><br><span class="line">// 禁止 function 定义中出现重名参数</span><br><span class="line">&quot;no-dupe-args&quot;: 2,</span><br><span class="line">// 禁止对象字面量中出现重复的 key</span><br><span class="line">&quot;no-dupe-keys&quot;: 2,</span><br><span class="line">// 禁止重复的 case 标签</span><br><span class="line">&quot;no-duplicate-case&quot;: 2,</span><br><span class="line">// 禁止空语句块</span><br><span class="line">&quot;no-empty&quot;: 2,</span><br><span class="line">// 禁止在正则表达式中使用空字符集 (/^abc[]/)</span><br><span class="line">&quot;no-empty-character-class&quot;: 2,</span><br><span class="line">// 禁止对 catch 子句的参数重新赋值</span><br><span class="line">&quot;no-ex-assign&quot;: 2,</span><br><span class="line">// 禁止不必要的布尔转换</span><br><span class="line">&quot;no-extra-boolean-cast&quot;: 2,</span><br><span class="line">// 禁止不必要的括号 //(a * b) + c;//报错</span><br><span class="line">&quot;no-extra-parens&quot;: 0,</span><br><span class="line">// 禁止不必要的分号</span><br><span class="line">&quot;no-extra-semi&quot;: 2,</span><br><span class="line">// 禁止对 function 声明重新赋值</span><br><span class="line">&quot;no-func-assign&quot;: 2,</span><br><span class="line">// 禁止在嵌套的块中出现 function 或 var 声明</span><br><span class="line">&quot;no-inner-declarations&quot;: [2, &quot;functions&quot;],</span><br><span class="line">// 禁止 RegExp 构造函数中无效的正则表达式字符串</span><br><span class="line">&quot;no-invalid-regexp&quot;: 2,</span><br><span class="line">// 禁止在字符串和注释之外不规则的空白</span><br><span class="line">&quot;no-irregular-whitespace&quot;: 2,</span><br><span class="line">// 禁止在 in 表达式中出现否定的左操作数</span><br><span class="line">&quot;no-negated-in-lhs&quot;: 2,</span><br><span class="line">// 禁止把全局对象 (Math 和 JSON) 作为函数调用 错误：var math = Math();</span><br><span class="line">&quot;no-obj-calls&quot;: 2,</span><br><span class="line">// 禁止直接使用 Object.prototypes 的内置属性</span><br><span class="line">&quot;no-prototype-builtins&quot;: 0,</span><br><span class="line">// 禁止正则表达式字面量中出现多个空格</span><br><span class="line">&quot;no-regex-spaces&quot;: 2,</span><br><span class="line">// 禁用稀疏数组</span><br><span class="line">&quot;no-sparse-arrays&quot;: 2,</span><br><span class="line">// 禁止出现令人困惑的多行表达式</span><br><span class="line">&quot;no-unexpected-multiline&quot;: 2,</span><br><span class="line">// 禁止在return、throw、continue 和 break语句之后出现不可达代码</span><br><span class="line">/*</span><br><span class="line"> function foo() &#123;</span><br><span class="line"> return true;</span><br><span class="line"> console.log(&quot;done&quot;);</span><br><span class="line"> &#125;//错误</span><br><span class="line"> */</span><br><span class="line">&quot;no-unreachable&quot;: 2,</span><br><span class="line">// 要求使用 isNaN() 检查 NaN</span><br><span class="line">&quot;use-isnan&quot;: 2,</span><br><span class="line">// 强制使用有效的 JSDoc 注释</span><br><span class="line">&quot;valid-jsdoc&quot;: 1,</span><br><span class="line">// 强制 typeof 表达式与有效的字符串进行比较</span><br><span class="line">// typeof foo === &quot;undefimed&quot; 错误</span><br><span class="line">&quot;valid-typeof&quot;: 2,</span><br></pre></td></tr></table></figure>

<h4 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 定义对象的set存取器属性时，强制定义get</span><br><span class="line">&quot;accessor-pairs&quot;: 2,</span><br><span class="line">// 强制数组方法的回调函数中有 return 语句</span><br><span class="line">&quot;array-callback-return&quot;: 0,</span><br><span class="line">// 强制把变量的使用限制在其定义的作用域范围内</span><br><span class="line">&quot;block-scoped-var&quot;: 0,</span><br><span class="line">// 限制圈复杂度，也就是类似if else能连续接多少个</span><br><span class="line">&quot;complexity&quot;: [2, 9],</span><br><span class="line">// 要求 return 语句要么总是指定返回的值，要么不指定</span><br><span class="line">&quot;consistent-return&quot;: 0,</span><br><span class="line">// 强制所有控制语句使用一致的括号风格</span><br><span class="line">&quot;curly&quot;: [2, &quot;all&quot;],</span><br><span class="line">// switch 语句强制 default 分支，也可添加 // no default 注释取消此次警告</span><br><span class="line">&quot;default-case&quot;: 2,</span><br><span class="line">// 强制object.key 中 . 的位置，参数:</span><br><span class="line">// property，&#x27;.&#x27;号应与属性在同一行</span><br><span class="line">// object, &#x27;.&#x27; 号应与对象名在同一行</span><br><span class="line">&quot;dot-location&quot;: [2, &quot;property&quot;],</span><br><span class="line">// 强制使用.号取属性</span><br><span class="line">// 参数： allowKeywords：true 使用保留字做属性名时，只能使用.方式取属性</span><br><span class="line">// false 使用保留字做属性名时, 只能使用[]方式取属性 e.g [2, &#123;&quot;allowKeywords&quot;: false&#125;]</span><br><span class="line">// allowPattern: 当属性名匹配提供的正则表达式时，允许使用[]方式取值,否则只能用.号取值 e.g [2, &#123;&quot;allowPattern&quot;: &quot;^[a-z]+(_[a-z]+)+$&quot;&#125;]</span><br><span class="line">&quot;dot-notation&quot;: [2, &#123;&quot;allowKeywords&quot;: false&#125;],</span><br><span class="line">// 使用 === 替代 == allow-null允许null和undefined==</span><br><span class="line">&quot;eqeqeq&quot;: [2, &quot;allow-null&quot;],</span><br><span class="line">// 要求 for-in 循环中有一个 if 语句</span><br><span class="line">&quot;guard-for-in&quot;: 2,</span><br><span class="line">// 禁用 alert、confirm 和 prompt</span><br><span class="line">&quot;no-alert&quot;: 0,</span><br><span class="line">// 禁用 arguments.caller 或 arguments.callee</span><br><span class="line">&quot;no-caller&quot;: 2,</span><br><span class="line">// 不允许在 case 子句中使用词法声明</span><br><span class="line">&quot;no-case-declarations&quot;: 2,</span><br><span class="line">// 禁止除法操作符显式的出现在正则表达式开始的位置</span><br><span class="line">&quot;no-div-regex&quot;: 2,</span><br><span class="line">// 禁止 if 语句中有 return 之后有 else</span><br><span class="line">&quot;no-else-return&quot;: 0,</span><br><span class="line">// 禁止出现空函数.如果一个函数包含了一条注释，它将不会被认为有问题。</span><br><span class="line">&quot;no-empty-function&quot;: 2,</span><br><span class="line">// 禁止使用空解构模式no-empty-pattern</span><br><span class="line">&quot;no-empty-pattern&quot;: 2,</span><br><span class="line">// 禁止在没有类型检查操作符的情况下与 null 进行比较</span><br><span class="line">&quot;no-eq-null&quot;: 1,</span><br><span class="line">// 禁用 eval()</span><br><span class="line">&quot;no-eval&quot;: 2,</span><br><span class="line">// 禁止扩展原生类型</span><br><span class="line">&quot;no-extend-native&quot;: 2,</span><br><span class="line">// 禁止不必要的 .bind() 调用</span><br><span class="line">&quot;no-extra-bind&quot;: 2,</span><br><span class="line">// 禁用不必要的标签</span><br><span class="line">&quot;no-extra-label:&quot;: 0,</span><br><span class="line">// 禁止 case 语句落空</span><br><span class="line">&quot;no-fallthrough&quot;: 2,</span><br><span class="line">// 禁止数字字面量中使用前导和末尾小数点</span><br><span class="line">&quot;no-floating-decimal&quot;: 2,</span><br><span class="line">// 禁止使用短符号进行类型转换(!!fOO)</span><br><span class="line">&quot;no-implicit-coercion&quot;: 0,</span><br><span class="line">// 禁止在全局范围内使用 var 和命名的 function 声明</span><br><span class="line">&quot;no-implicit-globals&quot;: 1,</span><br><span class="line">// 禁止使用类似 eval() 的方法</span><br><span class="line">&quot;no-implied-eval&quot;: 2,</span><br><span class="line">// 禁止 this 关键字出现在类和类对象之外</span><br><span class="line">&quot;no-invalid-this&quot;: 0,</span><br><span class="line">// 禁用 __iterator__ 属性</span><br><span class="line">&quot;no-iterator&quot;: 2,</span><br><span class="line">// 禁用标签语句</span><br><span class="line">&quot;no-labels&quot;: 2,</span><br><span class="line">// 禁用不必要的嵌套块</span><br><span class="line">&quot;no-lone-blocks&quot;: 2,</span><br><span class="line">// 禁止在循环中出现 function 声明和表达式</span><br><span class="line">&quot;no-loop-func&quot;: 1,</span><br><span class="line">// 禁用魔术数字(3.14什么的用常量代替)</span><br><span class="line">&quot;no-magic-numbers&quot;:[1, &#123;&quot;ignore&quot;: [0, -1, 1] &#125;],</span><br><span class="line">// 禁止使用多个空格</span><br><span class="line">&quot;no-multi-spaces&quot;: 2,</span><br><span class="line">// 禁止使用多行字符串，在 JavaScript 中，可以在新行之前使用斜线创建多行字符串</span><br><span class="line">&quot;no-multi-str&quot;: 2,</span><br><span class="line">// 禁止对原生对象赋值</span><br><span class="line">&quot;no-native-reassign&quot;: 2,</span><br><span class="line">// 禁止在非赋值或条件语句中使用 new 操作符</span><br><span class="line">&quot;no-new&quot;: 2,</span><br><span class="line">// 禁止对 Function 对象使用 new 操作符</span><br><span class="line">&quot;no-new-func&quot;: 0,</span><br><span class="line">// 禁止对 String，Number 和 Boolean 使用 new 操作符</span><br><span class="line">&quot;no-new-wrappers&quot;: 2,</span><br><span class="line">// 禁用八进制字面量</span><br><span class="line">&quot;no-octal&quot;: 2,</span><br><span class="line">// 禁止在字符串中使用八进制转义序列</span><br><span class="line">&quot;no-octal-escape&quot;: 2,</span><br><span class="line">// 不允许对 function 的参数进行重新赋值</span><br><span class="line">&quot;no-param-reassign&quot;: 0,</span><br><span class="line">// 禁用 __proto__ 属性</span><br><span class="line">&quot;no-proto&quot;: 2,</span><br><span class="line">// 禁止使用 var 多次声明同一变量</span><br><span class="line">&quot;no-redeclare&quot;: 2,</span><br><span class="line">// 禁用指定的通过 require 加载的模块</span><br><span class="line">&quot;no-return-assign&quot;: 0,</span><br><span class="line">// 禁止使用 javascript: url</span><br><span class="line">&quot;no-script-url&quot;: 0,</span><br><span class="line">// 禁止自我赋值</span><br><span class="line">&quot;no-self-assign&quot;: 2,</span><br><span class="line">// 禁止自身比较</span><br><span class="line">&quot;no-self-compare&quot;: 2,</span><br><span class="line">// 禁用逗号操作符</span><br><span class="line">&quot;no-sequences&quot;: 2,</span><br><span class="line">// 禁止抛出非异常字面量</span><br><span class="line">&quot;no-throw-literal&quot;: 2,</span><br><span class="line">// 禁用一成不变的循环条件</span><br><span class="line">&quot;no-unmodified-loop-condition&quot;: 2,</span><br><span class="line">// 禁止出现未使用过的表达式</span><br><span class="line">&quot;no-unused-expressions&quot;: 0,</span><br><span class="line">// 禁用未使用过的标签</span><br><span class="line">&quot;no-unused-labels&quot;: 2,</span><br><span class="line">// 禁止不必要的 .call() 和 .apply()</span><br><span class="line">&quot;no-useless-call&quot;: 2,</span><br><span class="line">// 禁止不必要的字符串字面量或模板字面量的连接</span><br><span class="line">&quot;no-useless-concat&quot;: 2,</span><br><span class="line">// 禁用不必要的转义字符</span><br><span class="line">&quot;no-useless-escape&quot;: 0,</span><br><span class="line">// 禁用 void 操作符</span><br><span class="line">&quot;no-void&quot;: 0,</span><br><span class="line">// 禁止在注释中使用特定的警告术语</span><br><span class="line">&quot;no-warning-comments&quot;: 0,</span><br><span class="line">// 禁用 with 语句</span><br><span class="line">&quot;no-with&quot;: 2,</span><br><span class="line">// 强制在parseInt()使用基数参数</span><br><span class="line">&quot;radix&quot;: 2,</span><br><span class="line">// 要求所有的 var 声明出现在它们所在的作用域顶部</span><br><span class="line">&quot;vars-on-top&quot;: 0,</span><br><span class="line">// 要求 IIFE 使用括号括起来</span><br><span class="line">&quot;wrap-iife&quot;: [2, &quot;any&quot;],</span><br><span class="line">// 要求或禁止 “Yoda” 条件</span><br><span class="line">&quot;yoda&quot;: [2, &quot;never&quot;],</span><br><span class="line">// 要求或禁止使用严格模式指令</span><br><span class="line">&quot;strict&quot;: 0,</span><br></pre></td></tr></table></figure>

<h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 要求或禁止 var 声明中的初始化(初值)</span><br><span class="line">&quot;init-declarations&quot;: 0,</span><br><span class="line">// 不允许 catch 子句的参数与外层作用域中的变量同名</span><br><span class="line">&quot;no-catch-shadow&quot;: 0,</span><br><span class="line">// 禁止删除变量</span><br><span class="line">&quot;no-delete-var&quot;: 2,</span><br><span class="line">// 不允许标签与变量同名</span><br><span class="line">&quot;no-label-var&quot;: 2,</span><br><span class="line">// 禁用特定的全局变量</span><br><span class="line">&quot;no-restricted-globals&quot;: 0,</span><br><span class="line">// 禁止 var 声明 与外层作用域的变量同名</span><br><span class="line">&quot;no-shadow&quot;: 0,</span><br><span class="line">// 禁止覆盖受限制的标识符</span><br><span class="line">&quot;no-shadow-restricted-names&quot;: 2,</span><br><span class="line">// 禁用未声明的变量，除非它们在 /*global */ 注释中被提到</span><br><span class="line">&quot;no-undef&quot;: 2,</span><br><span class="line">// 禁止将变量初始化为 undefined</span><br><span class="line">&quot;no-undef-init&quot;: 2,</span><br><span class="line">// 禁止将 undefined 作为标识符</span><br><span class="line">&quot;no-undefined&quot;: 0,</span><br><span class="line">// 禁止出现未使用过的变量</span><br><span class="line">&quot;no-unused-vars&quot;: [2, &#123;&quot;vars&quot;: &quot;all&quot;, &quot;args&quot;: &quot;none&quot;&#125;],</span><br><span class="line">// 不允许在变量定义之前使用它们</span><br><span class="line">&quot;no-use-before-define&quot;: 0,</span><br></pre></td></tr></table></figure>

<h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// require return statements after callbacks</span><br><span class="line">&quot;callback-return&quot;: 0,</span><br><span class="line">// 要求 require() 出现在顶层模块作用域中</span><br><span class="line">&quot;global-require&quot;: 1,</span><br><span class="line">// 要求回调函数中有容错处理</span><br><span class="line">&quot;handle-callback-err&quot;: [2, &quot;^(err|error)$&quot;],</span><br><span class="line">// 禁止混合常规 var 声明和 require 调用</span><br><span class="line">&quot;no-mixed-requires&quot;: 0,</span><br><span class="line">// 禁止调用 require 时使用 new 操作符</span><br><span class="line">&quot;no-new-require&quot;: 2,</span><br><span class="line">// 禁止对 __dirname 和 __filename进行字符串连接</span><br><span class="line">&quot;no-path-concat&quot;: 0,</span><br><span class="line">// 禁用 process.env</span><br><span class="line">&quot;no-process-env&quot;: 0,</span><br><span class="line">// 禁用 process.exit()</span><br><span class="line">&quot;no-process-exit&quot;: 0,</span><br><span class="line">// 禁用同步方法</span><br><span class="line">&quot;no-sync&quot;: 0,</span><br></pre></td></tr></table></figure>



<h4 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h4><p>eslint-plugin-prettier插件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> rules: &#123;</span><br><span class="line">    &quot;prettier/prettier&quot;: [</span><br><span class="line">      &quot;off&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        useTabs: false, // 不使用tab</span><br><span class="line">        singleQuote: false, // 不使用单引号</span><br><span class="line">        printWidth: 150, // 换行字符串阈值</span><br><span class="line">        semi: true, // 句末加分号</span><br><span class="line">        trailingComma: &quot;none&quot;, // 最后一个对象元素加逗号</span><br><span class="line">        bracketSpacing: true, // 对象，数组加空格</span><br><span class="line">        jsxBracketSameLine: true, // jsx &gt; 是否另起一行</span><br><span class="line">        arrowParens: &quot;avoid&quot;, // (x) =&gt; &#123;&#125; 是否要有小括号</span><br><span class="line">        requirePragma: false, // 是否要注释来决定是否格式化代码</span><br><span class="line">        proseWrap: &quot;preserve&quot; // 是否要换行</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Prettier-代码风格"><a href="#Prettier-代码风格" class="headerlink" title="Prettier(代码风格)"></a>Prettier(代码风格)</h2><h3 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h3><p>它是<strong>代码格式化工具</strong>，用来做代码格式化，有了Prettier之后，它能去掉原始的代码风格，确保团队的代码使用统一相同的格式</p>
<h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 常用配置相关解释</span></span><br><span class="line">  printWidth: <span class="number">100</span>, <span class="comment">// 超过最大值换行</span></span><br><span class="line">  tabWidth: <span class="number">4</span>, <span class="comment">// 缩进字节数</span></span><br><span class="line">  useTabs: <span class="literal">false</span>, <span class="comment">// 缩进不使用tab，使用空格</span></span><br><span class="line">  semi: <span class="literal">true</span>, <span class="comment">// 句尾添加分号</span></span><br><span class="line">  singleQuote: <span class="literal">true</span>, <span class="comment">// 使用单引号代替双引号</span></span><br><span class="line">  proseWrap: <span class="string">&quot;preserve&quot;</span>, <span class="comment">// 默认值。因为使用了一些折行敏感型的渲染器（如GitHub comment）而按照markdown文本样式进行折行</span></span><br><span class="line">  arrowParens: <span class="string">&quot;avoid&quot;</span>, <span class="comment">//  (x) =&gt; &#123;&#125; 箭头函数参数只有一个时是否要有小括号。avoid：省略括号</span></span><br><span class="line">  bracketSpacing: <span class="literal">true</span>, <span class="comment">// 在对象，数组括号与文字之间加空格 &quot;&#123; foo: bar &#125;&quot;</span></span><br><span class="line">  disableLanguages: [<span class="string">&quot;vue&quot;</span>], <span class="comment">// 不格式化vue文件，vue文件的格式化单独设置</span></span><br><span class="line">  endOfLine: <span class="string">&quot;auto&quot;</span>, <span class="comment">// 结尾是 \n \r \n\r auto</span></span><br><span class="line">  eslintIntegration: <span class="literal">false</span>, <span class="comment">//不让prettier使用eslint的代码格式进行校验</span></span><br><span class="line">  htmlWhitespaceSensitivity: <span class="string">&quot;ignore&quot;</span>, <span class="comment">// &quot;指定 HTML 元素是在「内容内换行」还是在「属性与右尖括号内换行」，前者可能导致内联元素渲染出额外的空格。选项：`css`──块级元素采用前者，内联元素采用后者、 `strict`──全部采用后者、 `ignore`──全部采用后者。[参考文档](https://www.wolai.com/make/nfqXcvFSXy6KtnVvD8xrNL)&quot;</span></span><br><span class="line">  ignorePath: <span class="string">&quot;.prettierignore&quot;</span>, <span class="comment">// 不使用prettier格式化的文件填写在项目的.prettierignore文件中</span></span><br><span class="line">  jsxBracketSameLine: <span class="literal">true</span>, <span class="comment">//多属性htmlproseWrap标签的‘&gt;’折行放置</span></span><br><span class="line">  bracketSameLine: <span class="literal">false</span>, <span class="comment">//如果 HTML 元素（包括 JSX 等） 具有多个属性，将其结束标签右尖括号 `&gt;` 放在最后一个属性的末尾，而不是另起一行,</span></span><br><span class="line">  jsxSingleQuote: <span class="literal">false</span>, <span class="comment">// 在jsx中使用单引号代替双引号</span></span><br><span class="line">  parser: <span class="string">&quot;babylon&quot;</span>, <span class="comment">// 格式化的解析器，默认是babylon</span></span><br><span class="line">  requirePragma: <span class="literal">false</span>, <span class="comment">//无需顶部注释即可格式化</span></span><br><span class="line">  stylelintIntegration: <span class="literal">false</span>, <span class="comment">//不让prettier使用stylelint的代码格式进行校验</span></span><br><span class="line">  trailingComma: <span class="string">&quot;es5&quot;</span>, <span class="comment">// 在对象或数组最后一个元素后面是否加逗号（在ES5中加尾逗号）</span></span><br><span class="line">  tslintIntegration: <span class="literal">false</span>, <span class="comment">// 不让prettier使用tslint的代码格式进行校验</span></span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.js&quot;</span>: <span class="string">&quot;prettier&quot;</span>, <span class="comment">// vetur 使用 prettier格式化代码</span></span><br><span class="line">  quoteProps: <span class="string">&quot;as-needed&quot;</span>, <span class="comment">// 对象的 key 仅在必要时用引号</span></span><br><span class="line">  <span class="comment">// 每个文件格式化的范围是文件的全部内容</span></span><br><span class="line">  rangeStart: <span class="number">0</span>,</span><br><span class="line">  rangeEnd: Infinity,</span><br><span class="line">  singleAttributePerLine: <span class="literal">false</span>, <span class="comment">//如果 HTML 元素（包括 JSX 等）具有多个属性，将其每个属性格式化为单独占一行</span></span><br><span class="line">  embeddedLanguageFormatting: <span class="literal">true</span>, <span class="comment">//对引号中代码使用智能格式化</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>ESLint 是用于发现并修复代码问题（包括代码风格格式化），这和 Prettier 美化代码风格显得很矛盾，因为它们存在重叠的部分，那么业界为什么要将二者结合在一起使用呢？</p>
<p>ESLint 之类的 Linters 对于代码格式化的能力是有限的，不如 Prettier 那么专业。所以使用<strong>Prettier 进行格式化</strong>，使用 linter<strong>来捕捉错误！</strong></p>
<p>所以，怎么处理重叠部分的冲突？Prettier 提供了两个插件：</p>
<ul>
<li><code>eslint-config-prettier</code>：<ul>
<li><p><a href="https://link.juejin.cn/?target=https://github.com/prettier/eslint-config-prettier">github.com/prettier/es…</a></p>
</li>
<li><p>解决 ESLint 中的样式规范（即代码风格）和 Prettier 中样式规范的冲突，<strong>以 Prettier 的样式规范为准，使 ESLint 中的样式规范自动失效</strong>。对应 .eslintrc 配置 <code>extends-&quot;prettier&quot;</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extends: [&quot;plugin:vue/essential&quot;, &quot;@vue/prettier&quot;, &quot;@vue/typescript&quot;, &#x27;prettier&#x27;], </span><br><span class="line">// 覆盖eslint格式配置,写在最后</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><code>eslint-plugin-prettier</code>：由于冲突的配置项被关闭, 相关的编码风格将不在检测, 为了继续检测这些风格, Prettier 提供 ESLint 插件 <a href="https://github.com/prettier/eslint-plugin-prettier">eslint-plugin-prettier</a> 注册规则(rule) <code>prettier/prettier</code> 到 ESLint, 开启这个规则后即可通过 ESLint 检测 Prettier 风格问题<ul>
<li><a href="https://link.juejin.cn/?target=https://github.com/prettier/eslint-plugin-prettier">github.com/prettier/es…</a></li>
<li><strong>将 Prettier 样式规范作为 ESLint 代码质量规范来使用，同样将格式问题以 error 的形式抛出</strong>，即 <code>rule-&quot;prettier/prettier&quot;</code>，可在 <code>rules-&quot;prettier/prettier&quot;</code> 中进行自定义配置。对应 .eslintrc 配置 <code>plugin-&quot;prettier&quot;</code></li>
</ul>
<blockquote>
<p>虽然可以通过ESLint配置文件将选项传递给Pretier，但不建议这样做，因为编辑器扩展名（如<code>prettier-atom</code> and <code>prettier-vscode</code> ）将读取<a href="https://prettier.io/docs/en/configuration.html"><code>.prettierrc</code></a>，但不会从ESLint读取设置，这可能会导致不一致的体验。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> rules: &#123;</span><br><span class="line">    &quot;prettier/prettier&quot;: [</span><br><span class="line">      &quot;off&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        useTabs: false, // 不使用tab</span><br><span class="line">        singleQuote: false, // 不使用单引号</span><br><span class="line">        printWidth: 150, // 换行字符串阈值</span><br><span class="line">        semi: true, // 句末加分号</span><br><span class="line">        trailingComma: &quot;none&quot;, // 最后一个对象元素加逗号</span><br><span class="line">        bracketSpacing: true, // 对象，数组加空格</span><br><span class="line">        jsxBracketSameLine: true, // jsx &gt; 是否另起一行</span><br><span class="line">        arrowParens: &quot;avoid&quot;, // (x) =&gt; &#123;&#125; 是否要有小括号</span><br><span class="line">        requirePragma: false, // 是否要注释来决定是否格式化代码</span><br><span class="line">        proseWrap: &quot;preserve&quot; // 是否要换行</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h2><h3 id="VS配置扩展"><a href="#VS配置扩展" class="headerlink" title="VS配置扩展"></a>VS配置扩展</h3><p>vscode中打开设置输入<code>@tag:sync</code>，点击setting.json配置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ----------------  prettier  ----------------</span></span><br><span class="line">  <span class="attr">&quot;prettier.jsxSingleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.printWidth&quot;</span>: <span class="number">800</span>, <span class="comment">//换行数</span></span><br><span class="line">  <span class="attr">&quot;prettier.vueIndentScriptAndStyle&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>, <span class="comment">// 用单引号</span></span><br><span class="line">  <span class="attr">&quot;prettier.semi&quot;</span>: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ----------------  vetur  ----------------</span></span><br><span class="line">  <span class="attr">&quot;vetur.validation.template&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;wrap_line_length&quot;</span>: <span class="number">150</span>, <span class="comment">//换行长度</span></span><br><span class="line">      <span class="attr">&quot;wrap_attributes&quot;</span>: <span class="string">&quot;auto&quot;</span>, <span class="comment">//属性换行</span></span><br><span class="line">      <span class="attr">&quot;end_with_newline&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;prettyhtml&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">      <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;wrapAttributes&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;sortAttributes&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">      <span class="comment">// Prettier option here</span></span><br><span class="line">      <span class="attr">&quot;printWidth&quot;</span>: <span class="number">180</span> <span class="comment">// 超过最大值换行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line">  <span class="comment">//让vue中的js按编辑器prettier格式进行格式化</span></span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.js&quot;</span>: <span class="string">&quot;prettier&quot;</span></span><br><span class="line">  <span class="comment">// 让vue中的js按编辑器自带的ts格式进行格式化</span></span><br><span class="line">  <span class="comment">// &quot;vetur.format.defaultFormatter.js&quot;: &quot;vscode-typescript&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vscode扩展"><a href="#vscode扩展" class="headerlink" title="vscode扩展"></a>vscode扩展</h3><h4 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h4><p>保存代码自动修复</p>
<h4 id="eslint"><a href="#eslint" class="headerlink" title="eslint"></a>eslint</h4><p>安装插件：ESLint，这样代码不规范的时候底部才有波浪线出现。</p>
<h4 id="Vetur和Volar"><a href="#Vetur和Volar" class="headerlink" title="Vetur和Volar"></a>Vetur和Volar</h4><p>给 Vue 提供代码高亮和语法提示</p>
<p>vue2:Vetur</p>
<p>vue3:Volar</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="JS规范"><a href="#JS规范" class="headerlink" title="JS规范"></a>JS规范</h2><p>Nodejs端是使⽤CommonJS规范的，前端</p>
<p>浏览器⼀般使⽤AMD、CMD、ES6等定义模块化开发的</p>
<h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><strong>AMD</strong></h3><p>鉴于浏览器的特殊情况，又出现了一个规范，这个规范呢可以实现异步加载依赖模块，并且会提前加载那就是AMD规范。AMD是RequireJS在推⼴过程中对模块定义的规范化产出</p>
<p><strong>其核心接口是</strong>：define(id, 『dependencies』, factory) ，它要在声明模块的时候指定所有的依赖 dependencies ，并且还要当做形参传到factory 中，对于依赖的模块<strong>提前执行</strong>，<strong>依赖前置</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="string">&quot;module&quot;</span>, [<span class="string">&quot;dep1&quot;</span>, <span class="string">&quot;dep2&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someExportedValue;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">require</span>([<span class="string">&quot;module&quot;</span>, <span class="string">&quot;../file&quot;</span>], <span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">module</span>, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>在浏览器环境中异步加载模块；并行加载多个模块；</p>
<p><strong>缺点：</strong>开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅；不符合通用的模块化思维方式，是一种妥协的实现；</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a><strong>CMD</strong></h3><p>Common Module Definition 规范和 AMD 很相似，尽量保持简单，并与 CommonJS 和 Node.js 的 Modules 规范保持了很大的兼容性。<strong>SeaJS</strong>在推⼴过程中对模块定义的规范化产出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">&#x27;jquery&#x27;</span>);</span><br><span class="line">  <span class="keyword">var</span> Spinning = <span class="built_in">require</span>(<span class="string">&#x27;./spinning&#x27;</span>);</span><br><span class="line">  <span class="built_in">exports</span>.doSomething = ...</span><br><span class="line">  <span class="built_in">module</span>.exports = ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>优点：依赖就近，延迟执行</strong>（对于依赖的模块延迟执行，即只在需要用到某个模块的时候再require） 可以很容易在 Node.js 中运行；<br><strong>缺点：</strong>依赖 SPM 打包，模块的加载逻辑偏重；<br><strong>实现：Sea.js</strong> ；coolie</p>
<h3 id="CommonJS和ES6"><a href="#CommonJS和ES6" class="headerlink" title="CommonJS和ES6"></a>CommonJS和ES6</h3><p><a href="https://es6.ruanyifeng.com/#docs/module-loader">https://es6.ruanyifeng.com/#docs/module-loader</a></p>
<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><p>是一种为JS的表现指定的规范，它希望js可以运行在任何地方，更多的说的是服务端模块规范，Node.js采用了这个规范。</p>
<p>核心思想：<br>允许模块通过 <code>require</code> 方法来同步加载所要依赖的其他模块，然后通过 <code>exports</code> 或 <code>module.exports</code> 来导出需要暴露的接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="comment">//本质上是将要导出的对象赋值给module对象的export属性，然后在其他文件中通过require这个方法访问该属性</span></span><br><span class="line"><span class="built_in">exports</span>.a = <span class="string">&#x27;Hello world&#x27;</span>; <span class="comment">// 相当于：module.exports.a = &#x27;Hello world&#x27;;</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="string">&#x27;Hello world&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> moduleA = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(moduleA.a); <span class="comment">// 打印出hello world</span></span><br></pre></td></tr></table></figure>

<p><strong>优点：</strong>服务器端模块重用，NPM中模块包多，有将近20万个。</p>
<p><strong>缺点：</strong>加载模块是<strong>同步</strong>的，只有加载完成后才能执行后面的操作，也就是当要用到该模块了，现加载现用，不仅加载速度慢，而且还会导致性能、可用性、调试和跨域访问等问题。Node.js主要用于服务器编程，加载的模块文件一般都存在本地硬盘，加载起来比较快，不用考虑异步加载的方式，因此,CommonJS规范比较适用。然而，这并不适合在浏览器环境，同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案。</p>
<p><strong>环境</strong>：</p>
<ul>
<li>服务器端的 <a href="http://www.nodejs.org/">Node.js</a></li>
<li><a href="http://browserify.org/">Browserify</a>，浏览器端的 CommonJS 实现，可以使用 NPM 的模块，但是编译打包后的文件体积可能很大</li>
<li><a href="https://github.com/medikoo/modules-webmake">modules-webmake</a>，类似Browserify，还不如 Browserify 灵活</li>
<li><a href="https://github.com/substack/wreq">wreq</a>，Browserify 的前身</li>
</ul>
<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a><strong>ES6</strong></h4><p>ECMAScript6 标准增加了 JavaScript 语言层面的模块体系定义。<a href="http://es6.ruanyifeng.com/#docs/module">ES6 模块</a>的设计思想，是尽量的静态化，使得<strong>编译</strong>时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。<strong>但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require</strong>。</p>
<ul>
<li><p><strong>命名导出</strong> </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// B.js</span><br><span class="line">/*--------  单个变量或函数导出  ----------*/</span><br><span class="line">export function show() &#123; console.log(&#x27;show方法被调用&#x27;) &#125;</span><br><span class="line"></span><br><span class="line">export let count = 3</span><br><span class="line"></span><br><span class="line">/*--------  批量导出  ----------*/</span><br><span class="line">function show() &#123; console.log(&#x27;show方法被调用&#x27;) &#125;</span><br><span class="line">let count = 3</span><br><span class="line">export &#123;show, count&#125; //  解构赋值语法(as关键字在这里表示将newA作为a的数据接口暴露给外部，外部不能直接访问a)</span><br></pre></td></tr></table></figure>

<p>第一种是单个的变量或函数导出，只需要直接在开头使用 <code>export</code> 关键字即可；</p>
<p>第二种情况是批量地把多个变量或函数导出，只需要把它们储存到一个对象中即可</p>
</li>
<li><p><strong>默认导出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// B.js</span><br><span class="line">function show() &#123; console.log(&#x27;show方法被调用&#x27;) &#125;</span><br><span class="line"></span><br><span class="line">// 默认导出函数show</span><br><span class="line">export default show</span><br></pre></td></tr></table></figure>

<p>默认导出是在 <code>export</code> 关键词后面再跟上一个 <code>default</code> 表示导出的该变量或函数是匿名的</p>
<blockquote>
<p><strong>注意：</strong> 一个模块只能默认导出一次，否则就会报错，具体原因会在后面讲解</p>
</blockquote>
</li>
<li><p><strong>导入</strong></p>
<p>ES6 Module 的导入用到的关键字是 <code>import</code> ，具体代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;show, count&#125; <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">show()   <span class="comment">// show方法被调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(count)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>ES6 Module的导入需要用一对 <code>&#123;&#125;</code> 大括号来接收我们需要导入的方法或函数</p>
<blockquote>
<p><strong>注意：</strong> 大括号中的变量或函数名必须与导出时的名称一模一样</p>
</blockquote>
<p>那么如果我们想修改导入的变量或函数的名称，可以通过 <code>as</code> 关键词来命名，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;show <span class="keyword">as</span> print, count <span class="keyword">as</span> number&#125; <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">print()   <span class="comment">// show方法被调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(number)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果我们要想将所有的变量或函数都导入，可以通过 <code>*</code> 来整体导入，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> bModule <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">bModule.show()  <span class="comment">// show方法被调用</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bModule.count)  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p><code>*</code> 表示全部的意思，我们将其全部导入，并赋值给 <code>bModule</code>，这样我们就可以通过 <code>bModule</code> 获取想要的变量或对象了</p>
<p>以上所说的都是针对命名导出的变量或函数，那么如何导入一个默认导出的变量或函数呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将通过 export default 导出的变量导入</span></span><br><span class="line"><span class="keyword">import</span> print <span class="keyword">from</span> <span class="string">&#x27;./B.js&#x27;</span></span><br><span class="line"></span><br><span class="line">print()  <span class="comment">// show方法被调用</span></span><br></pre></td></tr></table></figure>

<p>命名导出的变量都是通过 <code>&#123;&#125;</code> 来接收的，那么去掉 <code>&#123;&#125;</code> ，接收的就是默认导出的变量了，因为导出的变量是匿名的，因此我们可以随意地起个变量名用于接收</p>
<p><strong>补充：</strong> 这里特别提一下，与CommonJS不同，ES6 Module 的导入文件路径是不支持表达式的</p>
</li>
</ul>
<p>优点：</p>
<ul>
<li>容易进行静态分析</li>
<li>面向未来的 ECMAScript 标准</li>
</ul>
<p>缺点：</p>
<ul>
<li>原生浏览器端还没有实现该标准</li>
<li>全新的命令字，新版的 Node.js才支持</li>
</ul>
<h5 id="CommonJS-与ES6的区别"><a href="#CommonJS-与ES6的区别" class="headerlink" title="CommonJS 与ES6的区别"></a>CommonJS 与ES6的区别</h5><p><a href="https://mp.weixin.qq.com/s/1wUU-i3W4RlR2hf86lZqEA">https://mp.weixin.qq.com/s/1wUU-i3W4RlR2hf86lZqEA</a></p>
<p>这两者的主要区别主要有以下两点：</p>
<ol>
<li>对于模块的依赖，CommonJS是<strong>动态的</strong>，ES6 Module 是<strong>静态的</strong></li>
<li>CommonJS导入的是值的<strong>拷贝</strong>，ES6 Module导入的是值的<strong>引用</strong></li>
</ol>
<h6 id="区别一"><a href="#区别一" class="headerlink" title="区别一"></a>区别一</h6><p>对于模块的依赖，何为<strong>动态</strong>？何为<strong>静态</strong>？</p>
<p>动态是指对于模块的依赖关系建立在代码执行阶段；静态是指对于模块的依赖关系建立在代码编译阶段；</p>
<p>上文提到，CommonJS导入时，<code>require</code> 的路径参数是支持表达式的，例如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">let</span> fileName = <span class="string">&#x27;example.js&#x27;</span></span><br><span class="line"><span class="keyword">const</span> bModule = <span class="built_in">require</span>(<span class="string">&#x27;./&#x27;</span> + fileName)</span><br></pre></td></tr></table></figure>

<p>因为该路径在代码执行时是可以动态改变的，所以如果在代码编译阶段就建立各个模块的依赖关系，那么一定是不准确的，只有在代码运行了以后，才可以真正确认模块的依赖关系，因此说CommonJS是动态的。</p>
<p>那么现在你也应该也知道为什么 ES6 Module 是静态的了吧</p>
<h6 id="区别二"><a href="#区别二" class="headerlink" title="区别二"></a>区别二</h6><p>为了验证这一点，我准备用实例来演示一下</p>
<p>首先来验证CommonJS，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    count ++    <span class="comment">// 变量count + 1</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;原count值为：&#x27;</span>, count);  <span class="comment">// 打印B.js模块中count的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    count,</span><br><span class="line">    change</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="built_in">require</span>(<span class="string">&#x27;./B.js&#x27;</span>).count </span><br><span class="line"><span class="keyword">let</span> change = <span class="built_in">require</span>(<span class="string">&#x27;./B.js&#x27;</span>).change</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;改变前：&#x27;</span>, count);   </span><br><span class="line">change()     <span class="comment">// 调用模块B.js中的change方法，将原来的count + 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;改变后：&#x27;</span>, count); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行A.js文件的结果</span></span><br><span class="line">改变前：<span class="number">3</span></span><br><span class="line">原count值为：<span class="number">4</span></span><br><span class="line">改变后：<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>在上述代码中我们可以看到，在 <code>A.js</code> 文件中导入了 <code>B.js</code> 文件中的变量 <code>count</code> 和 函数 <code>change</code>，因为导入的 <code>count</code> 只是对原有值的一个拷贝，因此尽管我们调用了函数 <code>change</code> 改变了 <code>B.js</code> 文件中变量 <code>count</code> 的值，也不会影响到 <code>A.js</code> 文件中的变量 <code>count</code></p>
<p>根据这个结果得出结论：CommonJS导入的变量是对原值的拷贝</p>
<h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a><strong>代码优化</strong></h2><ul>
<li>对组件使用<code>Gzip</code>压缩</li>
</ul>
<h3 id="html"><a href="#html" class="headerlink" title="html"></a><strong>html</strong></h3><ul>
<li><p>禁止使用<code>iframe</code>（阻塞父文档<code>onload</code>事件）</p>
<ul>
<li><code>iframe</code>会阻塞主页面的<code>Onload</code>事件</li>
<li>搜索引擎的检索程序无法解读这种页面，不利于SEO</li>
<li><code>iframe</code>和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>使用<code>iframe</code>之前需要考虑这两个缺点。如果需要使用<code>iframe</code>，最好是通过<code>javascript</code></li>
<li>动态给<code>iframe</code>添加<code>src</code>属性值，这样可以绕开以上两个问题</li>
</ul>
</li>
<li><p>将 CSS 放在文件头部，JavaScript 文件放在底部</p>
<p>如果这些 CSS、JS 标签放在 HEAD 标签里，并且需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部（不阻止 DOM 解析，但会阻塞渲染），等 HTML 解析完了再加载 JS 文件，尽早向用户呈现页面的内容。</p>
<p>那为什么 CSS 文件还要放在头部呢？</p>
<p>因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。</p>
<p>另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 <strong>defer</strong> 属性就可以了，异步下载，延迟执行。</p>
</li>
<li><p><strong>图片</strong></p>
<ul>
<li><code>css</code>精灵图</li>
<li>对于一些小图标，可以使用base64位编码，以减少网络请求。但不建议大图使用，比较耗费<code>CPU</code><ul>
<li>小图标优势在于<ul>
<li>减少<code>HTTP</code>请求</li>
<li>避免文件跨域</li>
<li>修改及时生效</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="css-3"><a href="#css-3" class="headerlink" title="css"></a><strong>css</strong></h3><ul>
<li>将样式表放到页面顶部</li>
<li>不使用<code>CSS</code>表达式</li>
<li>使用<code>&lt;link&gt;</code>不使用<code>@import</code></li>
<li>使用<code>CSS3</code>代码代替<code>JS</code>动画（尽可能避免重绘重排以及回流）</li>
<li>当需要设置的样式很多时设置<code>className</code>而不是直接操作<code>style</code></li>
</ul>
<h3 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h3><ul>
<li><p>减少<code>DOM</code>访问</p>
</li>
<li><p>for 与 forEach，哪个遍历数组会更快</p>
<ul>
<li><p>使用 time 和 console.timeEnd 来测量执行 javascript 脚本所消耗的时间。 </p>
<p><img src="img/%E5%B8%B8%E8%AF%86/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220913165448.png"></p>
<p>for 语句赢得了这场比赛。让我们总结一下原因：</p>
<p>1).for不创建函数</p>
<p>2).forEach创建每次调用的函数</p>
<p>3).函数现在需要单独的作用域</p>
<p>这会产生额外的开销注意：日常开发中不要只考虑性能，forEach的代码更具可读性。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>内存泄漏</p>
<ul>
<li><p>未使用 var 声明的全局变量</p>
</li>
<li><p>闭包函数(Closures)</p>
</li>
<li><p>循环引用(两个对象相互引用)</p>
</li>
<li><p>控制台日志(console.log)</p>
</li>
<li><p>移除存在绑定事件的DOM元素(IE)</p>
</li>
<li><p><code>setTimeout</code> 的第一个参数使用字符串而非函数的话，会引发内存泄漏</p>
</li>
<li><p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收</p>
</li>
</ul>
</li>
</ul>
<h1 id="插件-4"><a href="#插件-4" class="headerlink" title="插件"></a>插件</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul>
<li><p>将DOM转化成canvas对象</p>
<p><a href="http://html2canvas.hertzen.com/dist/html2canvas.min.js">http://html2canvas.hertzen.com/dist/html2canvas.min.js</a></p>
</li>
<li><p>将canvas生成照片</p>
<p><a href="http://github.com/randreucetti/canvas2image">HTTP://github.com/randreucetti/canvas2image</a></p>
</li>
<li><p>一个用于将文本复制到剪贴板的 JS 库</p>
<p><a href="https://github.com/zenorocha/clipboard.js">https://github.com/zenorocha/clipboard.js</a></p>
</li>
<li><p>QRCode:生成二维码</p>
<p><a href="https://www.npmjs.com/package/qrcode#api">https://www.npmjs.com/package/qrcode#api</a></p>
<p><a href="https://zh.qr-code-generator.com/">https://zh.qr-code-generator.com/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">QRCode.toDataURL(url.basePage + &quot;/common/share/#/homeshare&quot;)</span><br><span class="line">.then(url =&gt; &#123;</span><br><span class="line">this.qrcodeImg = url</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err =&gt; &#123;</span><br><span class="line">console.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><ul>
<li><p>moment时间处理：<a href="http://momentjs.cn/">http://momentjs.cn/</a></p>
</li>
<li><p>qs:序列化</p>
<p>将URL解析成对象</p>
<ul>
<li>qs.parse() 方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> url = <span class="string">&#x27;method=one&amp;projectId=85&amp;appToken=abc&#x27;</span>;</span><br><span class="line">Qs.parse(url);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&#x27;one&#x27;</span>,</span><br><span class="line">    <span class="attr">projectId</span>:<span class="string">&#x27;85&#x27;</span>,</span><br><span class="line">    <span class="attr">appToken</span>:<span class="string">&#x27;abc&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="将对象序列化为URL"><a href="#将对象序列化为URL" class="headerlink" title="将对象序列化为URL"></a>将对象<a href="https://so.csdn.net/so/search?q=%E5%BA%8F%E5%88%97%E5%8C%96&spm=1001.2101.3001.7020">序列化</a>为URL</h5><ul>
<li>qs.stringify()</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Qs = <span class="built_in">require</span>(<span class="string">&#x27;qs&#x27;</span>); </span><br><span class="line"><span class="keyword">let</span> obj= &#123; <span class="attr">method</span>: <span class="string">&quot;one&quot;</span>, <span class="attr">projectId</span>: <span class="string">&quot;85&quot;</span>, <span class="attr">appToken</span>: <span class="string">&quot;abc&quot;</span>&#125;;</span><br><span class="line">Qs.stringify(obj);</span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line">method=one&amp;projectId=<span class="number">85</span>&amp;appToken=abc</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h2><p><strong>H5页面唤起指定app或跳转到应用市场</strong></p>
<p><a href="https://suanmei.github.io/2018/08/23/h5_call_app/">https://suanmei.github.io/2018/08/23/h5_call_app/</a></p>
<p>github插件：<a href="https://github.com/suanmei/callapp-lib">https://github.com/suanmei/callapp-lib</a></p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><h3 id="js-md5"><a href="#js-md5" class="headerlink" title="js-md5"></a>js-md5</h3><h2 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h2><h3 id="js-cookie"><a href="#js-cookie" class="headerlink" title="js-cookie"></a>js-cookie</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install js-cookie --save</span><br><span class="line">import Cookies from &#x27;js-cookie&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a cookie, valid across the entire site:  </span></span><br><span class="line">Cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;value&#x27;</span>);  </span><br><span class="line">   </span><br><span class="line"><span class="comment">// Create a cookie that expires 7 days from now, valid across the entire site:  </span></span><br><span class="line">Cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, &#123; <span class="attr">expires</span>: <span class="number">7</span> &#125;);  </span><br><span class="line">   </span><br><span class="line"><span class="comment">// Create an expiring cookie, valid to the path of the current page:  </span></span><br><span class="line">Cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, &#123; <span class="attr">expires</span>: <span class="number">7</span>, <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span> &#125;); </span><br><span class="line"></span><br><span class="line"><span class="comment">// Read cookie:  </span></span><br><span class="line">Cookies.get(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// =&gt; &#x27;value&#x27;  </span></span><br><span class="line">Cookies.get(<span class="string">&#x27;nothing&#x27;</span>); <span class="comment">// =&gt; undefined  </span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// Read all visible cookies:  </span></span><br><span class="line">Cookies.get(); <span class="comment">// =&gt; &#123; name: &#x27;value&#x27; &#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete cookie:  </span></span><br><span class="line">Cookies.remove(<span class="string">&#x27;name&#x27;</span>);  </span><br><span class="line">   </span><br><span class="line"><span class="comment">// Delete a cookie valid to the path of the current page:  </span></span><br><span class="line">Cookies.set(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;value&#x27;</span>, &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span> &#125;);  </span><br><span class="line">Cookies.remove(<span class="string">&#x27;name&#x27;</span>); <span class="comment">// fail!  </span></span><br><span class="line">Cookies.remove(<span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span> &#125;); <span class="comment">// removed!  </span></span><br><span class="line">Cookies.remove(<span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">domain</span>: <span class="string">&#x27;&#x27;</span> &#125;); <span class="comment">// removed! </span></span><br></pre></td></tr></table></figure>

<h1 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h1><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><p>域名：利用多个域名来存储网站资源，节约主域名的连接数，优化页面响应速度 </p>
</li>
<li><p>减少<code>HTTP</code>请求次数：合并文件、<code>CSS</code>精灵、<code>inline Image</code></p>
</li>
<li><p>减少<code>DNS</code>查询：<code>DNS</code>缓存、将资源分布到恰当数量的主机名</p>
</li>
<li><p>懒加载也是一个经常被提及的技术，视窗外的内容是不会被用户立即看到的，这时加载过多的内容反而拖慢了网站整体的渲染，我们就可以用懒加载推迟这部分内容的加载来达到加速可访问和可交互性的目的，等用户即将到达视窗内的时候再开始加载这部分内容，通常懒加载会与loading和骨架屏等技术搭配使用。</p>
</li>
<li><p>prefetch：关键字 <strong>prefetch</strong> 作为元素  的属性 rel 的值，是为了提示浏览器，用户未来的浏览有可能需要加载目标资源，所以浏览器会事先获取和缓存对应资源，优化用户体验 ——MDN</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/page-data/docs/getting-started.html/page-data.json&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span> <span class="attr">as</span>=<span class="string">&quot;fetch&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li><p>减少不必要的 cookie</p>
<p>不必要的 <code>cookie</code> 来回传输会造成带宽浪费：</p>
</li>
</ul>
<h2 id="缓存-1"><a href="#缓存-1" class="headerlink" title="缓存"></a><strong>缓存</strong></h2><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><p><a href="https://mp.weixin.qq.com/s/-MbBKo6l-SxSmJmKvaWTGQ">https://mp.weixin.qq.com/s/-MbBKo6l-SxSmJmKvaWTGQ</a></p>
<p>白屏大概可能的原因有两种：</p>
<ol>
<li>js 执行过程中的错误</li>
<li>资源错误</li>
</ol>
<p><strong>从而造成根节点下所有 DOM 被卸载</strong></p>
<h1 id="业务"><a href="#业务" class="headerlink" title="业务"></a>业务</h1><h2 id="组件资源共享与中心化管理"><a href="#组件资源共享与中心化管理" class="headerlink" title="组件资源共享与中心化管理"></a>组件资源共享与中心化管理</h2><p>京东零售平台：前端组件资源共享与中心化管理实践：<a href="https://mp.weixin.qq.com/s/tZpf6aG3x6yOmajYAaPuAg">https://mp.weixin.qq.com/s/tZpf6aG3x6yOmajYAaPuAg</a></p>
<p><img src="img/%E5%B8%B8%E8%AF%86/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220913154644.png"></p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><a href="https://mp.weixin.qq.com/s/Yvl5ePZ1t0DS82FvHHozgw">https://mp.weixin.qq.com/s/Yvl5ePZ1t0DS82FvHHozgw</a></p>
<h2 id="鉴权"><a href="#鉴权" class="headerlink" title="鉴权"></a>鉴权</h2><p><a href="https://mp.weixin.qq.com/s/BNJa3DjnM9ZELsfCnYxK5w">https://mp.weixin.qq.com/s/BNJa3DjnM9ZELsfCnYxK5w</a></p>
<h3 id="token"><a href="#token" class="headerlink" title="token"></a>token</h3><img src="https://mmbiz.qpic.cn/mmbiz_png/TRiapJU3MMsZBgRKMl9Uor5iazd3BPKHxh1pp5jQibGiafq4a1Fbzf8of4KJONMrkl05WgoWQUc5nicY6ENibJoqCoIw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<p>token 的流程是这样的：</p>
<ul>
<li>用户登录，服务端校验账号密码，获得用户信息</li>
<li>把用户信息、token 配置编码成 token，通过 cookie set 到浏览器</li>
<li>此后用户请求业务接口，通过 cookie 携带 token</li>
<li>接口校验 token 有效性，进行正常业务接口处理</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP 是无状态的，为了维持前后请求，需要前端存储标记</li>
<li>cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石</li>
<li>token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性</li>
<li>token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案</li>
<li>在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验</li>
<li>单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket</li>
</ul>
<h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p><a href="https://mp.weixin.qq.com/s/AblKH21Leh_IowXJ8lPcww">https://mp.weixin.qq.com/s/AblKH21Leh_IowXJ8lPcww</a></p>
<h2 id="微前端-1"><a href="#微前端-1" class="headerlink" title="微前端"></a>微前端</h2><p><a href="https://mp.weixin.qq.com/s/x9CV_lhBpxW3lL0LZ9gXqg">https://mp.weixin.qq.com/s/x9CV_lhBpxW3lL0LZ9gXqg</a></p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</p>
<p>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</p>
<p>懒惰实现方式：<br> 1.第一种是纯粹的延迟加载，使用setTimeOut或setInterval进行加载延迟.<br> 2.第二种是条件加载，符合某些条件，或触发了某些事件才开始异步下载。<br> 3.第三种是可视区加载，即仅加载用户可以看到的区域，这个主要由监控滚动条来实现，一般会在距用户看到某图片前一定距离遍开始加载，这样能保证用户拉下时正好能看到图片。</p>
<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 </p>
<h2 id="storage加密"><a href="#storage加密" class="headerlink" title="storage加密"></a>storage加密</h2><p><a href="https://mp.weixin.qq.com/s/_XsKamJOcmmDl1SvMXY0VA">https://mp.weixin.qq.com/s/_XsKamJOcmmDl1SvMXY0VA</a></p>
<h2 id="ws"><a href="#ws" class="headerlink" title="ws"></a>ws</h2><p><a href="https://baijiahao.baidu.com/s?id=1713307876537918339&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1713307876537918339&amp;wfr=spider&amp;for=pc</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WebsocketObj</span> </span>&#123;</span><br><span class="line">  ws = <span class="literal">null</span>;</span><br><span class="line">  status;</span><br><span class="line">  pingPong = <span class="string">&#x27;ping&#x27;</span>;</span><br><span class="line">  pingInterval;</span><br><span class="line">  pongInterval;</span><br><span class="line">  uid = <span class="built_in">Math</span>.round();</span><br><span class="line">  uid = [<span class="built_in">this</span>.uid];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = <span class="literal">null</span>;</span><br><span class="line">    <span class="built_in">this</span>.ws = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">initWebsocket</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">&#x27;local&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://192.168.86.109:7071/coilwms&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV == <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.ws = <span class="keyword">new</span> WebSocket(<span class="string">&#x27;ws://113.249.91.10:18080/coilwms/ws&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接成功建立的回调方法</span></span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Websocket通道建立成功&#x27;</span>, that.ws);</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;open&#x27;</span>;</span><br><span class="line">      store.commit(<span class="string">&#x27;setWsStatus&#x27;</span>, <span class="built_in">this</span>.status);</span><br><span class="line">      that.onmessage();</span><br><span class="line">      that.heartCheck();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">this</span>.ws.onclose = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;websocket 断开: &#x27;</span> + res.code + <span class="string">&#x27; &#x27;</span> + res.reason + <span class="string">&#x27; &#x27;</span> + res.wasClean);</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">//wasClean表示是否正常断开</span></span><br><span class="line">        <span class="keyword">if</span> (res.wasClean) &#123;</span><br><span class="line">          that.disconnect();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		  that.reconnect();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//在刷新前，执行disconnect</span></span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">&#x27;beforeunload&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;beforeunload&#x27;</span>);</span><br><span class="line">      that.disconnect();</span><br><span class="line">      <span class="built_in">this</span>.reconnect();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// window.addEventListener(&#x27;load&#x27;, e =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   that.ws.initWebsocket();</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接受信息</span></span><br><span class="line">  <span class="function"><span class="title">onmessage</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">this</span>.ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      that.pingPong = <span class="string">&#x27;pong&#x27;</span>;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="regexp">/^&#123;/</span>.test(res.data)) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Received Message: &#x27;</span>, res.data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> &#123; data = &#123;&#125;, code &#125; = <span class="built_in">JSON</span>.parse(res.data);</span><br><span class="line">      <span class="keyword">if</span> (code === <span class="string">&#x27;C1L203&#x27;</span>) &#123;</span><br><span class="line">        store.commit(<span class="string">&#x27;setCoilCarTerminalData&#x27;</span>, data);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;Received Message: &#x27;</span>, data, code);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//发送信息</span></span><br><span class="line">  <span class="function"><span class="title">send</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.uid = [...this.uid, res.uid];</span><br><span class="line">    <span class="built_in">this</span>.ws.send(<span class="built_in">JSON</span>.stringify(res));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//手动断开连接</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">disconnect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;断开连接&#x27;</span>);</span><br><span class="line">    <span class="comment">//断开时发送断开信息</span></span><br><span class="line">    <span class="built_in">this</span>.uid.map(<span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.send(&#123; <span class="attr">cid</span>: val &#125;, <span class="string">&#x27;disconnect&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.ws.close();</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.pingInterval);</span><br><span class="line">    <span class="built_in">clearInterval</span>(<span class="built_in">this</span>.pongInterval);</span><br><span class="line">    <span class="built_in">this</span>.status = <span class="string">&#x27;close&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//重连</span></span><br><span class="line">  <span class="function"><span class="title">reconnect</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initWebsocket();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//心跳机制</span></span><br><span class="line">  <span class="function"><span class="title">heartCheck</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.pingInterval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.ws.readyState === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 检查ws为链接状态 才可发送</span></span><br><span class="line">        <span class="built_in">this</span>.ws.send(<span class="built_in">JSON</span>.stringify(&#123; <span class="attr">uid</span>: <span class="string">&#x27;ping&#x27;</span> &#125;)); <span class="comment">// 客户端发送ping</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">100000</span>);</span><br><span class="line">    <span class="built_in">this</span>.pongInterval = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.pingPong !== <span class="string">&#x27;pong&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.pingPong = <span class="string">&#x27;ping&#x27;</span>;</span><br><span class="line">        <span class="built_in">this</span>.reconnect();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="number">200000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> WebsocketObj();</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ws;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ws对象"><a href="#ws对象" class="headerlink" title="ws对象"></a>ws对象</h3><h4 id="readyState"><a href="#readyState" class="headerlink" title="readyState"></a>readyState</h4><p><code>readyState</code> 属性返回实例对象的当前状态，共有四种。</p>
<ul>
<li><code>CONNECTING</code>：值为0，表示正在连接。</li>
<li><code>OPEN</code>：值为1，表示连接成功，可以通信了。</li>
<li><code>CLOSING</code>：值为2，表示连接正在关闭。</li>
<li><code>CLOSED</code>：值为3，表示连接已经关闭，或者打开连接失败。</li>
</ul>
<h4 id="onopen"><a href="#onopen" class="headerlink" title="onopen"></a>onopen</h4><p>实例对象的 <code>onopen</code> 属性，用于指定连接成功后的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ws.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ws.send(<span class="string">&#x27;Hello Server!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onclose"><a href="#onclose" class="headerlink" title="onclose"></a>onclose</h4><p>实例对象的 <code>onclose</code> 属性，用于指定连接关闭后的回调函数。</p>
<h4 id="onmessage"><a href="#onmessage" class="headerlink" title="onmessage"></a>onmessage</h4><p>实例对象的 <code>onmessage</code> 属性，用于指定收到服务器数据后的回调函数。</p>
<p>注意，服务器数据可能是文本，也可能是二进制数据（<code>blob</code> 对象或 <code>Arraybuffer</code> 对象）。</p>
<p>除了动态判断收到的数据类型，也可以使用 binaryType 属性，显式指定收到的二进制数据类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 收到的是 blob 数据</span><br><span class="line">ws.binaryType = &quot;blob&quot;;</span><br><span class="line">ws.onmessage = function(e) &#123;</span><br><span class="line">  console.log(e.data.size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 收到的是 ArrayBuffer 数据</span><br><span class="line">ws.binaryType = &quot;arraybuffer&quot;;</span><br><span class="line">ws.onmessage = function(e) &#123;</span><br><span class="line">  console.log(e.data.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="send"><a href="#send" class="headerlink" title="send()"></a>send()</h4><p>实例对象的 send() 方法用于向服务器发送数据。</p>
<p>发送文本的例子。</p>
<p>ws.send(‘your message’);</p>
<p>发送 Blob 对象的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var file = document</span><br><span class="line">  .querySelector(&#x27;input[type=&quot;file&quot;]&#x27;)</span><br><span class="line">  .files[0];</span><br><span class="line">ws.send(file)</span><br></pre></td></tr></table></figure>

<p>发送 ArrayBuffer 对象的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Sending canvas ImageData as ArrayBuffer</span><br><span class="line">var img = canvas_context.getImageData(0, 0, 400, 320);</span><br><span class="line">var binary = new Uint8Array(img.data.length);</span><br><span class="line">for (var i = 0; i &lt; img.data.length; i++) &#123;</span><br><span class="line">  binary[i] = img.data[i];</span><br><span class="line">&#125;</span><br><span class="line">ws.send(binary.buffer);</span><br></pre></td></tr></table></figure>

<h4 id="bufferedAmount"><a href="#bufferedAmount" class="headerlink" title="bufferedAmount"></a>bufferedAmount</h4><p>实例对象的 bufferedAmount 属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var data = new ArrayBuffer(10000000);</span><br><span class="line">socket.send(data);</span><br><span class="line"></span><br><span class="line">if (socket.bufferedAmount === 0) &#123;</span><br><span class="line">  // 发送完毕</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  // 发送还没结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="onerror"><a href="#onerror" class="headerlink" title="onerror"></a>onerror</h4><p>实例对象的onerror属性，用于指定报错时的回调函数。</p>
<h3 id="断开"><a href="#断开" class="headerlink" title="断开"></a>断开</h3><p>close([code[, reason]])：该方法用于关闭 WebSocket 连接，如果连接已经关闭，则此方法不执行任何操作；</p>
<p>WebSocket断开时，会触发CloseEvent, CloseEvent会在连接关闭时发送给使用 WebSockets 的客户端. 它在 WebSocket 对象的 onclose 事件监听器中使用。CloseEvent的code字段表示了WebSocket断开的原因。可以从该字段中分析断开的原因。</p>
<p>CloseEvent有三个字段需要注意, 通过分析这三个字段，一般就可以找到断开原因</p>
<p>CloseEvent.code: code是错误码，是整数类型<br>CloseEvent.reason: reason是断开原因，是字符串<br>CloseEvent.wasClean: wasClean表示是否正常断开，是布尔值。一般异常断开时，该值为false</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0–999         .</td>
<td></td>
<td>保留段, 未使用</td>
</tr>
<tr>
<td>1000</td>
<td>CLOSE_NORMAL</td>
<td>正常关闭; 无论为何目的而创建, 该链接都已成功完成任务.</td>
</tr>
<tr>
<td>1001    CLOSE_GOING_AWAY    终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1002    CLOSE_PROTOCOL_ERROR    由于协议错误而中断连接.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1003    CLOSE_UNSUPPORTED    由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据).</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1004         保留. 其意义可能会在未来定义.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1005    CLOSE_NO_STATUS    保留. 表示没有收到预期的状态码.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1006</td>
<td>CLOSE_ABNORMAL</td>
<td>保留. 用于期望收到状态码时连接非正常关闭 (也就是说, 没有发送关闭帧)</td>
</tr>
<tr>
<td>1007    Unsupported Data    由于收到了格式不符的数据而断开连接 (如文本消息中包含了非 UTF-8 数据).</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1008    Policy Violation    由于收到不符合约定的数据而断开连接. 这是一个通用状态码, 用于不适合使用 1003 和 1009 状态码的场景.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1009    CLOSE_TOO_LARGE    由于收到过大的数据帧而断开连接.<br/>3000–3999         可以由库或框架使用.? 不应由应用使用. 可以在 IANA 注册, 先到先得.<br/>4000–4999         可以由应用使用.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1010    Missing Extension    客户端期望服务器商定一个或多个拓展, 但服务器没有处理, 因此客户端断开连接.<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1011    Internal Error    客户端由于遇到没有预料的情况阻止其完成请求, 因此服务端断开连接.<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1012    Service Restart    服务器由于重启而断开连接.<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1013    Try Again Later    服务器由于临时原因断开连接, 如服务器过载因此断开一部分客户端连接.<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1014         由 WebSocket标准保留以便未来使用.<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1015    TLS Handshake    保留. 表示连接由于无法完成 TLS 握手而关闭 (例如无法验证服务器证书).<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>1016–1999         由 WebSocket标准保留以便未来使用.<br/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2000–2999         由 WebSocket拓展保留使用.<br/></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="数据埋点SDK"><a href="#数据埋点SDK" class="headerlink" title="数据埋点SDK"></a>数据埋点SDK</h2><p><a href="https://mp.weixin.qq.com/s/9Qwp6g8QKFK2ehDLyEu0Wg">https://mp.weixin.qq.com/s/9Qwp6g8QKFK2ehDLyEu0Wg</a></p>
<h2 id="app跳转"><a href="#app跳转" class="headerlink" title="app跳转"></a>app跳转</h2><p>H5页面唤起指定app或跳转到应用市场</p>
<p><a href="https://suanmei.github.io/2018/08/23/h5_call_app/">https://suanmei.github.io/2018/08/23/h5_call_app/</a></p>
<p><a href="https://juejin.cn/post/6844903664155525127#heading-20">https://juejin.cn/post/6844903664155525127#heading-20</a></p>
<p>github插件：<a href="https://github.com/suanmei/callapp-lib">https://github.com/suanmei/callapp-lib</a></p>
<ul>
<li><p>应用市场:使用应用宝</p>
<p><a href="https://a.app.qq.com/o/simple.jsp?pkgname=net.pinrenwu.pinrenwu">https://a.app.qq.com/o/simple.jsp?pkgname=net.pinrenwu.pinrenwu</a></p>
<p>腾讯应用宝直接打开 APP 的某个功能</p>
<p>刚刚我们说到，如果你不是微信的家属，那你是很难进入白名单的，所以在安卓中我们一般都是直接打开腾讯应用宝，ios 中 直接打开 App Store。点击腾讯应用宝中的“打开”按钮，可以直接唤起我们的 APP，但是无法打开 APP 中的某个功能（就是无法打开指定页面）。</p>
<p>腾讯应用宝对外开放了一个叫做 APP Link 的申请，只要你申请了 APP Link，就可以通过在打开应用宝的时候在应用宝地址后面添加上 <code>&amp;android_schema=&#123;your_scheme&#125;</code> ，来打开指定的页面了。</p>
</li>
<li><p>指定app：在移动端浏览器H5页面中，点击按钮打开本地应用主要通过 scheme 协议</p>
<ul>
<li><p>scheme 是一种页面之间跳转的协议，不仅可以用于app之间进行跳转，还可以用于 H5 页面跳转到app页面。<strong>但在微信浏览器里scheme不起作用</strong>，有没有印象有时在微信上打开的一些需要跳转到app的操作时，会提示在浏览器上打开，就是这个原因。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">scheme 协议定义和 http 协议类似，都是标准的 URI 结构。</span><br><span class="line">[scheme:][<span class="comment">//host:port][path][?query][#fragment]</span></span><br><span class="line">scheme : 协议名称 - 必须</span><br><span class="line"><span class="attr">host</span> : 协议地址 - 必须</span><br><span class="line"><span class="attr">port</span> : 协议的端口，可以不填</span><br><span class="line"><span class="attr">path</span> : 协议路径，可用 / 连接多个</span><br><span class="line"><span class="attr">query</span> : 携带的参数可用 &amp; 连接多个。URI中的参数如果包含特殊字符，需要预先进行url编码，否则的话URI可能不能打开。</span><br><span class="line"><span class="attr">fragment</span> : 锚点</span><br><span class="line"></span><br><span class="line">     行为(应用的某个功能)    </span><br><span class="line">            |</span><br><span class="line">scheme:<span class="comment">//[path][?query]</span></span><br><span class="line">   |               |</span><br><span class="line">应用标识       功能需要的参数</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="git如何创建多个ssh"><a href="#git如何创建多个ssh" class="headerlink" title="git如何创建多个ssh"></a>git如何创建多个ssh</h2><h3 id="清除原有的设置"><a href="#清除原有的设置" class="headerlink" title="清除原有的设置"></a>清除原有的设置</h3><p><strong>初次使用git请跳过此步骤</strong></p>
<p>如果之前对git设置过global信息，则需要先清除这些信息，通过如下指令：</p>
<p>查看Git所有配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<p>查看当前用户（<strong>local</strong>）配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --local  --list</span><br><span class="line">或者</span><br><span class="line">cat .git/config</span><br></pre></td></tr></table></figure>

<p>查看<code>user.name</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.name</span><br></pre></td></tr></table></figure>

<p>查看<code>user.email</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config user.email</span><br></pre></td></tr></table></figure>

<p><strong>删除</strong>全局配置项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global --unset user.name</span><br></pre></td></tr></table></figure>

<h3 id="2-ssh配置"><a href="#2-ssh配置" class="headerlink" title="2.ssh配置"></a>2.ssh配置</h3><h4 id="配置用户信息"><a href="#配置用户信息" class="headerlink" title="配置用户信息"></a>配置用户信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/workspace/gitlab</span><br><span class="line">git init</span><br><span class="line">git config --local user.name ‘gitlab‘//local局部 global</span><br><span class="line">git config --local user.email ‘gitlab@company.com‘</span><br></pre></td></tr></table></figure>

<h4 id="生成ssh-key"><a href="#生成ssh-key" class="headerlink" title="生成ssh key"></a>生成ssh key</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>

<p> 当命令行出现 Enter file in which to save the key (~/.ssh/id_rsa):  </p>
<p> 它会提示你输入一个保存key的路径/文件名，默认创建文件名id_rsa（若有多个邮箱，则创建不同的文件名）</p>
<p> 在.ssh文件中找到创建的id_rsa_pub并复制里面的内容，在远程的设置的密钥（key）里面粘贴</p>
<h4 id="配置config文件"><a href="#配置config文件" class="headerlink" title="配置config文件"></a>配置config文件</h4><p>id_rsa文件同级目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Host 它涵盖了下面一个段的配置，我们可以通过他来替代将要连接的服务器地址。</span><br><span class="line">#HostName    真正连接的服务器地址</span><br><span class="line">#User是本地ssh-agent与github服务器建立SSH连接时采用的用户名，IdentityFile是对应的私钥文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ssh -T User@Host	判断连接是否成功</span><br><span class="line"></span><br><span class="line"># gitlab</span><br><span class="line">Host git.lab</span><br><span class="line">HostName gitlab.com</span><br><span class="line">User git</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_lab</span><br><span class="line"></span><br><span class="line"># github</span><br><span class="line">Host git.hub</span><br><span class="line">HostName github.com</span><br><span class="line">User git</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure>

<h4 id="本地仓库与远程仓库关联"><a href="#本地仓库与远程仓库关联" class="headerlink" title="本地仓库与远程仓库关联"></a>本地仓库与远程仓库关联</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin(设置的远程库名) User@Host:用户名/仓库名</span><br><span class="line">或者直接 git clone 链接(一般是master上的分支)</span><br><span class="line">无法连接到仓库,尝试重新连接</span><br><span class="line">git remote rm origin  删除远程origin</span><br><span class="line">git remote add origin git@git.hub.bundle:bibo72/bundleb2b-v3.0-storefront.git</span><br><span class="line"></span><br><span class="line">clone https时，每次pull都会输入密码</span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<h4 id="测试连接成功"><a href="#测试连接成功" class="headerlink" title="测试连接成功"></a>测试连接成功</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T User@Host</span><br></pre></td></tr></table></figure>

<h2 id="git-指令"><a href="#git-指令" class="headerlink" title="git 指令"></a>git 指令</h2><h3 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h3><p>git init 初始化版本库（clone下来的不用初始化）</p>
<img src="https://mmbiz.qpic.cn/mmbiz_jpg/QhRDUrJbPe6737sZ1ptKUEQcY6YOcKFqqqdv3riaAEJYVibl3GUgmRTiaH5sldypibNN7Zzk3Zqv9lMCAAsvT4vVQw/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片" style="zoom:67%;" />

<p>首先<strong>工作区</strong>就是我们当前的文件目录，我们改完代码，用<code>git add</code>命令把当前文件加入<strong>暂存区</strong>，然后<code>git commit</code>把<strong>暂存区</strong>生成的快照提交到<strong>本地仓库</strong>，最后再用<code>git push</code>命令把<strong>本地仓库</strong>的提交复制到<strong>远程仓库</strong>，也就是<code>Github</code>之类的在线仓库。</p>
<p>git add  文件名                                              放入暂存区stage</p>
<p>git commit -m “提交的说明message”        放入分支里</p>
<p>git commit  -am                                            add和commit的合并，便捷写法</p>
<p>git commit –amend                                     尝试重新提交(<strong>漏掉了几个文件没有添加，或者提交信息commit message写错</strong>)，新增的<code>commit</code>会代替原来的<code>commit</code>的位置，而旧<code>commit</code>则被抛弃掉</p>
<h3 id="本地分支的操作"><a href="#本地分支的操作" class="headerlink" title="本地分支的操作"></a>本地分支的操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b dev 或者git switch -c dev    创建并切换该分支</span><br><span class="line">git branch dev 								创建分支</span><br><span class="line">git checkout master							切换分支</span><br><span class="line">git branch -d dev							删除分支</span><br><span class="line">git branch -D dev							强行删除一个没有合并的分支    </span><br><span class="line">git branch -vv                              查看关联关系                         </span><br><span class="line"></span><br><span class="line">git branch									查看本地分支</span><br><span class="line">git branch -r			    				查看远程分支</span><br><span class="line">git branch -a 			   					查看所有分支（包括远程分支和本地分支）</span><br><span class="line">git branch -a | grep paynicorn2-repay-notice 查询指定分支(本地和远程的)</span><br></pre></td></tr></table></figure>

<h3 id="远程分支的操作"><a href="#远程分支的操作" class="headerlink" title="远程分支的操作"></a>远程分支的操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">远程分支的移除</span><br><span class="line">git remote rm paul				</span><br><span class="line">git push origin --delete main</span><br><span class="line">删除远程分支，git branch -a,还是可以看到远程的分支</span><br><span class="line">解决：git remote prune origin </span><br><span class="line"></span><br><span class="line">远程分支重命名，pb 重命名为 paul</span><br><span class="line">git remote rename pb paul</span><br><span class="line">拉取远程分支到本地</span><br><span class="line">git checkout -b dev origin/dev	         直接拉取远程的分支，创建为本地的分支</span><br><span class="line">推送到远程分支</span><br><span class="line">git push --set-upstream origin wangxiao	 将本地的分支推送远程上（第一次推送）</span><br><span class="line">git push orgin dev 						 上传分支到远程dev</span><br><span class="line">为此分支创建跟踪信息，您可以执行：</span><br><span class="line">git branch --set-upstream-to=origin/&lt;分支&gt; master</span><br><span class="line">//https://blog.csdn.net/wangqingpei557/article/details/53147086</span><br></pre></td></tr></table></figure>

<h3 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h3><img src="https://img2018.cnblogs.com/blog/333765/202001/333765-20200111163049190-252688967.png" alt="img" style="zoom: 67%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//查看文件状态（是否被add或者commit）</span><br><span class="line">git status 					  </span><br><span class="line">使用 git status -s 命令或 git status –short 命令，你将得到一种更为紧凑的格式输出</span><br><span class="line">//文件的区别</span><br><span class="line">git diff 						 		    区和的暂存区差异</span><br><span class="line">git diff HEAD								显示工作区与当前分支最新commit之间											的差异</span><br><span class="line">git diff --cached 							显示暂存区和上一个commit的差异</span><br><span class="line">git diff branch-1 branch-2 	[filename]		比较两个分支(filename)的不同</span><br><span class="line">git diff commit1 commit2  					查看两个 commit 的对比</span><br><span class="line">git ls-files								查看暂存区的文件</span><br><span class="line">git diff origin/branchname branchname 		查看远程分支和本地分支的对比</span><br><span class="line"></span><br><span class="line">//查看提交日志，每一次提交都有对应的 commit id 和 commit message(看不出来被删除的commitid),可以加上参数--pretty=oneline，只会显示版本号和提交时的备注信息</span><br><span class="line">git log							</span><br><span class="line">git log  -p					  用来显示每次提交的内容差异							</span><br><span class="line">//记录操作记录(包括已经被删除的 commit 记录和 reset 的操作)		  </span><br><span class="line">git reflog					  </span><br><span class="line"></span><br><span class="line">git remote -v				查看关联的远程仓库url</span><br><span class="line">cat .git/HEAD			    查看当前 HEAD 指向</span><br></pre></td></tr></table></figure>

<h3 id="回退系列"><a href="#回退系列" class="headerlink" title="回退系列"></a>回退系列</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^					    回退到上一个版本</span><br><span class="line">git reset --hard HEAD~1					    回退到上一个版本</span><br><span class="line">git reset --hard id(前6位就行)	        	 回退到指定版本</span><br><span class="line"></span><br><span class="line">git checkout .										   清空工作区改动</span><br><span class="line">git checkout -- 文件名 					  </span><br><span class="line"></span><br><span class="line">当你开始修改一个文件后，还没有执行 git add命令前(此时还在工作区）,想撤销对这个文件的改动，可以使用git checkout -- 文件名 </span><br><span class="line">一旦你使用了 git add命令将文件添加到暂存区，此时不想改这个文件了，需要用git reset HEAD filename(git reset HEAD .)把文件移会到工作区，再使用第一步的git checkout -- 文件名 撤销工作区改动</span><br></pre></td></tr></table></figure>

<h3 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）git stash save <span class="string">&quot;save message&quot;</span>  : 执行存储时，添加备注，方便查找，只有git stash 也要可以的，但查找时不方便识别。</span><br><span class="line"></span><br><span class="line">（2）git stash list  ：查看stash了哪些存储</span><br><span class="line"></span><br><span class="line">（3）git stash show ：显示做了哪些改动，默认show第一个存储,如果要显示其他存贮，后面加stash@&#123;<span class="variable">$num</span>&#125;，比如第二个 git stash show stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line">（4）git stash show -p : 显示第一个存储的改动，如果想显示其他存存储，命令：git stash show  stash@&#123;<span class="variable">$num</span>&#125;  -p ，比如第二个：git stash show  stash@&#123;1&#125;  -p</span><br><span class="line"></span><br><span class="line">（5）git stash apply :应用某个存储,但不会把存储从存储列表中删除，默认使用第一个存储,即stash@&#123;0&#125;，如果要使用其他个，git stash apply stash@&#123;<span class="variable">$num</span>&#125; ， 比如第二个：git stash apply stash@&#123;1&#125; </span><br><span class="line"></span><br><span class="line">（6）git stash pop ：命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下,默认为第一个stash,即stash@&#123;0&#125;，如果要应用并删除其他stash，命令：git stash pop stash@&#123;<span class="variable">$num</span>&#125; ，比如应用并删除第二个：git stash pop stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line">（7）git stash drop stash@&#123;<span class="variable">$num</span>&#125; ：丢弃stash@&#123;<span class="variable">$num</span>&#125;存储，从列表中删除这个存储</span><br><span class="line"></span><br><span class="line">（8）git stash clear ：删除所有缓存的stash</span><br></pre></td></tr></table></figure>

<h3 id="合并分支的操作"><a href="#合并分支的操作" class="headerlink" title="合并分支的操作"></a>合并分支的操作</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase 分支	合并本地分支</span><br><span class="line"></span><br><span class="line">git config --global pull.rebase true     这个配置就是告诉git在每次pull前先进行											rebase操作</span><br><span class="line">git pull orgin 分支名	拉取远程分支并合并分支</span><br><span class="line">pull= fetch + merge</span><br><span class="line">git pull --rebase</span><br><span class="line">pull= fetch + rebase</span><br><span class="line"></span><br><span class="line">git fetch</span><br><span class="line">从远程获取最新版本到本地，不会自动合并分支</span><br><span class="line"></span><br><span class="line">git rebase --abort</span><br><span class="line">执行之后，本地内容会回到提交之间的状态，也就是回到以前提交但没有pull的状态，简单来说就是撤销rebase。</span><br><span class="line"></span><br><span class="line">git合并其他分支上指定的commit</span><br><span class="line">git cherry-pick 1f56cd48e7f3da2b9d2bcd2d853e992d74d68885</span><br></pre></td></tr></table></figure>

<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h3><p><a href="https://www.cnblogs.com/tian874540961/p/12172900.html">https://www.cnblogs.com/tian874540961/p/12172900.html</a></p>
<p><a href="https://blog.csdn.net/hudashi/article/details/7664631/">https://blog.csdn.net/hudashi/article/details/7664631/</a></p>
<p><a href="https://www.cnblogs.com/hujunzheng/p/9732936.html">https://www.cnblogs.com/hujunzheng/p/9732936.html</a></p>
<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/086ccdee-4f40-4a8c-99c8-886bc672f0d8.jpg" alt="img" style="zoom:50%;" />

<p>当我开发完D后，准备push到远端master时，git会进行检查：<strong>远端master的最新节点是否是节点D的基点，即检查远端master的基点是否是节点C</strong>，如果是，则可以直接push，如果不是，也就是上图的情况：在你push之前远端master已经被他人提交了E和F节点，这时可以执行<code>git pull -r</code></p>
<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/88729b51-5f43-42a5-bd69-9c39f863ab92.jpg" alt="img" style="zoom:50%;" />

<p>git会以F节点作为新的基点，与D节点的代码进行融合，如果此时出现<strong>冲突</strong>，那么你就会被移到临时解冲突的分支，需要人工解冲突，解完后执行<code>git add -A</code>保存操作，再执行<code>git rebase --continue</code>继续后续操作，你可能会遗漏某一处冲突，这个完全不同担会帮你检查是否解决完成，如果没有完成则不会让你回到正常分支。</p>
<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/beb6433f-49e8-4b42-b821-32a7350f2cc7.jpg" alt="img" style="zoom:50%;" />

<p>此时我再执行<code>git push</code>，就可以顺利将D节点提交到远端master上去了：</p>
<img src="https://qboshi.oss-cn-hangzhou.aliyuncs.com/pic/469b4e16-c88d-4f71-9dde-c7eb432b7a78.jpg" alt="img" style="zoom:50%;" />

<p>这同理本地基于master分支创建dev分支，master拉取远程代码后(其他人push了代码到远程master)，本地的master领先与dev分支，所以需要rebase，不然会污染了 commit 记录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase --edit-todo</span><br><span class="line">git rebase —abort 都可以用 --abort 参数来终止 rebase 的行动，并且分支会回到 rebase 开始前的状态。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>合并多个提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i HEAD~2</span><br><span class="line">将第二行的 pick 改为 s “s” 为 “squash” 的缩写</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick：保留该commit（缩写:p）</span><br><span class="line">reword：保留该commit，但我需要修改该commit的注释（缩写:r）</span><br><span class="line">edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）</span><br><span class="line">squash：将该commit和前一个commit合并（缩写:s）</span><br><span class="line">fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）</span><br><span class="line">exec：执行shell命令（缩写:x）</span><br><span class="line">drop：我要丢弃该commit（缩写:d）</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>指定某个分支在执行git pull时默认采用rebase方式：<br>$ git config branch.dev.rebase true<br>如果你觉得所有的分支都应该用rebase，那就设置：<br>git config –global branch.autosetuprebase always</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 代码提交规范</span><br><span class="line"></span><br><span class="line">### git分支管理</span><br><span class="line"></span><br><span class="line">分支规范https://zhuanlan.zhihu.com/p/108385922</span><br><span class="line"></span><br><span class="line">**master：产品分支**</span><br><span class="line"></span><br><span class="line">只能从其它分支合并内容，不能再这个分支直接修改内容。合并到master上的commit只能来自release分支或hotfix分支</span><br><span class="line"></span><br><span class="line">**release分支：预发布分支**</span><br><span class="line"></span><br><span class="line">当需要发布时，我们从master分支创建一个release分支，然后将模块分支合并到 release分支会发布到预发布环境进行测试，</span><br><span class="line"></span><br><span class="line">&gt; 1、如果发现问题，在模块分支上进行修复，然后将模块分支合并到release分支和dev分支。</span><br><span class="line"></span><br><span class="line"> **hotfix分支：补丁分支**</span><br><span class="line"></span><br><span class="line">主要用于紧急修复一些bug。会从master分支上建立，修复结束后会再合并到dev和release分支上，谁的bug上线谁负责同步代码。</span><br><span class="line"></span><br><span class="line">&gt; 1、目前测试 有两套环境  pre：release分支 </span><br><span class="line">&gt;</span><br><span class="line">&gt; ​											dev：dev分支</span><br><span class="line">&gt;</span><br><span class="line">&gt; 自己的hotfix 分支 需分别合并到 release 分支和dev分支进行测试，上线时 将自己的hotfix合并到master进行发版。</span><br><span class="line">&gt;</span><br><span class="line">&gt; 2、git上的hotfix分支不会进行删除，所以当自己改需要用到hotfix时，需先从master分支更新代码，再进行操作</span><br><span class="line">&gt;</span><br><span class="line">&gt; 3、特殊情况下：如果单独拉出自己的hotfix分支，需要发布到预发布的情况下，先更新master的代码再发版本</span><br><span class="line"></span><br><span class="line"> **dev：开发主干分支**</span><br><span class="line"></span><br><span class="line">基于master的tag分支，主要用来暂时 保存开发完成而又未发布的feature分支内容，以及release和hotfix的补充内容；</span><br><span class="line"></span><br><span class="line">1、cem不直接在dev分支上修改代码，如需修改一定是在自己分支上修改好了，再merge到模块分支和dev分支</span><br><span class="line"></span><br><span class="line">**feature:功能分支**</span><br><span class="line"></span><br><span class="line">一般一个新功能对应一个功能分支，从而和已完成的功能隔离开来，而且只有在新功能完成开发的情况下，其对应的feature分支才会合并到dev分支上；</span><br><span class="line"></span><br><span class="line">**1、由于是分功能发版，dev分支的代码是三个小组共有的代码，以方便测试使用，所以任何时候不能将dev分支merge到自己的分支、release分支、master分支、hotfix分支，否则自己负责的功能无法中途上线；**</span><br><span class="line"></span><br><span class="line">3、hotfix分支代码更新后需要将hotfix分支merge到dev分支、master分支、release分支，谁更新的hotfix分支谁负责merge</span><br><span class="line"></span><br><span class="line">5、自己的分支的代码，自己负责更新，只能从master上进行更新</span><br><span class="line"></span><br><span class="line">6、在push代码之前，一定先执行git pull，由于不知道远程分支是否更新，git pull总没错；</span><br><span class="line"></span><br><span class="line">7、前端线上只有master分支的包，虽然不必需tag来记录版本，但是最好还是做好版本记录</span><br><span class="line"></span><br><span class="line">### **commit规范**</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>feat：新功能<br>fix：修补 BUG<br>docs：修改文档，比如 README, CHANGELOG, CONTRIBUTE 等等<br>style：不改变代码逻辑 (仅仅修改了空格、格式缩进、逗号等等)<br>refactor：重构（既不修复错误也不添加功能）<br>perf：优化相关，比如提升性能、体验<br>test：增加测试，包括单元测试、集成测试等<br>build：构建系统或外部依赖项的更改<br>ci：自动化流程配置或脚本修改<br>chore：非 src 和 test 的修改，发布版本等<br>revert：恢复先前的提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 工具</span><br><span class="line"></span><br><span class="line">- **husky**</span><br><span class="line"></span><br><span class="line">  - 操作 git 钩子的工具</span><br><span class="line"></span><br><span class="line">- **lint-staged**</span><br><span class="line"></span><br><span class="line">  - 本地暂存代码检查工具</span><br><span class="line"></span><br><span class="line">- **commitlint**</span><br><span class="line"></span><br><span class="line">  - commit 信息校验工具</span><br><span class="line"></span><br><span class="line">- **commitizen**</span><br><span class="line"></span><br><span class="line">  辅助 commit 信息 ,就像这样,通过选择输入,规范提交信息</span><br><span class="line"></span><br><span class="line">  ![image.png](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b7470030c2b04b488f0d4bc5729db82f~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp?)</span><br><span class="line"></span><br><span class="line">​		</span><br><span class="line"></span><br><span class="line">## Tips</span><br><span class="line"></span><br><span class="line">- clone https时，每次pull都会输入密码</span><br><span class="line">  git config --global credential.helper store</span><br><span class="line"></span><br><span class="line">- git忽略文件权限的改变</span><br><span class="line">  git config core.filemode false</span><br><span class="line">  </span><br><span class="line">- git 换行符LF与CRLF转换问题https://blog.csdn.net/qq_22978533/article/details/78145935</span><br><span class="line"></span><br><span class="line">  在各操作系统下，文本文件所使用的换行符是不一样的。UNIX/Linux/ Mac OS使用的是 LF，但 DOS/Windows 一直使用 CRLF作为换行符。Git提供了一个“换行符自动转换”功能。这个功能默认处于“自动模式”，当你在签出文件时，它试图将 UNIX 换行符（LF）替换为 Windows 的换行符（CRLF）；当你在提交文件时，它又试图将 CRLF 替换为 LF。Git 的“换行符自动转换”功能听起来似乎很智能、很贴心，因为它试图一方面保持仓库内文件的一致性（UNIX 风格），一方面又保证本地文件的兼容性（Windows 风格）。但遗憾的是，这个功能是有 bug 的，而且在短期内都不太可能会修正。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>#提交时转换为LF，检出时不转换<br>git config –global core.autocrlf input<br>#提交检出均不转换<br>git config –global core.autocrlf false<br>#提交检出均转换<br>git config –global core.autocrlf true</p>
<p>SafeCRLF<br>#拒绝提交包含混合换行符的文件<br>git config –global core.safecrlf true<br>#允许提交包含混合换行符的文件<br>git config –global core.safecrlf false<br>#提交包含混合换行符的文件时给出警告<br>git config –global core.safecrlf warn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 解决Git在添加ignore文件之前就提交了项目无法再过滤问题</span><br><span class="line"></span><br><span class="line">  ```matlab</span><br><span class="line">  首先为避免冲突需要先同步下远程仓库</span><br><span class="line">  $ git pull</span><br><span class="line">  在本地项目目录下删除缓存</span><br><span class="line">  $ git rm -r --cached .</span><br><span class="line">  新建.gitignore文件</span><br><span class="line">  在项目的根目录下面新建.gitignore文件并添加相应的过滤规则</span><br><span class="line">  </span><br><span class="line">  再次add所有文件</span><br><span class="line">  输入以下命令，再次将项目中所有文件添加到本地仓库缓存中</span><br><span class="line">  $ git add .</span><br><span class="line">  </span><br><span class="line">  再次添加commit</span><br><span class="line">  这次commit是为了说明添加ignore文件的。</span><br><span class="line">  $ git commit -m &quot;add ignore&quot;  </span><br><span class="line">  最后提交到远程仓库即可</span><br><span class="line">  $ git push</span><br></pre></td></tr></table></figure></li>
<li><p>fatal: 当前分支 master 没有对应的上游分支。<br>为推送当前分支并建立与远程上游的跟踪，使用</p>
<pre><code>git push --set-upstream origin master
</code></pre>
</li>
<li><p>无法连接到仓库,尝试重新连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote rm origin  删除远程origin</span><br><span class="line">git remote add origin git@git.hub.bundle:bibo72/bundleb2b-v3.0-storefront.git</span><br></pre></td></tr></table></figure></li>
<li><p>```<br>git config –global core.editor vim </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  clone https时，每次pull都会输入密码</span><br><span class="line">  git config --global credential.helper store</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h1><h2 id="NVM"><a href="#NVM" class="headerlink" title="NVM"></a>NVM</h2><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><ul>
<li><p>镜像</p>
<ul>
<li>nvm node_mirror <a href="https://npm.taobao.org/mirrors/node/">https://npm.taobao.org/mirrors/node/</a></li>
<li>nvm npm_mirror <a href="https://npm.taobao.org/mirrors/npm/">https://npm.taobao.org/mirrors/npm/</a></li>
</ul>
</li>
<li><p>nvm设置默认node版本：nvm alias default 14.18.2</p>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><h3 id="npm-包的发布流程"><a href="#npm-包的发布流程" class="headerlink" title="npm 包的发布流程"></a>npm 包的发布流程</h3><p><a href="https://mp.weixin.qq.com/s/m045lpzwzTAx9O6Xf_wi5Q">https://mp.weixin.qq.com/s/m045lpzwzTAx9O6Xf_wi5Q</a></p>
<h3 id="下载npm"><a href="#下载npm" class="headerlink" title="下载npm"></a>下载npm</h3><p><strong>解决npm下载慢的问题</strong></p>
<p>方法一：使用淘宝定制的cnpm命令行工具替代默认安装npm</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>方法二：将npm默认的下载地址修改为淘宝镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>

<p>注意，如果将来你需要发布自己的软件包时，需要将registry字段的值修改回来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm config set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure>

<h3 id="依赖命令"><a href="#依赖命令" class="headerlink" title="依赖命令"></a>依赖命令</h3><h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><ul>
<li><p>用于查看本机的<code>npm</code>缓存的位置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config get cache</span><br><span class="line">npm cache clean -f</span><br></pre></td></tr></table></figure></li>
<li><p>查看当前项目安装过的依赖模块</p>
</li>
<li><p>npm list –depth 0</p>
</li>
<li><p>查看全局安装过的依赖模块</p>
</li>
<li><p>npm list -g –depth 0</p>
</li>
</ul>
<h4 id="缓存-2"><a href="#缓存-2" class="headerlink" title="缓存"></a>缓存</h4><ul>
<li><p>清理缓存命令：</p>
<ul>
<li>局部<ul>
<li>npm cache clean –force</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>全局</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd ~/.npm</span><br><span class="line">du -sh * </span><br><span class="line">rm -rf _cacache   </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="npm-check"><a href="#npm-check" class="headerlink" title="npm-check"></a><strong>npm-check</strong></h4><p><a href="https://link.zhihu.com/?target=https://link.jianshu.com/?t=https://www.npmjs.com/package/npm-check">npm-check</a>是用来检查npm依赖包是否有更新，错误以及不在使用的，我们也可以使用npm-check进行包的更新</p>
<p>安装npm-check：</p>
<blockquote>
<p>npm install -g npm-check</p>
</blockquote>
<p>检查npm包的状态:</p>
<blockquote>
<p>npm-check -u -g</p>
</blockquote>
<p><strong>升级依赖</strong></p>
<blockquote>
<p>npm install -g npm-check-updates</p>
<p>ncu -u</p>
</blockquote>
<p><strong>查找未使用的npm包</strong></p>
<blockquote>
<p>npm install -g depcheck</p>
<p>depcheck</p>
</blockquote>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config set proxy proxy-url</span><br><span class="line">npm config set https-proxy proxy-url</span><br></pre></td></tr></table></figure>

<h2 id="lerna-1"><a href="#lerna-1" class="headerlink" title="lerna"></a>lerna</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install --global lerna</span><br></pre></td></tr></table></figure>

<h2 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h2><p><img src="https://pic2.zhimg.com/80/v2-569d5a6225720e38796e3fcd4bb72155_720w.webp" alt="img"></p>
<h2 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安装yarn </span><br><span class="line">npm install -g yarn</span><br><span class="line">安装成功后，查看版本号： </span><br><span class="line">yarn --version</span><br><span class="line">创建文件夹 yarn </span><br><span class="line">md yarn</span><br><span class="line">进入yarn文件夹 </span><br><span class="line"><span class="built_in">cd</span> yarn</span><br><span class="line">初始化项目 </span><br><span class="line">yarn init // 同npm init，执行输入信息后，会生成package.json文件</span><br><span class="line">yarn的配置项： </span><br><span class="line">yarn config list // 显示所有配置项</span><br><span class="line">yarn config get &lt;key&gt; //显示某配置项</span><br><span class="line">yarn config delete &lt;key&gt; //删除某配置项</span><br><span class="line">yarn config <span class="built_in">set</span> &lt;key&gt; &lt;value&gt; [-g|--global] //设置配置项</span><br><span class="line">安装包</span><br><span class="line">yarn install //安装package.json里所有包，并将包及它的所有依赖项保存进yarn.lock</span><br><span class="line">yarn install --flat //安装一个包的单一版本</span><br><span class="line">yarn install --force //强制重新下载所有包</span><br><span class="line">yarn install --production //只安装dependencies里的包</span><br><span class="line">yarn install --no-lockfile //不读取或生成yarn.lock</span><br><span class="line">yarn install --pure-lockfile //不生成yarn.lock</span><br><span class="line">添加包（会更新package.json和yarn.lock）</span><br><span class="line">yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中</span><br><span class="line">yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数</span><br><span class="line">yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）</span><br><span class="line">//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：</span><br><span class="line"></span><br><span class="line">yarn add --dev/-D // 加到 devDependencies</span><br><span class="line">yarn add --peer/-P // 加到 peerDependencies</span><br><span class="line">yarn add --optional/-O // 加到 optionalDependencies</span><br><span class="line">//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：</span><br><span class="line"></span><br><span class="line">yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版</span><br><span class="line">yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0</span><br><span class="line">发布包</span><br><span class="line">yarn publish</span><br><span class="line">移除一个包 </span><br><span class="line">yarn remove &lt;packageName&gt;：移除一个包，会自动更新package.json和yarn.lock</span><br><span class="line">查看包的缓存列表</span><br><span class="line">yarn cache list</span><br><span class="line">全局安装包 == npm -g</span><br><span class="line">yarn global</span><br><span class="line">更新一个依赖 yarn upgrade 用于更新包到基于规范范围的最新版本 运行脚本 yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本 显示某个包的信息 </span><br><span class="line">yarn info &lt;packageName&gt; 可以用来查看某个模块的最新版本信息 缓存 yarn cache </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="缓存-3"><a href="#缓存-3" class="headerlink" title="缓存"></a>缓存</h3><p>1、查看<a href="https://so.csdn.net/so/search?q=yarn&spm=1001.2101.3001.7020">yarn</a>全局缓存目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yarn cache dir</span><br></pre></td></tr></table></figure>

<p>2、清除缓存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">yarn cache clean</span><br></pre></td></tr></table></figure>

<p>yarn cache list # 列出已缓存的每个包 </p>
<h1 id="node"><a href="#node" class="headerlink" title="node"></a>node</h1><blockquote>
<p>项目开发中，经常需要import或者export各种模块</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">require.context参数介绍</span><br><span class="line">require.context(directory,useSubdirectories,regExp)</span><br><span class="line"></span><br><span class="line">directory:表示检索的目录</span><br><span class="line">useSubdirectories：表示是否检索子文件夹</span><br><span class="line">regExp:匹配文件的正则表达式,一般是文件名</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>webpack</tag>
        <tag>优化</tag>
        <tag>项目构建</tag>
        <tag>规范</tag>
        <tag>业务</tag>
        <tag>npm</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>图形构建</title>
    <url>/2020/09/25/09-%E5%9B%BE%E5%BD%A2%E6%9E%84%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>常见的数据可视化库</strong></p>
<ul>
<li>D3.js 目前 Web 端评价最高的 Javascript 可视化工具库(入手难)</li>
<li>ECharts.js 百度出品的一个开源 Javascript 数据可视化库</li>
<li>Highcharts.js 国外的前端数据可视化库，非商用免费，被许多国外大公司所使用</li>
<li>AntV 蚂蚁金服全新一代数据可视化解决方案 等等</li>
<li>Highcharts 和 Echarts 就像是 Office 和 WPS 的关系</li>
</ul>
<h1 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h1><p><a href="https://mp.weixin.qq.com/s/iybivItaK5fAU2yPX1OrJQ">https://mp.weixin.qq.com/s/iybivItaK5fAU2yPX1OrJQ</a></p>
<h1 id="图形-canvas"><a href="#图形-canvas" class="headerlink" title="图形:canvas"></a>图形:canvas</h1><p><a href="https://www.w3school.com.cn/tags/html_ref_canvas.asp">https://www.w3school.com.cn/tags/html_ref_canvas.asp</a></p>
<h2 id="canvas元素"><a href="#canvas元素" class="headerlink" title="canvas元素"></a>canvas元素</h2><p><code>&lt;canvas&gt;</code> 是 <code>HTML5</code> 新增的，一个可以使用脚本(通常为 <code>JavaScript</code>) 在其中绘制图像的 <code>HTML</code> 元素。它可以用来制作照片集或者制作简单(也不是那么简单)的动画，甚至可以进行实时视频处理和渲染。</p>
<p><code>&lt;canvas&gt;</code> 看起来和 <code>&lt;img&gt;</code> 标签一样，只是 <code>&lt;canvas&gt;</code> 只有两个可选的属性 <code>width、heigth</code> 属性，而没有 <code>src、alt</code> 属性。</p>
<p>如果不给 <code>&lt;canvas&gt;</code> 设置 <code>widht、height</code> 属性时，则默认 <code>width</code>为300、<code>height</code> 为 150，单位都是 <code>px</code>。也可以使用 <code>css</code> 属性来设置宽高，但是如宽高属性和初始比例不一致，他会出现扭曲。所以，建议永远不要使用 <code>css</code> 属性来设置 <code>&lt;canvas&gt;</code> 的宽高。</p>
<h2 id="渲染上下文-Thre-Rending-Context"><a href="#渲染上下文-Thre-Rending-Context" class="headerlink" title="渲染上下文(Thre Rending Context)"></a>渲染上下文(Thre Rending Context)</h2><p>canvas元素创造了一个固定大小的画布，它公开了一个或多个<strong>渲染上下文</strong>，其可以用来绘制和处理要展示的内容。我们将会将注意力放在2D渲染上下文中。<canvas> 元素有一个叫做 getContext() 的方法，这个方法是用来获得渲染上下文和它的绘画功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var canvas = document.getElementById(&#x27;tutorial&#x27;);</span><br><span class="line">//获得 2d 上下文对象</span><br><span class="line">var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h2><p>不同于 SVG，<canvas> 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。所有其他类型的图形都是通过一条或者多条路径组合而成的。</p>
<p>canvas提供了三种方法绘制矩形：</p>
<ul>
<li>fillRect(x, y, width, height)<br>绘制一个填充的矩形，默认填充黑色</li>
<li>strokeRect(x, y, width, height)<br>绘制一个矩形的边框</li>
<li>clearRect(x, y, width, height)<br>清除指定矩形区域，让清除部分完全透明。</li>
</ul>
<p>x与y指定了在canvas画布上所绘制的矩形的左上角（相对于原点）的坐标。width和height设置矩形的尺寸。</p>
<h2 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h2><p>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。</p>
<ol>
<li>首先，你需要创建路径起始点。</li>
<li>然后你使用画图命令去画出路径。</li>
<li>之后你把路径封闭。</li>
<li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。</li>
</ol>
<ul>
<li><p>beginPath()</p>
<p>·新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径</p>
</li>
<li><p>closePath()</p>
<p>闭合路径之后图形绘制命令又重新指向到上下文中。</p>
</li>
<li><p>moveTo(x,y) </p>
<p>方法把路径移动到画布中的指定点，不创建线条。</p>
</li>
<li><p>stroke()</p>
<p>通过线条来绘制图形轮廓</p>
</li>
<li><p>lineTo(x,y)</p>
<p>绘制一条从当前位置到指定x以及y位置的直线。</p>
</li>
<li><p>fill()</p>
<p>通过填充路径的内容区域生成实心的图形。</p>
</li>
</ul>
<p>*<em>注意：当你调用fill()函数时，所有没有闭合的形状都会自动闭合，所以你不需要调用closePath()函数。但是调用stroke()时不会自动闭合</em>***。</p>
<p><strong>绘制一个三角形</strong></p>
<p>例如，绘制三角形的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function draw() &#123;</span><br><span class="line">  var canvas = document.getElementById(&#x27;canvas&#x27;);</span><br><span class="line">  if (canvas.getContext) &#123;</span><br><span class="line">    var ctx = canvas.getContext(&#x27;2d&#x27;);</span><br><span class="line"></span><br><span class="line">    ctx.beginPath();</span><br><span class="line">    ctx.moveTo(75, 50);</span><br><span class="line">    ctx.lineTo(100, 75);</span><br><span class="line">    ctx.lineTo(100, 25);</span><br><span class="line">    ctx.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="样式和颜色"><a href="#样式和颜色" class="headerlink" title="样式和颜色"></a>样式和颜色</h2><h3 id="颜色绘制"><a href="#颜色绘制" class="headerlink" title="颜色绘制"></a>颜色绘制</h3><ul>
<li>fillStyle = color<br>设置图形的填充颜色。</li>
<li>strokeStyle = color<br>设置图形轮廓的颜色。</li>
</ul>
<p>一旦您设置了 <code>strokeStyle</code> 或者 <code>fillStyle</code> 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 <code>fillStyle</code> 或 <code>strokeStyle</code> 的值。</p>
<ul>
<li><p>透明度 Transparency</p>
<p>除了可以绘制实色图形，我们还可以用 canvas 来绘制半透明的图形。通过设置 <code>globalAlpha</code> 属性或者使用一个半透明颜色作为轮廓或填充的样式。</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/globalAlpha"><code>globalAlpha = transparencyValue</code></a></p>
<p>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</p>
</li>
</ul>
</li>
</ul>
<h3 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h3><ul>
<li>lineWidth = value<br>设置线条宽度。</li>
<li>lineCap = type<br>设置线条末端样式。</li>
<li>lineJoin = type<br>设定线条与线条间接合处的样式。</li>
<li>miterLimit = value<br>限制当两条线相交时交接处最大长度；所谓交接处长度（斜接长度）是指线条交接处内角顶点到外角顶点的长度。</li>
<li>getLineDash()<br>返回一个包含当前虚线样式，长度为非负偶数的数组。</li>
<li>setLineDash(segments)<br>设置当前虚线样式。</li>
<li>lineDashOffset = value<br>设置虚线样式的起始偏移量。</li>
</ul>
<h3 id="渐变-Gradients"><a href="#渐变-Gradients" class="headerlink" title="渐变 Gradients"></a>渐变 Gradients</h3><p>就好像一般的绘图软件一样，我们可以用线性或者径向的渐变来填充或描边。我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性。</p>
<ul>
<li>createLinearGradient(x1, y1, x2, y2)<br>createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。</li>
<li>createRadialGradient(x1, y1, r1, x2, y2, r2)<br>createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var lineargradient = ctx.createLinearGradient(0,0,150,150);</span><br><span class="line">var radialgradient = ctx.createRadialGradient(75,75,0,75,75,100);</span><br></pre></td></tr></table></figure>

<p>Copy to Clipboard</p>
<p>创建出 <code>canvasGradient</code> 对象后，我们就可以用 <code>addColorStop</code> 方法给它上色了。</p>
<ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasGradient/addColorStop"><code>gradient.addColorStop(position, color)</code></a></p>
<p>addColorStop 方法接受 2 个参数，<code>position</code> 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。<code>color</code> 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。</p>
</li>
</ul>
<h3 id="图案样式-Patterns"><a href="#图案样式-Patterns" class="headerlink" title="图案样式 Patterns"></a>图案样式 Patterns</h3><p>上一节的一个例子里面，我用了循环来实现图案的效果。其实，有一个更加简单的方法：createPattern。</p>
<p>createPattern(image, type)<br>该方法接受两个参数。Image 可以是一个 Image 对象的引用，或者另一个 canvas 对象。Type 必须是下面的字符串值之一：repeat，repeat-x，repeat-y 和 no-repeat。<br>注意: 用 canvas 对象作为 Image 参数在 Firefox 1.5 (Gecko 1.8) 中是无效的。<br>图案的应用跟渐变很类似的，创建出一个 pattern 之后，赋给 fillStyle 或 strokeStyle 属性即可。</p>
<p>var img = new Image();<br>img.src = ‘someimage.png’;<br>var ptrn = ctx.createPattern(img,’repeat’);</p>
<h3 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h3><ul>
<li><p>shadowOffsetX = float<br>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</p>
</li>
<li><p>shadowOffsetY = float<br>shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。</p>
</li>
<li><p>shadowBlur = float<br>shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。</p>
</li>
<li><p>shadowColor = color<br>shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色。</p>
</li>
</ul>
<h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><h3 id="上传图像"><a href="#上传图像" class="headerlink" title="上传图像"></a>上传图像</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObjectURL</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> url = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.createObjcectURL != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        url = <span class="built_in">window</span>.createOjcectURL(file);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.URL != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        url = <span class="built_in">window</span>.URL.createObjectURL(file);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.webkitURL != <span class="literal">undefined</span>) &#123;</span><br><span class="line">        url = <span class="built_in">window</span>.webkitURL.createObjectURL(file);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objURL = getObjectURL(imgFile);<span class="comment">//imgFile文件对象</span></span><br><span class="line"><span class="comment">//objURL --&gt;blob:http://127.0.0.1:5500/d17cdcc3-b698-4011-a6d2-f63360cdd22b</span></span><br><span class="line"><span class="comment">// 你可以像使用普通 URL 那样使用它，比如用在 img.src 上。</span></span><br><span class="line">$(<span class="string">&quot;#img&quot;</span>).attr(<span class="string">&quot;src&quot;</span>, objURL);</span><br></pre></td></tr></table></figure>

<p>通过window.URL.createObjectURL方法可以把一个blob转化为一个Blob URL，并且用做文件下载或者图片显示的链接。<strong>File对象是一种特殊的Blob对象</strong></p>
<p>每次你调用window.URL.createObjectURL()，就会产生一个唯一的对象URL，即使是你对一个已创建了对象URL的文件再次创建一个对象URL。每个创建了的对象URL必须要释放。当文档关闭时，它们会自动被释放。如果你的网页要动态使用它们，你需要显式调用 <strong>window.URL.revokeObjectURL()</strong> 来释放它们</p>
<h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p><strong>获取图片的方式</strong></p>
<ul>
<li><p>HTMLImageElement<br>图片由Image()函数构造出来，或者任何的<img>元素</p>
<ul>
<li><p>用脚本创建一个新的 <strong>HTMLImageElement</strong> 对象，使用Image()构造函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();   <span class="comment">// 创建一个&lt;img&gt;元素</span></span><br><span class="line">img.src = objURL; <span class="comment">// 设置图片源地址</span></span><br></pre></td></tr></table></figure>

<p>若调用 <code>drawImage</code> 时，图片没装载完，那什么都不会发生（在一些旧的浏览器中可能会抛出异常）。因此你应该用<strong>load</strong>事件来保证不会在加载完毕之前使用这个图片：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//已知图像路径</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();   <span class="comment">// 创建img元素</span></span><br><span class="line">img.src = <span class="string">&#x27;myImage.png&#x27;</span>; <span class="comment">// 设置图片源地址</span></span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 执行drawImage语句</span></span><br><span class="line">    <span class="comment">//1.创建的img对象</span></span><br><span class="line">    ctx.drawImage(<span class="built_in">this</span>,offsetX,<span class="number">0</span>,imgW,imgH);</span><br><span class="line">    <span class="comment">//2.文中的img标签</span></span><br><span class="line">    ctx.drawImage(<span class="built_in">document</span>.getElementById(<span class="string">&quot;img&quot;</span>), <span class="number">0</span>, <span class="number">0</span>, imgW, imgH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>HTMLVideoElement<br>用一个HTML的 <video>元素作为你的图片源，可以从视频中抓取当前帧作为一个图像</p>
</li>
<li><p>HTMLCanvasElement<br>可以使用另一个 <canvas> 元素作为你的图片源。</p>
<ul>
<li><p><strong><code>HTMLCanvasElement.toDataURL()</code><strong>获取</strong>canvas</strong>对应的data-URL (一串 Base64 编码的字符串)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">canvas.toDataURL(type, encoderOptions);</span><br><span class="line">type 可选的</span><br><span class="line">默认格式类型为 image/png.</span><br><span class="line">encoderOptions 可选的</span><br><span class="line">表示所述图像质量对于使用的图像格式即使用有损压缩，如 image/jpeg和image/webp。</span><br><span class="line">如果此参数是其他任何参数，则使用图像质量的默认值。默认值为<span class="number">0.92</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.getElementById(<span class="string">&quot;canvas&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> dataURL = canvas.toDataURL();</span><br><span class="line"><span class="comment">//dataURL，相当于就是src</span></span><br><span class="line">img.src = dataURL</span><br><span class="line"><span class="comment">//src-&gt; //&#x27;data:image/gif;base64,R0lGODlhCwALAIAAAAAA3pn/ZiH5BAEAAAEALAAAAAALAAsAAAIUhA+hkcuO4lmNVindo7qyrIXiGBYAOw==&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>设置jpegs图片的质量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fullQuality = canvas.toDataURL(<span class="string">&quot;image/jpeg&quot;</span>, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// data:image/jpeg;base64,/9j/4AAQSkZJRgABAQ...9oADAMBAAIRAxEAPwD/AD/6AP/Z&quot;</span></span><br><span class="line"><span class="keyword">var</span> mediumQuality = canvas.toDataURL(<span class="string">&quot;image/jpeg&quot;</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="keyword">var</span> lowQuality = canvas.toDataURL(<span class="string">&quot;image/jpeg&quot;</span>, <span class="number">0.1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>ImageBitmap<br>这是一个高性能的位图，可以低延迟地绘制，它可以从上述的所有源以及其它几种源中生成。</p>
</li>
</ul>
<h3 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h3><p>ImageData对象中存储着canvas对象真实的像素数据</p>
<p><strong>getImageData(left, top, width, height)</strong></p>
<p>获得一个包含画布场景像素数据的ImageData对像</p>
<ul>
<li><p>**<code>width</code>**图片宽度，单位是像素</p>
</li>
<li><p><code>height</code>图片高度，单位是像素</p>
</li>
<li><p><code>data</code></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray"><code>Uint8ClampedArray</code></a>类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。</p>
</li>
</ul>
<p>**putImageData()**对场景进行像素数据的写入</p>
<h3 id="图像模糊"><a href="#图像模糊" class="headerlink" title="图像模糊"></a>图像模糊</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31426945">https://zhuanlan.zhihu.com/p/31426945</a></p>
<p><a href="https://juejin.cn/post/6844903759995207693">https://juejin.cn/post/6844903759995207693</a></p>
<h4 id="设备像素比"><a href="#设备像素比" class="headerlink" title="设备像素比"></a>设备像素比</h4><p><strong>设备像素比(window.devicePixelRatio)当前显示设备的<em>物理像素</em>分辨率与<em>CSS像素</em>分辨率之比，此值也可以解释为像素大小的比率：一个CSS像素的大小与一个物理像素的大小。 简单来说，它告诉浏览器应使用多少屏幕实际像素来绘制单个CSS像素。</strong></p>
<p>在很早以前还没高分屏的时候，开发写的的1像素也就是实际的1像素（如果不考虑缩放的情况），你根本不需要做什么特殊的处理。如果css中设置100px那他就是100px。</p>
<p>后来出现了高分屏的手机，并且在window对象下面出现了devicePixelRatio 这个神秘的属性，并且还可以用devicePixelRatio在媒体查询中进行判断。这个属性的意思就是：渲染时，css中的像素（逻辑像素）候和实际像素（物理像素）的比值。比如说：iPhone 4S它的devicePixelRatio 属性的值是2，那就是100px逻辑像素等于200px的设备实际像素。原先需要一个像素绘制的点，现在会用两个像素来绘制。</p>
<h4 id="canvas-的-css-宽高与画布宽高"><a href="#canvas-的-css-宽高与画布宽高" class="headerlink" title="canvas 的 css 宽高与画布宽高"></a>canvas 的 css 宽高与<strong>画布宽高</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;canvas id=&quot;canvas&quot; width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure>

<p>canvas 标签中的 <code>width</code> 和 <code>height</code> 属性并不是 css 中的宽高，而是 canvas <strong>画布宽高</strong>（绘图区域），当不设置 canvas 的 css 宽高时，canvas 会将 <code>width</code> 和 <code>height</code>的值作为 css 宽高，而 css 宽高是元素在页面上的可见尺寸</p>
<p>但是 canvas 的上下文宽高略奇怪，它可不管像素比是 1 是 2 还是 3，它就是会将整个 canvas 绘图区域塞进 css 宽高中并且填满，绘图的时候会将绘制的图形的宽高按照塞进 css 时宽与高的缩放比率分别进行缩放（<strong>所以如果缩放比率不同，就会导致绘制的图形变形</strong>）</p>
<p><strong>但是上面这些都不是导致模糊的真正原因，下面这个才是捣乱的元凶：</strong></p>
<blockquote>
<p>canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊</p>
</blockquote>
<h4 id="解决绘图模糊"><a href="#解决绘图模糊" class="headerlink" title="解决绘图模糊"></a>解决绘图模糊</h4><p>创建的图片的时候根据devicePixelRatio 放大数倍（比原照片更大的新的一张图片）然后再用css再把它缩小到原来的样子。因此缩小后的图片不会超过自己原来的尺寸并且不会再模糊。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getPixelRatio = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> backingStore = context.backingStorePixelRatio ||</span><br><span class="line">        context.webkitBackingStorePixelRatio ||</span><br><span class="line">        context.mozBackingStorePixelRatio ||</span><br><span class="line">        context.msBackingStorePixelRatio ||</span><br><span class="line">        context.oBackingStorePixelRatio ||</span><br><span class="line">        context.backingStorePixelRatio || <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span>) / backingStore;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> pixelRatio = getPixelRatio(canvas);</span><br><span class="line"><span class="built_in">console</span>.log(pixelRatio)</span><br><span class="line"><span class="comment">//设置宽高</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCanvasArea</span>(<span class="params">canvas, ctx</span>) </span>&#123;</span><br><span class="line">    canvas.width = <span class="built_in">Math</span>.floor(cw * pixelRatio);</span><br><span class="line">    canvas.height = <span class="built_in">Math</span>.floor(ch * pixelRatio);</span><br><span class="line">    <span class="comment">// 设置canvas的真实宽高</span></span><br><span class="line">    canvas.style.width = cw + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    canvas.style.height = ch + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">    ctx.scale(pixelRatio, pixelRatio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="反锯齿"><a href="#反锯齿" class="headerlink" title="反锯齿"></a>反锯齿</h4><p><code>CanvasRenderingContext2D</code><strong><code>.imageSmoothingEnabled</code></strong> 是 Canvas 2D API 用来设置图片是否平滑的属性，true表示图片平滑（默认值），false表示图片不平滑。</p>
<p>反锯齿默认是启用的，我们可能想要关闭它以看到清楚的像素。你可以通过切换勾选框来看到imageSmoothingEnabled属性的效果</p>
<pre><code>zoomctx.imageSmoothingEnabled = false;
zoomctx.mozImageSmoothingEnabled = false;
zoomctx.webkitImageSmoothingEnabled = false;
zoomctx.msImageSmoothingEnabled = false;
</code></pre>
<p><img src="data:image/png;base64,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" alt="img"></p>
<p> 第一个图像以其自然大小绘制，第二个图像缩放为3倍并启用了图像平滑，而第三个图像缩放为3倍但禁用了图像平滑。</p>
<p><strong>imageSmoothingQuality</strong></p>
<p>使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/imageSmoothingQuality"><code>imageSmoothingQuality</code></a>属性来调整平滑质量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ctx.imageSmoothingQuality = value</span><br><span class="line">value = ctx.imageSmoothingQuality</span><br><span class="line"><span class="comment">//value</span></span><br><span class="line"><span class="comment">//&quot;low&quot;,&quot;medium&quot;,&quot;high&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>image-rendering</strong></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/image-rendering">https://developer.mozilla.org/zh-CN/docs/Web/CSS/image-rendering</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS">CSS</a> 属性 <strong><code>image-rendering</code></strong> 用于设置图像缩放算法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 专有属性值 */</span><br><span class="line">image-rendering: auto;</span><br><span class="line">image-rendering: crisp-edges;</span><br><span class="line">image-rendering: pixelated;</span><br><span class="line"></span><br><span class="line">/* 全局属性值 */</span><br><span class="line">image-rendering: inherit;</span><br><span class="line">image-rendering: initial;</span><br><span class="line">image-rendering: unset;</span><br></pre></td></tr></table></figure>

<h4 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h4><p><a href="https://juejin.cn/post/6844904019605848072">https://juejin.cn/post/6844904019605848072</a></p>
<ul>
<li><p>将DOM转化成canvas对象</p>
<p><a href="http://html2canvas.hertzen.com/dist/html2canvas.min.js">http://html2canvas.hertzen.com/dist/html2canvas.min.js</a></p>
</li>
<li><p>将canvas生成照片</p>
<p><a href="http://github.com/randreucetti/canvas2image">HTTP://github.com/randreucetti/canvas2image</a></p>
</li>
</ul>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ul>
<li>避免浮点数的坐标点，用整数取而代之</li>
<li>在离屏canvas中缓存图片的不同尺寸，而不要用<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D/drawImage"><code>drawImage()</code></a>去缩放它们。</li>
</ul>
<h2 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h2><h3 id="translate-x-y"><a href="#translate-x-y" class="headerlink" title="translate(x, y)"></a>translate(x, y)</h3><h3 id="rotate-angle"><a href="#rotate-angle" class="headerlink" title="rotate(angle)"></a>rotate(angle)</h3><h3 id="scale-x-y"><a href="#scale-x-y" class="headerlink" title="scale(x, y)"></a>scale(x, y)</h3><p>如果比1小，会缩小图形， 如果比1大会放大图形</p>
<p>如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用<code>translate(0,canvas.height); scale(1,-1);</code> 以y轴作为对称轴镜像反转</p>
<h3 id="transform-a-b-c-d-e-f"><a href="#transform-a-b-c-d-e-f" class="headerlink" title="transform(a, b, c, d, e, f)"></a>transform(a, b, c, d, e, f)</h3><p>a (m11)<br>水平方向的缩放<br>b(m12)<br>竖直方向的倾斜偏移<br>c(m21)<br>水平方向的倾斜偏移<br>d(m22)<br>竖直方向的缩放<br>e(dx)<br>水平方向的移动<br>f(dy)<br>竖直方向的移动</p>
<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>绘制顺序：<strong>globalCompositeOperation</strong>，这个属性设定了在画新图形时采用的遮盖策略</p>
<h2 id="save-amp-amp-restore"><a href="#save-amp-amp-restore" class="headerlink" title="save&amp;&amp;restore"></a>save&amp;&amp;restore</h2><ul>
<li>save()<br>保存画布(canvas)的所有状态</li>
<li>restore()<br>save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</li>
</ul>
<p>Canvas状态存储在栈中，每当<code>save()</code>方法被调用后，当前的状态就被推送到栈中保存。每一次调用 <code>restore</code> 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。</p>
<h1 id="图形-Konva"><a href="#图形-Konva" class="headerlink" title="图形:Konva"></a>图形:Konva</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>Konva 的对象是以一颗树的形式保存的，<code>Konva.Stage</code> 是树的根节点，<code>Stage</code> 子节点是用户创建的图层 （<code>Konva.Layer</code>）。</p>
<p>每一个 layer 有两个 <code>&lt;canvas&gt;</code> 渲染器： 场景渲染器 和 图像命中检测渲染器。场景渲染器输出你所看见的内容，图像命中渲染器在隐藏的 canvas 里用于高性能的检测事件。</p>
<p>图层可以包含图形、嵌套图形的组、嵌套组的组。<code>Stage</code>（舞台），<code>layers</code>（图层），<code>groups</code>（组），和 <code>shapes</code>（图形） 都是虚拟节点，类似于 HTML 的 DOM 节点。</p>
<p>节点结构图:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">              Stage</span><br><span class="line">                |</span><br><span class="line">         +------+------+</span><br><span class="line">         |             |</span><br><span class="line">       Layer         Layer</span><br><span class="line">         |             |</span><br><span class="line">   +-----+-----+     Shape</span><br><span class="line">   |           |</span><br><span class="line"> Group       Group</span><br><span class="line">   |           |</span><br><span class="line">   +       +---+---+</span><br><span class="line">   |       |       |</span><br><span class="line">Shape   Group    Shape</span><br><span class="line">           |</span><br><span class="line">           +</span><br><span class="line">           |</span><br><span class="line">         Shape</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ol>
<li><p>引入 Konva.js 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script src=&quot;konva.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>然后页面中放置一个容器作为 Konva 处理的对象. Konva 会在该容器中添加 canvas 标签. 值得说明的是, 需要为这个标签添加 id 属性.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;dv&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>然后编写 js 代码，Konva 是一个<strong>完全面向对象</strong>的库.</p>
</li>
<li><p>创建舞台</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var stage = new Konva.Stage(&#123;</span><br><span class="line"> container: &#x27;dv&#x27;,</span><br><span class="line"> width: window.innerWidth,</span><br><span class="line"> height: window.innerHeight</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>首先, 在 Konva 中所有的图形都是在 Konva 中的一个构造函数. Konva 是全局的命名空间.</li>
<li>创建舞台使用的是 Stage 构造函数，该函数需要提供参数.</li>
<li>Konva 中所有图形的参数都是使用 json 对象的方式进行提供.</li>
<li>舞台需要设置容器的 id, 即 container 属性. 以及宽( width ), 高( height ).</li>
</ul>
<ol start="5">
<li><p>舞台中可以放置一个到多个层( Layer ), 所有的图形应该放在在层中</p>
<ul>
<li>首先创建层对象. 层对象不需要传递参数.</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var layer = new Konva.Layer();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将层添加到舞台中. Konva 中凡是添加, 都是使用 add 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stage.add( layer );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>在层中放置一个矩形, 就创建一个 矩形对象</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var rect = new Konva.Rect(&#123;</span><br><span class="line">x: 100,</span><br><span class="line">y: 50,</span><br><span class="line">width: 200,</span><br><span class="line">height: 100,</span><br><span class="line">fill: &#x27;red&#x27;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>将矩形添加到 层中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layer.add( rect );</span><br></pre></td></tr></table></figure></li>
<li><p>最后绘图使用 draw 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">layer.draw();</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="stage"><a href="#stage" class="headerlink" title="stage"></a>stage</h2><p>layer 的概念类似于 ps 中的图层，或者 DOM 中的 z-index，当我们向 stage 中添加一个 layer 时，DOM 中会再加入一个 canvas 元素来对应这个 layer。</p>
<p>当我们往 layer 中添加了多个 shape 时，调用 layer.draw 时，layer 会按照形状添加的先后顺序依次进行绘制。后面添加的在上面，最先添加的在最下面。</p>
<h1 id="图表-Antv"><a href="#图表-Antv" class="headerlink" title="图表:Antv"></a>图表:Antv</h1><h2 id="G2"><a href="#G2" class="headerlink" title="G2"></a>G2</h2><p><a href="https://blog.csdn.net/u011262253/article/details/107370549">https://blog.csdn.net/u011262253/article/details/107370549</a></p>
<h3 id="G2-的数据处理流程"><a href="#G2-的数据处理流程" class="headerlink" title="G2 的数据处理流程"></a>G2 的数据处理流程</h3><p><a href="https://g2.antv.vision/zh/docs/manual/tutorial/data-flow">https://g2.antv.vision/zh/docs/manual/tutorial/data-flow</a></p>
<h3 id="图形组件"><a href="#图形组件" class="headerlink" title="图形组件"></a>图形组件</h3><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">const data = [</span><br><span class="line">  &#123; year: &#x27;<span class="number">1951</span> 年&#x27;, sales|value: <span class="number">38</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1952</span> 年&#x27;, sales|value: <span class="number">52</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1956</span> 年&#x27;, sales|value: <span class="number">61</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1957</span> 年&#x27;, sales|value: <span class="number">145</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1958</span> 年&#x27;, sales|value: <span class="number">48</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1959</span> 年&#x27;, sales|value: <span class="number">38</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1960</span> 年&#x27;, sales|value: <span class="number">38</span> &#125;,</span><br><span class="line">  &#123; year: &#x27;<span class="number">1962</span> 年&#x27;, sales|value: <span class="number">38</span> &#125;,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<h4 id="度量-scale和坐标轴Axis"><a href="#度量-scale和坐标轴Axis" class="headerlink" title="度量 scale和坐标轴Axis"></a>度量 scale和坐标轴Axis</h4><p>每个图表通常包含两个坐标轴，在直角坐标系（笛卡尔坐标系）下，分别为 x 轴和 y 轴，在极坐标轴下，则分别由角度和半径 2 个维度构成。</p>
<img src="https://gw.alipayobjects.com/mdn/rms_f5c722/afts/img/A*0Q09R4hQe8YAAAAAAAAAAABkARQnAQ" alt="image.png" style="zoom:33%;" />

<p>每个坐标轴由坐标轴线（line）、刻度线（tickLine）、刻度文本（label）、标题（title）以及网格线（grid）组成。</p>
<img src="https://gw.alipayobjects.com/mdn/rms_f5c722/afts/img/A*o64XRZfivrEAAAAAAAAAAABkARQnAQ" alt="image.png" style="zoom: 33%;" />

<h5 id="度量类型"><a href="#度量类型" class="headerlink" title="度量类型"></a>度量类型</h5><p><a href="https://g2.antv.vision/zh/docs/manual/tutorial/scale">https://g2.antv.vision/zh/docs/manual/tutorial/scale</a></p>
<ol>
<li>分类（非连续）数据，又分为有序分类和无序分类。</li>
<li>连续数据，时间也是一种连续数据类型。</li>
<li>常量度量，数据是一种常量，只有单个值。</li>
</ol>
<p>度量的类型有：</p>
<table>
<thead>
<tr>
<th align="left">数据类型</th>
<th align="left">度量类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">连续</td>
<td align="left">linear、log、pow、time、quantize、quantile</td>
</tr>
<tr>
<td align="left">分类（非连续）</td>
<td align="left">cat、timeCat</td>
</tr>
<tr>
<td align="left">常量</td>
<td align="left">identity</td>
</tr>
</tbody></table>
<ul>
<li>分类度量：<ul>
<li>cat： 分类度量，[‘男’, ‘女’]。</li>
<li>timeCat: 时间分类度量，比如股票的时间不包括周末或者未开盘的日期。</li>
</ul>
</li>
<li>连续度量：<ul>
<li>linear: 线性度量，连续的数字 [1, 2, 3, 4, 5]。</li>
<li>time：连续的时间度量。</li>
<li>log: log 度量连，续非线性的 Log 数据 将 [1, 10, 100, 1000] 转换成 [0, 1, 2, 3]。</li>
<li>pow: pow 度量，连续非线性的 pow 数据 将 [2, 4, 8, 16, 32] 转换成 [1, 2, 3, 4, 5]。</li>
<li>quantize：分段度量，用户可以指定不均匀的分段，例如 [0-100, 100-200, 200-300] 在一个区间内映射到一个值上。</li>
<li>quantile: 等分度量，根据数据的分布自动计算分段。</li>
</ul>
</li>
<li>常量度量<ul>
<li>identity: 常量度量，也就是说数据的某个字段是不变的常量。</li>
</ul>
</li>
</ul>
<h5 id="坐标轴配置"><a href="#坐标轴配置" class="headerlink" title="坐标轴配置"></a>坐标轴配置</h5><p>坐标轴的内容是由 scale 度量控制的，所以 scale 度量的名字控制着坐标轴的标题内容。 <code>chart.axis()</code> 只用于控制坐标轴的外观配置 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//度量（Scale）用于定义坐标轴内容的类型和展示方式</span></span><br><span class="line">chart.scale(&#123;</span><br><span class="line">    <span class="attr">year</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: <span class="string">&quot;时间&quot;</span>,</span><br><span class="line">        <span class="attr">range</span>: [<span class="number">0.05</span>, <span class="number">0.75</span>], <span class="comment">//设置坐标系两端留白</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">value</span>: &#123;</span><br><span class="line">        <span class="attr">alias</span>: <span class="string">&quot;数量&quot;</span>,</span><br><span class="line">        <span class="comment">// ticks: [0, 100, 200, 300, 400, 500, 600], //设置坐标轴数值范围</span></span><br><span class="line">        <span class="comment">//设置坐标轴数值范围</span></span><br><span class="line">        <span class="attr">min</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="attr">max</span>: <span class="number">1000</span>,</span><br><span class="line">        <span class="attr">tickCount</span>: <span class="number">10</span>, <span class="comment">//设置坐标轴刻度线个数</span></span><br><span class="line">        <span class="attr">tickInterval</span>: <span class="number">200</span>, <span class="comment">//设置坐标轴刻度线间距</span></span><br><span class="line">        <span class="attr">formatter</span>: <span class="function">(<span class="params">val</span>) =&gt;</span> <span class="string">`￥<span class="subst">$&#123;val&#125;</span>`</span>, <span class="comment">//格式化</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">Value</span>: &#123;</span><br><span class="line">        <span class="attr">sync</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">nice</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//scale 度量的名字控制着坐标轴的标题内容</span></span><br><span class="line"><span class="comment">// chart.scale(&quot;year&quot;, &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">// chart.scale(&quot;value&quot;, &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// &#125;);</span></span><br><span class="line"><span class="comment">//只用于控制坐标轴的外观配置</span></span><br><span class="line">chart.axis(<span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// tickLine: null, //刻度线</span></span><br><span class="line">    <span class="attr">title</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">fill</span>: <span class="string">&quot;#1890ff&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line">chart.axis(<span class="string">&quot;value&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// tickLine: null, //刻度线</span></span><br><span class="line">    <span class="attr">title</span>: &#123;</span><br><span class="line">        <span class="attr">style</span>: &#123;</span><br><span class="line">            <span class="attr">fill</span>: <span class="string">&quot;#1890ff&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="图例legend"><a href="#图例legend" class="headerlink" title="图例legend"></a>图例legend</h4><p><a href="https://g2.antv.vision/zh/docs/api/general/legend/">图例配置</a></p>
<p>图例作为图表的辅助元素，用于标定不同的数据类型以及数据的范围，辅助阅读图表，帮助用户在图表中进行数据的筛选过滤。 </p>
<p>在 G2 中，根据数据的类型，目前提供了以下两种图例：</p>
<ol>
<li><p>分类图例            </p>
 <img src="https://gw.alipayobjects.com/mdn/rms_f5c722/afts/img/A*i4FsS4X0-G8AAAAAAAAAAABkARQnAQ" alt="img" style="zoom:33%;" />         </li>
<li><p>连续图例</p>
 <img src="https://gw.alipayobjects.com/mdn/rms_f5c722/afts/img/A*1v5vT44hdEYAAAAAAAAAAABkARQnAQ" alt="img" style="zoom:33%;" /> </li>
</ol>
<h5 id="分类图例"><a href="#分类图例" class="headerlink" title="分类图例"></a>分类图例</h5><p>图例配置：通过 <code>chart.legend()</code> 接口对图例进行配置，具体的配置详见 <a href="https://g2.antv.vision/zh/docs/api/general/legend">API</a>。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">chart.legend(<span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">show</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">position</span>: <span class="string">&quot;top-left&quot;</span>,</span><br><span class="line">    <span class="attr">marker</span>: <span class="function">(<span class="params">name: <span class="built_in">any</span>, index: <span class="built_in">any</span>, item: <span class="built_in">any</span></span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">symbol</span>: <span class="string">&quot;circle&quot;</span>,</span><br><span class="line">            <span class="attr">style</span>: &#123;</span><br><span class="line">                <span class="attr">fill</span>: index === <span class="number">0</span> ? <span class="string">&quot;purple&quot;</span> : <span class="string">&quot;green&quot;</span>,</span><br><span class="line">                <span class="attr">stroke</span>: <span class="string">&quot;#363636&quot;</span>,</span><br><span class="line">                <span class="attr">lineWidth</span>: <span class="number">1</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">        <span class="attr">fontWeight</span>: <span class="string">&quot;normal&quot;</span>,</span><br><span class="line">        <span class="attr">fontSize</span>: <span class="number">12</span>,</span><br><span class="line">        <span class="attr">fill</span>: <span class="string">&quot;#303133&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;); <span class="comment">// 只更改 x 维度对应的图例的显示位置</span></span><br></pre></td></tr></table></figure>

<h5 id="连续图例"><a href="#连续图例" class="headerlink" title="连续图例"></a>连续图例</h5><h4 id="提示信息Tooltip"><a href="#提示信息Tooltip" class="headerlink" title="提示信息Tooltip"></a>提示信息Tooltip</h4><p><a href="https://g2.antv.vision/zh/docs/manual/tutorial/tooltip">https://g2.antv.vision/zh/docs/manual/tutorial/tooltip</a></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">chart.tooltip(&#123;</span><br><span class="line">  <span class="attr">showCrosshairs</span>: <span class="literal">true</span>, <span class="comment">// 展示 Tooltip 辅助线</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h4><p><a href="https://g2.antv.vision/zh/docs/api/general/label">https://g2.antv.vision/zh/docs/api/general/label</a></p>
<p>文本标签对应每一条数据记录，G2 除了提供文本标签的显示功能外，用户还可以指定显示的内容、配置文本样式等。使用如下接口配置：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">chart.line().position(<span class="string">&quot;date*blockchain&quot;</span>).label(<span class="string">&quot;nlp&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>文本标签类型</p>
<p>针对不同的图表类型有不同的文本标签类型。G2 默认提供了 4 种类型：</p>
<ul>
<li>‘base’，默认类型，用于直角坐标系下的图表</li>
<li>‘interval’，用于 Interval 几何标记下所有图形的文本标注，比如柱状图等</li>
<li>‘pie’，专用于饼图的文本标注，带有文本连接线</li>
<li>‘polar’，用于极坐标系下图表的文本标注</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chart.interval().position(&#x27;x*y&#x27;).label(&#x27;z&#x27;, &#123;</span><br><span class="line">  type: &#x27;polar&#x27;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="图形标注"><a href="#图形标注" class="headerlink" title="图形标注"></a>图形标注</h4><p>图形标注，Annotation，作为 G2 图表的辅助元素，主要用于在图表上标识额外的标记注解。</p>
  <img src="https://gw.alipayobjects.com/mdn/rms_f5c722/afts/img/A*B0q9R7s1v3sAAAAAAAAAAABkARQnAQ" alt="image.png" style="zoom:50%;" /> 



<h4 id="滑块"><a href="#滑块" class="headerlink" title="滑块"></a>滑块</h4><p><a href="https://g2.antv.vision/zh/docs/manual/concepts/component/slider">https://g2.antv.vision/zh/docs/manual/concepts/component/slider</a></p>
<h4 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h4><p><a href="https://g2.antv.vision/zh/docs/manual/concepts/component/scrollbar">https://g2.antv.vision/zh/docs/manual/concepts/component/scrollbar</a></p>
<h4 id="color"><a href="#color" class="headerlink" title="color"></a>color</h4><ul>
<li>如果班级等于 ‘1’或者人数大于 40 则映射成红色</li>
<li>其他则映射成绿色</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chart</span><br><span class="line">  .interval()</span><br><span class="line">  .position(&#x27;班级*人数&#x27;)</span><br><span class="line">  .color(&#x27;班级*人数&#x27;, (grade, count) =&gt; &#123;</span><br><span class="line">    if (grade == &#x27;1&#x27; || count &gt; 40) &#123;</span><br><span class="line">      return &#x27;red&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">    return &#x27;green&#x27;;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p> <img src="https://zos.alipayobjects.com/rmsportal/rpqzzXemVdFsncz.png#align=left&display=inline&height=405&originHeight=405&originWidth=773&status=done&style=none&width=773" alt="img"> </p>
<h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p> <a href="https://g2.antv.vision/zh/docs/api/advanced/register-theme">自定义主题 - Theme </a> </p>
<h5 id="缩略轴"><a href="#缩略轴" class="headerlink" title="缩略轴"></a><a href="https://g2.antv.vision/zh/docs/api/general/slider">缩略轴</a></h5><h3 id="几何图形"><a href="#几何图形" class="headerlink" title="几何图形"></a>几何图形</h3><h4 id="点图-point"><a href="#点图-point" class="headerlink" title="点图 point"></a>点图 point</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">x、y 映射到位置的单个图形</span><br><span class="line">chart.point()</span><br></pre></td></tr></table></figure>

<ul>
<li>单个的数值字段，分类字段或者连续字段，数据以及语法如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123; <span class="attr">carat</span>: <span class="number">10</span> &#125;];</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">chart.point().position(<span class="string">&#x27;carat&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>两个数值字段，分类字段连续字段，语法如下：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123; <span class="attr">month</span>: <span class="string">&#x27;一月&#x27;</span>, <span class="attr">temperature</span>: <span class="number">10</span> &#125;];</span><br><span class="line">chart.point().position(<span class="string">&#x27;month*temperature&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>两个数据字段，y 轴对应的数据字段是数组，如：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [&#123; <span class="attr">month</span>: <span class="string">&#x27;一月&#x27;</span>, <span class="attr">temperature</span>: [-<span class="number">5</span>, <span class="number">10</span>] &#125;];</span><br><span class="line">chart.point().position(<span class="string">&#x27;month*temperature&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="路径和线-path-amp-amp-line"><a href="#路径和线-path-amp-amp-line" class="headerlink" title="路径和线 path &amp;&amp; line"></a>路径和线 path &amp;&amp; line</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">多个点连接成线</span><br><span class="line">chart.line()</span><br></pre></td></tr></table></figure>

<h5 id="color-1"><a href="#color-1" class="headerlink" title="color"></a>color</h5><p>color 可以区分不同的线，增加 color 视觉通道，可以将数据进行分组，绘制出多条直线</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [</span><br><span class="line">  &#123; <span class="attr">month</span>: <span class="string">&#x27;一月&#x27;</span>, <span class="attr">temperature</span>: <span class="number">10</span>, <span class="attr">city</span>: <span class="string">&#x27;北京&#x27;</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">month</span>: <span class="string">&#x27;一月&#x27;</span>, <span class="attr">temperature</span>: <span class="number">15</span>, <span class="attr">city</span>: <span class="string">&#x27;南京&#x27;</span> &#125;,</span><br><span class="line">];</span><br><span class="line">chart.line().position(<span class="string">&#x27;month*temperature&#x27;</span>).color(<span class="string">&#x27;city&#x27;</span>);</span><br></pre></td></tr></table></figure>

 <img src="https://zos.alipayobjects.com/basement/skylark/0ad680ae14791814186284070d17cd/attach/4080/900/image.png#align=left&amp;display=inline&amp;height=494&amp;originHeight=494&amp;originWidth=961&amp;status=done&amp;style=none&amp;width=961" alt="img" style="zoom:50%;" /> 

<h5 id="size"><a href="#size" class="headerlink" title="size"></a>size</h5><p>size 的视觉通道跟图形的自由度相关，自由度 = 空间维度 - 图形维度，线是一维的，所以线图的自由度是 1。在 G2 中我们将 size 视觉通道映射的线的宽度，由于人对宽度的识别度不高，这个映射慎用。</p>
<img src="https://zos.alipayobjects.com/basement/skylark/0ad6383d14791814326954771d7553/attach/4080/900/image.png#align=left&amp;display=inline&amp;height=469&amp;originHeight=469&amp;originWidth=874&amp;status=done&amp;style=none&amp;width=874" alt="img" style="zoom:50%;" />

<h5 id="shape"><a href="#shape" class="headerlink" title="shape"></a>shape</h5><p>线图支持的图形：</p>
<ul>
<li>line 常见的实线</li>
<li>dot 点线</li>
<li>smooth 平滑的曲线</li>
</ul>
<img src="https://zos.alipayobjects.com/basement/skylark/0ad6383d14791814488053451d7565/attach/4080/900/image.png#align=left&amp;display=inline&amp;height=495&amp;originHeight=495&amp;originWidth=962&amp;status=done&amp;style=none&amp;width=962" alt="img" style="zoom:50%;" />

<ul>
<li>信号相关的折线图：vh hv hvh vhv</li>
</ul>
<img src="https://zos.alipayobjects.com/basement/skylark/0ad6383d14791814670683470d7565/attach/4080/900/image.png#align=left&amp;display=inline&amp;height=490&amp;originHeight=490&amp;originWidth=949&amp;status=done&amp;style=none&amp;width=949" alt="img" style="zoom:50%;" />

<h5 id="线图和坐标系"><a href="#线图和坐标系" class="headerlink" title="线图和坐标系"></a>线图和坐标系</h5><p>线图在直角坐标系和极坐标系下有所差别，在极坐标下线图需要进行闭合。</p>
<img src="https://zos.alipayobjects.com/basement/skylark/0ad6383d14791814858303483d7565/attach/4080/900/image.png#align=left&amp;display=inline&amp;height=476&amp;originHeight=476&amp;originWidth=771&amp;status=done&amp;style=none&amp;width=771" alt="img" style="zoom:50%;" />

<h4 id="区域图-area"><a href="#区域图-area" class="headerlink" title="区域图 area"></a>区域图 area</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">线和 x 轴包围而成的面积使用颜色或者纹理填充</span><br><span class="line">chart.area()</span><br></pre></td></tr></table></figure>

<h4 id="区间图-interval"><a href="#区间图-interval" class="headerlink" title="区间图 interval"></a>区间图 interval</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">分类字段映射到 x 轴的位置， y 是个区间值，默认最小值是 <span class="number">0</span></span><br><span class="line">chart.interval()</span><br></pre></td></tr></table></figure>

<h4 id="多边形-polygon"><a href="#多边形-polygon" class="headerlink" title="多边形 polygon"></a>多边形 polygon</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chart.polygon()</span><br></pre></td></tr></table></figure>

<h4 id="自定义图-schema"><a href="#自定义图-schema" class="headerlink" title="自定义图 schema"></a>自定义图 schema</h4><h3 id="图形元素"><a href="#图形元素" class="headerlink" title="图形元素"></a>图形元素</h3><p>Element 即一条/一组数据对应的图形元素，它代表一条数据或者一个数据集</p>
<p>职责：绘制、更新、销毁 Shape &amp; 状态管理</p>
<p> <img src="https://gw.alipayobjects.com/zos/antfincdn/hT2K%24T1lnH/element-intro-1.png" alt="element" style="zoom:33%;" />  <img src="https://gw.alipayobjects.com/zos/antfincdn/Dtxo%26Fd6fm/element-intro-2.png" alt="element" style="zoom: 25%;" /> </p>
<p>Element 主要职责如下：</p>
<ul>
<li>绘制 Shape</li>
<li>更新 Shape，当对应的 Element 数据发生更新时，更新对应的 shape（而不是销毁再创建）</li>
<li>销毁 Shape</li>
<li>Shape 状态管理</li>
</ul>
<p>G2 默认提供了三种图形状态：active、selected 以及 inactive，对于 Element 来说这三种状态都是相互独立的，即用户开启了 active 状态之后又开启了 selected 状态，element 就会在 active 的状态上叠加 selected 状态，交互状态之间的关联全部交由具体的交互行为负责，所以我们除了提供 <code>setState()</code> 方法外，还会提供 <code>clearState()</code> <code>hasState()</code> 方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">element.setState(<span class="string">&#x27;active&#x27;</span>, <span class="literal">true</span>); <span class="comment">// 开启 active 状态</span></span><br></pre></td></tr></table></figure>

<h3 id="Element-相关操作"><a href="#Element-相关操作" class="headerlink" title="Element 相关操作"></a>Element 相关操作</h3><ol>
<li>如何获取 Element 实例</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 Interval</span></span><br><span class="line"><span class="keyword">const</span> interval = chart.interval().position(<span class="string">&#x27;x*y&#x27;</span>);</span><br><span class="line"></span><br><span class="line">chart.render();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Interval 下的 Element 实例</span></span><br><span class="line"><span class="keyword">const</span> elements = interval.elements;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据特定的条件查找 Element 实例</span></span><br><span class="line"><span class="keyword">const</span> someElements = interval.getElementsBy(<span class="function">(<span class="params">element</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = element.getData();</span><br><span class="line">  <span class="keyword">return</span> data.x === <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>通过 Element 操纵图形状态</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> interval = chart.interval().position(<span class="string">&#x27;x*y&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 Interval 的第一个 Element 实例设置为 active 状态</span></span><br><span class="line">interval.elements[<span class="number">0</span>].setState(<span class="string">&#x27;active&#x27;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<ol>
<li>修改 Element 图形元素的状态样式</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">chart</span><br><span class="line">  .interval()</span><br><span class="line">  .position(<span class="string">&#x27;x*y&#x27;</span>)</span><br><span class="line">  .state(&#123;</span><br><span class="line">    <span class="attr">active</span>: &#123;</span><br><span class="line">      <span class="attr">style</span>: &#123;</span><br><span class="line">        <span class="attr">lineWidth</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">stroke</span>: <span class="string">&#x27;#000&#x27;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="View-视图"><a href="#View-视图" class="headerlink" title="View 视图"></a>View 视图</h3><p>G2 的 View 是图层容器的概念，每一个 View 拥有自己独立的数据源、坐标系、几何标记、Tooltip 以及图例，可以理解 View 是整个 G2 体系中，用来组装数据，Component，Geometry 的容器。 一个 View 可以包含有多个子 View，通过这种嵌套关系，可以将一个画布按照不同的布局划分多个不同区域（分面），也可以将不同数据源的多个 View 叠加到一起，形成一个多数据源，多图层的图表。</p>
<h4 id="如何创建视图"><a href="#如何创建视图" class="headerlink" title="如何创建视图"></a>如何创建视图</h4><p>直接通过调用 <code>chart.createview()</code> 即可创建 View 对象，此时会默认创建一个绘图区域于 Chart 相同的视图，当然你可以通过 <code>region</code> 属性指定 view 的绘图区域。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Chart &#125; <span class="keyword">from</span> <span class="string">&#x27;@antv/g2&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1: 需要创建 chart 对象</span></span><br><span class="line"><span class="keyword">const</span> chart = <span class="keyword">new</span> Chart(&#123;</span><br><span class="line">  <span class="attr">container</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">  <span class="attr">autoFit</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">width</span>: <span class="number">1000</span>,</span><br><span class="line">  <span class="attr">height</span>: <span class="number">500</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2: 然后创建一个视图</span></span><br><span class="line"><span class="keyword">const</span> view = chart.createView(&#123;</span><br><span class="line">  <span class="attr">region</span>: &#123;</span><br><span class="line">    <span class="attr">start</span>: &#123; <span class="attr">x</span>: <span class="number">0.2</span>, <span class="attr">y</span>: <span class="number">0.2</span> &#125;, <span class="comment">// 指定该视图绘制的起始位置，x y 为 [0 - 1] 范围的数据</span></span><br><span class="line">    <span class="attr">end</span>: &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;, <span class="comment">// 指定该视图绘制的结束位置，x y 为 [0 - 1] 范围的数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">padding</span>: [<span class="number">20</span>, <span class="number">40</span>], <span class="comment">// 指定视图的留白</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="多-View-划分画布"><a href="#多-View-划分画布" class="headerlink" title="多 View 划分画布"></a>多 View 划分画布</h4><p>在看股票涨跌情况的时候</p>
<ol>
<li>一方面会使用专业的 k 线图去展示股票涨跌信息；</li>
<li>另一方面，我们也可以使用一个简单的柱形图，显示绝对的涨跌情况，并根据柱子的红绿颜色标记涨跌。</li>
</ol>
<p>这种情况，就使用两个 View 并排显示，去显示不同的图形，具体如下 demo：</p>
<p> <img src="data:image/png;base64,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" alt="img"> </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> DataSet <span class="keyword">from</span> <span class="string">&#x27;@antv/data-set&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Chart &#125; <span class="keyword">from</span> <span class="string">&#x27;@antv/g2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">fetch(<span class="string">&#x27;https://gw.alipayobjects.com/os/antvdemo/assets/data/candle-sticks.json&#x27;</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置状态量，时间格式建议转换为时间戳，转换为时间戳时请注意区间</span></span><br><span class="line">    <span class="keyword">const</span> ds = <span class="keyword">new</span> DataSet();</span><br><span class="line">    <span class="keyword">const</span> dv = ds.createView();</span><br><span class="line">    dv.source(data)</span><br><span class="line">      .transform(&#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;map&#x27;</span>,</span><br><span class="line">        <span class="attr">callback</span>: <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">          obj.trend = (obj.start &lt;= obj.end) ? <span class="string">&#x27;上涨&#x27;</span> : <span class="string">&#x27;下跌&#x27;</span>;</span><br><span class="line">          obj.range = [obj.start, obj.end, obj.max, obj.min];</span><br><span class="line">          <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">const</span> chart = <span class="keyword">new</span> Chart(&#123;</span><br><span class="line">      <span class="attr">container</span>: <span class="string">&#x27;container&#x27;</span>,</span><br><span class="line">      <span class="attr">autoFit</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">height</span>: <span class="number">400</span>,</span><br><span class="line">      <span class="attr">padding</span>: [<span class="number">10</span>, <span class="number">40</span>, <span class="number">40</span>, <span class="number">40</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">    chart.scale(&#123;</span><br><span class="line">      <span class="attr">time</span>: &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;timeCat&#x27;</span>,</span><br><span class="line">        <span class="attr">range</span>: [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        <span class="attr">tickCount</span>: <span class="number">4</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">trend</span>: &#123;</span><br><span class="line">        <span class="attr">values</span>: [<span class="string">&#x27;上涨&#x27;</span>, <span class="string">&#x27;下跌&#x27;</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">volumn</span>: &#123; <span class="attr">alias</span>: <span class="string">&#x27;成交量&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">start</span>: &#123; <span class="attr">alias</span>: <span class="string">&#x27;开盘价&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">end</span>: &#123; <span class="attr">alias</span>: <span class="string">&#x27;收盘价&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">max</span>: &#123; <span class="attr">alias</span>: <span class="string">&#x27;最高价&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">min</span>: &#123; <span class="attr">alias</span>: <span class="string">&#x27;最低价&#x27;</span> &#125;,</span><br><span class="line">      <span class="attr">range</span>: &#123; <span class="attr">alias</span>: <span class="string">&#x27;股票价格&#x27;</span> &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    chart.tooltip(&#123;</span><br><span class="line">      <span class="attr">showTitle</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">showMarkers</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">itemTpl</span>: <span class="string">&#x27;&lt;li class=&quot;g2-tooltip-list-item&quot; data-index=&#123;index&#125;&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&lt;span style=&quot;background-color:&#123;color&#125;;&quot; class=&quot;g2-tooltip-marker&quot;&gt;&lt;/span&gt;&#x27;</span></span><br><span class="line">        + <span class="string">&#x27;&#123;name&#125;&#123;value&#125;&lt;/li&gt;&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> kView = chart.createView(&#123;</span><br><span class="line">      <span class="attr">region</span>: &#123;</span><br><span class="line">        <span class="attr">start</span>: &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0</span> &#125;,</span><br><span class="line">        <span class="attr">end</span>: &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">0.7</span> &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    kView.data(dv.rows);</span><br><span class="line">    kView.schema()</span><br><span class="line">      .position(<span class="string">&#x27;time*range&#x27;</span>)</span><br><span class="line">      .color(<span class="string">&#x27;trend&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;上涨&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;#f04864&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;下跌&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;#2fc25b&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .shape(<span class="string">&#x27;candle&#x27;</span>)</span><br><span class="line">      .tooltip(<span class="string">&#x27;time*start*end*max*min&#x27;</span>, <span class="function">(<span class="params">time, start, end, max, min</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">name</span>: time,</span><br><span class="line">          <span class="attr">value</span>: <span class="string">&#x27;&lt;br&gt;&lt;span style=&quot;padding-left: 16px&quot;&gt;开盘价：&#x27;</span> + start + <span class="string">&#x27;&lt;/span&gt;&lt;br/&gt;&#x27;</span></span><br><span class="line">            + <span class="string">&#x27;&lt;span style=&quot;padding-left: 16px&quot;&gt;收盘价：&#x27;</span> + end + <span class="string">&#x27;&lt;/span&gt;&lt;br/&gt;&#x27;</span></span><br><span class="line">            + <span class="string">&#x27;&lt;span style=&quot;padding-left: 16px&quot;&gt;最高价：&#x27;</span> + max + <span class="string">&#x27;&lt;/span&gt;&lt;br/&gt;&#x27;</span></span><br><span class="line">            + <span class="string">&#x27;&lt;span style=&quot;padding-left: 16px&quot;&gt;最低价：&#x27;</span> + min + <span class="string">&#x27;&lt;/span&gt;&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> barView = chart.createView(&#123;</span><br><span class="line">      <span class="attr">region</span>: &#123;</span><br><span class="line">        <span class="attr">start</span>: &#123; <span class="attr">x</span>: <span class="number">0</span>, <span class="attr">y</span>: <span class="number">0.7</span> &#125;,</span><br><span class="line">        <span class="attr">end</span>: &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">1</span> &#125;,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    barView.data(dv.rows);</span><br><span class="line">    barView.scale(<span class="string">&#x27;volumn&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">tickCount</span>: <span class="number">2</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    barView.axis(<span class="string">&#x27;time&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">tickLine</span>: <span class="literal">null</span>,</span><br><span class="line">      <span class="attr">label</span>: <span class="literal">null</span></span><br><span class="line">    &#125;);</span><br><span class="line">    barView.axis(<span class="string">&#x27;volumn&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">label</span>: &#123;</span><br><span class="line">        <span class="attr">formatter</span>: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> +val / <span class="number">1000</span> + <span class="string">&#x27;k&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    barView.interval()</span><br><span class="line">      .position(<span class="string">&#x27;time*volumn&#x27;</span>)</span><br><span class="line">      .color(<span class="string">&#x27;trend&#x27;</span>, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;上涨&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;#f04864&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (val === <span class="string">&#x27;下跌&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">&#x27;#2fc25b&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .tooltip(<span class="string">&#x27;time*volumn&#x27;</span>, <span class="function">(<span class="params">time, volumn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          <span class="attr">name</span>: time,</span><br><span class="line">          <span class="attr">value</span>: <span class="string">&#x27;&lt;br/&gt;&lt;span style=&quot;padding-left: 16px&quot;&gt;成交量：&#x27;</span> + volumn + <span class="string">&#x27;&lt;/span&gt;&lt;br/&gt;&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    chart.render();</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><a href="https://g2.antv.vision/zh/docs/api/general/chart#chart-api">https://g2.antv.vision/zh/docs/api/general/chart#chart-api</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chart.clear(); // 清理所有</span><br><span class="line">chart.source(newData); // 重新加载数据</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="图表-echarts"><a href="#图表-echarts" class="headerlink" title="图表:echarts"></a>图表:echarts</h1><p><strong>版本5</strong></p>
<p>ECharts，一个使用 <strong>JavaScript 实现的开源可视化库</strong>，可以流畅的运行在 PC 和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库 <a href="https://gitee.com/link?target=https://github.com/ecomfe/zrender">ZRender</a>，提供直观，交互丰富，可高度个性化定制的数据可视化图表。</p>
<h2 id="图表容器及大小"><a href="#图表容器及大小" class="headerlink" title="图表容器及大小"></a>图表容器及大小</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>echarts.init</p>
<ul>
<li><p>在 HTML 中定义有宽度和高度的父容器（推荐）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;main&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>指定图表的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div id=&quot;main&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  var myChart = echarts.init(document.getElementById(&#x27;main&#x27;), null, &#123;</span><br><span class="line">    width: 600,</span><br><span class="line">    height: 400</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="监听容器大小并改变图表大小"><a href="#监听容器大小并改变图表大小" class="headerlink" title="监听容器大小并改变图表大小"></a>监听容器大小并改变图表大小</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));</span><br><span class="line">window.onresize = function() &#123;</span><br><span class="line">	myChart.resize();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//改变图表大小</span><br><span class="line">myChart.resize(&#123;</span><br><span class="line">  width: 800,</span><br><span class="line">  height: 400</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="颜色主题（Theme）"><a href="#颜色主题（Theme）" class="headerlink" title="颜色主题（Theme）"></a>颜色主题（Theme）</h3><p>最简单的更改全局样式的方式，是直接采用颜色主题（theme）。例如，在 <a href="https://echarts.apache.org/examples">示例集合</a> 中，可以通过切换深色模式，直接看到采用主题的效果。</p>
<p>ECharts5 除了一贯的默认主题外，还内置了<code>&#39;dark&#39;</code>主题。可以像这样切换成深色模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> chart = echarts.init(dom, <span class="string">&#x27;dark&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>其他的主题，没有内置在 ECharts 中，需要自己加载。这些主题可以在 <a href="https://echarts.apache.org/theme-builder.html">主题编辑器</a> 里访问到。也可以使用这个主题编辑器，自己编辑主题。下载下来的主题可以这样使用：</p>
<p>如果主题保存为 JSON 文件，则需要自行加载和注册，例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设主题名称是 &quot;vintage&quot;</span></span><br><span class="line">$.getJSON(<span class="string">&#x27;xxx/xxx/vintage.json&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">themeJSON</span>) </span>&#123;</span><br><span class="line">  echarts.registerTheme(<span class="string">&#x27;vintage&#x27;</span>, <span class="built_in">JSON</span>.parse(themeJSON));</span><br><span class="line">  <span class="keyword">var</span> chart = echarts.init(dom, <span class="string">&#x27;vintage&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>如果保存为 UMD 格式的 JS 文件，文件内部已经做了自注册，直接引入 JS 即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// HTML 引入 vintage.js 文件后（假设主题名称是 &quot;vintage&quot;）</span></span><br><span class="line"><span class="keyword">var</span> chart = echarts.init(dom, <span class="string">&#x27;vintage&#x27;</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h2 id="坐标轴"><a href="#坐标轴" class="headerlink" title="坐标轴"></a>坐标轴</h2><h3 id="x-轴、y-轴"><a href="#x-轴、y-轴" class="headerlink" title="x 轴、y 轴"></a>x 轴、y 轴</h3><p>x 轴和 y 轴都由<strong>轴线、刻度、刻度标签、轴标题</strong>四个部分组成。</p>
<p><img src="https://echarts.apache.org/handbook/images/design/axis/charts_axis_img02.jpg" alt="img"></p>
<p>普通的二维数据坐标系都有 x 轴和 y 轴，通常情况下，x 轴显示在图表的底部，y 轴显示在左侧，一般配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;销售时间&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;销售数量&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当 x 轴（水平坐标轴）跨度很大，可以采用区域缩放方式灵活显示数据内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;time&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;销售时间&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;value&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;销售数量&#x27;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">dataZoom</span>: [</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  ]</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="轴线"><a href="#轴线" class="headerlink" title="轴线"></a>轴线</h3><p>ECharts 提供了轴线 <a href="https://echarts.apache.org/option.html#xAxis.axisLine">axisLine</a> 相关的配置</p>
<h3 id="刻度"><a href="#刻度" class="headerlink" title="刻度"></a>刻度</h3><p>ECharts 提供了轴线 <a href="https://echarts.apache.org/option.html#xAxis.axisTick">axisTick</a> 相关的配置</p>
<h3 id="刻度标签"><a href="#刻度标签" class="headerlink" title="刻度标签"></a>刻度标签</h3><p>ECharts 提供了轴线 <a href="https://echarts.apache.org/option.html#xAxis.axisLabel">axisLabel</a> 相关的配置</p>
<h2 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h2><p>图例是图表中对内容区元素的注释、用不同形状、颜色、文字等来标示不同数据列，通过点击对应数据列的标记，可以<strong>显示或隐藏</strong>该数据列。</p>
<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">legend</span>: &#123;</span><br><span class="line">    <span class="comment">// Try &#x27;horizontal&#x27;</span></span><br><span class="line">    <span class="attr">orient</span>: <span class="string">&#x27;vertical&#x27;</span>,</span><br><span class="line">    <span class="attr">right</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">top</span>: <span class="string">&#x27;center&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">dataset</span>: &#123;</span><br><span class="line">    <span class="attr">source</span>: [</span><br><span class="line">      [<span class="string">&#x27;product&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>],</span><br><span class="line">      [<span class="string">&#x27;Matcha Latte&#x27;</span>, <span class="number">43.3</span>, <span class="number">85.8</span>, <span class="number">93.7</span>],</span><br><span class="line">      [<span class="string">&#x27;Milk Tea&#x27;</span>, <span class="number">83.1</span>, <span class="number">73.4</span>, <span class="number">55.1</span>],</span><br><span class="line">      [<span class="string">&#x27;Cheese Cocoa&#x27;</span>, <span class="number">86.4</span>, <span class="number">65.2</span>, <span class="number">82.5</span>],</span><br><span class="line">      [<span class="string">&#x27;Walnut Brownie&#x27;</span>, <span class="number">72.4</span>, <span class="number">53.9</span>, <span class="number">39.1</span>]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xAxis</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">series</span>: [&#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,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QAABBBBAAIEmCBCaNGGKHAMCCCCAAAIIIIAAAggggAACCFgXIDSxTkpBBBBAAAEEEEAAAQQQQAABBBBoggChSROmyDEggAACCCCAAAIIIIAAAggggIB1AUIT66QURAABBBBAAAEEEEAAAQQQQACBJggQmjRhihwDAggggAACCCCAAAIIIIAAAghYFyA0sU5KQQQQQAABBBBAAAEEEEAAAQQQaIIAoUkTpsgxIIAAAggggAACCCCAAAIIIICAdQFCE+ukFEQAAQQQQAABBBBAAAEEEEAAgSYIEJo0YYocAwIIIIAAAggggAACCCCAAAIIWBcgNLFOSkEEEEAAAQQQQAABBBBAAAEEEGiCAKFJE6bIMSCAAAIIIIAAAggggAACCCCAgHUBQhPrpBREAAEEEEAAAQQQQAABBBBAAIEmCBCaNGGKHAMCCCCAAAIIIIAAAggggAACCFgXIDSxTkpBBBBAAAEEEEAAAQQQQAABBBBoggChSROmyDEggAACCCCAAAIIIIAAAggggIB1AUIT66QURAABBBBAAAEEEEAAAQQQQACBJggQmjRhihwDAggggAACCCCAAAIIIIAAAghYFyA0sU5KQQQQQAABBBBAAAEEEEAAAQQQaIIAoUkTpsgxIIAAAggggAACCCCAAAIIIICAdQFCE+ukFEQAAQQQQAABBBBAAAEEEEAAgSYIEJo0YYocAwIIIIAAAggggAACCCCAAAIIWBcgNLFOSkEEEEAAAQQQQAABBBBAAAEEEGiCAKFJE6bIMSCAAAIIIIAAAggggAACCCCAgHUBQhPrpBREAAEEEEAAAQQQQAABBBBAAIEmCBCaNGGKHAMCCCCAAAIIIIAAAggggAACCFgXIDSxTkpBBBBAAAEEEEAAAQQQQAABBBBoggChSROmyDEggAACCCCAAAIIIIAAAggggIB1AUIT66QURAABBBBAAAEEEEAAAQQQQACBJggQmjRhihwDAggggAACCCCAAAIIIIAAAghYFyA0sU5KQQQQQAABBBBAAAEEEEAAAQQQaIIAoUkTpsgxIIAAAggggAACCCCAAAIIIICAdQFCE+ukFEQAAQQQQAABBBBAAAEEEEAAgSYIEJo0YYocAwIIIIAAAggggAACCCCAAAIIWBcgNLFOSkEEEEAAAQQQQAABBBBAAAEEEGiCAKFJE6bIMSCAAAIIIIAAAggggAACCCCAgHUBQhPrpBREAAEEEEAAAQQQQAABBBBAAIEmCBCaNGGKHAMCCCCAAAIIIIAAAggggAACCFgXIDSxTkpBBBBAAAEEEEAAAQQQQAABBBBoggChSROmyDEggAACCCCAAAIIIIAAAggggIB1AUIT66QURAABBBBAAAEEEEAAAQQQQACBJggQmjRhihwDAggggAACCCCAAAIIIIAAAghYFyA0sU5KQQQQQAABBBBAAAEEEEAAAQQQaIIAoUkTpsgxIIAAAggggAACCCCAAAIIIICAdQFCE+ukFEQAAQQQQAABBBBAAAEEEEAAgSYIEJo0YYocAwIIIIAAAggggAACCCCAAAIIWBf4/wHiNDtjUcu+eQAAAABJRU5ErkJggg==" alt="img"></p>
<p>对于图例较多时，可以使用可滚动翻页的图例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">legend</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;scroll&#x27;</span>,</span><br><span class="line">    <span class="attr">orient</span>: <span class="string">&#x27;vertical&#x27;</span>,</span><br><span class="line">    <span class="attr">right</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">top</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">bottom</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;图例一&#x27;</span>, <span class="string">&#x27;图例二&#x27;</span>, <span class="string">&#x27;图例三&#x27;</span> <span class="comment">/* ... */</span>, , <span class="string">&#x27;图例n&#x27;</span>]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="样式-1"><a href="#样式-1" class="headerlink" title="样式"></a>样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">legend</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;图例一&#x27;</span>, <span class="string">&#x27;图例二&#x27;</span>, <span class="string">&#x27;图例三&#x27;</span>],</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="string">&#x27;#ccc&#x27;</span>,</span><br><span class="line">    <span class="attr">textStyle</span>: &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;#ccc&#x27;</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p>根据场景需要，图例可支持交互操作，点击控制显示或隐藏对应的数据列；</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">legend</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;图例一&#x27;</span>, <span class="string">&#x27;图例二&#x27;</span>, <span class="string">&#x27;图例三&#x27;</span>],</span><br><span class="line">    <span class="attr">selected</span>: &#123;</span><br><span class="line">      图例一: <span class="literal">true</span>,</span><br><span class="line">      图例二: <span class="literal">true</span>,</span><br><span class="line">      图例三: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="视觉映射"><a href="#视觉映射" class="headerlink" title="视觉映射"></a>视觉映射</h2><p>数据可视化简单来讲就是将数据用图表的形式来展示，专业的表达方式就是数据到视觉元素的映射过程。ECharts 的每种图表本身就内置了这种映射过程，比如折线图把数据映射到“线”，柱状图把数据映射到“长度”。</p>
<p>此外，ECharts 还提供了 <a href="https://echarts.apache.org/option.html#visualMap">visualMap 组件</a> 来提供通用的视觉映射。<code>visualMap</code> 组件中可以使用的视觉元素有：</p>
<ul>
<li>图形类别（symbol）、图形大小（symbolSize）</li>
<li>颜色（color）、透明度（opacity）、颜色透明度（colorAlpha）、</li>
<li>颜色明暗度（colorLightness）、颜色饱和度（colorSaturation）、色调（colorHue）</li>
</ul>
<h3 id="数据和维度"><a href="#数据和维度" class="headerlink" title="数据和维度"></a>数据和维度</h3><p>ECharts 中的数据，一般存放于 <a href="https://echarts.apache.org/option.html#series.data"><code>series.data</code></a> 中。</p>
<p>不同的图表类型，数据格式有所不一样，但是他们的共同特点就都是数据项（dataItem） 的集合。每个数据项含有 数据值（value） 和其他信息（可选）。每个数据值，可以是单一的数值（一维）或者一个数组（多维）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线性表</span></span><br><span class="line"><span class="attr">series</span>: &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">        &#123;       <span class="comment">// 这里每一个项就是数据项（dataItem）</span></span><br><span class="line">            <span class="attr">value</span>: <span class="number">2323</span>, <span class="comment">// 这是数据项的数据值（value）</span></span><br><span class="line">            <span class="attr">itemStyle</span>: &#123;...&#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="number">1212</span>,   <span class="comment">// 也可以直接是 dataItem 的 value，这更常见。</span></span><br><span class="line">        <span class="number">2323</span>,   <span class="comment">// 每个 value 都是『一维』的。</span></span><br><span class="line">        <span class="number">4343</span>,</span><br><span class="line">        <span class="number">3434</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="visualMap-组件"><a href="#visualMap-组件" class="headerlink" title="visualMap 组件"></a>visualMap 组件</h3><p>visualMap 组件定义了把数据的指定维度映射到对应的视觉元素上。</p>
<p>visualMap 组件可以定义多个，从而可以同时对数据中的多个维度进行视觉映射。</p>
<p>ECharts 的视觉映射组件分为连续型（<a href="https://echarts.apache.org/option.html#visualMap-continuous">visualMapContinuous</a>）与分段型（<a href="https://echarts.apache.org/option.html#visualMap-piecewise">visualMapPiecewise</a>）。</p>
<p>连续型的意思是，进行视觉映射的数据维度是连续的数值；而分段型则是数据被分成了多段或者是离散型的数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    visualMap: [</span><br><span class="line">        &#123; // 第一个 visualMap 组件</span><br><span class="line">            type: &#x27;continuous&#x27;, // 定义为连续型 visualMap</span><br><span class="line">            ...</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123; // 第二个 visualMap 组件</span><br><span class="line">            type: &#x27;piecewise&#x27;, // 定义为分段型 visualMap</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="连续型视觉映射"><a href="#连续型视觉映射" class="headerlink" title="连续型视觉映射"></a>连续型视觉映射</h4><p>连续型视觉映射通过指定最大值、最小值，就可以确定视觉映射的范围。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">visualMap</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;continuous&#x27;</span>,</span><br><span class="line">      <span class="attr">min</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">max</span>: <span class="number">5000</span>,</span><br><span class="line">      <span class="attr">dimension</span>: <span class="number">3</span>, <span class="comment">// series.data 的第四个维度（即 value[3]）被映射</span></span><br><span class="line">      <span class="attr">seriesIndex</span>: <span class="number">4</span>, <span class="comment">// 对第四个系列进行映射。</span></span><br><span class="line">      <span class="attr">inRange</span>: &#123;</span><br><span class="line">        <span class="comment">// 选中范围中的视觉配置</span></span><br><span class="line">        <span class="attr">color</span>: [<span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;#121122&#x27;</span>, <span class="string">&#x27;red&#x27;</span>], <span class="comment">// 定义了图形颜色映射的颜色列表，</span></span><br><span class="line">        <span class="comment">// 数据最小值映射到&#x27;blue&#x27;上，</span></span><br><span class="line">        <span class="comment">// 最大值映射到&#x27;red&#x27;上，</span></span><br><span class="line">        <span class="comment">// 其余自动线性计算。</span></span><br><span class="line">        <span class="attr">symbolSize</span>: [<span class="number">30</span>, <span class="number">100</span>] <span class="comment">// 定义了图形尺寸的映射范围，</span></span><br><span class="line">        <span class="comment">// 数据最小值映射到30上，</span></span><br><span class="line">        <span class="comment">// 最大值映射到100上，</span></span><br><span class="line">        <span class="comment">// 其余自动线性计算。</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">outOfRange</span>: &#123;</span><br><span class="line">        <span class="comment">// 选中范围外的视觉配置</span></span><br><span class="line">        <span class="attr">symbolSize</span>: [<span class="number">30</span>, <span class="number">100</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    ...</span></span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>其中，<a href="https://echarts.apache.org/option.html#visualMap.inRange">visualMap.inRange</a> 表示在数据映射范围内的数据采用的样式；而 <a href="https://echarts.apache.org/option.html#visualMap.outOfRange">visualMap.outOfRange</a> 则指定了超出映射范围外的数据的样式。</p>
<p><a href="https://echarts.apache.org/handbook/~visualMap.dimension">visualMap.dimension</a> 则指定了将数据的哪个维度做视觉映射。</p>
<h4 id="分段型视觉映射"><a href="#分段型视觉映射" class="headerlink" title="分段型视觉映射"></a>分段型视觉映射</h4><p>分段型视觉映射组件有三种模式：</p>
<ul>
<li>连续型数据平均分段：依据 <a href="https://echarts.apache.org/option.html#visualMap-piecewise.splitNumber">visualMap-piecewise.splitNumber</a> 来自动平均分割成若干块。</li>
<li>连续型数据自定义分段：依据 <a href="https://echarts.apache.org/option.html#visualMap-piecewise.pieces">visualMap-piecewise.pieces</a> 来定义每块范围。</li>
<li>离散数据（类别性数据）：类别定义在 <a href="https://echarts.apache.org/option.html#visualMap-piecewise.categories">visualMap-piecewise.categories</a> 中。</li>
</ul>
<p>使用分段型视觉映射时，需要将 <code>type</code> 设为 <code>&#39;piecewise&#39;</code>，并且将上面的三个配置项选其一配置即可，其他配置项类似连续型视觉映射。</p>
<h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p><a href="https://juejin.cn/post/6844903552108724238#heading-0">https://juejin.cn/post/6844903552108724238#heading-0</a></p>
<p><a href="https://www.runoob.com/echarts/echarts-dataset.html">https://www.runoob.com/echarts/echarts-dataset.html</a></p>
<p><code>数据集</code>（<code>dataset</code>）来单独声明数据。虽然每个系列都可以在 <code>series.data</code> 中设置数据，但是从 ECharts4 支持 <code>数据集</code> 开始，更推荐使用 <code>数据集</code> 来管理数据。</p>
<p>数据集带来的好处是：</p>
<ul>
<li>能够贴近数据可视化常见思维方式：（I）提供数据，（II）指定数据到视觉的映射，从而形成图表。</li>
<li>数据和其他配置可以被分离开来。数据常变，其他配置常不变。分开易于分别管理。</li>
<li>数据可以被多个系列或者组件复用，对于大数据量的场景，不必为每个系列创建一份数据。</li>
<li>支持更多的数据的常用格式，例如二维数组、对象数组等，一定程度上避免使用者为了数据格式而进行转换。</li>
</ul>
<h3 id="设置数据"><a href="#设置数据" class="headerlink" title="设置数据"></a>设置数据</h3><h4 id="在系列中设置数据"><a href="#在系列中设置数据" class="headerlink" title="在系列中设置数据"></a><strong>在系列中设置数据</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: [<span class="string">&#x27;Matcha Latte&#x27;</span>, <span class="string">&#x27;Milk Tea&#x27;</span>, <span class="string">&#x27;Cheese Cocoa&#x27;</span>, <span class="string">&#x27;Walnut Brownie&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;2015&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">89.3</span>, <span class="number">92.1</span>, <span class="number">94.4</span>, <span class="number">85.4</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;2016&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">95.8</span>, <span class="number">89.4</span>, <span class="number">91.2</span>, <span class="number">76.9</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;2017&#x27;</span>,</span><br><span class="line">      <span class="attr">data</span>: [<span class="number">97.7</span>, <span class="number">83.1</span>, <span class="number">92.5</span>, <span class="number">78.1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方式的优点是，适于对一些特殊的数据结构（如“树”、“图”、超大数据）进行一定的数据类型定制。 但是缺点是，常需要用户先处理数据，把数据分割设置到各个系列（和类目轴）中。此外，不利于多个系列共享一份数据，也不利于基于原始数据进行图表类型、系列的映射安排。</p>
<h4 id="在数据集中设置数据"><a href="#在数据集中设置数据" class="headerlink" title="在数据集中设置数据"></a><strong>在数据集中设置数据</strong></h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//dataset</span></span><br><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">legend</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">tooltip</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">dataset</span>: &#123;</span><br><span class="line">    <span class="comment">// 提供一份数据。</span></span><br><span class="line">    <span class="attr">source</span>: [</span><br><span class="line">      [<span class="string">&#x27;product&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>],</span><br><span class="line">      [<span class="string">&#x27;Matcha Latte&#x27;</span>, <span class="number">43.3</span>, <span class="number">85.8</span>, <span class="number">93.7</span>],</span><br><span class="line">      [<span class="string">&#x27;Milk Tea&#x27;</span>, <span class="number">83.1</span>, <span class="number">73.4</span>, <span class="number">55.1</span>],</span><br><span class="line">      [<span class="string">&#x27;Cheese Cocoa&#x27;</span>, <span class="number">86.4</span>, <span class="number">65.2</span>, <span class="number">82.5</span>],</span><br><span class="line">      [<span class="string">&#x27;Walnut Brownie&#x27;</span>, <span class="number">72.4</span>, <span class="number">53.9</span>, <span class="number">39.1</span>]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 声明一个 X 轴，类目轴（category）。默认情况下，类目轴对应到 dataset 第一列。</span></span><br><span class="line">  <span class="attr">xAxis</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span> &#125;,</span><br><span class="line">  <span class="comment">// 声明一个 Y 轴，数值轴。</span></span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">// 声明多个 bar 系列，默认情况下，每个系列会自动对应到 dataset 的每一列。</span></span><br><span class="line">  <span class="attr">series</span>: [&#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种或者也可以使用常见的“对象数组”的格式：</span></span><br><span class="line">option = &#123;</span><br><span class="line">  <span class="attr">legend</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">tooltip</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">dataset</span>: &#123;</span><br><span class="line">    <span class="comment">// 用 dimensions 指定了维度的顺序。直角坐标系中，如果 X 轴 type 为 category，</span></span><br><span class="line">    <span class="comment">// 默认把第一个维度映射到 X 轴上，后面维度映射到 Y 轴上。</span></span><br><span class="line">    <span class="comment">// 如果不指定 dimensions，也可以通过指定 series.encode</span></span><br><span class="line">    <span class="comment">// 完成映射，参见后文。</span></span><br><span class="line">    <span class="attr">dimensions</span>: [<span class="string">&#x27;product&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>, <span class="string">&#x27;2016&#x27;</span>, <span class="string">&#x27;2017&#x27;</span>],</span><br><span class="line">    <span class="attr">source</span>: [</span><br><span class="line">      &#123; <span class="attr">product</span>: <span class="string">&#x27;Matcha Latte&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>: <span class="number">43.3</span>, <span class="string">&#x27;2016&#x27;</span>: <span class="number">85.8</span>, <span class="string">&#x27;2017&#x27;</span>: <span class="number">93.7</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">product</span>: <span class="string">&#x27;Milk Tea&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>: <span class="number">83.1</span>, <span class="string">&#x27;2016&#x27;</span>: <span class="number">73.4</span>, <span class="string">&#x27;2017&#x27;</span>: <span class="number">55.1</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">product</span>: <span class="string">&#x27;Cheese Cocoa&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>: <span class="number">86.4</span>, <span class="string">&#x27;2016&#x27;</span>: <span class="number">65.2</span>, <span class="string">&#x27;2017&#x27;</span>: <span class="number">82.5</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">product</span>: <span class="string">&#x27;Walnut Brownie&#x27;</span>, <span class="string">&#x27;2015&#x27;</span>: <span class="number">72.4</span>, <span class="string">&#x27;2016&#x27;</span>: <span class="number">53.9</span>, <span class="string">&#x27;2017&#x27;</span>: <span class="number">39.1</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xAxis</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">series</span>: [&#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span> &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABE0AAAHCCAYAAAAaQTeLAAAAAXNSR0IArs4c6QAAIABJREFUeF7t3X+wXXV97//POokkVhKIkR+SwPijBZHrbWeqgoljraVoubbekXDJ7Q9v/dJ7O/YaDuFev5DRQqBlwr1XSQ6njNP6a6a9+g1fQkdHRbhSax2JoNDpfK2idBQHiCgpJkaQBMhZ39nJWYedffbe69f79fmx9tO/MPvzeX8+6/Fe5+x9XmetdTLH/xBAAAEEEEAAAQQQQAABBBBAAAEEFglkmCCAAAIIIIAAAggggAACCCCAAAIILBYgNOGsQAABBBBAAAEEEEAAAQQQQAABBIYIEJpwWiCAAAIIIIAAAggggAACCCCAAAKEJpwDCCCAAAIIIIAAAggggAACCCCAQDUBrjSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCk2pOjEIAAQQQQAABBBBAAAEEEEAAgQkTIDSZsIZzuAgggAACCCCAAAIIIIAAAgggUE2A0KSaE6MQQAABBBBAAAEEEEAAAQQQQGDCBAhNJqzhHC4CCCCAAAIIIIAAAggggAACCFQTIDSp5sQoBBBAAAEEEEAAAQQQQAABBBCYMAFCkwlrOIeLAAIIIIAAAggggAACCCCAAALVBAhNqjkxCgEEEEAAAQQQQAABBBBAAAEEJkyA0GTCGs7hIoAAAggggAACCCCAAAIIIIBANQFCkzFO09Nbzs0zd2eW55fOzNxw27Chmy7fsjNz7pLitTx318zObLtucGxRyzl3wvxrDy/JptZt3379nmqtYhQCCCCAAAIIIIAAAggggAACCPgUIDQZoj0YcGR5vmFYaDIfmLyhCD+mp6+6KM+yXYPBSVEvz92NvUBl06atK6eWHLo9d+50ghOfpztrIYAAAggggAACCCCAAAIIIFBdgNBkwKoXhEw5t3bu8LIL3dShy7PMXTssNCkCksHX5oOUt2W5e+vMzLZ7i4Ckt0yv5uzs1gO9/14IUpy7Y3bHto3VW8ZIBBBAAAEEEEAAAQQQQAABBBDwIUBoMkZ50/SWq0eFJoNXmRRlBq82GbzKpBjH1SY+Tm/WQAABBBBAAAEEEEAAAQQQQKC5AKFJg9Bk8+b3rzmcz+3Onfva4FUig1eQzAcvVxRXnvQvN3hVSvM2MhMBBBBAAAEEEEAAAQQQQAABBKwFCE0ahCbjbq0pApXMuUeO3OKz5NBfZc4t3K5zTGgy5koW60ZTDwEEEEAAAQQQQAABBBBAAAEE6gkQmrQJTeYf7NpfYkRosvCwWEKTeicooxFAAAEEEEAAAQQQQAABBBAIJUBoQmgS6txjXQQQQAABBBBAAAEEEEAAAQSiFiA0aROaDPnLN4PPOxn33JJxzzuJ+qxhcwgggAACCCCAAAIIIIAAAghMgAChSYPQZNyDYBeFJkefWzL8QbBjXis7937w2IE9Ls9PKxvH6wgggAACCCCAAAIIIIAAAoEFsuyHL3vpyjWBd8HyDQQITRqEJsWfC+5N7T3sdXZ264GiTPEnh7M83zAzc8Ntg/+/GDeuRpU+PrRn39Yq4xiDAAIIIIAAAggggAACCCAQXuDla1bxM1z4NtTeAaFJg9CkN2XUrTXzt+MsPPh11FUpC3+BZ8jDZGt3kQkIIIAAAggggAACCCCAAAIIIGAuQGjSNDTZtHXl1JJDt+fOnb4km1q3ffv1e0ZdVVL8e567a2Zntl3X9ioT87OAgggggAACCCCAAAIIIIAAAgggsEiA0KRhaNKbVoQfuXPr58v8NMvdW2dmtt07WLYITop/z527ZXbHto2ckwgggAACCCCAAAIIIIAAAgggEKcAoUmcfWFXCMgFDt59ySvli3hYYPn6W77nYRmWQAABBBBAAAEEEEAAgQkUIDSZwKZzyAj0BJ69Z+MjuXNrE9d45rjzdi5L/BjYPgIIIIAAAggggAACCEQqQGgSaWPYFgJqAUITtTD1EUAAAQQQQAABBBBAIHUBQpPUO8j+EWgoQGjSEI5pCCCAAAIIIIAAAgggMDEChCYT02oOFIFjBQhNOCMQQAABBBBAAAEEEEAAgfEChCacIQjMC8x8430XdgFjzi35zubX3fD9smMhNCkT4nUEEEAAAQQQQAABBBCYdAFCk0k/Azj+BYGZ+9/3RZe781MnmcuXvJLQJPUusn8EEEAAAQQQQAABBBCIQYDQJIYusIcoBAhNomhD3U3w13PqijEeAQQQQAABBBBAAAEEKgsQmlSmYmDXBQhNkuwwoUmSbWPTCCCAAAIIIIAAAgikIUBokkaf2KUHAUITD8j2SxCa2JtSEYHOC1y8efdr8jn3P5M/0Mwd2rVj3b9P/jg4AAQQQAABBCIWIDSJuDlsza8AoYlfb6PVCE2MICmDwCQJHAlNcvf/deCYP0No0oEucggIIIAAAlELEJpE3R4251OA0MSnttlahCZmlBRCYHIECE0mp9ccKQIIIIAAAm0FCE3aCjK/MwKEJkm2ktAkybaxaQTCChCahPVndQQQQAABBFISIDRJqVvsVSpAaCLlVRUnNFHJUheBDgsQmnS4uRwaAggggAACxgKEJsaglEtXgNAkyd4RmiTZNjaNQFgBQpOw/urVD+2+5OpsKnu3eh19/fy648675RP6dVgBAQQQQGCcAKEJ5wcC8wKEJkmeCp0JTTZcdve73VS2Jcku9G06z+f+920zb7wu9eNg/90WIDTpdn/nQ5Nr0z/K/P8iNEm/ixwBAgikL0Bokn4POQIjAUITI0i/ZboWmnzcL5/9ank+dw2hib0rFW0FCE1sPWOrRmgSW0fYDwIIIJC2AKFJ2v1j94YChCaGmP5KEZr4s660EqFJJSYGBRaYtNBk5v7//h+cy84LzN56+SzPnrnstf/zqrJChCZlQryOAAIIIFBHgNCkjhZjOy1AaJJkewlNImsboUlkDWE7QwUmMjTJs1tSPx0yl/0PQpPUu8j+EUAAgfQECE3S6xk7FgkQmohgtWUJTbS+tasTmtQmY0IAAUKTAOgGSxKaGCBSAgEEEECgtgChSW0yJnRVgNAkyc4SmkTWNkKTyBrCdoYKEJqkeWIQmqTZN3aNAAIIpC5AaJJ6B9m/mQChiRmlz0KEJj61K6xFaFIBiSHBBQhNgreg0QYITRqxMQkBBBBAoKUAoUlLwC5Pv3jz7tk8z16Z+jFmbu7mW3es/3zZcRCalAlF+TqhSWRtqRqa3HTf/31D7vLpyLZffztZ/p+mf/WD/2/9icwIKUBoElK/+dqEJs3tmIkAAggg0FyA0KS5XednHg1N3HtTP9DM5W8nNFncxWfv2fhI7tzaxPtLaBJZA2uGJldGtv3628nySwhN6rOFnkFoEroDzdYnNGnmxiwEEEAAgXYChCbt/Do9m9AkzfbO5Uteufl1N3y/bPeEJmVCfl/fcNnd73ZT2cf9rmq/GqGJvSkV7QUITexNfVQkNPGhzBoIIIAAAoMChCacEyMFCE3SPDkITdLsG6FJmn1zXGmSZOMITZJsmyM0SbNv7BoBBBBIXYDQJPUOCvdPaCLEFZYmNBHiCksTmghxlaUJTZS6stqEJjJaaWFCEykvxRFAAAEERggQmnBqcKXJvAAPgk3yi4FnmkTWNm7PiawhbGeoAKFJmicGoUmafWPXCCCAQOoChCapd1C4f640EeIKS3OliRBXWJorTYS4ytJcaaLUldUmNJHRSgsTmkh5KY4AAgggMEKA0IRTY6QAoUmaJwehSZp9IzRJs2880yTNvhGapNk3QpM0+8auEUAAgdQFCE1S76Bw/4QmQlxhaUITIa6wNKGJEFdZmitNlLqy2oQmMlppYUITKS/FEUAAAQS40oRzoK4AoUldsTjGE5rE0Ye6uyA0qSsWyXhCk0gaUW8bhCb1vGIZTWgSSyfYBwIIIDBZAlxpMln9rnW0hCa1uKIZTGgSTStqbYTQpBZXPIMJTeLpRY2dEJrUwIpoKKFJRM2ouZWLL9/91ZpTohx+6451b4xyY2wKAQSkAoQmUt60ixOapNk/QpM0+0ZokmbfeKZJmn0jNEmzb4Qmafatt+sNl+8+5Jw7Lt0jOLLzR3ftWHd64sfA9hFAoIEAoUkDtEmZQmiSZqcJTdLsG6FJmn0jNEmzb4QmafaN0CTNvhGapNs3do4AAkcFCE04E0YKEJqkeXIQmqTZN0KTNPtGaJJm3whN0uwboUmafSM0Sbdv7BwBBAhNOAdKBAhN0jxFCE3S7BuhSZp9IzRJs2+EJmn2jdAkzb4RmqTbN3aOAAKEJibnwKbLt+zMnLukKJbl+YaZmRtuGyw+Pb3l3DxzdzrnTph/7eEl2dS67duv32OyEUERQhMBqoeShCYekAVLEJoIUH2U5EGwPpTN1yA0MSf1UpDQxAuzZBGeaSJhpSgCCHgS4PachtCbNm1dObXk0O25c6cX4cf09FUX5Vm2K8/dNbMz264rSheBSZ67G3v/Pmxuw21IpxGaSHllxQlNZLTSwoQmUl5d8YqhybP3bPy0c+5c3Ub8VJ6bO3zBsnW3ftPParpVCE10tsrKhCZKXW1tQhOtL9URQEArQGjS0LcISAavLJm/8uQNRZBSBCS9ZeYOL7twdnbrgd5/LwQpzt0xu2PbxobbkE4jNJHyyooTmshopYUJTaS8uuI1QpPcuXfoNuKncj53+N8SmvixrrjKZ3btWPfvy8bO3P/f/4PLs1vKxsX+OqFJ7B0avT9Ck3R7x84RQIAHwTY+BzZNb7k6y9y1i0KTo/9+RZa7t87MbLt38CqTYsEUrjYhNGl8egSdSGgSlL/x4oQmjenCTiQ0CevfcHWuNGkIF3gaoUngBrRYntCkBR5TEUAguABXmjRswahbcRZdaTIQovQvNz/2bUXA0nArsmmEJjJaaWFCEymvrDihiYxWW5jQROsrqk5oIoIVlyU0EQMLyxOaCHEpjQACcgFCkxbEg6HHsFt2xgUjo65WabEl06mEJqac3ooRmnijNl2I0MSU018xQhN/1oYrEZoYYnosRWjiEdt4KUITY1DKIYCAVwFCk5bcZX89Z/DKk/7lCE1a4lecnrn87bfuWP/5suEz97/viy5355eNi/11QpPYOzR8f4Qmafat6p8c7j0IlmeaxNNjQpN4elFnJ4QmdbTiGktoElc/2A0CCNQTIDSp57UwunhWSebcPxcPeB32b4QmDYENpxGaDMd89p6Nj+TOrTWkDlHqmePO27ksxMLWaxKaWIt6qseVJp6gbZchNLH19FWN0MSXtP06hCb2plREAAF/AoQmDazHPcR18FknFW7PWXhobIOtSKdwe46UV1acK01ktNLChCZSXl1xQhOdrbAyoYkQV1ia0ESIKy5NaCIGpjwCCEgFCE0a8I77c8GbN79/zeF8bnfm3CO9K1Dc1KHL+/+aTv9y87fnNApNfvDYgT0uz09rsP3KUz5912Puq//4k8rjYx146UVnuLNfuaJ0e7uf+KTbe+ih0nGxDzj/5Pe6Fy09sXSbp+650k0d3l86LuYBuVvqHjvj5pi3WHlv3/jmPnfLF35YeXysAy9Yf5K7YP3Jpdt74MCX3INP7i4dF/uA1656p1vzwleXbvPFez/slj/9T6XjYh/w+Kl/6p47LvUL1Jx7bO9B96FPfC927tL9nfOLK92733l66bg9T3/b3bfvb0vHxT7gzOPXubNXvqV0m8fv/5xbeeCzpeNiH7B/9bvcz1+0PvZtVtrflR/8tjs8l1caG+ugE1csdR94z1mxbo99pSCQZT982UtXrklhq+zxWAFCkwZnRJ3QZGrq4G/mWbZr0Z8m3rR15dSSQ7f3li9u76mzlYf27NtaZ3yTsR/Z9fBvPfjQU69vMjemOb/95lM+9abXvfhfyvb0pX/9yz948tknXlE2LvbX169+102rj1u7r2yfp+3ZvDmbO7iybFzcr08d3nP6zX8e9x6r7e6zf//jX/nKfT95R7XR8Y765bNWfPn3f2ftP5Tt8Ov7dp3/o4MPJv/TwJnHv3HXq1a86Vtlx3vKj67fuPTZR5P/tP3ESX/y4YPLX/N42fHG/voDDz118sd3Pfye2PdZtr/TTlr23c1/+IqdZeO+87OvnPPgk1/dUDYu9tdPXX7m3a9fteGusn2u2vvRX/uFg/e/uWxc7K8/ueI3PvPTEzekn7Y656784AMfmMvdktjNx+1v+fKpA3+26aztKR8Dew8v8PI1q+Q/w4U/yu7tgNCkQU/r3J5TXHmSO/e12R3bNhbLLQQvubtxdmbbdQ22IZ/C7TlyYskC3J4jYZUX5fYcObFmAW7P0biKq3J7jhhYVJ7bc0SwHspye44HZJZAAAGZAKFJQ9phV5sUAUmv5JJsat327dfv6f33ouectLzKpOGWa08jNKlNFsUEQpMo2lB7E4QmtcnimEBoEkcfau6C0KQmWCTDCU0iaUSDbRCaNEBjCgIIRCNAaNKiFX0hyRlFmdy5W/qvKCn+vQhOysa12I75VEITc1IvBQlNvDCbL0JoYk7qpyChiR9n41UITYxBPZUjNPEELViG0ESAGknJQ7v/46si2UrrbSxb9/98p3URCnRSgNCkk221OShCExtH31UITXyL26xHaGLj6L0KoYl3cosFCU0sFP3XIDTxb261IqGJlWR8dQ7eu/HfTeXuc/HtrN6OpjL3F0vP3bmp3ixGT4oAocmkdLrBcRKaNECLYAqhSQRNaLAFQpMGaDFMITSJoQu190BoUpssigmEJlG0odEmCE0asSUxidAkiTaxyZYChCYtAbs8ndAkze4SmqTZN0KTNPvmCE2SbByhSZJtc4Qmafatt+tJCk1u/vr7Tk23U8fu/L++/n/9qOxYCE3KhHi9CwKEJl3oougYCE1EsOKyhCZiYFF5QhMRrLosoYlaWFKf0ETCKi9KaCInli0wSaHJ9m9c9Yqp7PD3ZJi+Cmfurulf/V+/WbYcoUmZEK93QYDQpAtdFB0DoYkIVlyW0EQMLCpPaCKCVZclNFELS+oTmkhY5UUJTeTEsgUITWS0usKEJjpbKicnQGiSXMv8bZjQxJ+15UqEJpaa/moRmvizNl2J0MSU01cxQhNf0rbrEJrYevqsRmjiU9toLUITI0jKdEGA0KQLXRQdA6GJCFZcltBEDCwqT2giglWXJTRRC0vqE5pIWOVFCU3kxLIFCE1ktLrChCY6WyonJ0BoklzL/G2Y0MSfteVKhCaWmv5qEZr4szZdidDElNNXMUITX9K26xCa2Hr6rEZo4lPbaC1CEyNIynRBgNCkC10UHQOhiQhWXJbQRAwsKk9oIoJVlyU0UQtL6hOaSFjlRQlN5MSyBQhNZLS6woQmOlsqJydAaJJcy/xtmNDEn7XlSoQmlpr+ahGa+LM2XYnQxJTTVzFCE1/StusQmth6+qxGaOJT22gtQhMjSMp0QYDQpAtdFB0DoYkIVlyW0EQMLCpPaCKCVZclNFELS+oTmkhY5UUJTeTEsgUITWS0usKEJjpbKicnQGiSXMv8bZjQxJ+15UqEJpaa/moRmvizNl2J0MSU01cxQhNf0rbrEJrYevqsRmjiU9toLUITI0jKdEGA0KQLXRQdA6GJCFZcltBEDCwqT2giglWXJTRRC0vqE5pIWOVFCU3kxLIFCE1ktLrChCY6WyonJ0BoklzL/G2Y0MSfteVKhCaWmv5qEZr4szZdidDElNNXMUITX9K26xCa2Hr6rEZo4lPbaC1CEyNIynRBgNCkC10UHQOhiQhWXJbQRAwsKk9oIoJVlyU0UQtL6hOaSFjlRQlN5MSyBQhNZLS6woQmOlsqJydAaJJcy/xtmNDEn7XlSoQmlpr+ahGa+LM2XYnQxJTTVzFCE1/StusQmth6+qxGaOJT22gtQhMjSMp0QYDQpAtdFB0DoYkIVlyW0EQMLCpPaCKCVZclNFELS+oTmkhY5UUJTeTEsgUITWS0usKEJjpbKicnQGiSXMv8bZjQxJ+15UqEJpaa/moRmvizNl2J0MSU01cxQhNf0rbrEJrYevqsRmjiU9toLUITI0jKdEGA0KQLXRQdA6GJCFZcltBEDCwqT2giglWXJTRRC0vqE5pIWOVFCU3kxLIFCE1ktLrChCY6WyonJ0BoklzL/G2Y0MSfteVKhCaWmv5qEZr4szZdidDElNNXMUITX9K26xCa2Hr6rEZo4lPbaC1CEyNIynRBgNCkC10UHQOhiQhWXJbQRAwsKk9oIoJVlyU0UQtL6hOaSFjlRQlN5MSyBQhNZLS6woQmOlsqJydAaJJcy/xtmNDEn7XlSoQmlpr+ahGa+LM2XYnQxJTTVzFCE1/StusQmth6+qxGaOJT22gtQhMjSMp0QYDQpAtdFB0DoYkIVlyW0EQMLCpPaCKCVZclNFELS+oTmkhY5UUJTeTEsgUITWS0usKEJjpbKicnQGiSXMv8bZjQxJ+15UqEJpaa/moRmvizNl2J0MSU01cxQhNf0rbrEJrYevqsRmjiU9toLUITI0jKdEGA0KQLXRQdA6GJCFZcltBEDCwqT2giglWXJTRRC0vqE5pIWOVFCU3kxLIFCE1ktLrChCY6WyonJ0BoklzL/G2Y0MSfteVKhCaWmv5qEZr4szZdidDElNNXMUITX9K26xCa2Hr6rEZo4lPbaC1CEyNIynRBgNCkC10UHQOhiQhWXJbQRAwsKk9oIoIa8ikMAAAgAElEQVRVlyU0UQtL6hOaSFjlRQlN5MSyBQhNZLS6woQmOlsqJydAaJJcy/xtmNDEn7XlSoQmlpr+ahGa+LM2XYnQxJTTVzFCE1/StusQmth6+qxGaOJT22gtQhMjSMp0QYDQpAtdFB0DoYkIVlyW0EQMLCpPaCKCVZclNFELS+oTmkhY5UUJTeTEsgUITWS0usKEJjpbKicnQGiSXMv8bZjQxJ+15UqEJpaa/moRmvizNl2J0MSU01cxQhNf0rbrEJrYevqsRmjiU9toLUITI0jKdEGA0KQLXRQdA6GJCFZcltBEDCwqT2giglWXJTRRC0vqE5pIWOVFCU3kxLIFCE1ktLrChCY6WyonJ0BoklzL/G2Y0MSfteVKhCaWmv5qEZr4szZdidDElNNXMUITX9K26xCa2Hr6rEZo4lPbaC1CEyNIynRBgNCkC10UHQOhiQhWXJbQRAwsKk9oIoJVlyU0UQtL6hOaSFjlRQlN5MSyBQhNZLS6woQmOlsqJydAaJJcy/xtmNDEn7XlSoQmlpr+ahGa+LM2XYnQxJTTVzFCE1/StusQmth6+qxGaOJT22gtQhMjSMp0QYDQpAtdFB0DoYkIVlyW0EQMLCpPaCKCVZclNFELS+oTmkhY5UUJTeTEsgUITWS0usKEJjpbKicnQGiSXMv8bZjQxJ+15UqEJpaa/moRmvizNl2J0MSU01cxQhNf0rbrEJrYevqsRmjiU9toLUITI0jKdEGA0KQLXRQdA6GJCFZcltBEDCwqT2giglWXJTRRC0vqE5pIWOVFCU3kxLIFCE1ktLrChCY6WyonJ0BoYtCyTdNbrs4yd21RKsvzDTMzN9zWX3p6esu5eebudM6dMP/vDy/JptZt3379HoMtSEoQmkhY5UUJTeTEkgUITSSs+qKEJnpjwQqEJgJUDyUJTTwgi5YgNBHBKssSmih1qZ2YAKFJi4Zt2rR15dSSQ7fnzp1eBCC9f3NLDv3V0mzqvxWBSBGY5Lm7cXZm23XD5rXYhmwqoYmMVlqY0ETKKytOaCKj1RYmNNH6iqoTmohgxWUJTcTAwvKEJkJcVWlCE5UsdRMUIDRp0bRNl2/ZOeXc2rnDyy6cnd16YFipIiDpvdY/biFIce6O2R3bNrbYhmwqoYmMVlqY0ETKKytOaCKj1RYmNNH6iqoTmohgxWUJTcTAwvKEJkJcVWlCE5UsdRMUIDRp2LQi9Mjy/NLBW3H6Sw5eZVK8lsLVJoQmDU+OwNMITQI3oOHyhCYN4UJPIzQJ3YFG6xOaNGILPonQJHgLGm+A0KQxXbiJhCbh7Fk5OgFCk4YtmX+OyaVlzyWZH3dFlru3zsxsu7d/ud6VKplzbxv2WsNtmU4jNDHl9FaM0MQbtelChCamnP6KEZr4szZcidDEENNjKUITj9jGSxGaGIP6KEdo4kOZNRIRIDRp0Kj+W25cnl2bZ/mtox7wOi4YKR4gO+zBsQ22ZT6F0MSc1EtBQhMvzOaLEJqYk/opSGjix9l4FUITY1BP5QhNPEELliE0EaCqSxKaqIWpn5AAoUmDZvXdWrPeObfwV3A2b37/msP53O5eyYUHwx69muQNw65IITRpgN9gSubyt9+6Y/3ny6bO3P++L7rcnV82LvbXCU1i79Dw/RGapNk3R2iSZOMITZJsmyM0SbNvvV0TmiTYO0KTBJvGllUChCYNZPvCkTMGrxKZnr7qojzLduW5u+bIX8ohNGkgbDuF0GS457P3bHwkd26trbb3as8cd97OZd5XFSxIaCJA9VGS0MSHsvkahCbmpF4KEpp4YZYsQmgiYdUWJTTR+lI9KQFCkwbtGnZFSVGmeC1z7pHeX8vp/fnhUc8tGfe8kwbbMp/C7TnmpF4KcqWJF2bzRQhNzEn9FCQ08eNsvAqhiTGop3KEJp6gBcsQmghQ1SUJTdTC1E9IgNCkQbPG/eWbRaHJ1KHLs8wNfxDs9JarR71Wtq0fPHZgj8vz08rGtXn903c95r76jz9pUyKKuZdedIY7+5UrSvey+4lPur2HHiodF/uA809+r3vR0hNLt3nqnivd1OH9peNiHpC7pe6xM26OeYuV9/aNb+5zt3zhh5XHxzrwgvUnuQvWn1y6vQcOfMk9+OSRuxmT/t9rV73TrXnhq0uP4cV7P+yWP/1PpeNiH/D4qX/qnjsu9QvUnHts70H3oU98L3bu0v2d84sr3bvfeXrpuD1Pf9vdt+9vS8fFPuDM49e5s1e+pXSbx+//nFt54LOl42IfsH/1u9zPX9S7Ezz9/135wW+7w3N50gdy4oql7gPvOav0GJ56br+76/G/KB0X+4CTlr3crVv9e6XbXPb0N93qvekf789X/Lrbv2pj6fG2GpBlP3zZS1euaVWDyUEECE0aso96wGsRmuTOfW12x7aNxe06g7fx9D9MtndFyuzs1gN1tvLQnn1b64xvMvYjux7+rQcfeur1TebGNOe333zKp970uhf/S9mevvSvf/kHTz77xCvKxsX++vrV77pp9XFr95Xt87Q9mzdncwdXlo2L+/Wpw3tOv/nP495jtd199u9//Ctfue8n76g2Ot5Rv3zWii///u+s/YeyHX59367zf3TwweR/Gjjz+DfuetWKN32r7HhP+dH1G5c++2j5p+2yQoFff+KkP/nwweWveTzwNlov/8BDT5388V0Pv6d1ocAFTjtp2Xc3/+ErdpZt4zs/+8o5Dz751Q1l42J//dTlZ979+lUb7irb56q9H/21Xzh4/5vLxsX++pMrfuMzPz1xQ/ppq3Puyg8+8IG53C2J3Xzc/pYvnzrwZ5vO2l52DE888+iqu5/468vKxsX++vEvWP39t7zkj/+mbJ/H/+zvfumE/bt+t2xc7K8/88Kzv773JZd9Qb3Pl69ZJf8ZTn0Mk1if0KRh1wefXVKUGQxJBkOU58dtOTfP3J157m7sPfuk4Tak07g9R8orK87tOTJaaWFuz5Hy6opze47OVliZ23OEuMLS3J4jxBWX5vYcMbCiPLfnKFSpmagAoUmLxg1ebTI6IBl4OOymrSunlhy6vbd0k6tMWmy51lRCk1pc0QwmNImmFbU2QmhSiyuewYQm8fSixk4ITWpgRTSU0CSiZtTcCqFJTbAYhhOaxNAF9hCJAKFJy0YUfza4KFP81ZzBssUVKAvjnLuld/tOy+Wl0wlNpLyy4oQmMlppYUITKa+uOKGJzlZYmdBEiCssTWgixBWXJjQRAyvKE5ooVKmZqAChSaKN87FtQhMfyvZrEJrYm/qoSGjiQ1mwBqGJAFVfktBEb6xYgdBEoeqnJqGJH2fTVQhNTDkplrYAoUna/ZPuntBEyisrTmgio5UWJjSR8uqKE5robIWVCU2EuMLShCZCXHFpQhMxsKI8oYlClZqJChCaJNo4H9smNPGhbL8GoYm9qY+KhCY+lAVrEJoIUPUlCU30xooVCE0Uqn5qEpr4cTZdhdDElJNiaQsQmqTdP+nuCU2kvLLihCYyWmlhQhMpr644oYnOVliZ0ESIKyxNaCLEFZcmNBEDK8oTmihUqZmoAKFJoo3zsW1CEx/K9msQmtib+qhIaOJDWbAGoYkAVV+S0ERvrFiB0ESh6qcmoYkfZ9NVCE1MOSmWtgChSdr9k+6e0ETKKytOaCKjlRYmNJHy6ooTmuhshZUJTYS4wtKEJkJccWlCEzGwojyhiUKVmokKEJok2jgf2yY08aFsvwahib2pj4qEJj6UBWsQmghQ9SUJTfTGihUITRSqfmoSmvhxNl2F0MSUk2JpCxCapN0/6e4JTaS8suKEJjJaaWFCEymvrjihic5WWJnQRIgrLE1oIsQVlyY0EQMryhOaKFSpmagAoUmijfOxbUITH8r2axCa2Jv6qEho4kNZsAahiQBVX5LQRG+sWIHQRKHqpyahiR9n01UITUw5KZa2AKFJ2v2T7p7QRMorK05oIqOVFiY0kfLqihOa6GyFlQlNhLjC0oQmQlxxaUITMbCiPKGJQpWaiQoQmiTaOB/bJjTxoWy/BqGJvamPioQmPpQFaxCaCFD1JQlN9MaKFQhNFKp+ahKa+HE2XYXQxJSTYmkLEJqk3T/p7glNpLyy4oQmMlppYUITKa+uOKGJzlZYmdBEiCssTWgixBWXJjQRAyvKE5ooVKmZqAChSaKN87FtQhMfyvZrEJrYm/qoSGjiQ1mwBqGJAFVfktBEb6xYgdBEoeqnJqGJH2fTVQhNTDkplrYAoUna/ZPuntBEyisrTmgio5UWJjSR8uqKE5robIWVCU2EuMLShCZCXHFpQhMxsKI8oYlClZqJChCaJNo4H9smNPGhbL8GoYm9qY+KhCY+lAVrEJoIUPUlCU30xooVCE0Uqn5qEpr4cTZdhdDElJNiaQsQmqTdP+nuCU2kvLLihCYyWmlhQhMpr644oYnOVliZ0ESIKyxNaCLEFZcmNBEDK8oTmihUqZmoAKFJoo3zsW1CEx/K9msQmtib+qhIaOJDWbAGoYkAVV+S0ERvrFiB0ESh6qcmoYkfZ9NVCE1MOSmWtgChSdr9k+6e0ETKKytOaCKjlRYmNJHy6ooTmuhshZUJTYS4wtKEJkJccWlCEzGwojyhiUKVmokKEJok2jgf2yY08aFsvwahib2pj4qEJj6UBWsQmghQ9SUJTfTGihUITRSqfmoSmvhxNl2F0MSUk2JpCxCapN0/6e4JTaS8suKEJjJaaWFCEymvrjihic5WWJnQRIgrLE1oIsQVlyY0EQMryhOaKFSpmagAoUmijfOxbUITH8r2axCa2Jv6qEho4kNZsAahiQBVX5LQRG+sWIHQRKHqpyahiR9n01UITUw5KZa2AKFJ2v2T7p7QRMorK05oIqOVFiY0kfLqihOa6GyFlQlNhLjC0oQmQlxxaUITMbCiPKGJQpWaiQoQmiTaOB/bJjTxoWy/BqGJvamPioQmPpQFaxCaCFD1JQlN9MaKFQhNFKp+ahKa+HE2XYXQxJSTYmkLEJqk3T/p7glNpLyy4oQmMlppYUITKa+uOKGJzlZYmdBEiCssTWgixBWXJjQRAyvKE5ooVKmZqAChSaKN87FtQhMfyvZrEJrYm/qoSGjiQ1mwBqGJAFVfktBEb6xYgdBEoeqnJqGJH2fTVQhNTDkplrYAoUna/ZPuntBEyisrTmgio5UWJjSR8uqKE5robIWVCU2EuMLShCZCXHFpQhMxsKI8oYlClZqJChCaJNo4H9smNPGhbL8GoYm9qY+KhCY+lAVrEJoIUPUlCU30xooVCE0Uqn5qEpr4cTZdhdDElJNiaQsQmqTdP+nuCU2kvLLihCYyWmlhQhMpr644oYnOVliZ0ESIKyxNaCLEFZcmNBEDK8oTmihUqZmoAKFJoo3zsW1CEx/K9msQmtib+qhIaOJDWbAGoYkAVV+S0ERvrFiB0ESh6qcmoYkfZ9NVCE1MOSmWtgChSdr9k+6e0ETKKytOaCKjlRYmNJHy6ooTmuhshZUJTYS4wtKEJkJccWlCEzGwojyhiUKVmokKEJok2jgf2yY08aFsvwahib2pj4qEJj6UBWsQmghQ9SUJTfTGihUITRSqfmoSmvhxNl2F0MSUk2JpCxCapN0/6e4JTaS8suKEJjJaaWFCEymvrjihic5WWJnQRIgrLE1oIsQVlyY0EQMryhOaKFSpmagAoUmijfOxbUITH8r2axCa2Jv6qEho4kNZsAahiQBVX5LQRG+sWIHQRKHqpyahiR9n01UITUw5KZa2AKFJ2v2T7p7QRMorK05oIqOVFiY0kfLqihOa6GyFlQlNhLjC0oQmQlxxaUITMbCiPKGJQpWaiQoQmiTaOB/bJjTxoWy/BqGJvamPioQmPpQFaxCaCFD1JQlN9MaKFQhNFKp+ahKa+HE2XYXQxJSTYmkLEJqk3T/p7glNpLyy4oQmMlppYUITKa+uOKGJzlZYmdBEiCssTWgixBWXJjQRAyvKE5ooVKmZqAChSaKN87FtQhMfyvZrEJrYm/qoSGjiQ1mwBqGJAFVfktBEb6xYgdBEoeqnJqGJH2fTVQhNTDkplrYAoYlR/zZt2rpyasmh23Pn1md5vmFm5obb+ktPT285N8/cnc65E+b//eEl2dS67duv32O0BfMyhCbmpF4KEpp4YTZfhNDEnNRPQUITP87GqxCaGIN6Kkdo4glasAyhiQBVXZLQRC1M/YQECE2MmrVpesvVWeau7ZUbDE2KwCTP3Y2zM9uu6wtYTo85OCE0MTo5PJchNPEMbrQcoYkRpO8yhCa+xU3WIzQxYfRehNDEO7nZgoQmZpT+ChGa+LNmpegFCE0MWrR58/vXHM7ndjvnzhgMTYqApPfvc4eXXTg7u/VA778XghTn7pjdsW2jwTbMSxCamJN6KUho4oXZfBFCE3NSPwUJTfw4G69CaGIM6qkcoYknaMEyhCYCVHVJQhO1MPUTEiA0MWjWpsu37Myce0Pv9pssd/+5/0qTwatMiuVSuNqE0MTg5AhQgtAkALrBkoQmBoghShCahFBvvSahSWvCIAUITYKwmyxKaGLC6LcIoYlfb1aLWoDQpGV7pqevuijPsl29oGTOZef0btHpD03mb9u5IsvdW2dmtt3bv9x82PK2Ya+13JbJdEITE0bvRQhNvJObLEhoYsLovwihiX9zgxUJTQwQA5QgNAmAbrQkoYkRpM8yhCY+tVkrcgFCkxYNKm7LyZ37Wu8Wm+K5JseEJkevQhkajAwb32I75lMJTcxJvRQkNPHCbL4IoYk5qZ+ChCZ+nI1XITQxBvVUjtDEE7RgGUITAaq6JKGJWpj6CQkQmrRoVnFbTvEw1zGhyRuGPfCV0KQFfo2pmcvffuuO9Z8vmzJz//u+6HJ3ftm42F8nNIm9Q8P3R2iSZt8coUmSjSM0SbJtjtAkzb71dk1okmDvCE0SbBpbVgkQmjSUHRqQzP8FnSFXmhCaNHS2mEZoMlzx2Xs2PpI7t9bCOGCNZ447b+eygOubLU1oYkbptxChiV9vo9UITYwgPZchNPEMbrgcoYkhpq9ShCa+pFknAQFCkwZNKp5jkufumt6fEC5KNLw9Z+jzThpsy3wKt+eYk3opyJUmXpjNFyE0MSf1U5DQxI+z8SqEJsagnsoRmniCFixDaCJAVZckNFELUz8hAUKTms3q+6s368um9j0cdviDYI9emdIoNPnBYwf2uDw/rWwPbV7/9F2Pua/+40/alIhi7qUXneHOfuWK0r3sfuKTbu+hh0rHxT7g/JPf61609MTSbZ6650o3dXh/6biYB+RuqXvsjJtj3mLlvX3jm/vcLV/4YeXxsQ68YP1J7oL1J5du74EDX3IPPtn7S+1p/++1q97p1rzw1aUH8eK9H3bLn/6n0nGxD3j81D91zx2X+gVqzj2296D70Ce+Fzt36f7O+cWV7t3vPL103J6nv+3u2/e3peNiH3Dm8evc2SvfUrrN4/d/zq088NnScbEP2L/6Xe7nLyr9uBn7YRzZ35Uf/LY7PJcnsddRmzxxxVL3gfecVXoMTz233931+F+Ujot9wEnLXu7Wrf690m0ue/qbbvXe9I/35yt+3e1ftbH0eFsNyLIfvuylK9e0qsHkIAKEJobsw6406f/rOjMzN9xWLFeEL73/P3d42YWzs1sP1NnKQ3v2ba0zvsnYj+x6+LcefOip1zeZG9Oc337zKZ960+te/C9le/rSv/7lHzz57BOvKBsX++vrV7/rptXHrd1Xts/T9mzenM0dXFk2Lu7Xpw7vOf3mP497j9V299m///GvfOW+n7yj2uh4R/3yWSu+/Pu/s/Yfynb49X27zv/RwQeT/2ngzOPfuOtVK970rbLjPeVH129c+uyj5Z+2ywoFfv2Jk/7kwweXv+bxwNtovfwDDz118sd3Pfye1oUCFzjtpGXf3fyHr9hZto3v/Owr5zz45Fc3lI2L/fVTl5959+tXbbirbJ+r9n70137h4P1vLhsX++tPrviNz/z0xA3pp61HQpMHPjCXuyWxm4/b3/LlUwf+bNNZ28uO4YlnHl119xN/fVnZuNhfP/4Fq7//lpf88d+U7fP4n/3dL52wf9fvlo2L/fVnXnj21/e+5LIvqPf58jWr5D/DqY9hEusTmhh2fVhoMvgXdorlpqe3nJtn7s48dzf23+JjuJ3Wpbg9pzVhkALcnhOEvfWi3J7TmjBMAW7PCePeclVuz2kJGGg6t+cEgjdYlttzDBB9l+D2HN/irBexAKGJYXNG/TWcwWegtL3KxHDLY0sRmviStl2H0MTW01c1QhNf0sbrEJoYg/opR2jix9l6FUITa1F/9QhN/FmbrURoYkZJofQFCE0MezjuTwgXwUmxXO7cLbM7tolvnGt3cIQm7fxCzSY0CSXfbl1Ck3Z+wWYTmgSjb7MwoUkbvXBzCU3C2bddmdCkrWCA+YQmAdBZMlYBQpNYOxPBvghNImhCgy0QmjRAi2AKoUkETWiyBUKTJmrB5xCaBG9Bow0QmjRii2ISoUkUbai3CUKTel6M7rQAoUmn29vu4AhN2vmFmk1oEkq+3bqEJu38gs0mNAlG32ZhQpM2euHmEpqEs2+7MqFJW8EA8wlNAqCzZKwChCaxdiaCfRGaRNCEBlsgNGmAFsEUQpMImtBkC4QmTdSCzyE0Cd6CRhsgNGnEFsUkQpMo2lBvE4Qm9bwY3WkBQpNOt7fdwRGatPMLNZvQJJR8u3UJTdr5BZtNaBKMvs3ChCZt9MLNJTQJZ992ZUKTtoIB5hOaBEBnyVgFCE1i7UwE+yI0iaAJDbZAaNIALYIphCYRNKHJFghNmqgFn0NoErwFjTZAaNKILYpJhCZRtKHeJghN6nkxutMChCadbm+7gyM0aecXajahSSj5dusSmrTzCzab0CQYfZuFCU3a6IWbS2gSzr7tyoQmbQUDzCc0CYDOkrEKEJrE2pkI9kVoEkETGmyB0KQBWgRTCE0iaEKTLRCaNFELPofQJHgLGm2A0KQRWxSTCE2iaEO9TRCa1PNidKcFCE063d52B0do0s4v1GxCk1Dy7dYlNGnnF2w2oUkw+jYLE5q00Qs3l9AknH3blQlN2goGmE9oEgCdJWMVIDSJtTMR7IvQJIImNNgCoUkDtAimEJpE0IQmWyA0aaIWfA6hSfAWNNoAoUkjtigmEZpE0YZ6myA0qefF6E4LEJp0ur3tDo7QpJ1fqNmEJqHk261LaNLOL9hsQpNg9G0WJjRpoxduLqFJOPu2KxOatBUMMJ/QJAA6S8YqQGgSa2ci2BehSQRNaLAFQpMGaBFMITSJoAlNtkBo0kQt+BxCk+AtaLQBQpNGbFFMIjSJog31NkFoUs+L0Z0WIDTpdHvbHRyhSTu/ULMJTULJt1uX0KSdX7DZhCbB6NssTGjSRi/cXEKTcPZtVyY0aSsYYD6hSQB0loxVgNAk1s5EsC9Ckwia0GALhCYN0CKYQmgSQROabIHQpIla8DmEJsFb0GgDhCaN2KKYRGgSRRvqbYLQpJ4XozstQGjS6fa2OzhCk3Z+oWYTmoSSb7cuoUk7v2CzCU2C0bdZmNCkjV64uYQm4ezbrkxo0lYwwHxCkwDoLBmrAKFJrJ2JYF+EJhE0ocEWCE0aoEUwhdAkgiY02QKhSRO14HMITYK3oNEGCE0asUUxidAkijbU2wShST0vRndagNCk0+1td3CEJu38Qs0mNAkl325dQpN2fsFmE5oEo2+zMKFJG71wcwlNwtm3XZnQpK1ggPmEJgHQWTJWAUKTWDsTwb4ITSJoQoMtEJo0QItgCqFJBE1osgVCkyZqwecQmgRvQaMNEJo0YotiEqFJFG2otwlCk3pejO60AKFJp9vb7uAITdr5hZpNaBJKvt26hCbt/ILNJjQJRt9mYUKTNnrh5hKahLNvuzKhSVvBAPMJTQKgs2SsAoQmsXYmgn0RmkTQhAZbIDRpgBbBFEKTCJrQZAuEJk3Ugs8hNAnegkYbIDRpxBbFJEKTKNpQbxOEJvW8GN1pAUKTTre33cERmrTzCzWb0CSUfLt1CU3a+QWbTWgSjL7NwoQmbfTCzSU0CWffdmVCk7aCAeYTmgRAZ8lYBQhNYu1MBPsiNImgCQ22QGjSAC2CKYQmETShyRYITZqoBZ9DaBK8BY02QGjSiC2KSYQmUbSh3iYITep5MbrTAoQmnW5vu4MjNGnnF2o2oUko+XbrEpq08ws2m9AkGH2bhQlN2uiFm0toEs6+7cqEJm0FA8wnNAmAzpKxChCaxNqZCPZFaBJBExpsgdCkAVoEUwhNImhCky0QmjRRCz6H0CR4CxptgNCkEVsUkwhNomhDvU0QmtTzYnSnBQhNOt3edgdHaNLOL9RsQpNQ8u3WJTRp5xdsNqFJMPo2CxOatNELN5fQJJx925UJTdoKBphPaBIAnSVjFSA0ibUzEeyL0CSCJjTYAqFJA7QIphCaRNCEJlsgNGmiFnwOoUnwFjTaAKFJI7YoJhGaRNGGepsgNKnnxehOCxCadLq97Q6O0KSdX6jZhCah5NutS2jSzi/YbEKTYPRtFiY0aaMXbi6hSTj7tisTmrQVDDCf0CQAOkvGKkBoEmtnItgXoUkETWiwBUKTBmgRTCE0iaAJTbZAaNJELfgcQpPgLWi0AUKTRmxRTCI0iaIN9TZBaFLPi9GdFiA06XR72x0coUk7v1CzCU1Cybdbl9CknV+w2YQmwejbLExo0kYv3FxCk3D2bVcmNGkrGGA+oUkAdJaMVYDQJNbORLAvQpMImtBgC4QmDdAimEJoEkETmmyB0KSJWvA5hCbBW9BoA4QmjdiimERoEkUb6m2C0KSeF6M7LUBo0un2tjs4QpN2fqFmE5qEkm+3LqFJO79gswlNgtG3WZjQpI1euLmEJuHs265MaNJWMMB8QpMA6CwZqwChSaydiWBfhCYRNKHBFghNGqBFMIXQJIImNNkCoUkTteBzCE2Ct8h6gLQAACAASURBVKDRBghNGrFFMYnQJIo21NsEoUk9L0Z3WoDQpNPtbXdwhCbt/ELNJjQJJd9uXUKTdn7BZhOaBKNvszChSRu9cHMJTcLZt12Z0KStYID5hCYB0FkyVgFCk1g7E8G+CE0iaEKDLRCaNECLYAqhSQRNaLIFQpMmasHnEJoEb0GjDRCaNGKLYhKhSRRtqLcJQpN6XozutAChSafb2+7gCE3a+YWaTWgSSr7duoQm7fyCzSY0CUbfZmFCkzZ64eYSmoSzb7syoUlbwQDzCU0CoLNkrAKEJrF2JoJ9EZpE0IQGWyA0aYAWwRRCkwia0GQLhCZN1ILPITQJ3oJGGyA0acQWxSRCkyjaUG8ThCb1vBjdaQFCk063t93BEZq08ws1m9AklHy7dQlN2vkFm01oEoy+zcKEJm30ws0lNAln33ZlQpO2ggHmE5oEQGfJWAUITWLtTAT7IjSJoAkNtkBo0gAtgimEJhE0ockWCE2aqAWfQ2gSvAWNNkBo0ogtikmEJlG0od4mCE3qeTG60wKEJi3au2l6y9VZ5q7tL5Hl+YaZmRtuGyw7Pb3l3DxzdzrnTph/7eEl2dS67duv39NiC9KphCZSXllxQhMZrbQwoYmUV1ec0ERnK6xMaCLEFZYmNBHiiksTmoiBFeUJTRSq1ExUgNCkYeOmp6+6KM+yG/uDjyJEyZ27ZXbHto1F6SIwyXN34+zMtus2bdq6cmrJodtz506POTghNGl4cgSeRmgSuAENlyc0aQgXehqhSegONFqf0KQRW/BJhCbBW9B4A4QmjenCTSQ0CWfPytEJEJo0bMnmze9f89xzL/jZ7OzWA/0lNl2+ZWfm3Nuy3L11ZmbbvUVA0hszd3jZhcX4hSDFuTv6A5aG25FMIzSRsMqLEprIiSULEJpIWPVFCU30xoIVCE0EqB5KEpp4QBYtQWgiglWWJTRR6lI7MQFCE+OGzV9tckURmgxeZVIsl8LVJoQmxieHp3KEJp6gjZchNDEG9VWO0MSXtOk6hCamnN6KEZp4ozZfiNDEnFRfkNBEb8wKyQgQmhi3ajA0Gfz//csNXpVivJXW5QhNWhMGKUBoEoS99aKEJq0JwxQgNAnj3nJVQpOWgIGmE5oEgjdYltDEANF3CUIT3+KsF7EAoYlhc4ZdPTIuGCmegTLq4bGGW2tUitCkEVvwSYQmwVvQaAOEJo3Ywk8iNAnfgwY7IDRpgBbBFEKTCJrQcAuEJg3hQk4jNAmpz9qRCRCaGDZkPiC5JM/dNb0HvvZKz//bG4Y98JXQxBB/TKnM5W+/dcf6z5etNnP/+77ocnd+2bjYXyc0ib1Dw/dHaJJm3xyhSZKNIzRJsm2O0CTNvvV2TWiSYO8ITRJsGltWCRCaGMj2XWGyPnPu7v4HvhKaGAC3LEFoMhzw2Xs2PpI7t7Ylb+jpzxx33s5loTdhsT6hiYVigBqEJgHQ2y9JaNLeMEQFQpMQ6jZrEprYOHqtQmjilZvF4hYgNGnZn+JBr865Ewb/1HCvdIXbcxYeGttyK+bTuT3HnNRLQa408cJsvgihiTmpn4KEJn6cjVchNDEG9VSO0MQTtGAZQhMBqrokoYlamPoJCRCatGjW9PRVF+VZtqtXYtRzScY+CHZ6y9VZ5hqFJj947MAel+entdh+6dRP3/WY++o//qR0XOwDLr3oDHf2K1eUbnP3E590ew89VDou9gHnn/xe96KlJ5Zu89Q9V7qpw/tLx8U8IHdL3WNn3BzzFivv7Rvf3Odu+cIPK4+PdeAF609yF6w/uXR7Dxz4knvwyd2l42If8NpV73RrXvjq0m2+eO+H3fKn/6l0XOwDHj/1T91zx6V+gZpzj+096D70ie/Fzl26v3N+caV79ztPLx235+lvu/v2/W3puNgHnHn8Onf2yreUbvP4/Z9zKw98tnRc7AP2r36X+/mL1se+zUr7u/KD33aH5/JKY2MddOKKpe4D7zmrdHtPPbff3fX4X5SOi33AScte7tat/r3SbS57+ptu9d70j/fnK37d7V+1sfR4Ww3Ish++7KUr17SqweQgAoQmDdn7rjBxxZ8XHlaqCFYGQ5Xilp7enP7beapu56E9+7ZWHdt03Ed2PfxbDz701Oubzo9l3m+/+ZRPvel1L/6Xsv186V//8g+efPaJV5SNi/319avfddPq49buK9vnaXs2b87mDq4sGxf361OH95x+85/Hvcdqu/vs3//4V75y30/eUW10vKN++awVX/7931n7D2U7/Pq+Xef/6OCDyf80cObxb9z1qhVv+lbZ8Z7yo+s3Ln320fJP22WFAr/+xEl/8uGDy1/zeOBttF7+gYeeOvnjux5+T+tCgQucdtKy727+w1fsLNvGd372lXMefPKrG8rGxf76qcvPvPv1qzbcVbbPVXs/+mu/cPD+N5eNi/31J1f8xmd+euKG9NNW59yVH3zgA3O5WxK7+bj9LV8+deDPNp21vewYnnjm0VV3P/HXl5WNi/3141+w+vtveckf/03ZPo//2d/90gn7d/1u2bjYX3/mhWd/fe9LLvuCep8vX7NK/jOc+hgmsT6hScOuV/1zwZs3v3/N4Xxud+7c12Z3bFuIL4vQJc/djcVDYxtuRTaN23NktNLC3J4j5ZUV5/YcGa22MLfnaH1F1bk9RwQrLsvtOWJgYXluzxHiqkpze45KlroJChCaNGha3atEiqtNir+qU3d+gy2aTCE0MWH0XoTQxDu5yYKEJiaM/osQmvg3N1iR0MQAMUAJQpMA6EZLEpoYQfosQ2jiU5u1IhcgNGnQoOLqEefcGaOmDz4Utv/5J705wx4a22Ar0imEJlJeWXFCExmttDChiZRXV5zQRGcrrExoIsQVliY0EeKKSxOaiIEV5QlNFKrUTFSA0CTRxvnYNqGJD2X7NQhN7E19VCQ08aEsWIPQRICqL0loojdWrEBoolD1U5PQxI+z6SqEJqacFEtbgNAk7f5Jd09oIuWVFSc0kdFKCxOaSHl1xQlNdLbCyoQmQlxhaUITIa64NKGJGFhRntBEoUrNRAUITRJtnI9tE5r4ULZfg9DE3tRHRUITH8qCNQhNBKj6koQmemPFCoQmClU/NQlN/DibrkJoYspJsbQFCE3S7p9094QmUl5ZcUITGa20MKGJlFdXnNBEZyusTGgixBWWJjQR4opLE5qIgRXlCU0UqtRMVIDQJNHG+dg2oYkPZfs1CE3sTX1UJDTxoSxYg9BEgKovSWiiN1asQGiiUPVTk9DEj7PpKoQmppwUS1uA0CTt/kl3T2gi5ZUVJzSR0UoLE5pIeXXFCU10tsLKhCZCXGFpQhMhrrg0oYkYWFGe0EShSs1EBQhNEm2cj20TmvhQtl+D0MTe1EdFQhMfyoI1CE0EqPqShCZ6Y8UKhCYKVT81CU38OJuuQmhiykmxtAUITdLun3T3hCZSXllxQhMZrbQwoYmUV1ec0ERnK6xMaCLEFZYmNBHiiksTmoiBFeUJTRSq1ExUgNAk0cb52DahiQ9l+zUITexNfVQkNPGhLFiD0ESAqi9JaKI3VqxAaKJQ9VOT0MSPs+kqhCamnBRLW4DQJO3+SXdPaCLllRUnNJHRSgsTmkh5dcUJTXS2wsqEJkJcYWlCEyGuuDShiRhYUZ7QRKFKzUQFCE0SbZyPbROa+FC2X4PQxN7UR0VCEx/KgjUITQSo+pKEJnpjxQqEJgpVPzUJTfw4m65CaGLKSbG0BQhN0u6fdPeEJlJeWXFCExmttDChiZRXV5zQRGcrrExoIsQVliY0EeKKSxOaiIEV5QlNFKrUTFSA0CTRxvnYNqGJD2X7NQhN7E19VCQ08aEsWIPQRICqL0loojdWrEBoolD1U5PQxI+z6SqEJqacFEtbgNAk7f5Jd09oIuWVFSc0kdFKCxOaSHl1xQlNdLbCyoQmQlxhaUITIa64NKGJGFhRntBEoUrNRAUITRJtnI9tE5r4ULZfg9DE3tRHRUITH8qCNQhNBKj6koQmemPFCoQmClU/NQlN/DibrkJoYspJsbQFCE3S7p9094QmUl5ZcUITGa20MKGJlFdXnNBEZyusTGgixBWWJjQR4opLE5qIgRXlCU0UqtRMVIDQJNHG+dg2oYkPZfs1CE3sTX1UJDTxoSxYg9BEgKovSWiiN1asQGiiUPVTk9DEj7PpKoQmppwUS1uA0CTt/kl3T2gi5ZUVJzSR0UoLE5pIeXXFCU10tsLKhCZCXGFpQhMhrrg0oYkYWFGe0EShSs1EBQhNEm2cj20TmvhQtl+D0MTe1EdFQhMfyoI1CE0EqPqShCZ6Y8UKhCYKVT81CU38OJuuQmhiykmxtAUITdLun3T3hCZSXllxQhMZrbQwoYmUV1ec0ERnK6xMaCLEFZYmNBHiiksTmoiBFeUJTRSq1ExUgNAk0cb52DahiQ9l+zUITexNfVQkNPGhLFiD0ESAqi9JaKI3VqxAaKJQ9VOT0MSPs+kqhCamnBRLW4DQJO3+SXdPaCLllRUnNJHRSgsTmkh5dcUJTXS2wsqEJkJcYWlCEyGuuDShiRhYUZ7QRKFKzUQFCE0SbZyPbROa+FC2X4PQxN7UR0VCEx/KgjUITQSo+pKEJnpjxQqEJgpVPzUJTfw4m65CaGLKSbG0BQhN0u6fdPeEJlJeWXFCExmttDChiZRXV5zQRGcrrExoIsQVliY0EeKKSxOaiIEV5QlNFKrUTFSA0CTRxvnYNqGJD2X7NQhN7E19VCQ08aEsWIPQRICqL0loojdWrEBoolD1U5PQxI+z6SqEJqacFEtbgNAk7f5Jd09oIuWVFSc0kdFKCxOaSHl1xQlNdLbCyoQmQlxhaUITIa64NKGJGFhRntBEoUrNRAUITRJtnI9tE5r4ULZfg9DE3tRHRUITH8qCNQhNBKj6koQmemPFCoQmClU/NQlN/DibrkJoYspJsbQFCE3S7p9094QmUl5ZcUITGa20MKGJlFdXnNBEZyusTGgixBWWJjQR4opLE5qIgRXlCU0UqtRMVIDQJNHG+dg2oYkPZfs1CE3sTX1UJDTxoSxYg9BEgKovSWiiN1asQGiiUPVTk9DEj7PpKoQmppwUS1uA0CTt/kl3T2gi5ZUVJzSR0UoLE5pIeXXFCU10tsLKhCZCXGFpQhMhrrg0oYkYWFGe0EShSs1EBQhNEm2cj20TmvhQtl+D0MTe1EdFQhMfyoI1CE0EqPqShCZ6Y8UKhCYKVT81CU38OJuuQmhiykmxtAUITdLun3T3hCZSXllxQhMZrbQwoYmUV1ec0ERnK6xMaCLEFZYmNBHiiksTmoiBFeUJTRSq1ExUgNAk0cb52DahiQ9l+zUITexNfVQkNPGhLFiD0ESAqi9JaKI3VqxAaKJQ9VOT0MSPs+kqhCamnBRLW4DQJO3+SXdPaCLllRUnNJHRSgsTmkh5dcUJTXS2wsqEJkJcYWlCEyGuuDShiRhYUZ7QRKFKzUQFCE0SbZyPbROa+FC2X4PQxN7UR0VCEx/KgjUITQSo+pKEJnpjxQqEJgpVPzUJTfw4m65CaGLKSbG0BQhN0u6fdPeEJlJeWXFCExmttDChiZRXV5zQRGcrrExoIsQVliY0EeKKSxOaiIEV5QlNFKrUTFSA0CTRxvnYNqGJD2X7NQhN7E19VCQ08aEsWIPQRICqL0loojdWrEBoolD1U5PQxI+z6SqEJqacFEtbgNDEU/+mp7ecm2fuTufcCfNLPrwkm1q3ffv1ezxtofYyhCa1yaKYQGgSRRtqb4LQpDZZHBMITeLoQ81dEJrUBItkOKFJJI1osA1CkwZooacQmoTuAOtHJEBo4qEZRWCS5+7G2Zlt123atHXl1JJDt+fOnR5zcEJo4uHkECxBaCJA9VCS0MQDsmIJQhOFqrwmoYmcWLIAoYmE1UtRQhMvzLaLEJrYelItaQFCE3H7ioCkt8zc4WUXzs5uPdD774Ugxbk7Znds2yjeRqPyhCaN2IJPIjQJ3oJGGyA0acQWfhKhSfgeNNgBoUkDtAimEJpE0ISGWyA0aQgXchqhSUh91o5MgNBE3JDBq0yK5VK42oTQRHxyiMoTmohgxWUJTcTAqvKEJipZaV1CEymvrDihiYxWXpjQRE5svwChib0pFZMVIDQRt27T9Jars8xdkeXurTMz2+7tX27T5Vt2Zs69bdhr4m1VKk9oUokpukGEJtG1pNKGCE0qMcU3iNAkvp5U2BGhSQWkCIcQmkTYlIpbIjSpCBXTMEKTmLrBXgILEJqIGzAuGJkPVK7N8nzDzMwNt4m3Urs8oUltsigmEJpE0YbamyA0qU0WxwRCkzj6UHMXhCY1wSIZTmgSSSMabIPQpAFa6CmEJqE7wPoRCRCaiJsxH5q8YdgDXwlNxPjz5TOXv/3WHes/X7bazP3v+6LL3fll42J/ndAk9g4N3x+hSZp9c4QmSTaO0CTJtjlCkzT71ts1oUmCvSM0SbBpbFklQGiikp2vS2giBq5QntBkONKz92x8JHdubQXCmIc8c9x5O5fFvMGqeyM0qSoV2ThCk8gaUm07hCbVnGIbRWgSW0eq74fQpLpVNCMJTaJpBRsJL0BoIu5Bhdtzhj7vRLytSuW5PacSU3SDuNIkupZU2hChSSWm+AYRmsTXkwo7IjSpgBThEEKTCJtScUuEJhWhYhpGaBJTN9hLYAFCE3EDxj4IdsxDYsdt67Lpq+5zWfar4q1THgEEjhHInXN8y+SkQEAvwNea3pgVEBgU4OuOcwIBLwJ5fv9NMze81staLGImwE8AZpTDC01PX3VRnmW7Bh/2WvzJ4d6sucPLLpyd3Xqg6lYum77yky6b+t0zX3XWl6vOYRwCCDQXePA7333ziatO/MHJp5zyg+ZVmIkAAlUEHv/xj1+2f9/+l/EeV0WLMQi0F+A9rr0hFRCoItD7WnP53Kdumvkfv1dlPGPiESA0Efdi8+b3rzmcz+3Onfva7I5tG4vlpqe3nJtn7s48dzfOzmy7rs42Lrv8qq3OZdfctGMb/asDx1gEGgpcdvmW3Ln82pt23LC1YQmmIYBARQHe4ypCMQwBIwHe44wgKYNAiQBfa+meIvzQ7aF3xdUmee6u6QUkba4y6W2XD5QemsYSCPQJ8CbH6YCAPwHe4/xZsxICRz9X8osBzgQEfAjwteZDWbMGoYnGdVHVIjgpXsidu6X/ypM62+ADZR0txiLQXoA3ufaGVECgqgDvcVWlGIeAjQDvcTaOVEGgTICvtTKheF8nNIm3NyN3xgfKBJvGlpMW4E0u6fax+cQEeI9LrGFsN3kB3uOSbyEHkIgAX2uJNGrINglNEuwdHygTbBpbTlqAN7mk28fmExPgPS6xhrHd5AV4j0u+hRxAIgJ8rSXSKEKTdBvVv/OjHyid46GU3egnRxG/AF9z8feIHXZHgK+37vSSI0lDgK+5NPrELtMX4Gst3R5ypUm6vWPnCCCAAAIIIIAAAggggAACCCAgFCA0EeJSGgEEEEAAAQQQQAABBBBAAAEE0hUgNEm3d+wcAQQQQAABBBBAAAEEEEAAAQSEAoQmQlxKI4AAAggggAACCCCAAAIIIIBAugKEJun2rrM737z5/WsO53O7nXNn5M7dMrtj28ZxBzs9fdVFeZbtcs79NMvdW2dmtt3rC2d6esu5eebuzJ27o2yfbfa0adPWlVNLDt2eO3f6kmxq3fbt1+9pU4+5CCgF+r4mXZbnG2Zmbrht3HqbLt+yM3Puksy5u+cOL7twdnbrgeL7QObcI+P+renXYP8ex+2tyv6VltTujkDf9/H1fUd1zPvWpuktV2eZu3YSzrthX4NV3vO7c0ZwJHUE+r5+/s2wz3plrw97Tylbv+n7S1ldi9f7PysP1kv9+8ckfR+0OBeo4UeA0MSPM6vUECjeCHLnjpyfU7m7eFwQUvzA1TQ0Kd5o55x7tG7w4esN1To0GXfMxTFleX5p2Q+7NdrK0AkSKH4Yyp371pRz+4vQYxhB/wc/n6HJ4F6KPaf+YXOCTrOkDrV4n8pzd83szLbris3Pn/93ZLn7o9773CT8sFC8x/Teswd/CdA7fpe5V9d9L07qZGCzjQXGfX30nVcnDH6d9RZceF8a+Boctxlfn/GKPczv8WNVfgE4KgQqjIYZNIb3PHESvg96JmU5AwFCEwNEStgK9P0QdaBXufeD16gPUL03tLnM3Trl8n/OXbauyhvN4h+Wml8t4usN1To0Gbdv3qxsz+dJrLYQQLj8C0e/LkcHcPPn28U9p8y5n1YJWPqvPrH6GiQ0mcQz1c8xzwcmb6vy/tT1779WX69+OscqsQmMO3+KwCF3rvfZcffg58YmX1u+z9c63ytGhibzVyb3ejfu/TS23rIfBGIXIDSJvUMTuL9j3gjy/J4syy4edUtK7w1myrm1c0fH/VGVD6WEJr3fuIwOipp8sJjA05RDHiPw/G/08g9NZdl5o67iWriqLM9v7Y0r+5A37EOi1YdaQhNOaYVA3d9ud/n7r3X4r+gXNeMW6Pulmlt0ldL850Hn8gO5y87pf73puWf1/lJV1TI04XbuquqMQ6CaAKFJNSdGeRTo/8Eoc4f/85xbckeeu4/1X9Lc287CuDy/Ys5l52SZu2IwNCk+gPZtf+H+8RH3l/eGPtz/Ztt/yed8nYXX+99Qp/L81vlnqxwZ1n+rQbH+sHtQq9zDXecNv+kxZ7n7r3nm/rdz7oT+dg/ur+92qCPDquzf4+nDUhEI9P+gOOXyb+VZNvRy4/lxN065w2/L3ZKP9IcmbZ5p0v+1XfX8HBeaDPkeMPT5SeO+9iJoC1sIIDD//fINVZ9F1R+azGXZxb1n/RTbHnW5/ZBngxzzHlbMr3IeD3lfHFqryfvAwvtl7m4cfD8f15q675uDX4fDvgdU/Vqtu3aAU2zilhwWLDwfwLuPzb/n7Oq/1bLvtu+vFVegVOntsNBk3Nfo4O2do0KQwbqjnrE17habUVeajDvW3lWaeeY+5nL38SOfU/ueOTbk+4PrX39UgDT6348+b7Co8bxFdrHL8mty54pnOy16Px0VHg/73J7ybUgT98Wb+AETmiTewC5uf/CNwC059FdHriaZf0Bkcczz31Qv7X0YfW5u7tLB0OTIvdHOueLD2ajgocpVF/3flOf3d/lNO7a9r/9Npj8k6Xumw8KDbHvz5vK5W6ayqUuKB7lW/S1k1dDE8pgXvfkPeRit79/CdPF87+Ix9Z/XS6emPtZ7sPNg8Nn/XB13eNl/6T3o2Cw0mX+wbJ0PU6NCk2Ffo8M+CFf92utivzmm4QJNHjzZ/8N8//m78LDkgQcrD/5wMfp97tgfYHo7HjyPx/ywdeT97sicFu8DTa6iGfb1N+pqg1EPAu3V6O2994yuUT7DngPR5j2brwmdwLBzov9ZbM5ljx55QH9fODc4p2pvx4UmR35p1Pd8lGFfo1VDk4XPtUffuyrdyjfs+8uo83vUs8MGPk8f8wDqBVPn/rn3+bs3dtgfJOj7nnVMwDr/7wu/zOwPWovPl6O+Zod9rxh+peni72u6M4/Kky5AaDLpZ0CExz/4jXFq6uBv9tLqcb81GPzmPOqwhv1gVDc976896oF2lUOOiveeVq037LjrHPORD8Uj/nrDKOMmH4QjPO3YkqHA4AfUYb9t7z8v5+aWf9EqNGn6ELxhXyfDfojsMVX9YZhbfgxPqgRLNQmVF87fgb8cN6zWqCs3BsdWPY/d1KHLy/5yT5v3gTq3HvTaPf75FYtvMa3yXjRuD1X2V7wX9we8CZ6aSW95TJBx9Jdoz73gZ4PvJ1U+Iw7r7bjQZPAKpqFjR4Qgo87tKudg0bxhV8oUrw3+0qtv7AmDV2SP++Xdovfyo58Pnw9C5j/Dzjl3RubcyuL5ZcMsRz0Me+gvJoZ8Dh111V4ds6RPfDYfXIDQJHgL2MCgwKIrTebT7f7nIgw+YbzKG2L/5Y9VLjmsVnPMs0FKfmMwcJnh0EugF34L0PBPDtc95lGhyagP3Uc/2JL081V8rMDgOdH/W8DiLzItPI+o7zdY/T+INLk9p7hFruotOccGoEfP4/4PmyN/QKzw9Tjqa49zZXIE2oQmo37o6X8I8qgfIha9hx4NQxbfvjpwHs9fsXntqCu02r4P1P3hZlwIMviLhGE/KJd9tuj9afNh3wNGHX+d9+zJOcv9H2mV3vd/bVQ5N0b1tuz2nP6/MDj0yg8PoUn/94T+z2Rlf41u4fPlmM+qi3+Jeejs/qt4FsKYzG3Ncndp8Tm9/3aphau9a1gMfu2Pu7WvSljq/yxlxS4KEJp0sauJH9PQN56+dHtubtkDVX6LMOz+zIKmLDSpemXH2Ft7hrxBDN4H3tcqk9CkzTEvvIEOSfjH1R1mmvgpyPZbCiz67dTAFVVTU8d+8Br2W6m6oUnxLJ4mgckxHzT7bn8Y8/VaCC16vtHgM4F6A+vcJtSSnukRCYwLGUZtc9QPAKN+mdD3XIBFJYsfmnq3uPY/G2XI2kfO47m5ubW9H4jmz+FFzxlo+z5Q5RcR/XsrC1n6fzAu9p47d8e4v7Z35Ae+EWOG/WDW9D07otOwk1vp/zqZmlpyz+AtoP1X+S287tzC80x6KFV6m2JocuTYBj7Hjbo6suyz7uB789Klz67oWRdBzfyV4DceucInn/tQcSv9sCvE69yqtDg0OfpLjXEn82DQ3MkTn4MKKkBoEpSfxYcJDL9v8fkrOqZyt733waf/z5gOfhgbuGxx8YNbj7nXdchlvhV+k3z0B63qV5qU3Ks+9kGBZW9svb20PeYqocm4D6SczQgUAmWX284/uPnIpdS95/tYhCaZc//c+2sBvT1Ufehmf8eG3UpT9kNbMb/O1x5nyeQIVPm+PajRIDQ5vex8r3oeH31PW/TDyUJ40uTKmWFfY1VDxLJ9q0OTNu/Zk3OWhznS/oBr7INf8+EPhq3a21RDk8EA0Co06V2dEB4vDwAADNFJREFUdcxVPIuDkiMPfZ9z7q1Z5hbe4/tCqkXPa6lizBXNYb7OWPVYAUITzojoBEZ+cz965cYbjjz927ljPigOhiajvsEO+01Sm3tLq4YmxdUxw/4E3KhLrPsbU+XDt8UxD/sNRX8gM3gZaHQnDxuKQmDcwxuLr9+877d+FqFJL9ArAlXn3E/LfpAchBoamox4vs+ouYM/DI67pDiKRrEJuUDdS8erhiZ9P7yUPjSy7h6GhCdHfvHQ+/f+3zIP3t5Shln1WUBFnSq35/TG9h5SOfgb8GF7K1t/2HOWmr5nl1nwejuB/l6O+xPDR86PPL8ny7I/Kp7lMe7z1ODnsSo/0BdHEsvtOUe/fud/oTf/C8Jx5/64cHLY1XILwWqWXe7y/IriIe/Pr5l/dCrLzuu/pb59aDL6F5TtziRmI1BdgNCkuhUjPQmM+uZ+zDMCBh6SNyo0WfQXYOZ/CBry13B29/8Q1/+hcdxvxeqGJsUHvOIDXd9vqMf+drxOaNLmmPuPu+qfzvN0WrBMQgKjArxhT88/8mFqyAOR696eU1wFtfCDj3N3D/7FrXGEdR+Y3F9r1ANfmz6UNqFWs9USgSrfu/tL1AlNqv72tekVIsP2Xnb1R9kJUXXPx/zgN+R2mjG30owNkSo8CPbIVZ+jnoNR9T27zIHX2wsUvcyd6z2bZvfgbVnF58Le61POPVy8H4x6mO+w3rYOTcY/WP/awdtJ69zCNjYIqXh7Ttln3XEPSM9c/q05l/2bqdxdPDOz7d5+117YmOX5Ff3PfGlze07d76Ptzy4qILBYgNCEsyI6gVFvBH1vaIue/j3q9pz+KyNGPZixwm8dLin7k8PDblsZfIMY/DBc56FyVd4wht/W9Pyl1sf8abwxtx+N+oDddz/7Mb/F7/27y/Jr5g4v31j3N4/RnXxsyERg9FVP8w9bHQg0LEOTIyFM8YGxRnAyMvgY8eeLjzzINs9v7X0orPO1ZwJMkaQE+m/fGvGA1zuy3P3RkR88RvyQNfS32M9/H19/zAOMj/z7wZ0uz67t1TzyNVHhPO6t3bvVofhBZ/hvmY/+xnfwaq467wPjvj57r7nMvbr4AXhY8Fj3M0Lva7tn0P+12vv//VejDXNv856d1Ama6GbLHrY97vWqvW0bmowLYnrPDlr8F3iqP1i/7BeM/bXLrrIqvj/0fx8ZeRV2//edwffy+e9fve8Pg3+lp01o0h/u9D/gtvj3uSy7eNSzjBI9vdl2hAKEJhE2ZdK3VJaeT2XugsHfIA9L5wcfWtf7Rtv7EJln+a153zNN+n+jNf8AvGMeyjrkHu/Fz0gZ8puwYW8Qgw8e671B9b7Z9247Gnc7wUDAsugUKQIRq2M+5n7fvqt6hu1j8A1s0s9fjn/0X1Qqzp+53P2f4on6R36gM7zSpPDv+1ob+5DlYvyo0KT/w1p/bwd/+K3ztcc5MpkCQ95LehDHnJ91QpOFc/35H1SKf1r0A0uV83jY9/dhV1pavA+Mek8btt6wB9COuwJ08H122MOhhzwEdOj3iabv2ZN5hvs96r7zwg3+gN7bybiwsj9ILHY97PNY29BkyOfLI1/zvasw8iz72JhfuF3SGzjuPB94ltYx+FX++tZgt4Z9fxr1cNWFMHPRn0Yf/ouRPu9GzzQp9jrsmJs+/N3v2cpqXRAgNOlCFzkGBBBAAAEEEEAAAQQQQAABBBAwFyA0MSelIAIIIIAAAggggAACCCCAAAIIdEGA0KQLXeQYEEAAAQQQQAABBBBAAAEEEEDAXIDQxJyUgggggAACCCCAAAIIIIAAAggg0AUBQpMudJFjQAABBBBAAAEEEEAAAQQQQAABcwFCE3NSCiKAAAIIIIAAAggggAACCCCAQBcECE260EWOAQEEEEAAAQQQQAABBBBAAAEEzAUITcxJKYgAAggggAACCCCAAAIIIIAAAl0QIDTpQhc5BgQQQAABBBBAAAEEEEAAAQQQMBcgNDEnpSACCCCAAAIIIIAAAggggAACCHRBgNCkC13kGBBAAAEEEEAAAQQQQAABBBBAwFyA0MSclIIIIIAAAggggAACCCCAAAIIINAFAUKTLnSRY0AAAQQQQAABBBBAAAEEEEAAAXMBQhNzUgoigAACCCCAAAIIIIAAAggggEAXBAhNutBFjgEBBBBAAAEEEEAAAQQQQAABBMwFCE3MSSmIAAIIIIAAAggggAACCCCAAAJdECA06UIXOQYEEEAAAQQQQAABBBBAAAEEEDAXIDQxJ6UgAggggAACCCCAAAIIIIAAAgh0QYDQpAtd5BgQQAABBBBAAAEEEEAAAQQQQMBcgNDEnJSCCCCAAAIIIIAAAggggAACCCDQBQFCky50kWNAAAEEEEAAAQQQQAABBBBAAAFzAUITc1IKIoAAAggggAACCCCAAAIIIIBAFwQITbrQRY4BAQQQQAABBBBAAAEEEEAAAQTMBQhNzEkpiAACCCCAAAIIIIAAAggggAACXRAgNOlCFzkGBBBAAAEEEEAAAQQQQAABBBAwFyA0MSelIAIIIIAAAggggAACCCCAAAIIdEGA0KQLXeQYEEAAAQQQQAABBBBAAAEEEEDAXIDQxJyUgggggAACCCCAAAIIIIAAAggg0AUBQpMudJFjQAABBBBAAAEEEEAAAQQQQAABcwFCE3NSCiKAAAIIIIAAAggggAACCCCAQBcECE260EWOAQEEEEAAAQQQQAABBBBAAAEEzAUITcxJKYgAAggggAACCCCAAAIIIIAAAl0QIDTpQhc5BgQQQAABBBBAAAEEEEAAAQQQMBcgNDEnpSACCCCAAAIIIIAAAggggAACCHRBgNCkC13kGBBAAAEEEEAAAQQQQAABBBBAwFyA0MSclIIIIIAAAggggAACCCCAAAIIINAFAUKTLnSRY0AAAQQQQAABBBBAAAEEEEAAAXMBQhNzUgoigAACCCCAAAIIIIAAAggggEAXBAhNutBFjgEBBBBAAAEEEEAAAQQQQAABBMwFCE3MSSmIAAIIIIAAAggggAACCCCAAAJdECA06UIXOQYEEEAAAQQQQAABBBBAAAEEEDAXIDQxJ6UgAggggAACCCCAAAIIIIAAAgh0QYDQpAtd5BgQQAABBBBAAAEEEEAAAQQQQMBcgNDEnJSCCCCAAAIIIIAAAggggAACCCDQBQFCky50kWNAAAEEEEAAAQQQQAABBBBAAAFzAUITc1IKIoAAAggggAACCCCAAAIIIIBAFwQITbrQRY4BAQQQQAABBBBAAAEEEEAAAQTMBQhNzEkpiAACCCCAAAIIIIAAAggggAACXRAgNOlCFzkGBBBAAAEEEEAAAQQQQAABBBAwFyA0MSelIAIIIIAAAggggAACCCCAAAIIdEGA0KQLXeQYEEAAAQQQQAABBBBAAAEEEEDAXIDQxJyUgggggAACCCCAAAIIIIAAAggg0AUBQpMudJFjQAABBBBAAAEEEEAAAQQQQAABcwFCE3NSCiKAAAIIIIAAAggggAACCCCAQBcECE260EWOAQEEEEAAAQQQQAABBBBAAAEEzAUITcxJKYgAAggggAACCCCAAAIIIIAAAl0QIDTpQhc5BgQQQAABBBBAAAEEEEAAAQQQMBcgNDEnpSACCCCAAAIIIIAAAggggAACCHRBgNCkC13kGBBAAAEEEEAAAQQQQAABBBBAwFyA0MSclIIIIIAAAggggAACCCCAAAIIINAFAUKTLnSRY0AAAQQQQAABBBBAAAEEEEAAAXMBQhNzUgoigAACCCCAAAIIIIAAAggggEAXBAhNutBFjgEBBBBAAAEEEEAAAQQQQAABBMwFCE3MSSmIAAIIIIAAAggggAACCCCAAAJdECA06UIXOQYEEEAAAQQQQAABBBBAAAEEEDAXIDQxJ6UgAggggAACCCCAAAIIIIAAAgh0QYDQpAtd5BgQQAABBBBAAAEEEEAAAQQQQMBcgNDEnJSCCCCAAAIIIIAAAggggAACCCDQBQFCky50kWNAAAEEEEAAAQQQQAABBBBAAAFzAUITc1IKIoAAAggggAACCCCAAAIIIIBAFwQITbrQRY4BAQQQQAABBBBAAAEEEEAAAQTMBQhNzEkpiAACCCCAAAIIIIAAAggggAACXRAgNOlCFzkGBBBAAAEEEEAAAQQQQAABBBAwFyA0MSelIAIIIIAAAggggAACCCCAAAIIdEGA0KQLXeQYEEAAAQQQQAABBBBAAAEEEEDAXIDQxJyUgggggAACCCCAAAIIIIAAAggg0AUBQpMudJFjQAABBBBAAAEEEEAAAQQQQAABcwFCE3NSCiKAAAIIIIAAAggggAACCCCAQBcECE260EWOAQEEEEAAAQQQQAABBBBAAAEEzAX+f4Oe29vAzioZAAAAAElFTkSuQmCC" alt="img"></p>
<h3 id="数据到图形的映射"><a href="#数据到图形的映射" class="headerlink" title="数据到图形的映射"></a>数据到图形的映射</h3><ul>
<li>指定 <code>数据集</code> 的列（column）还是行（row）映射为 <code>系列</code>（<code>series</code>）。这件事可以使用 <a href="https://echarts.apache.org/option.html##series.seriesLayoutBy">series.seriesLayoutBy</a> 属性来配置。默认是按照列（column）来映射。</li>
<li>指定维度映射的规则：如何从 dataset 的维度（一个“维度”的意思是一行/列）映射到坐标轴（如 X、Y 轴）、提示框（tooltip）、标签（label）、图形元素大小颜色等（visualMap）。这件事可以使用 <a href="https://echarts.apache.org/option.html##series.encode">series.encode</a> 属性，以及 <a href="https://echarts.apache.org/option.html##visualMap">visualMap</a> 组件来配置（如果有需要映射颜色大小等视觉维度的话）。上面的例子中，没有给出这种映射配置，那么 ECharts 就按最常见的理解进行默认映射：X 坐标轴声明为类目轴，默认情况下会自动对应到 <code>dataset.source</code> 中的第一列；三个柱图系列，一一对应到 <code>dataset.source</code> 中后面每一列。</li>
</ul>
<h4 id="series-seriesLayoutBy"><a href="#series-seriesLayoutBy" class="headerlink" title="series.seriesLayoutBy"></a>series.seriesLayoutBy</h4><p>把数据集（ dataset ）的行或列映射为系列（series）</p>
<p><a href="https://echarts.apache.org/option.html##series.seriesLayoutBy">series.seriesLayoutBy</a> </p>
<ul>
<li>‘column’: 默认值。系列被安放到 <code>dataset</code> 的列上面。</li>
<li>‘row’: 系列被安放到 <code>dataset</code> 的行上面。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">    legend: &#123;&#125;,</span><br><span class="line">    tooltip: &#123;&#125;,</span><br><span class="line">    dataset: &#123;</span><br><span class="line">        source: [</span><br><span class="line">            [&#x27;product&#x27;, &#x27;2012&#x27;, &#x27;2013&#x27;, &#x27;2014&#x27;, &#x27;2015&#x27;],</span><br><span class="line">            [&#x27;Matcha Latte&#x27;, 41.1, 30.4, 65.1, 53.3],</span><br><span class="line">            [&#x27;Milk Tea&#x27;, 86.5, 92.1, 85.7, 83.1],</span><br><span class="line">            [&#x27;Cheese Cocoa&#x27;, 24.1, 67.2, 79.5, 86.4]</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: [</span><br><span class="line">        &#123;type: &#x27;category&#x27;, gridIndex: 0&#125;,</span><br><span class="line">        &#123;type: &#x27;category&#x27;, gridIndex: 1&#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [</span><br><span class="line">        &#123;gridIndex: 0&#125;,</span><br><span class="line">        &#123;gridIndex: 1&#125;</span><br><span class="line">    ],</span><br><span class="line">    grid: [</span><br><span class="line">        &#123;bottom: &#x27;55%&#x27;&#125;,</span><br><span class="line">        &#123;top: &#x27;55%&#x27;&#125;</span><br><span class="line">    ],</span><br><span class="line">    series: [</span><br><span class="line">        // 这几个系列会在第一个直角坐标系中，每个系列对应到 dataset 的每一行。</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, seriesLayoutBy: &#x27;row&#x27;&#125;,</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, seriesLayoutBy: &#x27;row&#x27;&#125;,</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, seriesLayoutBy: &#x27;row&#x27;&#125;,</span><br><span class="line">        // 这几个系列会在第二个直角坐标系中，每个系列对应到 dataset 的每一列。</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, xAxisIndex: 1, yAxisIndex: 1&#125;,</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, xAxisIndex: 1, yAxisIndex: 1&#125;,</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, xAxisIndex: 1, yAxisIndex: 1&#125;,</span><br><span class="line">        &#123;type: &#x27;bar&#x27;, xAxisIndex: 1, yAxisIndex: 1&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,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ozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgkoDQJBK8bgkQIECAAAECBAgQIECAAIG0BYQmaY+P6ggQIECAAAECBAgQIECAAIFIAkKTSPC6JUCAAAECBAgQIECAAAECBNIWEJqkPT6qI0CAAAECBAgQIECAAAECBCIJCE0iweuWAAECBAgQIECAAAECBAgQSFtAaJL2+KiOAAECBAgQIECAAAECBAgQiCQgNIkEr1sCBAgQIECAAAECBAgQIEAgbQGhSdrjozoCBAgQIECAAAECBAgQIEAgksD/AxQoClMIpiGJAAAAAElFTkSuQmCC" alt="img"></p>
<h4 id="series-encode"><a href="#series-encode" class="headerlink" title="series.encode"></a>series.encode</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> option = &#123;</span><br><span class="line">  <span class="attr">dataset</span>: &#123;</span><br><span class="line">    <span class="attr">source</span>: [</span><br><span class="line">      [<span class="string">&#x27;score&#x27;</span>, <span class="string">&#x27;amount&#x27;</span>, <span class="string">&#x27;product&#x27;</span>],</span><br><span class="line">      [<span class="number">89.3</span>, <span class="number">58212</span>, <span class="string">&#x27;Matcha Latte&#x27;</span>],</span><br><span class="line">      [<span class="number">57.1</span>, <span class="number">78254</span>, <span class="string">&#x27;Milk Tea&#x27;</span>],</span><br><span class="line">      [<span class="number">74.4</span>, <span class="number">41032</span>, <span class="string">&#x27;Cheese Cocoa&#x27;</span>],</span><br><span class="line">      [<span class="number">50.1</span>, <span class="number">12755</span>, <span class="string">&#x27;Cheese Brownie&#x27;</span>],</span><br><span class="line">      [<span class="number">89.7</span>, <span class="number">20145</span>, <span class="string">&#x27;Matcha Cocoa&#x27;</span>],</span><br><span class="line">      [<span class="number">68.1</span>, <span class="number">79146</span>, <span class="string">&#x27;Tea&#x27;</span>],</span><br><span class="line">      [<span class="number">19.6</span>, <span class="number">91852</span>, <span class="string">&#x27;Orange Juice&#x27;</span>],</span><br><span class="line">      [<span class="number">10.6</span>, <span class="number">101852</span>, <span class="string">&#x27;Lemon Juice&#x27;</span>],</span><br><span class="line">      [<span class="number">32.7</span>, <span class="number">20112</span>, <span class="string">&#x27;Walnut Brownie&#x27;</span>]</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">xAxis</span>: &#123;&#125;,</span><br><span class="line">  <span class="attr">yAxis</span>: &#123; <span class="attr">type</span>: <span class="string">&#x27;category&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">      <span class="attr">encode</span>: &#123;</span><br><span class="line">        <span class="comment">// 将 &quot;amount&quot; 列映射到 X 轴。</span></span><br><span class="line">        <span class="attr">x</span>: <span class="string">&#x27;amount&#x27;</span>,</span><br><span class="line">        <span class="comment">// 将 &quot;product&quot; 列映射到 Y 轴。</span></span><br><span class="line">        <span class="attr">y</span>: <span class="string">&#x27;product&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 在任何坐标系和系列中，都支持：</span></span><br><span class="line">encode: &#123;</span><br><span class="line">  <span class="comment">// 使用 “名为 product 的维度” 和 “名为 score 的维度” 的值在 tooltip 中显示</span></span><br><span class="line">  <span class="attr">tooltip</span>: [<span class="string">&#x27;product&#x27;</span>, <span class="string">&#x27;score&#x27;</span>]</span><br><span class="line">  <span class="comment">// 使用 “维度 1” 和 “维度 3” 的维度名连起来作为系列名。（有时候名字比较长，这可以避免在 series.name 重复输入这些名字）</span></span><br><span class="line">  <span class="attr">seriesName</span>: [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="comment">// 表示使用 “维度2” 中的值作为 id。这在使用 setOption 动态更新数据时有用处，可以使新老数据用 id 对应起来，从而能够产生合适的数据更新动画。</span></span><br><span class="line">  <span class="attr">itemId</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="comment">// 指定数据项的名称使用 “维度3” 在饼图等图表中有用，可以使这个名字显示在图例（legend）中。</span></span><br><span class="line">  <span class="attr">itemName</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直角坐标系（grid/cartesian）特有的属性：</span></span><br><span class="line"><span class="attr">encode</span>: &#123;</span><br><span class="line">  <span class="comment">// 把 “维度1”、“维度5”、“名为 score 的维度” 映射到 X 轴：</span></span><br><span class="line">  <span class="attr">x</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="string">&#x27;score&#x27;</span>],</span><br><span class="line">  <span class="comment">// 把“维度0”映射到 Y 轴。</span></span><br><span class="line">  <span class="attr">y</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单轴（singleAxis）特有的属性：</span></span><br><span class="line"><span class="attr">encode</span>: &#123;</span><br><span class="line">  <span class="attr">single</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 极坐标系（polar）特有的属性：</span></span><br><span class="line"><span class="attr">encode</span>: &#123;</span><br><span class="line">  <span class="attr">radius</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">angle</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 地理坐标系（geo）特有的属性：</span></span><br><span class="line"><span class="attr">encode</span>: &#123;</span><br><span class="line">  <span class="attr">lng</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">lat</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于一些没有坐标系的图表，例如饼图、漏斗图等，可以是：</span></span><br><span class="line"><span class="attr">encode</span>: &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABE0AAAHCCAYAAAAaQTeLAAAAAXNSR0IArs4c6QAAIABJREFUeF7t3V+sZdd5GPa179Dl1HVIEZVhwRRpxgXS2jFSQC8MyZfRQ01CKKAAEksWtSE0TPI2vEMWATgRqhkKlYcPLWcuJw+BYAECYqAkSAZNgQii8mBACCnRKFAgkp2RXuxSYpEAsclhUIODeO4u9r13X+7Zd59z1rlnnX3WOvs3LxLv3Wetb/2+75571nf3nyr4R4AAAQIECBAgQIAAAQIECBAgcEKgYkKAAAECBAgQIECAAAECBAgQIHBSQNNEVRAgQIAAAQIECBAgQIAAAQIEBgQ0TZQFAQIECBAgQIAAAQIECBAgQEDTRA0QIECAAAECBAgQIECAAAECBOIEnGkS5+QoAgQIECBAgAABAgQIECBAYGICmiYTS7jlEiBAgAABAgQIECBAgAABAnECmiZxTo4iQIAAAQIECBAgQIAAAQIEJiagaTKxhFsuAQIECBAgQIAAAQIECBAgECegaRLn5CgCBAgQIECAAAECBAgQIEBgYgKaJhNLuOUSIECAAAECBAgQIECAAAECcQKaJnFOjiJAgAABAgQIECBAgAABAgQmJqBpMrGEWy4BAgQIECBAgAABAgQIECAQJ6BpEufkKAIECBAgQIAAAQIECBAgQGBiApomE0u45RIgQIAAAQIECBAgQIAAAQJxApomcU6OIkCAAAECBAgQIECAAAECBCYmoGkysYRbLgECBAgQIECAAAECBAgQIBAnoGkS5+QoAgQIECBAgAABAgQIECBAYGICmiYTS7jlEiBAgAABAgQIECBAgAABAnECmiZxTo4iQIAAAQIECBAgQIAAAQIEJiagaTKxhFsuAQIECBAgQIAAAQIECBAgECegaRLn5CgCBAgQIECAAAECBAgQIEBgYgKaJhNLuOUSIECAAAECBAgQIECAAAECcQKaJnFOjiJAgAABAgQIECBAgAABAgQmJqBpMrGEWy4BAgQIECBAgAABAgQIECAQJ6BpEufkKAIECBAgQIAAAQIECBAgQGBiApomE0u45RIgQIAAAQIECBAgQIAAAQJxApomcU6OIkCAAAECBAgQIECAAAECBCYmoGkysYRbLgECBAgQIECAAAECBAgQIBAnoGkS5+QoAgQIECBAgAABAgQIECBAYGICmiYTS7jlEiBAgAABAgQIECBAgAABAnECmiZxTo4iQIAAAQIECBAgQIAAAQIEJiagaTKxhFsuAQIECBAgQIAAAQIECBAgECegaRLn5CgCBAgQIECAAAECBAgQIEBgYgKaJhNLuOUSIECAAAECBAgQIECAAAECcQKaJnFOjiJAgAABAgQIECBAgAABAgQmJqBpMrGEWy4BAgQIECBAgAABAgQIECAQJ6BpEufkKAIECBAgQIAAAQIECBAgQGBiApomE0u45RIgQIAAAQIECBAgQIAAAQJxApomcU6OIkCAAAECBAgQIECAAAECBCYmoGkysYRbLgECBAgQIECAAAECBAgQIBAnoGkS5+QoAgQIECBAgAABAgQIECBAYGICmiYTS7jlEiBAgAABAgQIECBAgAABAnECmiZxTo4iQIAAAQIECBAgQIAAAQIEJiagaTKxhFsuAQIECBAgQIAAAQIECBAgECegaRLn5CgCBAgQIECAAAECBAgQIEBgYgKaJhNLuOUSIECAAAECBAgQIECAAAECcQKaJnFOjiJAgAABAgQIECBAgAABAgQmJqBpMrGEWy4BAgQIECBAgAABAgQIECAQJ6BpEufkKAIECBAgQIAAAQIECBAgQGBiApomE0u45RIgQIAAAQIECBAgQIAAAQJxApomcU6OIkCAAAECBAgQIECAAAECBCYmoGkysYRbLgECBAgQIECAAAECBAgQIBAnoGkS5+QoAgQIECBAgAABAgQIECBAYGICmiYTS7jlEiBAgAABAgQIECBAgAABAnECmiZxTo4iQIAAAQIECBAgQIAAAQIEJiagaTKxhFsuAQIECBAgQIAAAQIECBAgECegaRLn5CgCBAgQIECAAAECBAgQIEBgYgKaJhNLuOUSIECAAAECBAgQIECAAAECcQKaJnFOjiJAgAABAgQIECBAgAABAgQmJqBpMrGEWy4BAgQIECBAgAABAgQIECAQJ6BpEufkKAIECBAgQIAAAQIECBAgQGBiApomE0u45RIgQIAAAQIECBAgQIAAAQJxApomcU6OIkCAAAECBAgQIECAAAECBCYmoGkysYRbLgECBAgQIECAAAECBAgQIBAnoGkS5+QoAgQIECBAgAABAgQIECBAYGICmiYTS7jlEiBAgAABAgQIECBAgAABAnECmiZxTo4iQIAAAQIECBAgQIAAAQIE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" alt="img"></p>
<h3 id="维度（-dimension-）"><a href="#维度（-dimension-）" class="headerlink" title="维度（ dimension ）"></a>维度（ dimension ）</h3><p>现在，当我们把系列（ series ）对应到“列”的时候，那么每一列就称为一个“维度（ dimension ）”，而每一行称为数据项（ item ）。反之，如果我们把系列（ series ）对应到表行，那么每一行就是“维度（ dimension ）”，每一列就是数据项（ item ）。</p>
<p>维度可以有单独的名字，便于在图表中显示。维度名（ dimension name ）可以在定义在 dataset 的第一行（或者第一列）。例如上面的例子中，<code>&#39;score&#39;</code>、<code>&#39;amount&#39;</code>、<code>&#39;product&#39;</code> 就是维度名。从第二行开始，才是正式的数据。当然也可以设置 <code>dataset.sourceHeader: true</code> 显示声明第一行（列）就是维度，或者 <code>dataset.sourceHeader: false</code> 表明第一行（列）开始就直接是数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//维度的定义，也可以使用单独的 dataset.dimensions 或者 series.dimensions 来定义，这样可以同时指定维度名，和维度的类型（ dimension type ）</span></span><br><span class="line"><span class="keyword">var</span> option1 = &#123;</span><br><span class="line">  <span class="attr">dataset</span>: &#123;</span><br><span class="line">    <span class="attr">dimensions</span>: [</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;score&#x27;</span> &#125;,</span><br><span class="line">      <span class="comment">// 可以简写为 string ，表示 dimension name 。</span></span><br><span class="line">      <span class="string">&#x27;amount&#x27;</span>,</span><br><span class="line">      <span class="comment">// 可以在 type 中指定维度类型。</span></span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;product&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;ordinal&#x27;</span> &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">source</span>: [</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> option2 = &#123;</span><br><span class="line">  <span class="attr">dataset</span>: &#123;</span><br><span class="line">    <span class="attr">source</span>: [</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">series</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;line&#x27;</span>,</span><br><span class="line">    <span class="comment">// series.dimensions 会更优先于 dataset.dimension 采纳。</span></span><br><span class="line">    <span class="attr">dimensions</span>: [</span><br><span class="line">      <span class="literal">null</span>, <span class="comment">// 可以设置为 null 表示不想设置维度名</span></span><br><span class="line">      <span class="string">&#x27;amount&#x27;</span>,</span><br><span class="line">      &#123; <span class="attr">name</span>: <span class="string">&#x27;product&#x27;</span>, <span class="attr">type</span>: <span class="string">&#x27;ordinal&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="数据转换transform"><a href="#数据转换transform" class="headerlink" title="数据转换transform"></a>数据转换transform</h3><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>标题组件，包含主标题和副标题。</p>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p><a href="https://echarts.apache.org/examples/zh/editor.html?c=scatter-anscombe-quartet&amp;edit=1&amp;reset=1">https://echarts.apache.org/examples/zh/editor.html?c=scatter-anscombe-quartet&amp;edit=1&amp;reset=1</a></p>
<p>容器中的图表位置，单个 grid 内最多可以放置上下两个 X 轴，左右两个 Y 轴。</p>
<ul>
<li>Axis. gridIndex<ul>
<li>x 轴所在的 grid 的索引，默认位于第一个 grid。</li>
</ul>
</li>
<li></li>
</ul>
<h3 id="xAxis"><a href="#xAxis" class="headerlink" title="xAxis"></a>xAxis</h3><ul>
<li>type<ul>
<li>category（默认），数据在x轴展示</li>
<li>value，数据在y轴展示</li>
</ul>
</li>
</ul>
<h3 id="series"><a href="#series" class="headerlink" title="series"></a>series</h3><ul>
<li>name（有的话，legend可以不用配置）</li>
<li>showSymbol，开始不显示拐点，鼠标经过显示</li>
<li>itemStyle：设置拐点颜色以及边框</li>
<li>radius：设置饼状图大小 ，[内圆，外圆]</li>
</ul>
<h2 id="API和事件"><a href="#API和事件" class="headerlink" title="API和事件"></a>API和事件</h2><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>在 Apache ECharts 的图表中用户的操作将会触发相应的事件。开发者可以监听这些事件，然后通过回调函数做相应的处理，比如跳转到一个地址，或者弹出对话框，或者做数据下钻等等。</p>
<p>ECharts 中的事件名称对应 DOM 事件名称，均为小写的字符串，如下是一个绑定点击操作的示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myChart.on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 控制台打印数据的名称</span></span><br><span class="line">  <span class="built_in">console</span>.log(params.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在 ECharts 中事件分为两种类型，一种是用户鼠标操作点击，或者 hover 图表的图形时触发的事件，还有一种是用户在使用可以交互的组件后触发的行为事件，例如在切换图例开关时触发的 <a href="https://echarts.apache.org/api.html#events.legendselectchanged">‘legendselectchanged’</a> 事件（这里需要注意切换图例开关是不会触发 <code>&#39;legendselected&#39;</code> 事件的），数据区域缩放时触发的 <a href="https://echarts.apache.org/api.html#events.legendselectchanged">‘datazoom’</a> 事件等等。</p>
<h4 id="鼠标事件的处理"><a href="#鼠标事件的处理" class="headerlink" title="鼠标事件的处理"></a>鼠标事件的处理</h4><p>ECharts 支持常规的鼠标事件类型，包括 <code>&#39;click&#39;</code>、 <code>&#39;dblclick&#39;</code>、 <code>&#39;mousedown&#39;</code>、 <code>&#39;mousemove&#39;</code>、 <code>&#39;mouseup&#39;</code>、 <code>&#39;mouseover&#39;</code>、 <code>&#39;mouseout&#39;</code>、 <code>&#39;globalout&#39;</code>、 <code>&#39;contextmenu&#39;</code> 事件。下面先来看一个简单的点击柱状图后打开相应的百度搜索页面的示例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 基于准备好的dom，初始化ECharts实例</span><br><span class="line">// var myChart = echarts.init(document.getElementById(&#x27;main&#x27;));</span><br><span class="line"></span><br><span class="line">// 指定图表的配置项和数据</span><br><span class="line">var option = &#123;</span><br><span class="line">  xAxis: &#123;</span><br><span class="line">    data: [&#x27;衬衫&#x27;, &#x27;羊毛衫&#x27;, &#x27;雪纺衫&#x27;, &#x27;裤子&#x27;, &#x27;高跟鞋&#x27;, &#x27;袜子&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  yAxis: &#123;&#125;,</span><br><span class="line">  series: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;销量&#x27;,</span><br><span class="line">      type: &#x27;bar&#x27;,</span><br><span class="line">      data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line">// 使用刚指定的配置项和数据显示图表。</span><br><span class="line">myChart.setOption(option);</span><br><span class="line">// 处理点击事件并且跳转到相应的百度搜索页面</span><br><span class="line">myChart.on(&#x27;click&#x27;, function(params) &#123;</span><br><span class="line">  window.open(&#x27;https://www.baidu.com/s?wd=&#x27; + encodeURIComponent(params.name));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>LIVE</p>
<p>所有的鼠标事件包含参数 <code>params</code>，这是一个包含点击图形的数据信息的对象，如下格式：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> EventParams = &#123;</span><br><span class="line">  <span class="comment">// 当前点击的图形元素所属的组件名称，</span></span><br><span class="line">  <span class="comment">// 其值如 &#x27;series&#x27;、&#x27;markLine&#x27;、&#x27;markPoint&#x27;、&#x27;timeLine&#x27; 等。</span></span><br><span class="line">  <span class="attr">componentType</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 系列类型。值可能为：&#x27;line&#x27;、&#x27;bar&#x27;、&#x27;pie&#x27; 等。当 componentType 为 &#x27;series&#x27; 时有意义。</span></span><br><span class="line">  seriesType: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 系列在传入的 option.series 中的 index。当 componentType 为 &#x27;series&#x27; 时有意义。</span></span><br><span class="line">  seriesIndex: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 系列名称。当 componentType 为 &#x27;series&#x27; 时有意义。</span></span><br><span class="line">  seriesName: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 数据名，类目名</span></span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 数据在传入的 data 数组中的 index</span></span><br><span class="line">  dataIndex: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 传入的原始数据项</span></span><br><span class="line">  data: <span class="built_in">Object</span>;</span><br><span class="line">  <span class="comment">// sankey、graph 等图表同时含有 nodeData 和 edgeData 两种 data，</span></span><br><span class="line">  <span class="comment">// dataType 的值会是 &#x27;node&#x27; 或者 &#x27;edge&#x27;，表示当前点击在 node 还是 edge 上。</span></span><br><span class="line">  <span class="comment">// 其他大部分图表中只有一种 data，dataType 无意义。</span></span><br><span class="line">  dataType: <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// 传入的数据值</span></span><br><span class="line">  value: <span class="built_in">number</span> | <span class="built_in">Array</span>;</span><br><span class="line">  <span class="comment">// 数据图形的颜色。当 componentType 为 &#x27;series&#x27; 时有意义。</span></span><br><span class="line">  color: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>如何区分鼠标点击到了哪里：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myChart.on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (params.componentType === <span class="string">&#x27;markPoint&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 点击到了 markPoint 上</span></span><br><span class="line">    <span class="keyword">if</span> (params.seriesIndex === <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="comment">// 点击到了 index 为 5 的 series 的 markPoint 上。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params.componentType === <span class="string">&#x27;series&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (params.seriesType === <span class="string">&#x27;graph&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (params.dataType === <span class="string">&#x27;edge&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 点击到了 graph 的 edge（边）上。</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 点击到了 graph 的 node（节点）上。</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>使用 <code>query</code> 只对指定的组件的图形元素的触发回调：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.on(eventName, query, handler);</span><br></pre></td></tr></table></figure>



<p><code>query</code> 可为 <code>string</code> 或者 <code>Object</code>。</p>
<p>如果为 <code>string</code> 表示组件类型。格式可以是 ‘mainType’ 或者 ‘mainType.subType’。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;series&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;series.line&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;dataZoom&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;click&#x27;</span>, <span class="string">&#x27;xAxis.category&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure>



<p>如果为 <code>Object</code>，可以包含以下一个或多个属性，每个属性都是可选的：</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  $&#123;mainType&#125;Index: <span class="built_in">number</span> <span class="comment">// 组件 index</span></span><br><span class="line">  $&#123;mainType&#125;Name: <span class="built_in">string</span> <span class="comment">// 组件 name</span></span><br><span class="line">  $&#123;mainType&#125;Id: <span class="built_in">string</span> <span class="comment">// 组件 id</span></span><br><span class="line">  <span class="attr">dataIndex</span>: <span class="built_in">number</span> <span class="comment">// 数据项 index</span></span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span> <span class="comment">// 数据项 name</span></span><br><span class="line">  <span class="attr">dataType</span>: <span class="built_in">string</span> <span class="comment">// 数据项 type，如关系图中的 &#x27;node&#x27;, &#x27;edge&#x27;</span></span><br><span class="line">  <span class="attr">element</span>: <span class="built_in">string</span> <span class="comment">// 自定义系列中的 el 的 name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.setOption(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;uuu&#x27;</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;mouseover&#x27;</span>, &#123; <span class="attr">seriesName</span>: <span class="string">&#x27;uuu&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// series name 为 &#x27;uuu&#x27; 的系列中的图形元素被 &#x27;mouseover&#x27; 时，此方法被回调。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.setOption(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="attr">data</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span>, <span class="attr">value</span>: <span class="number">121</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;yy&#x27;</span>, <span class="attr">value</span>: <span class="number">33</span> &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;mouseover&#x27;</span>, &#123; <span class="attr">seriesIndex</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;xx&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// series index 1 的系列中的 name 为 &#x27;xx&#x27; 的元素被 &#x27;mouseover&#x27; 时，此方法被回调。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.setOption(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">series</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="string">&#x27;graph&#x27;</span>,</span><br><span class="line">      <span class="attr">nodes</span>: [</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span>, <span class="attr">value</span>: <span class="number">10</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span>, <span class="attr">value</span>: <span class="number">20</span> &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="attr">edges</span>: [&#123; <span class="attr">source</span>: <span class="number">0</span>, <span class="attr">target</span>: <span class="number">1</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;click&#x27;</span>, &#123; <span class="attr">dataType</span>: <span class="string">&#x27;node&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关系图的节点被点击时此方法被回调。</span></span><br><span class="line">&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;click&#x27;</span>, &#123; <span class="attr">dataType</span>: <span class="string">&#x27;edge&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 关系图的边被点击时此方法被回调。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chart.setOption(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">series</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;custom&#x27;</span>,</span><br><span class="line">    <span class="attr">renderItem</span>: <span class="function"><span class="keyword">function</span>(<span class="params">params, api</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">type</span>: <span class="string">&#x27;group&#x27;</span>,</span><br><span class="line">        <span class="attr">children</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;my_el&#x27;</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">data</span>: [[<span class="number">12</span>, <span class="number">33</span>]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">chart.on(<span class="string">&#x27;mouseup&#x27;</span>, &#123; <span class="attr">element</span>: <span class="string">&#x27;my_el&#x27;</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// name 为 &#x27;my_el&#x27; 的元素被 &#x27;mouseup&#x27; 时，此方法被回调。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<p>你可以在回调函数中获得这个对象中的数据名、系列名称后在自己的数据仓库中索引得到其它的信息后更新图表，显示浮层等等，如下示例代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myChart.on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">parmas</span>) </span>&#123;</span><br><span class="line">  $.get(<span class="string">&#x27;detail?q=&#x27;</span> + params.name, <span class="function"><span class="keyword">function</span>(<span class="params">detail</span>) </span>&#123;</span><br><span class="line">    myChart.setOption(&#123;</span><br><span class="line">      <span class="attr">series</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">name</span>: <span class="string">&#x27;pie&#x27;</span>,</span><br><span class="line">          <span class="comment">// 通过饼图表现单个柱子中的数据分布</span></span><br><span class="line">          <span class="attr">data</span>: [detail.data]</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="组件交互的行为事件"><a href="#组件交互的行为事件" class="headerlink" title="组件交互的行为事件"></a>组件交互的行为事件</h4><p>在 ECharts 中基本上所有的组件交互行为都会触发相应的事件，常用的事件和事件对应参数在 <a href="https://echarts.apache.org//api.html#events">events</a> 文档中有列出。</p>
<p>下面是监听一个图例开关的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 图例开关的行为只会触发 legendselectchanged 事件</span></span><br><span class="line">myChart.on(<span class="string">&#x27;legendselectchanged&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取点击图例的选中状态</span></span><br><span class="line">  <span class="keyword">var</span> isSelected = params.selected[params.name];</span><br><span class="line">  <span class="comment">// 在控制台中打印</span></span><br><span class="line">  <span class="built_in">console</span>.log((isSelected ? <span class="string">&#x27;选中了&#x27;</span> : <span class="string">&#x27;取消选中了&#x27;</span>) + <span class="string">&#x27;图例&#x27;</span> + params.name);</span><br><span class="line">  <span class="comment">// 打印所有图例的状态</span></span><br><span class="line">  <span class="built_in">console</span>.log(params.selected);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="代码触发-ECharts-中组件的行为"><a href="#代码触发-ECharts-中组件的行为" class="headerlink" title="代码触发 ECharts 中组件的行为"></a>代码触发 ECharts 中组件的行为</h4><p>上面提到诸如 <code>&#39;legendselectchanged&#39;</code> 事件会由组件交互的行为触发，那除了用户的交互操作，有时候也会有需要在程序里调用方法触发图表的行为，诸如显示 tooltip，选中图例。</p>
<p>在 ECharts 通过调用 <code>myChart.dispatchAction(&#123; type: &#39;&#39; &#125;)</code> 触发图表行为，统一管理了所有动作，也可以方便地根据需要去记录用户的行为路径。</p>
<p>常用的动作和动作对应参数在 <a href="https://echarts.apache.org//api.html#action">action</a> 文档中有列出。</p>
<p>下面示例演示了如何通过 <code>dispatchAction</code> 去轮流高亮饼图的每个扇形。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option = &#123;</span><br><span class="line">  title: &#123;</span><br><span class="line">    text: &#x27;饼图程序调用高亮示例&#x27;,</span><br><span class="line">    left: &#x27;center&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  tooltip: &#123;</span><br><span class="line">    trigger: &#x27;item&#x27;,</span><br><span class="line">    formatter: &#x27;&#123;a&#125; &lt;br/&gt;&#123;b&#125; : &#123;c&#125; (&#123;d&#125;%)&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  legend: &#123;</span><br><span class="line">    orient: &#x27;vertical&#x27;,</span><br><span class="line">    left: &#x27;left&#x27;,</span><br><span class="line">    data: [&#x27;直接访问&#x27;, &#x27;邮件营销&#x27;, &#x27;联盟广告&#x27;, &#x27;视频广告&#x27;, &#x27;搜索引擎&#x27;]</span><br><span class="line">  &#125;,</span><br><span class="line">  series: [</span><br><span class="line">    &#123;</span><br><span class="line">      name: &#x27;访问来源&#x27;,</span><br><span class="line">      type: &#x27;pie&#x27;,</span><br><span class="line">      radius: &#x27;55%&#x27;,</span><br><span class="line">      center: [&#x27;50%&#x27;, &#x27;60%&#x27;],</span><br><span class="line">      data: [</span><br><span class="line">        &#123; value: 335, name: &#x27;直接访问&#x27; &#125;,</span><br><span class="line">        &#123; value: 310, name: &#x27;邮件营销&#x27; &#125;,</span><br><span class="line">        &#123; value: 234, name: &#x27;联盟广告&#x27; &#125;,</span><br><span class="line">        &#123; value: 135, name: &#x27;视频广告&#x27; &#125;,</span><br><span class="line">        &#123; value: 1548, name: &#x27;搜索引擎&#x27; &#125;</span><br><span class="line">      ],</span><br><span class="line">      emphasis: &#123;</span><br><span class="line">        itemStyle: &#123;</span><br><span class="line">          shadowBlur: 10,</span><br><span class="line">          shadowOffsetX: 0,</span><br><span class="line">          shadowColor: &#x27;rgba(0, 0, 0, 0.5)&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let currentIndex = -1;</span><br><span class="line"></span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">  var dataLen = option.series[0].data.length;</span><br><span class="line">  // 取消之前高亮的图形</span><br><span class="line">  myChart.dispatchAction(&#123;</span><br><span class="line">    type: &#x27;downplay&#x27;,</span><br><span class="line">    seriesIndex: 0,</span><br><span class="line">    dataIndex: currentIndex</span><br><span class="line">  &#125;);</span><br><span class="line">  currentIndex = (currentIndex + 1) % dataLen;</span><br><span class="line">  // 高亮当前图形</span><br><span class="line">  myChart.dispatchAction(&#123;</span><br><span class="line">    type: &#x27;highlight&#x27;,</span><br><span class="line">    seriesIndex: 0,</span><br><span class="line">    dataIndex: currentIndex</span><br><span class="line">  &#125;);</span><br><span class="line">  // 显示 tooltip</span><br><span class="line">  myChart.dispatchAction(&#123;</span><br><span class="line">    type: &#x27;showTip&#x27;,</span><br><span class="line">    seriesIndex: 0,</span><br><span class="line">    dataIndex: currentIndex</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>LIVE</p>
<p>访问来源<br>直接访问 : 335 (13.08%)</p>
<h4 id="监听“空白处”的事件"><a href="#监听“空白处”的事件" class="headerlink" title="监听“空白处”的事件"></a>监听“空白处”的事件</h4><p>有时候，开发者需要监听画布的“空白处”所触发的事件。比如，当需要在用户点击“空白处”的时候重置图表时。</p>
<p>在讨论这个功能之前，我们需要先明确两种事件。zrender 事件和 echarts 事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myChart.getZr().on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 该监听器正在监听一个`zrender 事件`。</span></span><br><span class="line">&#125;);</span><br><span class="line">myChart.on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 该监听器正在监听一个`echarts 事件`。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>zrender 事件与 echarts 事件不同。前者是当鼠标在任何地方都会被触发，而后者是只有当鼠标在图形元素上时才能被触发。事实上，echarts 事件是在 zrender 事件的基础上实现的，也就是说，当一个 zrender 事件在图形元素上被触发时，echarts 将触发一个 echarts 事件给开发者。</p>
<p>有了 zrender 事件，我们就可以实现监听空白处的事件，具体如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myChart.getZr().on(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 没有 target 意味着鼠标/指针不在任何一个图形元素上，它是从“空白处”触发的。</span></span><br><span class="line">  <span class="keyword">if</span> (!event.target) &#123;</span><br><span class="line">    <span class="comment">// 点击在了空白处，做些什么。</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>假设页面中存在多个标签页，每个标签页都包含一些图表。当选中一个标签页的时候，其他标签页的内容在 DOM 中被移除了。这样，当用户再选中这些标签页的时候，就会发现图表“不见”了。</p>
<p>本质上，这是由于图表的容器节点被移除导致的。即使之后该节点被重新添加，图表所在的节点也已经不存在了。</p>
<p>正确的做法是，在图表容器被销毁之后，调用 <a href="https://echarts.apache.org/api.html#echartsInstance.dispose"><code>echartsInstance.dispose</code></a> 销毁实例，在图表容器重新被添加后再次调用 <a href="https://echarts.apache.org//api.html#echarts.init">echarts.init</a> 初始化。</p>
<blockquote>
<p>小贴士：在容器节点被销毁时，总是应调用 <a href="https://echarts.apache.org/api.html#echartsInstance.dispose"><code>echartsInstance.dispose</code></a> 以销毁实例释放资源，避免内存泄漏。</p>
</blockquote>
<h3 id="setoption"><a href="#setoption" class="headerlink" title="setoption"></a>setoption</h3><p>切换数据</p>
<h2 id="问题合集"><a href="#问题合集" class="headerlink" title="问题合集"></a>问题合集</h2><p><a href="https://mp.weixin.qq.com/s/h6mJY0tuaw_Pr6mdRmWu5Q">https://mp.weixin.qq.com/s/h6mJY0tuaw_Pr6mdRmWu5Q</a></p>
<h2 id="Echarts-资源-🔫"><a href="#Echarts-资源-🔫" class="headerlink" title="Echarts 资源 🔫"></a>Echarts 资源 🔫</h2><blockquote>
<p>目前整个数据大屏的 Echarts 图表资源都是在社区中寻找的资源。推荐几个 Echarts 社区地址：</p>
</blockquote>
<ul>
<li>MCChart：<a href="https://link.juejin.cn/?target=http://echarts.zhangmuchen.top/%23/index">echarts.zhangmuchen.top/#/index</a></li>
<li>PPChart：<a href="https://link.juejin.cn/?target=http://www.ppchart.com/%23/">www.ppchart.com/#/</a></li>
<li>isqqw：<a href="https://link.juejin.cn/?target=https://www.isqqw.com/">www.isqqw.com/</a></li>
</ul>
<h1 id="D3-js和echarts-js不同"><a href="#D3-js和echarts-js不同" class="headerlink" title="D3.js和echarts.js不同"></a><strong>D3.js和echarts.js不同</strong></h1><p>D3.js和echarts.js都是用来生成各类图表的，区别的话可以从使用方法和实现方式上,echart.js是通过canvas来绘制图形具体使用方法是通过echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图很轻松搞定。D3.js通过svg来绘制图形,使用时需要先创建画布(svg元素),然后进行各种绘制图形。</p>
<p>从兼容方面对比两者的话,echart.js兼容到IE6及以上的所有主流浏览器，而D3.js兼容IE9及以上以及所有的主流浏览器，如果项目考虑兼容IE6，建议使用echart.js</p>
<p>从学习成本上来说,echart.js是封装好的方法可以直接调用,学习起来更加快速上手,而相对来说D3.js的学习偏底层学习起来成本较大,也正因为如此D3.js也有更大的灵活性,当你需要的图表中echart中找不到时可以来D3中自己搞定</p>
<h1 id="前端地图框架"><a href="#前端地图框架" class="headerlink" title="前端地图框架"></a>前端地图框架</h1><p>地图：<a href="https://blog.csdn.net/weixin_43216105/article/details/109715995">https://blog.csdn.net/weixin_43216105/article/details/109715995</a></p>
<ol>
<li>Leaflet<br><a href="https://leafletjs.com/">Leaflet</a> 是最著名的前端地图<a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E8%A7%86%E5%8C%96&spm=1001.2101.3001.7020">可视化</a>库，它开源、体积小、结构清晰、简单易用。</li>
<li>Mapbox GL JS<br><a href="http://www.mapbox.cn/mapbox-gl-js/overview/">Mapbox GL JS</a> 是目前最新潮的前端地图库，它的矢量压缩、动态样式和三维性能令人印象深刻。它本身是开源的，但一般依赖于Mapbox公司提供的底图服务。</li>
<li><a href="https://so.csdn.net/so/search?q=ArcGIS&spm=1001.2101.3001.7020">ArcGIS</a> API for JS<br><a href="https://developers.arcgis.com/javascript/latest/">ArcGIS API for JS</a> 是较为学院派的前端地图库，它是ArcGIS开发套件中的一部分，和桌面端和服务器端ArcGIS软件有较好的协作。它不开源且收费不低，在学术场景下较为常用。</li>
<li>Openlayers<br><a href="https://openlayers.org/">Openlayers</a> 也是常用的前端地图库，它开源，相比于Leaflet更加复杂和完备。</li>
<li>Cesium<br><a href="https://www.cesium.com/">Cesium</a> 是三维地理可视化的常用库，在大尺度的可视化（地形、建筑、地球）中十分常用。</li>
<li>百度地图 JS <a href="https://so.csdn.net/so/search?q=API&spm=1001.2101.3001.7020">API</a> /百度地图 API GL<br><a href="https://lbsyun.baidu.com/index.php?title=jspopular3.0">百度地图 JS API</a> 是传统的二维地图，百度地图 API GL 是三维地图，它们依赖百度地图提供的后台服务。除了地图服务外还有检索、导航、实时交通等关联服务。开发者有免费的限额。</li>
<li>高德地图 JS API<br><a href="https://lbs.amap.com/api/javascript-api/summary">高德地图 JS API</a> 与百度类似。</li>
<li>Google Maps JS API<br><a href="https://developers.google.com/maps/documentation/javascript/overview">谷歌地图 JS API</a> 在境外有更好的数据。</li>
<li>AntV L7<br><a href="https://antv.vision/zh/">AntV L7</a> 是空间数据可视化库，它可以使用高德地图等协作构建地图可视化。</li>
<li>Mapbox.js<br><a href="https://docs.mapbox.com/mapbox.js/api/v3.3.1/">Mapbox.js</a> 是 Leaflet 的一个扩展插件（与 Mapbox GL JS 不同）。</li>
</ol>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="引入百度地图"><a href="#引入百度地图" class="headerlink" title="引入百度地图"></a>引入百度地图</h3><h4 id="js"><a href="#js" class="headerlink" title="js"></a>js</h4><p>在vue项目里面引入百度地图api有两种方式，一个是官方文档提供</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//注意版本</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;http://api.map.baidu.com/api?v=3.0&amp;ak=你的密钥&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后在webpack里面需要配置externals选项，设置外部扩展</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">externals: &#123;</span><br><span class="line">    <span class="string">&#x27;BaiduMap&#x27;</span>: <span class="string">&#x27;BMap&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在使用的时候，组件里面需要引入</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> BaiduMap <span class="keyword">from</span> <span class="string">&#x27;BaiduMap&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">var</span> map = <span class="keyword">new</span> BaiduMap.<span class="built_in">Map</span>(xxx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="vue-baidu-map"><a href="#vue-baidu-map" class="headerlink" title="vue-baidu-map"></a>vue-baidu-map</h4><h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
<th>描述</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>enableDragging()</td>
<td>none</td>
<td>启用地图拖拽，默认启用</td>
<td></td>
</tr>
<tr>
<td>disableDragging()</td>
<td>none</td>
<td>禁用地图拖拽</td>
<td></td>
</tr>
<tr>
<td>enableInertialDragging()</td>
<td>none</td>
<td>启用地图惯性拖拽，默认禁用</td>
<td></td>
</tr>
<tr>
<td>disableInertialDragging()</td>
<td>none</td>
<td>禁用地图惯性拖拽</td>
<td></td>
</tr>
<tr>
<td>enableScrollWheelZoom()</td>
<td>none</td>
<td>允许地图可被鼠标滚轮缩放，默认禁用</td>
<td></td>
</tr>
<tr>
<td>disableScrollWheelZoom()</td>
<td>none</td>
<td>禁止地图被鼠标滚轮缩放</td>
<td></td>
</tr>
<tr>
<td>enableContinuousZoom()</td>
<td>none</td>
<td>开启双击平滑缩放效果</td>
<td></td>
</tr>
<tr>
<td>disableContinuousZoom()</td>
<td>none</td>
<td>关闭双击平滑缩放效果</td>
<td></td>
</tr>
<tr>
<td>enableResizeOnCenter()</td>
<td>none</td>
<td>开启图区resize中心点不变</td>
<td></td>
</tr>
<tr>
<td>disableResizeOnCenter()</td>
<td>none</td>
<td>关闭图区resize中心点不变</td>
<td></td>
</tr>
<tr>
<td>enableDoubleClickZoom()</td>
<td>none</td>
<td>启用地图双击缩放，左键双击放大、右键双击缩小</td>
<td></td>
</tr>
<tr>
<td>disableDoubleClickZoom()</td>
<td>none</td>
<td>取消地图双击缩放</td>
<td></td>
</tr>
<tr>
<td>enableKeyboard()</td>
<td>none</td>
<td>启用键盘操作，默认禁用。键盘的上、下、左、右键可连续移动地图。同时按下其中两个键可使地图进行对角移动。PgUp、PgDn、Home和End键会使地图平移其1/2的大小。+、-键会使地图放大或缩小一级</td>
<td></td>
</tr>
<tr>
<td>disableKeyboard()</td>
<td>none</td>
<td>禁用键盘操作</td>
<td></td>
</tr>
<tr>
<td>enablePinchToZoom()</td>
<td>none</td>
<td>启用双指缩放地图。</td>
<td></td>
</tr>
<tr>
<td>disablePinchToZoom()</td>
<td>none</td>
<td>禁用双指缩放地图。</td>
<td></td>
</tr>
<tr>
<td>enableRotateGestures()</td>
<td>none</td>
<td>是否允许通过手势旋转地图。</td>
<td></td>
</tr>
<tr>
<td>enableTiltGestures()</td>
<td>none</td>
<td>是否允许通过手势倾斜地图。</td>
<td></td>
</tr>
<tr>
<td>enableAutoResize()</td>
<td>none</td>
<td>启用自动适应容器尺寸变化，默认启用</td>
<td></td>
</tr>
<tr>
<td>disableAutoResize()</td>
<td>none</td>
<td>禁用自动适应容器尺寸变化</td>
<td></td>
</tr>
<tr>
<td>checkResize()</td>
<td>none</td>
<td>地图容器变化后调用此方法用来重新铺图</td>
<td></td>
</tr>
<tr>
<td>resize()</td>
<td>none</td>
<td>强制地图调整尺寸，此时会以当前容器尺寸为基准重新计算视野所需图像数据并重新绘制。当关闭自动调整视野时（<code>enableAutoResize</code> 配置），需要调用此方法来强制地图刷新。</td>
<td></td>
</tr>
<tr>
<td>getSize()</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b3">Size</a></td>
<td>返回地图当前尺寸，以像素表示</td>
<td></td>
</tr>
<tr>
<td>getContainerSize()</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b3">Size</a></td>
<td>获取地图容器尺寸</td>
<td></td>
</tr>
<tr>
<td>getZoomUnits()</td>
<td>Number</td>
<td>返回当前地图级别，一个像素对应多少单位的平面墨卡托坐标</td>
<td></td>
</tr>
<tr>
<td>getContainer()</td>
<td>HTMLElement</td>
<td>返回地图的DOM容器元素。当创建用户自定义控件时，需要自行实现Control.initialize()方法，并将控件的容器元素添加到地图上，通过此方法可获得地图容器</td>
<td></td>
</tr>
<tr>
<td>pixelToPoint(pixel: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b1">Pixel </a>)</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point</a></td>
<td>像素坐标转换为经纬度坐标</td>
<td></td>
</tr>
<tr>
<td>pointToPixel(point: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>)</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b1">Pixel</a></td>
<td>经纬度坐标转换为像素坐标</td>
<td></td>
</tr>
<tr>
<td>lnglatToMercator(lng: Number, lat: Number)</td>
<td>[McLng, McLat]</td>
<td>经纬度球体坐标转换为墨卡托平面坐标</td>
<td></td>
</tr>
<tr>
<td>mercatorToLnglat(McLng: Number, lat: McLat)</td>
<td>[lng, lat]</td>
<td>墨卡托平面坐标转换为经纬度球体坐标</td>
<td></td>
</tr>
<tr>
<td>isLoaded()</td>
<td>boolean</td>
<td>返回地图是否经过centerAndZoom进行初始化</td>
<td></td>
</tr>
<tr>
<td>addSpots(spots: Array, options: Object)</td>
<td>number</td>
<td>添加地点区域，作为地图上的虚拟可点击区域。其中参数spots为热区点数组，options为可选配置参数；返回区域id。</td>
<td></td>
</tr>
<tr>
<td>getSpots(id: string)</td>
<td>Array</td>
<td>根据id返回地点区域数组</td>
<td></td>
</tr>
<tr>
<td>removeSpots(id: number)</td>
<td>none</td>
<td>根据id移除区域数组</td>
<td></td>
</tr>
<tr>
<td>clearSpots()</td>
<td>none</td>
<td>清除地点区域，此操作将清空所有虚拟可点数据</td>
<td></td>
</tr>
<tr>
<td>clearLabels()</td>
<td>none</td>
<td>清空当前map所有的自定义底图标注</td>
<td></td>
</tr>
<tr>
<td>addLabelsToMapTile(labels:Array)</td>
<td>none</td>
<td>在底图上添加文字，这些文字会和底图文字一同参与避让。</td>
<td></td>
</tr>
<tr>
<td>removeLabelsFromMapTile(labelUids:Array)</td>
<td>none</td>
<td>从底图上移除文字标注，参数为uid数组，根据数组里的uid进行移除</td>
<td></td>
</tr>
<tr>
<td>getIconByClickPosition(clickPosition: Pixel)</td>
<td>Object</td>
<td>null</td>
<td>通过点击坐标获取当前点中的底图icon，如果获取到返回其{name, uid, position}，否则返回null</td>
</tr>
<tr>
<td>setBounds(bounds:Bounds)</td>
<td>none</td>
<td>设置地图可拖动区域，参数为地图拖拽的区域范围</td>
<td></td>
</tr>
<tr>
<td>getBounds()</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b2">Bounds</a></td>
<td>获取地图当前视野范围的矩形区域，以地理坐标表示。如果地图尚未初始化则返回一个空的 <code>Bounds</code> 实例。</td>
<td></td>
</tr>
<tr>
<td>getCoordType()</td>
<td>string</td>
<td>获取地图坐标类型，为CoordType常量</td>
<td></td>
</tr>
<tr>
<td>getMapStyleId()</td>
<td>string</td>
<td>获取当前地图样式id，对于内置样式则返回样式名称；对于自定义样式，则返回内部自动生成的样式id</td>
<td></td>
</tr>
<tr>
<td>getPanes()</td>
<td>MapPanes</td>
<td>获取覆盖物容器元素，返回地图覆盖物容器对象</td>
<td></td>
</tr>
<tr>
<td>getInfoWindow()</td>
<td>InfoWindow</td>
<td>null</td>
<td>获取当前打开的信息窗口实例，如果当前地图没有处于打开状态信息窗口，则返回 <code>null</code></td>
</tr>
<tr>
<td>setDefaultCursor(cursor: String)</td>
<td>none</td>
<td>设置地图默认的鼠标指针样式。参数cursor应符合CSS的cursor属性规范</td>
<td></td>
</tr>
<tr>
<td>getDefaultCursor()</td>
<td>String</td>
<td>获取地图默认的鼠标指针样式，返回cursor值</td>
<td></td>
</tr>
<tr>
<td>setDraggingCursor(cursor: String)</td>
<td>none</td>
<td>设置拖拽地图时的鼠标指针样式。参数cursor应符合CSS的cursor属性规范</td>
<td></td>
</tr>
<tr>
<td>getDraggingCursor()</td>
<td>String</td>
<td>返回拖拽地图时的鼠标指针样式</td>
<td></td>
</tr>
<tr>
<td>setMinZoom(zoom: Number)</td>
<td>none</td>
<td>设置地图允许的最小级别。取值不得小于地图类型所允许的最小级别</td>
<td></td>
</tr>
<tr>
<td>setMaxZoom(zoom: Number)</td>
<td>none</td>
<td>设置地图允许的最大级别。取值不得大于地图类型所允许的最大级别</td>
<td></td>
</tr>
<tr>
<td>getDistance(start: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>, end: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>)</td>
<td>Number</td>
<td>返回两点之间的距离，单位是米</td>
<td></td>
</tr>
<tr>
<td>getMapType()</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a4b0">MapTypeId</a></td>
<td>返回地图类型</td>
<td></td>
</tr>
<tr>
<td>setViewport(view: Array</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a0b3">Viewport </a>, viewportOptions: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a0b4">ViewportOptions </a>)</td>
<td>none</td>
<td>根据提供的地理区域或坐标设置地图视野，调整后的视野会保证包含提供的地理区域或坐标</td>
</tr>
<tr>
<td>getViewport(view: Array&lt; <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>&gt;, viewportOptions: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a0b3">ViewportOptions </a>)</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a0b2">Viewport</a></td>
<td>根据提供的地理区域或坐标获得最佳的地图视野，返回的对象中包含center和zoom属性，分别表示地图的中心点和级别。此方法仅返回视野信息，不会将新的中心点和级别做用到当前地图上</td>
<td></td>
</tr>
<tr>
<td>centerAndZoom(center: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>, zoom: Number)</td>
<td>none</td>
<td>设初始化地图。 如果center类型为Point时，zoom必须赋值，范围3-19级，若调用高清底图（针对移动端开发）时，zoom可赋值范围为3-18级。如果center类型为字符串时，比如“北京”，zoom可以忽略，地图将自动根据center适配最佳zoom级别</td>
<td></td>
</tr>
<tr>
<td>panTo(center: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>)</td>
<td>none</td>
<td>将地图的中心点更改为给定的点，跳转到指定中心点进行渲染。如果该点在当前的地图视图中已经可见，则会以平滑动画的方式移动到中心点位置。可以通过配置强制移动过程不使用动画效果</td>
<td></td>
</tr>
<tr>
<td>panBy(x: Number, y: Number)</td>
<td>none</td>
<td>将地图在水平位置上移动x像素，垂直位置上移动y像素。如果指定的像素大于可视区域范围或者在配置中指定没有动画效果，则不执行滑动效果</td>
<td></td>
</tr>
<tr>
<td>flyTo(center: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>, zoom: Number)</td>
<td>none</td>
<td>飞到指定的中心点和级别，提供给定位缩放地图使用</td>
<td></td>
</tr>
<tr>
<td>reset()</td>
<td>none</td>
<td>重新设置地图，恢复地图初始化时的中心点和级别</td>
<td></td>
</tr>
<tr>
<td>setCenter(center: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a></td>
<td>String[, options: Object])</td>
<td>none</td>
<td>设置地图中心点。center除了可以为坐标点以外，还支持城市名。可选配置参数包括’noAnimation: boolean’是否禁用动画效果；’callback: function’动画结束后调用此方法，如果没有动画则立即调用</td>
</tr>
<tr>
<td>getCenter()</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point</a></td>
<td>返回地图当前中心点</td>
<td></td>
</tr>
<tr>
<td>setMapType(mapTypeId: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a4b0">MapTypeId </a>)</td>
<td>none</td>
<td>设置地图类型</td>
<td></td>
</tr>
<tr>
<td>setZoom(zoom: Number[,options])</td>
<td>none</td>
<td>将视图切换到指定的缩放等级，中心点坐标不变。注意：当有信息窗口在地图上打开时，地图缩放将保证信息窗口所在的坐标位置不动。可选配置参数包括’noAnimation：boolean’是否禁用动画效果；’callback:function’动画结束后会调用此方法，如果没有动画则立即调用；’zoomCenter：Point’缩放中心点，默认以地图中心点为基准缩放</td>
<td></td>
</tr>
<tr>
<td>getZoom()</td>
<td>Number</td>
<td>返回地图当前缩放级别</td>
<td></td>
</tr>
<tr>
<td>zoomIn()</td>
<td>none</td>
<td>放大一级视图</td>
<td></td>
</tr>
<tr>
<td>zoomOut()</td>
<td>none</td>
<td>缩小一级视图</td>
<td></td>
</tr>
<tr>
<td>addControl(control: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a2b0">Control </a>)</td>
<td>none</td>
<td>将控件添加到地图，一个控件实例只能向地图中添加一次</td>
<td></td>
</tr>
<tr>
<td>removeControl(control: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a2b0">Control </a>)</td>
<td>none</td>
<td>从地图中移除控件。如果控件从未被添加到地图中，则该移除不起任何作用</td>
<td></td>
</tr>
<tr>
<td>addContextMenu()(menu: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a4b0">ContextMenu </a>)</td>
<td>none</td>
<td>添加右键菜单</td>
<td></td>
</tr>
<tr>
<td>removeContextMenu()(menu: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a4b0">ContextMenu </a>)</td>
<td>none</td>
<td>移除右键菜单</td>
<td></td>
</tr>
<tr>
<td>addOverlay(overlay: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a3b0">Overlay </a>)</td>
<td>none</td>
<td>将覆盖物添加到地图中，一个覆盖物实例只能向地图中添加一次</td>
<td></td>
</tr>
<tr>
<td>removeOverlay(overlay: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a3b0">Overlay </a>)</td>
<td>none</td>
<td>从地图中移除覆盖物。如果覆盖物从未被添加到地图中，则该移除不起任何作用</td>
<td></td>
</tr>
<tr>
<td>clearOverlays()</td>
<td>none</td>
<td>清除地图上所有覆盖物</td>
<td></td>
</tr>
<tr>
<td>pointToOverlayPixel(point: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point </a>)</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b1">Pixel</a></td>
<td>根据地理坐标获取对应的覆盖物容器的坐标，此方法用于自定义覆盖物</td>
<td></td>
</tr>
<tr>
<td>overlayPixelToPoint(pixel: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b1">Pixel </a>)</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a1b0">Point</a></td>
<td>根据覆盖物容器的坐标获取对应的地理坐标</td>
<td></td>
</tr>
<tr>
<td>getOverlays()</td>
<td>Array&lt; <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a3b0">Overlay </a>&gt;</td>
<td>获取当前地图上的所有覆盖物，返回覆盖物对象的集合</td>
<td></td>
</tr>
<tr>
<td>getPanes()</td>
<td><a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a3b1">MapPanes</a></td>
<td>返回地图覆盖物容器列表</td>
<td></td>
</tr>
<tr>
<td>getCurrentMaxTilt()</td>
<td>number</td>
<td>获取当前地图允许的最大倾斜角度</td>
<td></td>
</tr>
<tr>
<td>hightlightSpotByUid(uid: string, tilePosStr: string)</td>
<td>none</td>
<td>根据 uid 将底图上的 poi 高亮显示，其中参数tilePosStr为label的位置字符串</td>
<td></td>
</tr>
<tr>
<td>resetSpotStatus()</td>
<td>none</td>
<td>重置热区状态，即将高亮的热区点取消</td>
<td></td>
</tr>
<tr>
<td>addAreaSpot()</td>
<td>none</td>
<td>重置热区状态，即将高亮的热区点取消</td>
<td></td>
</tr>
<tr>
<td>getAreaSpot(id: string)</td>
<td>Array</td>
<td>返回地点区域数组</td>
<td></td>
</tr>
<tr>
<td>removeAreaSpot(id: string)</td>
<td>none</td>
<td>移除区域数组</td>
<td></td>
</tr>
<tr>
<td>clearAreaSpots()</td>
<td>none</td>
<td>清除地点区域，此操作将清空所有虚拟可点数据</td>
<td></td>
</tr>
<tr>
<td>setTrafficOn()</td>
<td>none</td>
<td>开启路况图层</td>
<td></td>
</tr>
<tr>
<td>setTrafficOff()</td>
<td>none</td>
<td>关闭路况图层</td>
<td></td>
</tr>
<tr>
<td>showOverlayContainer()</td>
<td>none</td>
<td>显示覆盖物</td>
<td></td>
</tr>
<tr>
<td>hideOverlayContainer()</td>
<td>none</td>
<td>不显示覆盖物</td>
<td></td>
</tr>
<tr>
<td>setMapStyleV2(config: Object)</td>
<td>none</td>
<td>设置个性化地图，参数为个性化配置对象</td>
<td></td>
</tr>
<tr>
<td>startViewAnimation(viewAnimation: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a7b0">ViewAnimation</a>)</td>
<td>Number</td>
<td>启动视角动画</td>
<td></td>
</tr>
<tr>
<td>cancelViewAnimation(viewAnimation: <a href="https://link.juejin.cn/?target=https://mapopen-pub-jsapi.bj.bcebos.com/jsapi/reference/jsapi_webgl_1_0.html%23a7b0">ViewAnimation</a>)</td>
<td>none</td>
<td>停止视角动画</td>
<td></td>
</tr>
<tr>
<td>getMapScreenshot()</td>
<td>url</td>
<td>获取地图截图，地球模式不支持。需要初始化地图配置preserveDrawingBuffer：true，否则是黑屏</td>
<td></td>
</tr>
<tr>
<td>loadMapStyleFiles(callback: Function)</td>
<td>none</td>
<td>加载地图当前样式所需要的样式文件，callback为加载成功后的回调函数</td>
<td></td>
</tr>
<tr>
<td>setCopyrightOffset(logo: Object, cpy: Object)</td>
<td>none</td>
<td>设置版权信息位置，其中logo为logo位置，copyright为文字位置</td>
<td></td>
</tr>
<tr>
<td>destroy()</td>
<td>none</td>
<td>销毁地图，当使用 WebGL 渲染地图时，如果确认不再使用该地图实例，则需要调用本方法销毁 WebGL 上下文，否则频繁创建新地图实例会导致浏览器报：too many WebGL context 的警告</td>
<td></td>
</tr>
<tr>
<td>isSupportEarth()</td>
<td>boolean</td>
<td>判断浏览器是否支持地球,支持返回true,否则返回false</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>图形构建</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>Konva</tag>
        <tag>antv</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机</title>
    <url>/2023/05/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>上午的考试为62道选择题，总分75分，通过分数通常为45分。纵观下面的考点分布，根据考试用书的章节，将各章节考点的分数占比从高到低排序：</p>
<ul>
<li>“第6章 网络互连与互联网”，占比高达20%。</li>
<li>“第8章 网络安全”，占比12%。</li>
<li>“第9章 网络操作系统与应用服务器配置”，占比12%。</li>
<li>“第12章 网络规划和设计”，占比10%。</li>
<li>“第13章 计算机基础知识”，占比10%。</li>
<li>“第2章 数据通信基础”，占比8%。</li>
<li>“第4章 局域网与城域网”，占比8%。</li>
<li>“第10章 组网技术”，占比8%。</li>
<li>“第3章 广域通信网”，占比5%。</li>
</ul>
<p><img src="C:/Users/liming/AppData/Roaming/Typora/typora-user-images/image-20230425164723857.png" alt="image-20230425164723857"></p>
<p><img src="C:/Users/liming/AppData/Roaming/Typora/typora-user-images/image-20230425164732678.png" alt="image-20230425164732678"></p>
<ul>
<li>校验码</li>
</ul>
<h1 id="常识"><a href="#常识" class="headerlink" title="常识"></a>常识</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>增量备份是备份的一个类型，是指在一次全备份或上一次增量备份后，以后每次的备份只需备份与前一次相比增加或者被修改的数据，能节约备份时间。</p>
<p>在局域网应用中，由于数据通信量的快速增长，交换机<strong>带宽</strong>往往不够用，于是出现了将多条物理链路当作一条逻辑链路使用的链路聚合技术，这时网络通信由聚合到逻辑链路中的所有物理链路共同承担。</p>
<h2 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h2><h3 id="存储单位"><a href="#存储单位" class="headerlink" title="存储单位"></a>存储单位</h3><p><img src="https://img-blog.csdnimg.cn/929a50a758624913b389a8d7d14dfe20.png" alt="img"></p>
<ul>
<li><p>位（bit）</p>
</li>
<li><p>字节（Byte）</p>
</li>
<li><p>字、字长</p>
<p>定义：CPU一次能处理的二进制就是一个字；CPU一次能处理的<strong>二进制的位数</strong>就是字长；<br>举例说明<br>32位的CPU，一次能处理32位的二进制（32bit是一个字），此时字长是32；所以 1字 = 32 bit（32个字长）；<br>64位的CPU，一次能处理64位的二进制（64bit是一个字），此时字长是64；所以 1字 = 64 bit；（64个字长）</p>
</li>
</ul>
<h3 id="周期和频率"><a href="#周期和频率" class="headerlink" title="周期和频率"></a>周期和频率</h3><p>f=1/T</p>
<p>T是周期，T是指以秒为单位。</p>
<p>f是指赫兹，赫兹是国际单位制中频率的单位（赫兹(H·Hertz)是德国著名的物理学家,1887年,是他通过实验证实了电磁波的存在。后人为了纪念他,把“赫兹”定为频率的单位），它具体是指每秒中的周期性变动重复次数的计量。秒是时间的计量单位。</p>
<ul>
<li><p>1、频率：1秒中发生的次数；</p>
</li>
<li><p>2、周期：发生一次所需要的时间；</p>
</li>
<li><p>3、频率和周期互为倒数。<em>时间(s)=1÷时钟频率Hz</em></p>
<ul>
<li>4、1Hz —— 1s</li>
<li>5、KHz —— ms</li>
<li>6、MHz —— us</li>
</ul>
</li>
</ul>
<h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>波特率用于描述UART通信时的通信速度，其单位为bps bit per second）即<strong>每秒钟传送的bit的数量</strong> 。bps=bit/s</p>
<p>通过知道每秒钟传送的bit的数量，可得到1个bit传送的时间，从而知道传输的是1个1还是2个1(电平一样)。但是这个接收方和发送方时间基准可能不同（即串口异步），从而造成累计误差，为了避免误差，最多只发8位</p>
<h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><table>
<thead>
<tr>
<th>周期类型</th>
<th>与其它周期类型的关系</th>
</tr>
</thead>
<tbody><tr>
<td>振荡周期</td>
<td>1/ (晶振频率) 或 1/(RC震荡频率）</td>
</tr>
<tr>
<td>时钟周期</td>
<td>振荡周期* 分频比</td>
</tr>
<tr>
<td>机器周期</td>
<td>时钟周期* 单片机T数</td>
</tr>
<tr>
<td>单指令周期</td>
<td>机器周期</td>
</tr>
<tr>
<td>双指令周期</td>
<td>2* 机器周期</td>
</tr>
<tr>
<td>四指令周期</td>
<td>4* 机器周期</td>
</tr>
</tbody></table>
<h4 id="时钟频率"><a href="#时钟频率" class="headerlink" title="时钟频率"></a>时钟频率</h4><p>时钟以精确和固定的时间间隔，触发电信号，其信号被控制单元用于推进CPU的内部操作。</p>
<h4 id="时钟周期"><a href="#时钟周期" class="headerlink" title="时钟周期"></a>时钟周期</h4><p>时钟周期也称为振荡周期，定义为时钟频率的倒数，**<a href="https://so.csdn.net/so/search?q=%E5%8D%95%E7%89%87%E6%9C%BA&spm=1001.2101.3001.7020">单片机</a>中最小的时间单位。**<br>例如51单片机中，时钟频率是12MHz，那么它的时钟周期就是1/12us。<br>在51单片机中晶振频率没有分频就直接作为CPU频率使用，所以<br>时钟周期 = 晶振周期 = 振荡周期。</p>
<h4 id="状态周期"><a href="#状态周期" class="headerlink" title="状态周期"></a>状态周期</h4><p>在51单片机中把一个时钟周期定义为一个节拍（用P表示），二个节拍定义为一个状态周期（用S表示）。即两个时钟周期=状态周期。</p>
<h4 id="机器周期"><a href="#机器周期" class="headerlink" title="机器周期"></a>机器周期</h4><p>例如，取指令、存储器读、存储器写等，这每一项工作称为一个基本操作。完成一个基本操作所需要的时间称为机器周期。<br>51单片机的一个机器周期同6个S周期（状态周期）组成，即51单片机的机器周期由6个状态周期组成，也就是 <strong>机器周期=6个状态周期=12个时钟周期</strong><br>那么以12Mhz的振荡频率为例，一个机器周期的时长是1us。</p>
<h2 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h2><p>速率：bps=bit/s；</p>
<h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><p>逻辑异或的公式：相同逻辑变量异或结果为0；相异逻辑变量异或结果为1。</p>
<p>$0\bigoplus0或者1\bigoplus1=0$</p>
<p>$0\bigoplus1=1$</p>
<p>不发生死锁的资源数R，M个进程 ，每个进程要N个资源，不发生死锁：R = M *（N－1）+1</p>
<h4 id="信噪比"><a href="#信噪比" class="headerlink" title="信噪比"></a>信噪比</h4><p>SNR（Signal-Noise Radio)，信号与噪声的功率之比。信噪比越高越好。</p>
<p>线性单位：<br> <img src="https://math.jianshu.com/math?formula=SNR%20=%20%5Cfrac%7BP_s%7D%7BP_n%7D%20=%20(%5Cfrac%7BV_s%7D%7BV_n%7D)%5E2" alt="SNR = \frac{P_s}{P_n} = (\frac{V_s}{V_n})^2"></p>
<p>以dB为单位：</p>
<p>$SNR (dB) = 10<em>log_{10}{\frac{P_s}{P_n}} \ = 20</em>log_{10}{\frac{V_s}{V_n}}$</p>
<p> <img src="https://math.jianshu.com/math?formula=P_s" alt="P_s">表示信号的有效功率，<img src="https://math.jianshu.com/math?formula=P_n" alt="P_n">表示噪声的有效功率。<br> <img src="https://math.jianshu.com/math?formula=V_s" alt="V_s">表示信号的电压幅值（有效值），<img src="https://math.jianshu.com/math?formula=V_n" alt="V_n">表示噪声的电压幅值（有效值)。</p>
<h4 id="香农-Shanon-定律"><a href="#香农-Shanon-定律" class="headerlink" title="香农 (Shanon) 定律"></a>香农 (Shanon) 定律</h4><p>香农定理指出：在一条带宽为W（HZ），信噪比为S/N的有噪声极限数据速率</p>
<p>C=W*$log_2(1+S/N)$</p>
<p>C数据传输速率，W带宽，S为信号功率,N为噪声功率,S/N为信噪比,通常把信噪比表示成10lg(S/N)分贝(dB)</p>
<p>信道带宽为3kHz,信噪比为20dB,它的最大数据传输率是多少?（$log_{10}101$=2.004,log102=0.301）</p>
<p>信噪比：由10lg(S/N) = 20db ，可得 S/N = 100</p>
<p>香农定理：C=C=H * log2(1+S/N)， 可得3000*log2(1+100)≈20100b/s</p>
<p>设信道带宽为1000Hz，信噪比为30dB，则信道的最大数据速率约为( )b/s。</p>
<p>$C=W\times\log_2(1+\frac{s}{n})=1000\times10 = 10000bps$</p>
<p>dB=10 * lg(S/N),当S/N为1000时dB为30</p>
<p>速率为C = w * log(1 + S/N) = 1000 * 10 = 10000b/s</p>
<h4 id="尼奎斯特定理"><a href="#尼奎斯特定理" class="headerlink" title="尼奎斯特定理"></a>尼奎斯特定理</h4><p>尼奎斯特定理：<strong>有限带宽无噪声信道</strong>的极限波特率，若信道带宽为W（HZ）,则最大码元速率（波特率）为：B=2W（baud）**(码元速率是带宽的两倍)**</p>
<p>由尼奎斯特定理可得：</p>
<p>$V_{max}=Blog_{2}N=2Wlog_{2}N$  单位（b/s），V是数据的速率，B是码元速率，N是波形的种类</p>
<blockquote>
<p><strong>采用四相位调制,表示有四种波形,为了标识这四种波形,至少需要2位,也就是用2位来表示一个码元</strong></p>
</blockquote>
<p>设信道带宽为4kHz，采用4相调制技术，则信道支持的最大数据速率是 （ ） 。</p>
<p>$2H\log_2{k}=8000\log_24$</p>
<p>例：设信道带宽为 3400Hz，调制为 4 种不同的码元，根据 Nyquist 定理，理想信道的数据速率为？</p>
<ul>
<li>1，根据题意例出尼奎斯特定理算式：Vmax=2 W long 2N</li>
<li>2, 直接套入数字：Vmax=2x3400x$log_24$</li>
<li>3, Vmax=2x3400x2=13600b/S=13.6kb/s</li>
</ul>
<p>例1：设信道采用2DPSK调制，码元速率为300波特，则最大数据速率为</p>
<p>解：Vmax=B log2N=300x1=300b/s  </p>
<p>例2：在异步通信中，每个字符包含1位起始位，7位数据位，1位奇偶效验位和两位终止位，若每秒传送100个字符，采用4DPSK调制，则码元速率为？有效数据速率为？</p>
<ul>
<li>1，根据题意计算数据速率为 （1+7+1+2）*100=1100b/s</li>
<li>2，由尼奎斯特定理得出，1100b/s=B*$log_24$</li>
<li>3，B=1100/2=550baud</li>
<li>4, 有效数据速率，即单位时间内传输的数据位，即7*100=700b/S</li>
</ul>
<h2 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h2><p>时延是指一个报文或分组从一个网络的一端传送到另一个端所需要的时间。它包括了发送时延，传播时延，处理时延，排队时延。</p>
<p>往返时间RTT：数据报文在端到端通信中的来回一次的时间。</p>
<ul>
<li><p>发送时延是主机或路由器发送数据帧所需要的时间，也就是从发送数据的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。发送时延也称为传输时延。</p>
<ul>
<li>发送时延 = 数据帧长度（b） / 信道带宽（b/s）</li>
</ul>
</li>
</ul>
<ul>
<li><p>传播时延是电磁波在信道中传播一定的距离需要花费的时间。</p>
<ul>
<li>传播时延 = 信道长度（m） / 电磁波在信道上的传播速率（m/s）</li>
</ul>
</li>
</ul>
<ul>
<li>处理时延：主机路由器在收到分组需要花费一定事件处理如分析分组首部，分组中提取数据，差错检验，查找路由等</li>
</ul>
<ul>
<li>排队时延：</li>
</ul>
<blockquote>
<ul>
<li>电信号在电缆上传播的速度为光速的2/3，即<strong>20km/ms</strong></li>
</ul>
<ul>
<li>卫星<strong>传播延迟</strong>恒定为<strong>270ms与地面距离无关</strong></li>
</ul>
</blockquote>
<p>例：在相隔2000km的两地间通过电缆以4800b/s的速率传送3000比特长的数据包，从开始发生到接收数据需要的时间是？如果用50Kb/s的卫星信道传送，则需要的时间</p>
<p>对于电缆：</p>
<p>传输延迟T1=2000km/(20km/ms)=10ms</p>
<p>发送延迟T2=3000b/(4800b/s)=625ms</p>
<p>T=T1+T2=625ms+10ms=635ms</p>
<p>对于卫星：</p>
<p>传输延迟 T1=270ms</p>
<p>发送延迟 T2=3000 b/(50kb/s)=60ms</p>
<p>T=T1+T2=270ms+60ms=330ms</p>
<h2 id="设备"><a href="#设备" class="headerlink" title="设备"></a>设备</h2><p>光功率计（optical power meter）是指用于测量绝对光功率或通过一段光纤的光功率相对损耗的仪器。<strong>测量光缆是否有问题</strong></p>
<p>光时域反射计（OTDR）是通过对测量曲线的分析，了解光纤的均匀性、缺陷、断裂、接头耦合等若干性能的仪器。<strong>判断出光缆的故障位置</strong></p>
<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>IPSEC中安全关联（security Associations）三元组是&lt;安全参数索引SPI，目标IP地址，安全协议&gt;</p>
<p>在生成快速转发表的过程中，五元组是指源IP地址、目的IP地址、源端口号、目的端口号、协议号</p>
<h1 id="计算机"><a href="#计算机" class="headerlink" title="计算机"></a>计算机</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="ASCII-编码"><a href="#ASCII-编码" class="headerlink" title="ASCII 编码"></a>ASCII 编码</h3><p>计算机是以二进制的形式来存储数据的，它只认识 0 和 1 两个数字，我们在屏幕上看到的文字，在存储之前都被转换成了二进制（0和1序列），在显示时也要根据二进制找到对应的字符。</p>
<p>可想而知，特定的文字必然对应着固定的二进制进行标识，否则在转换时将发生混乱。那么，怎样将文字与二进制对应起来呢？这就需要有一套规范，计算机公司和软件开发者都必须遵守，这样的一套规范就称为字符集（Character Set）或者字符编码（Character Encoding）。</p>
<blockquote>
<p>严格来说，字符集和字符编码不是一个概念，字符集定义了文字和二进制的对应关系，为字符分配了唯一的编号，而字符编码规定了如何将文字的编号存储到计算机中。</p>
</blockquote>
<p>可以将字符集理解成一个很大的表格，它列出了所有字符和二进制的对应关系，计算机显示文字或者存储文字，就是一个查表的过程。</p>
<p><img src="img/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/c%E8%AF%AD%E8%A8%80/ASCII.png" alt="ASCII"></p>
<h2 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h2><p><a href="http://c.biancheng.net/view/1725.html">http://c.biancheng.net/view/1725.html</a></p>
<h3 id="转换为十进制"><a href="#转换为十进制" class="headerlink" title="转换为十进制"></a>转换为十进制</h3><p>假设当前数字是 N 进制，那么：</p>
<ul>
<li>对于整数部分，从右往左看，第 i 位的位权等于$N^{i-1}$</li>
<li>对于小数部分，恰好相反，要从左往右看，第 j 位的位权为$N^{-j}$</li>
</ul>
<p>整数部分</p>
<p>例如，将八进制数字 53627 转换成十进制：</p>
<p>53627 = 5×8^4 + 3×8^3 + 6×8^2 + 2×8^1 + 7×8^0 = 22423（十进制）</p>
<p>小数部分</p>
<p>例如，将八进制数字 423.5176 转换成十进制：</p>
<p>423.5176 = 4×8^2 + 2×8^1 + 3×8^0 + 5×8^-1 + 1×8^-2 + 7×8^-3 + 6×8^-4 = 275.65576171875（十进制）</p>
<h3 id="十进制转换"><a href="#十进制转换" class="headerlink" title="十进制转换"></a>十进制转换</h3><h4 id="整数部分"><a href="#整数部分" class="headerlink" title="整数部分"></a>整数部分</h4><p>十进制整数转换为 N 进制整数采用“<strong>除 N 取余，逆序排列</strong>”法。具体做法是：</p>
<ul>
<li>将 N 作为除数，用十进制整数除以 N，可以得到一个商和余数；</li>
<li>保留余数，用商继续除以 N，又得到一个新的商和余数；</li>
<li>仍然保留余数，用商继续除以 N，还会得到一个新的商和余数；</li>
<li>……</li>
<li>如此反复进行，每次都保留余数，用商接着除以 N，直到商为 0 时为止。</li>
</ul>
<p>把先得到的余数作为 N 进制数的低位数字，后得到的余数作为 N 进制数的高位数字，依次排列起来，就得到了 N 进制数字。</p>
<p>将十进制数字 36926 转换成八进制的过程：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181221/1AP56143-0.png" alt="img"></p>
<h4 id="小数部分"><a href="#小数部分" class="headerlink" title="小数部分"></a>小数部分</h4><p>十进制小数转换成 N 进制小数采用“<strong>乘 N 取整，顺序排列</strong>”法。具体做法是：</p>
<ul>
<li>用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分；</li>
<li>将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积；</li>
<li>再将积的整数部分取出，继续用 N 乘以余下的小数部分；</li>
<li>……</li>
<li>如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求的精度为止。</li>
</ul>
<p>把取出的整数部分按顺序排列起来，先取出的整数作为 N 进制小数的高位数字，后取出的整数作为低位数字，这样就得到了 N 进制小数。</p>
<p>将十进制小数 0.930908203125 转换成八进制小数的过程：</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181221/1AP55414-2.png" alt="img"></p>
<p>如果一个数字既包含了整数部分又包含了小数部分，那么将整数部分和小数部分开，分别按照上面的方法完成转换，然后再合并在一起即可</p>
<ul>
<li>十进制数字 36926.930908203125 转换成八进制的结果为 110076.7345；</li>
</ul>
<h3 id="二进制和八进制、十六进制的转换"><a href="#二进制和八进制、十六进制的转换" class="headerlink" title="二进制和八进制、十六进制的转换"></a>二进制和八进制、十六进制的转换</h3><h4 id="二进制整数和八进制整数之间的转换"><a href="#二进制整数和八进制整数之间的转换" class="headerlink" title="二进制整数和八进制整数之间的转换"></a>二进制整数和八进制整数之间的转换</h4><p>二进制整数转换为八进制整数时，每三位二进制数字转换为一位八进制数字，运算的顺序是从低位向高位依次进行，高位不足三位用零补齐</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181221/1AP53a2-4.png" alt="img"></p>
<p>八进制整数转换为二进制整数时，思路是相反的，每一位八进制数字转换为三位二进制数字，运算的顺序也是从低位向高位依次进行</p>
<p><img src="http://c.biancheng.net/uploads/allimg/181221/1AP54395-5.png" alt="img"></p>
<h4 id="二进制整数和十六进制整数之间的转换"><a href="#二进制整数和十六进制整数之间的转换" class="headerlink" title="二进制整数和十六进制整数之间的转换"></a>二进制整数和十六进制整数之间的转换</h4><p><img src="http://c.biancheng.net/uploads/allimg/181221/1AP53006-6.png" alt="img"></p>
<p><img src="http://c.biancheng.net/uploads/allimg/181221/1AP53555-7.png" alt="img"></p>
<h2 id="原码补码反码"><a href="#原码补码反码" class="headerlink" title="原码补码反码"></a>原码补码反码</h2><h3 id="概念引入"><a href="#概念引入" class="headerlink" title="概念引入"></a>概念引入</h3><p>在介绍补码概念之前，先介绍一下“<a href="https://baike.baidu.com/item/%E6%A8%A1/13332718?fromModule=lemma_inlink">模</a>”的概念：“模”是指一个计量系统的计数范围，如过去计量粮食用的斗、时钟等。计算机也可以看成一个计量机器，因为计算机的存储和处理的位数是有限的，因此它也有一个计量范围，即都存在一个“模”。如：时钟的计量范围是0~11，模=12。表示n位的<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink">计算机</a>计量范围是</p>
<p>$$<br>0\sim2^n-1<br>$$<br>，模=</p>
<p>$$<br>2^n<br>$$<br>“模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数。<strong>任何有模的计量器，均可化减法为加法运算 。</strong></p>
<p><strong>就是取反后加1</strong></p>
<p>假设当前时针指向8点，而准确时间是6点，调整时间可有以下两种拨法：一种是倒拨2小时，即8-2=6；另一种是顺拨10小时，8+10=12+6=6，即8-2=8+10=8+12-2(mod 12)．在12为模的系统里，加10和减2效果是一样的，因此凡是减2运算，都可以用加10来代替。若用一般公式可表示为：a-b=a-b+mod=a+mod-b。<strong>对“模”而言，2和10互为补数</strong>。实际上，以12为模的系统中，11和1，8和4，9和3，7和5，6和6都有这个特性，共同的特点是两者相加等于模。对于<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink">计算机</a>，其概念和方法完全一样。n位计算机，设n=8，所能表示的最大数是11111111，若再加1成100000000(9位)，但因只有8位，最高位1自然丢失（相当于丢失一个模）。又回到了 00000000，所以8位<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6/361457?fromModule=lemma_inlink">二进制</a>系统的模为$2^8$</p>
<p>在这样的系统中减法问题也可以化成加法问题，只需<strong>把减数用相应的补数表示</strong>就可以了。把补数用到计算机对数的处理上，就是补码。</p>
<p>8-2=8+10=8+12-2(mod 12)</p>
<ul>
<li>00001011- 00000100 = 00000111（11-4=7）</li>
</ul>
<ul>
<li>补码：00001011- 00000100 =  00001011+（11111011+1）</li>
</ul>
<h3 id="编码-1"><a href="#编码-1" class="headerlink" title="编码"></a>编码</h3><p>计算机中的有符号数有三种表示方法，即<a href="https://baike.baidu.com/item/%E5%8E%9F%E7%A0%81/1097586?fromModule=lemma_inlink">原码</a>、<a href="https://baike.baidu.com/item/%E5%8F%8D%E7%A0%81/769985?fromModule=lemma_inlink">反码</a>和补码。三种表示方法均有符号位和数值位两部分</p>
<ul>
<li><p>符号位，都是用0表示“正”，用1表示“负”，</p>
</li>
<li><p>数值位，三种表示方法各不相同。</p>
</li>
</ul>
<blockquote>
<p>在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink">计算机</a>系统中，<strong>数值一律用补码来表示和存储。</strong>原因在于，使用补码，可以将符号位和数值域统一处理；同时，<strong>加法和减法也可以统一处理</strong> </p>
</blockquote>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81.png" alt="数据编码"></p>
<h3 id="原码求补码"><a href="#原码求补码" class="headerlink" title="原码求补码"></a>原码求补码</h3><h4 id="正数"><a href="#正数" class="headerlink" title="正数"></a>正数</h4><p>正整数与原码相同 。</p>
<p>例：+9的补码是00001001。</p>
<h4 id="负数"><a href="#负数" class="headerlink" title="负数"></a>负数</h4><p>求负整数的补码，将其原码<strong>除符号位外的所有位取反</strong>（0变1，1变0，符号位为1不变）<strong>后加1</strong> 。</p>
<p>同一个数字在不同的补码表示形式中是不同的。比如-15的补码，在8位二<a href="https://baike.baidu.com/item/%E8%BF%9B%E5%88%B6?fromModule=lemma_inlink">进制</a>中是11110001，然而在16位二进制补码表示中，就是1111111111110001。以下都使用8位2进制来表示。</p>
<p>例：求-5的补码。</p>
<p>-5对应带符号位负数5（10000101）→除符号位外所有位取反（11111010）→加 00000001为 (11111011)</p>
<p>所以-5的补码是11111011。</p>
<h4 id="0的补码"><a href="#0的补码" class="headerlink" title="0的补码"></a>0的补码</h4><p>数0的补码表示是<strong>唯一</strong>的 。</p>
<p>[+0]补=[+0]反=[+0]原=00000000</p>
<p>[ -0]补=11111111+1=00000000</p>
<h3 id="补码求原码"><a href="#补码求原码" class="headerlink" title="补码求原码"></a>补码求原码</h3><p>已知一个数的补码，求原码的操作其实就是对该补码再求补码 ：</p>
<p>⑴如果补码的符号位为“0”，表示是一个<a href="https://baike.baidu.com/item/%E6%AD%A3%E6%95%B0/1294288?fromModule=lemma_inlink">正数</a>，其原码就是补码。</p>
<p>⑵如果补码的符号位为“1”，表示是一个<a href="https://baike.baidu.com/item/%E8%B4%9F%E6%95%B0/1294977?fromModule=lemma_inlink">负数</a>，那么求给定的这个补码的补码就是要求的原码。</p>
<p>例：已知一个补码为11111001，则原码是10000111。</p>
<p>解：因为符号位为“1”，表示是一个负数，所以该位不变，仍为“1”。其余七位1111001取反后为0000110；再加1，所以是10000111。</p>
<h2 id="计算机分类"><a href="#计算机分类" class="headerlink" title="计算机分类"></a>计算机分类</h2><h3 id="Flynn"><a href="#Flynn" class="headerlink" title="Flynn"></a>Flynn</h3><p>Flynn根据不同的指令流和数据流组织方式，把计算机系统分成如下4类：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>特点</th>
<th>典型</th>
</tr>
</thead>
<tbody><tr>
<td>SISD</td>
<td>传统串行计算机，一个时钟周期仅处理一条指令和一条数据</td>
<td>早期的大型机 / 微型机 / 单核 PC</td>
</tr>
<tr>
<td>SIMD</td>
<td>所有处理器单时钟一条指令处理多条数据</td>
<td>矩阵处理器 / 向量流水线</td>
</tr>
<tr>
<td>MISD(<strong>只有理论意义</strong>)</td>
<td>多个处理单元各自独立使用指令处理一条数据</td>
<td>实时容错计算机 / 单一信号多频滤波器</td>
</tr>
<tr>
<td>MIMD</td>
<td>每个处理器执行各自的指令和各自的数据</td>
<td>超级计算机 / 集群服务器 /多核计算机</td>
</tr>
</tbody></table>
<p>串行计算机单个处理器 + 单条指令 + 单条数据 = SISD</p>
<p>现代计算机多个处理器 + 独立指令(或单条指令) + 独立数据 = MIMD (或SIMD)</p>
<p>超级计算机多个处理器 + 独立指令 + 独立数据 = MIMD</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>cpu组成：</p>
<ul>
<li>运算器</li>
<li>控制器</li>
<li>寄存器组（PC、IR、PSW、DR、通用寄存器等）</li>
<li>内部总线</li>
<li>中断系统组成</li>
</ul>
<p>如下图所示：</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230318215729763.png" alt="image-20230318215729763"></p>
<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><p>控制器的功能：<strong>它决定了计算机运行过程的自动化</strong></p>
<ul>
<li>从指令cache中取出一条指令，并指出下一条指令在指令cache中的位置。</li>
<li>对指令进行译码或测试，并产生相应的操作控制信号，以便于启动规定的动作。例如：一次数据cache的读写操作，一个算术逻辑运算操作，一个输入输出操作。</li>
<li>指挥并控制CPU，数据cache和输入输出设备之间数据流向的方向。</li>
</ul>
<p>控制器的组成</p>
<ul>
<li><p>程序计数器<strong>PC</strong>：程序的执行分两种情况，一是顺序执行，二是转移执行。</p>
<ul>
<li><strong>PC（程序计数器）是用于存放下一条指令所在单元的地址</strong>。当执行一条指令时，处理器首先 需要从 PC 中取出指令在内存中的地址，通过地址总线寻址获取。执行指令时，CPU 将自动修改 PC 的 内容，以便使其保持的总是将要执行的下一条指令的地址。<strong>由于大多数指令都是按顺序来执行的， 所以修改的过程通常只是简单地对 PC 加 1</strong>。</li>
<li>当遇到转移指令时，后继指令的地址根据当前指令的 地址加上一个向前或向后转移的位移量得到，或者根据转移指令给出的直接转移地址得到。</li>
</ul>
</li>
<li><p>指令寄存器<strong>IR</strong>：<strong>用来存放当前正在执行的指令</strong>。当 CPU 执行一条指令时，先把它从内存储器取到缓冲寄存器中，再送入IR暂存。</p>
<ul>
<li>指令寄存器的位数取决于 （ ）。指令字长</li>
</ul>
</li>
<li><p>地址寄存器<strong>AR</strong>：AR保存<strong>当前CPU所访问的内存单元的地址</strong>，暂存指令执行地址</p>
</li>
<li><p>指令译码器<strong>ID</strong>：对指令进行“翻译”，确定指令执行什么操作。指令分为操作码和地址码两部分</p>
</li>
</ul>
<h3 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h3><p>(1) 算术逻辑单元ALU：处理数据，实现对数据的算术运算和逻辑运算。</p>
<p>(2) 累加寄存器AC：为ALU提供一个工作区，例如，在执行一个减法运算前，先将被减数取出暂存在AC中，再从内存储器中取出减数，然后同AC的内容相减，将所得的结果送回AC中</p>
<p>(3) 数据缓冲寄存器DR：用来暂时存放由内存读出的一条指令或一个<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AD%97/8877755?fromModule=lemma_inlink">数据字</a>；反之，当向内存存入一条指令或一个数据字时，也暂时将它们存放在数据缓冲寄存器中。<strong>DR的主要作用为： 作为CPU和内存、外部设备之间数据传送的中转站，起操作速度上的缓冲</strong></p>
<p>(4) 状态条件寄存器PSW：保存由算术指令和逻辑指令运行或测试的结果建立的各种条件码内容，主要分为状态标志和控制标志</p>
<h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><p>RISC精简指令集，是计算机中央处理器的一种设计模式。这种设计思路可以想像成是一家流水线工厂，对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。</p>
<table>
<thead>
<tr>
<th>指令系统</th>
<th>特点</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>CISC（复杂）</td>
<td>数量多，使用频率差别大，可变长格式</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>RISC（精简）</td>
<td>数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器，只有Load/Store操作内存支持</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p><a href="https://blog.csdn.net/helloword111222/article/details/121312837">https://blog.csdn.net/helloword111222/article/details/121312837</a></p>
<p>指令的地址码字段<strong>通常不代表操作数的真实地址</strong>，故把它称为<strong>形式地址，记作A</strong>。操作数的真实地址称为<strong>有效地址，记作EA</strong>，它是由寻址方式和形式地址共同确定的。</p>
<p>格式：操作码    |    寻址特征   |   形式地址A</p>
<blockquote>
<p>立即数寻址和寄存器寻址在效率上是最快的，但是寄存器数目少，不可能将操作数都存入其中等待使用，立即数的使用场合也非常有限，这样就需要将数据保存在内存中，然后使用直接寻址、寄存器间接寻址、寄存器相对寻址、基址加变址寻址、相对基址及变址寻址等寻址方式将内存中的数据移入寄存器中</p>
</blockquote>
<h4 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h4><p>立即寻址的特点是<strong>操作数设在指令字内</strong>，即形式地址A不是操作数地址，而是操作数本身，又称为立即数。数据是采用补码存放的。</p>
<p><img src="https://img-blog.csdnimg.cn/c5bcc7bc4d7c4189b9cdab8fc82238a4.png" alt="img"></p>
<p>优点：是只要取出指令就能立即获得操作数，在执行阶段不必再访问存储器。</p>
<p>缺点：A的位数限制了这类指令所能表达的立即数的范围。</p>
<h4 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h4><p>直接寻址的特点是指令中的形式地址A就是操作数的实际地址EA</p>
<p><img src="https://img-blog.csdnimg.cn/670f9542f1594db0a89f47e8f524998f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_13,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>优点：</strong>寻找操作数比较简单，不需要专门计算操作数的地址，在指令执行阶段对主存只访问一次。</p>
<p><strong>缺点：</strong>A的范围限制了操作数的寻址范围，而且必须修改A的值，才能修改操作数的地址。</p>
<h4 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h4><p>形式地址不直接指出操作数的地址，而是指出操作数有效地址所在的存储单元地址，也就是说有效地址是由形式地址间接提供的，即为间接寻址。</p>
<img src="https://img-blog.csdnimg.cn/eb129beffd5245b5ad3796b51c04156e.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

<p><strong>优点：</strong>1，扩大了操作数的寻址范围。</p>
<p>​      2，便于编制程序。例如间接寻址可以很方便地完成子程序的返回。如下图</p>
<img src="https://img-blog.csdnimg.cn/ba668c8092bb404299059c3cdf185a01.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:33%;" />

<p> <strong>缺点：</strong>是指令在执行阶段需要访问两次内存（一次间接寻址）或多次（多次间接寻址），使执行时间延长。</p>
<h4 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h4><p>在寄存器的指令中，地址码字段直接指出了寄存器的编号，即EA=Ri.</p>
<p>如下图示：</p>
<img src="https://img-blog.csdnimg.cn/347f1702f756467380a0796f9c1642db.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_10,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:33%;" />

<p><strong>优点</strong>：操作数不在主存中，而在寄存器中，故寄存器寻址在指令执行阶段无需访存，减少执行时间。地址字段只需指明寄存器编号（寄存器数量有限），故指令字较短，节省了存储空间。</p>
<h4 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h4><p> 寄存器寻址指令中的Ri的内容不是操作数，而是操作数所处在主存单元的地址号，即有效地址EA=(Ri)，与寄存器寻址相比指令的执行阶段还需要访存，但他比间接寻址少访存一次。</p>
 <img src="https://img-blog.csdnimg.cn/e48a1fa87727457a9c850f2b1b2f5589.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_12,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:50%;" />

<h4 id="基址寻址"><a href="#基址寻址" class="headerlink" title="基址寻址"></a>基址寻址</h4><p>基址寻址需设基址寄存器BR，其操作数的有效地址EA等于指令字中的形式地址与基址寄存器中的内容相加，即</p>
<p><strong>EA=A+（BR）</strong></p>
<img src="https://img-blog.csdnimg.cn/dc9ee3656c204cab9d623c7fa667b30b.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom: 25%;" />

<p>基址寄存器可采用隐式和显式两种。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">隐式：在计算机内专门设有一个基址寄存器BR，不必指明该基址寄存器，只需有指令的寻址特征反映出基址寻址即可。</span><br><span class="line"></span><br><span class="line">显式：在一组通用寄存器里，由用户明确指出那个寄存器用作基址寄存器，存放基地址。</span><br></pre></td></tr></table></figure>

<p>基址寻址主要用于为程序或数据分配存储空间，故基址寄存器的内容通常由操作系统或管理程序确定，在程序的执行过程中其值是不可变的，而指令字中的A是可变的。</p>
<p>优点：基址寻址可以扩大寻址范围，寄存器位数可以大于形式地址A的位数。</p>
<h4 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h4><p>变址寻址与基址寻址极为相似，其有效地址EA等于形式地址A与变址寄存器IX的内容相加之和，</p>
<p>即：EA=A+（IX）</p>
<img src="https://img-blog.csdnimg.cn/727e6a984db2483d97f543a0f4e9e2b7.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:25%;" />

<p>在变址寻址中，变址寄存器的内容是用户设定的，而指令之中的A 是不可改变的。</p>
<p>变址寄存器主要用于处理数组问题，在数组处理过程中可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可容易形成数组中任意数据的地址，特别适合变址循环程序。</p>
<h4 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h4><p>相对寻址的有效地址是将程序计数器PC的内容（当前指令的地址）与指令中的形式地址A相加之和，即：EA=（PC）+A</p>
<p>相对寻址常被用于转移类指令，转以后的目标地址与当前指令有一段距离，称为相对位移量，他有指令字的形式地址A给出，故又称A 为位移量。位移量A可正可负，通常用补码表示。 </p>
<img src="https://img-blog.csdnimg.cn/6e68707245fc4ebba88ac0756a19b2ce.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qyi5b-r55qE5bCP5aSq6Ziz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img" style="zoom:25%;" />





<h3 id="指令系统分类总结"><a href="#指令系统分类总结" class="headerlink" title="指令系统分类总结"></a>指令系统分类总结</h3><p>如果按功能分类，STC89C52系列单片机指令系统可分为：</p>
<ul>
<li><p>1.数据传送类指令；</p>
</li>
<li><p>2.算术操作类指令；</p>
</li>
<li><p>3.逻辑操作类指令；</p>
</li>
<li><p>4.控制转移类指令；</p>
</li>
<li><p>5.布尔变量操作类指令。</p>
</li>
</ul>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20230401230745840.png" alt="image-20230401230745840"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20230401230829458.png" alt="image-20230401230829458"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20230401230852761.png" alt="image-20230401230852761"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/image-20230401230917987.png" alt="image-20230401230917987"></p>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><p>计算机系统的存储器按所处的位置：可分为内存和外存。</p>
</li>
<li><p>按构成存储器的材料：可分为磁存储器，信半导体存储器和光存储器。</p>
</li>
<li><p>按存储器的工作方式：可分为读写存储器和只读存储器。</p>
</li>
<li><p>按访问方式可分为</p>
<ul>
<li>按地址访问的存储器</li>
<li>按内容访问的存储器。<ul>
<li> 相联存储器是一种按<strong>内容访问</strong>的存储器。</li>
</ul>
</li>
</ul>
</li>
<li><p>按寻址方式：可分为随机存储器、顺序存储器和直接存储器。</p>
</li>
</ul>
<h3 id="外存ROM只读存储器"><a href="#外存ROM只读存储器" class="headerlink" title="外存ROM只读存储器"></a>外存ROM只读存储器</h3><p><strong>掉电数据不丢失，用来放程序</strong></p>
<p>常见的外存设备：硬盘、flash、rom、u盘、光盘、磁带</p>
<h4 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h4><p>RAID 0：将多个较小的磁盘合并成一个大的磁盘，不具有冗余，并行I/O，速度最快， <strong>磁盘容量利用率最高，可靠性最差</strong></p>
<p>RAID 1：两组相同的磁盘系统作镜像，速度没有提高，但是允许单个磁盘出错，可靠性最好，但是其磁盘的利用率却只有50%，<strong>是所有RAID上磁盘利用率最低的一个级别</strong>。</p>
<p>RAID2：2级廉价冗余磁盘阵列是采用<strong>海明码</strong>作错误检测的 一种磁盘阵列。</p>
<p>RAID3：存放数据的原理和RAID0、RAID1不同。RAID3是<strong>以一个硬盘来存放数据的奇偶校验位</strong>，<strong>数据分段存储于其余硬盘中</strong>。利用单独的校验盘来保护数据虽然没有镜像的安全性高，但是硬盘利用率得到了很大的提高，为n-1。</p>
<p>RAID4：4级廉价冗余磁盘阵列是一种可独立地对组内各磁 盘进行读写的磁盘阵列,、该阵列也只用一个检验盘。</p>
<p>RAID 5：向阵列中的磁盘写数据，<strong>奇偶校验</strong>数据存放在阵列中的各个盘上，允许单个磁盘出错。RAID 5也是以数据的校验位来保证数据的安全，但它不是以单独硬盘来存放数据的校验位，而是<strong>将数据段的校验位交互存放于各个硬盘上</strong>。这样，任何一个硬盘损坏，都可以提供其他硬盘上的校验位来重建损坏的数据。<strong>raid5实际数据存储为n-1块硬盘的容量</strong></p>
<p>RAID 5存在分散在不同条带上的奇偶校验数据。允许一块数据盘故障，并可通过奇偶校验数据计算得到故障硬盘中的数据。如果<strong>出现两块或两块以上数据盘故障，整个RAID组故障。</strong></p>
<p>RAID 6存在<strong>两组</strong>独立的分散在不同条带上的校验数据，<strong>允许两块数据盘故障</strong>，并可通过校验数据计算得到故障硬盘中的数据。</p>
<blockquote>
<p>与RAID 5相比，RAID 6增加了第二个独立的奇偶校验信息块</p>
</blockquote>
<h3 id="内存-主存RAM"><a href="#内存-主存RAM" class="headerlink" title="内存/主存RAM"></a>内存/主存RAM</h3><blockquote>
<p>内存（RAM随机存储器）又叫内部存储器和主存储器，暂时存放数据，掉电数据丢失，常见的内存设备：RAM、DDR</p>
</blockquote>
<ul>
<li>它用于暂时存放CPU中的运算数据</li>
<li>它是<a href="https://baike.baidu.com/item/%E5%A4%96%E5%AD%98/2445612?fromModule=lemma_inlink">外存</a>与<a href="https://baike.baidu.com/item/CPU/120556?fromModule=lemma_inlink">CPU</a>进行沟通的桥梁。计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</li>
</ul>
<h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>如果我们运行的程序较多，占用的空间就会超过内存（内存条）容量。例如计算机的内存容量为2G，却运行着10个程序，这10个程序共占用3G的空间，也就意味着需要从硬盘复制 3G 的数据到内存，这显然是不可能的。</p>
<p>操作系统（Operating System，简称 OS）为我们解决了这个问题：当程序运行需要的空间大于内存容量时，会将内存中暂时不用的数据再写回硬盘；需要这些数据时再从硬盘中读取，并将另外一部分不用的数据写入硬盘。这样，硬盘中就会有一部分空间用来存放内存中暂时不用的数据。这一部分空间就叫做虚拟内存（Virtual Memory）。</p>
<p>3G - 2G = 1G，上面的情况需要在硬盘上分配 1G 的虚拟内存。</p>
<p>硬盘的读写速度比内存慢很多，反复交换数据会消耗很多时间，所以如果你的内存太小，会严重影响计算机的运行速度，甚至会出现”卡死“现象，即使CPU强劲，也不会有大的改观。</p>
<p><strong>总结：CPU直接从内存中读取数据，处理完成后将结果再写入内存。</strong></p>
<p><img src="http://c.biancheng.net/uploads/allimg/181221/1I05B017-0.png" alt="img"></p>
<h4 id="QQ是怎么运行起来的呢？"><a href="#QQ是怎么运行起来的呢？" class="headerlink" title="QQ是怎么运行起来的呢？"></a>QQ是怎么运行起来的呢？</h4><p>首先，有一点你要明确，你安装的QQ软件是保存在硬盘中的。</p>
<p>双击QQ图标，操作系统就会知道你要运行这个软件，它会在硬盘中找到你安装的QQ软件，将数据（安装的软件本质上就是很多数据的集合）复制到内存。对！就是复制到内存！QQ不是在硬盘中运行的，而是在内存中运行的。</p>
<p>为什么呢？因为内存的读写速度比硬盘快很多。</p>
<p>对于读写速度，内存 &gt; 固态硬盘 &gt; 机械硬盘。机械硬盘是靠电机带动盘片转动来读写数据的，而内存条通过电路来读写数据，电机的转速肯定没有电的传输速度（几乎是光速）快。虽然固态硬盘也是通过电路来读写数据，但是因为与内存的控制方式不一样，速度也不及内存。</p>
<p>所以，不管是运行QQ还是编辑Word文档，都是先将硬盘上的数据复制到内存，才能让CPU来处理，这个过程就叫作载入内存（Load into Memory）。完成这个过程需要一个特殊的程序（软件），这个程序就叫做加载器（Loader）。</p>
<p>CPU直接与内存打交道，它会读取内存中的数据进行处理，并将结果保存到内存。如果需要保存到硬盘，才会将内存中的数据复制到硬盘。</p>
<p>例如，打开Word文档，输入一些文字，虽然我们看到的不一样了，但是硬盘中的文档没有改变，新增的文字暂时保存到了内存，Ctrl+S才会保存到硬盘。因为内存断电后会丢失数据，所以如果你编辑完Word文档忘记保存就关机了，那么你将永远无法找回这些内容。</p>
<h3 id="Cache存储器和主存映射"><a href="#Cache存储器和主存映射" class="headerlink" title="Cache存储器和主存映射"></a>Cache存储器和主存映射</h3><blockquote>
<p>Cache是在计算机存储系统的层次结构中，<strong>介于中央处理器和主存储器之间的高速小容量存储器</strong>。它和主存储器一起构成一级的存储器。高速缓冲存储器和主存储器之间信息的调度和传送<strong>是由硬件</strong>自动进行的，所以其读写速度最快。内存速度次之，硬盘是有机械装置的存储方式，比较慢，光盘最慢。</p>
</blockquote>
<p>Cache存储器的组织结构与主存储器不一样，它以行(line)作为基本单元。<strong>每一行又分为标志项和数据域</strong>两部分。数据域中存放着若干项数据，而标志项则是这一块数据的地址标识。</p>
<p>当CPU发出对存储器的读命令后，其访问地址先送给Cache控制器，Cache检查其地址标识符目录以确定是否有匹配项。若发现有匹配项(命中)，则根据其访问地址确定是对该行数据块中的第几项进行读取，然后该项即进入Cache的数据寄存器。如果没有命中，则去主存储器读取数据。这时不仅仅只是读该地址指定的存储单元而且把其<strong>相邻的K-1个单元(K是Cache中一行所能保存的数据单元个数)<strong>的内容都读入Cache中保存。因为根据</strong>局部性原理</strong>，这一块数据很有可能将被CPU访问。同时把指定的存储单元的内容送入CPU。如果Cache存储器已满；还要根据某种淘汰算法从Cache中清除一行以存放该数据块。</p>
<p>当CPU发出访存请求后，存储器地址先被送到Cache控制器以确定所需数据是否已在 Cache中，若命中(hit)则直接对Cache进行访问。这个过程称为Cache的<strong>地址映射</strong>(mapping)。为了适应Cache存储器的极高存取速率，映射也必须在极短的时间内完成。Cache存储器的映射机制比较复杂，常见的<strong>映射方法有直接映射、相联映射和组相联映射</strong>。 </p>
<ul>
<li><p>直接映像</p>
<p>主存与Cache的划分：将主存根据Cache的大小分成若干分区，Cache也分成若干个相等的块，主存的每个分区也分成与Cache相等的块。</p>
<p>主存与Cache的映像：主存中的每一个分区由于大小相同，可以与整个Cache相像，其中的每一块正好配对。编号不一致的块是不能相互映像的。</p>
<p>特点：</p>
<ul>
<li><p>优点：地址变换简单。</p>
</li>
<li><p>缺点：每块相互对应，不够灵活。</p>
</li>
</ul>
<p>主存与Cache的地址组成：</p>
<ul>
<li><p>主存：区号+块号+块内地址</p>
</li>
<li><p>Cache：块号+块内地址</p>
</li>
</ul>
</li>
<li><p>全相联映像</p>
<p>主存与Cache的划分：将主存与Cache划分成若干个大小相等的块。</p>
<p>主存与Cache的映像：主存中每一块都可以调到Cache中的每一块。</p>
<p>特点：<br>优点：访问灵活，冲突率低，只有Cache满时才会出现在冲突。缺点：地址变换比较复杂，速度相对慢。</p>
<p>主存与Cache的地址组成：</p>
<ul>
<li>主存：块号+块内地址</li>
<li>Cache：块号+块内地址</li>
</ul>
</li>
<li><p>组相联映像</p>
<p>主存与Cache的划分：</p>
<ul>
<li>主存：主存根据Cache大小划分成若干个区，每个区内划分成若干个组，每个组再划分成若干个块。</li>
<li>Cache：划分成若干个组，每个组划分成若干个块。</li>
</ul>
<p>主存与Cache的映像：<strong>主存的每个分区与Cache采用直接映像，主存的每个组之内采用全相联映像</strong>。</p>
<p>特点：<strong>融合了直接映像与全相联映像两种映像方式，结合了两者的优据点。</strong>具体实现容易，命中率与全相联映像接近。</p>
<p>主存与Cache的地址组成：</p>
<ul>
<li>主存：区号+组号+块号+块内地址</li>
<li>Cache：组号+块号+块内地址</li>
</ul>
</li>
</ul>
<p>容量为64块的Cache采用组相联方式映像，字块大小为128个字，每4块为一组。若主存容量为4096块，且以字编址，那么主存地址应为 (30) 位，主存区号应为 (31) 位</p>
<p>组相联的<strong>地址构成为：区号+组号+块号+块内地址。</strong></p>
<p><strong>主存的每个分区大小与整个Cache大小相等</strong>，故此主存需要分的区数为：4096/64=64，因为$2^6$＝64，因此需要6位来表示区号。</p>
<p>每4块为一组，故共有组数 64/4 = 16 ，因为$2^4$＝16，因此需要4位表示组号。</p>
<p>每组4块，故表示块号需要2位。</p>
<p>块内地址共128字节，$2^7$＝128，所以块内地需要7位表示。</p>
<p>所以：主存地址的位数＝6+4+2+7 ＝ 19</p>
<p>主存区号的位数＝6</p>
<h2 id="中断-DMA-通道"><a href="#中断-DMA-通道" class="headerlink" title="中断/DMA/通道"></a>中断/DMA/通道</h2><p><a href="https://blog.51cto.com/u_15270205/2911616">https://blog.51cto.com/u_15270205/2911616</a></p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>中断方式是程序切换，每次操作需要保护和恢复现场，中断次数多，CPU需要花较多的时间处理中断，中断次数多也会导致数据丢失</p>
<ul>
<li><p>引入中断的原因：<br>1.适应 I/O 设备工作速度低问题<br>2.将有用信息送至不受电源控制的存储系统中，带电源恢复后接着使用</p>
</li>
<li><p>中断处理程序的流程：</p>
<p>1.中断请求<br>2.中断判优：可能会有多个部件同时请求中断，此时需要判优<br>3.中断响应：判优完成之后，就需要对 CPU 进行中断了<br>4.中断服务：此次响应完以后，就需要跳到中断服务程序里，求执行某些操作<br>5.中断返回：服务程序执行完成之后，就要返回原来的地方，继续执行原本的程序</p>
</li>
<li><p>中断服务程序流程：</p>
<p>1.保护现场。 （保护程序断点，保护通用寄存器和状态寄存器）<br>2.中断服务程序:不同的 I/O 设备具有不同的中断服务程序<br>3.恢复现场：将原程序中断时现场恢复到原来的寄存器中（采用取数指令或出栈指令）<br>4:中断返回： 中断服务程序的最后一条指令通常是返回指令，时原程序的断点处，以便继续执行原程序。<br>⚠️注意：计算机在执行中断的时候，可能会出现新的中断，这时候有两种方：一种对于新的中断不理睬，叫做<em>单重中断，另一种暂停现在执行的中断，转向新的中断，叫做多重中断</em>。<strong>这两种中断最大的区别就是开中断的位置的区别</strong></p>
</li>
</ul>
<h3 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h3><p>DMA是存储器直接访问，这是指一种高速的数据传输操作，允许在外部设备和存储器之间直接读写数据。<strong>DMA直接通过一个通路把数据传送到主存储器，无需cpu的参与</strong></p>
<ul>
<li>主要特点：<ul>
<li>直接通过一条数据通路直接与主存进行交换信息</li>
<li>无需CPU的直接参与，大大提高了cpu资源利用率</li>
<li>I/O与CPU并行工作</li>
<li>适合于高速 I/O 或辅存与主存之间交换信息</li>
</ul>
</li>
<li>工作机制：DMA由专门的硬件（DMA）控制下，实现高速外设和主存储器之间自动成批交换数据尽量减少CPU干预的输入/输出操作方式。</li>
<li>DMA 工作流程<ul>
<li>1.预处理：<br>cpu 给 dma 指明传送方向是输入还是输出<br>给 DMA 地址寄存送入设备号，启动设备<br>向 DMA 主存地址寄存器送入交换数据的主存起始地址<br>对计数器赋予交换数据的个数</li>
<li>2.数据传送：<br>以块为单位</li>
<li>3.后处理<br>中断服务程序，做 DMA 结束处理（包括，检验送入主存的数是否正确，决定是否使用 DMA 传送其他数据块，，测试传送过程是否正确）</li>
</ul>
</li>
<li>注意<ul>
<li>DMA传送虽然脱离CPU的控制，但并不是说DMA传送不需要进行控制和管理。通常是采用DMA控制器来取代CPU，负责DMA传送的全过程控制。<strong>DMA 中的程序中断部件的作用是向 CPU 提出传输结束</strong></li>
<li>DMA是必须利用中断的，否则CPU无法得到数据已经传输结束,当数据传输开始结束的时候,需要给CPU一个中断信号，CPU进行处理.这个就大大的节约了CPU的 资源。</li>
</ul>
</li>
</ul>
<h3 id="IO通道"><a href="#IO通道" class="headerlink" title="IO通道"></a>IO通道</h3><p>就是来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件，他有自己的指令和程序，专门负责数据输入输出的传输控制（相当于cpu把传输控制下放给了通道），具有一些专用的通道指令，它受CPU的I/O指令启动I/O设备，执行通道指令，组织I/O设备和主存交换信息，向CPU报告中断</p>
<p>通道控制方式：</p>
<p>所需的CPU干预更少，并且一个通道可以控制多个设备——-进一步CPU的负担</p>
<p>有专门的指令来改变通道程序</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p><a href="https://so.csdn.net/so/search?q=%E4%B8%AD%E6%96%AD&spm=1001.2101.3001.7020">中断</a>控制方式虽然在某种程度上解决了上述问题，但由于中断次数多，因而CPU仍需要花较多的时间处理中断，而且能够<strong>并行</strong>操作的设备台数也受到中断处理时间的限制，中断次数增多导致数据丢失。</p>
</li>
<li><p><a href="https://so.csdn.net/so/search?q=DMA&spm=1001.2101.3001.7020">DMA</a>方式不需CPU干预传送操作,<strong>仅仅是开始和结尾借用CPU一点时间,其余不占用CPU任何资源</strong>，中断方式是程序切换,每次操作需要保护和恢复现场</p>
</li>
<li><p>DMA方式和通道方式较好地解决了上述问题。这两种方式采用了外设和内存直接交换数据的方式。只有在一段数据传送结束时，这两种方式才发出中断信号要求CPU做善后处理，从而大大减少了CPU的工作负担。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>DMA</th>
<th>中断</th>
<th>通道</th>
</tr>
</thead>
<tbody><tr>
<td>驱动方式</td>
<td>直接存储器存取方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放” CPU</td>
<td>允许I/O设备主动打断CPU的运行并请求服务</td>
<td>DMA方式的发展，它可以进一步减少CPU的干预，即把对一个数据块的读（或写）为单位的干预，减少为对一组数据块的读（或写）及有关的控制和管理为单位的干预。</td>
</tr>
<tr>
<td>适用场景</td>
<td>不需要CPU干预介入的控制器来控制内存与外设之间的数据交流的场合 I/O通道方式：适用于以字节为单位的干预，同时实现CPU、通道和I/O设备三者并行操作的场合</td>
<td>适用于高效场合</td>
<td></td>
</tr>
<tr>
<td>处理方法</td>
<td>获取总线的3种方式分别为:暂停方式、周期窃取方式和共享方式</td>
<td>在系统中具有多个中断源的情况下,常用的处理方法有，多中断信号线法.中断软件查询法.雏菊链法、总线仲裁法和中断向量表法</td>
<td>通道是一种通过执行通道程序管理I/O操作的控制器,它使主机与1/0操作之间达到更高的并行程度。</td>
</tr>
</tbody></table>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>操作系统内核功能通常包含以下几部分： </p>
<ul>
<li><p>系统调用接口（System call interface）。 </p>
</li>
<li><p>程序管理（Process control）。 </p>
</li>
<li><p>内存管理（Memory management）。 </p>
</li>
<li><p>文件系统管理（FileSystem management）。 </p>
</li>
<li><p>设备驱动（Device driver）。 </p>
</li>
</ul>
<p><strong>但不包括版本管理。</strong></p>
<h3 id="时间片轮转法"><a href="#时间片轮转法" class="headerlink" title="时间片轮转法"></a>时间片轮转法</h3><p>时间片轮转算法的基本思想是，系统将所有的<strong>就绪进程（不是线程）</strong>按先来先服务算法的原则，排成一个队列，每次调度时，系统把<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>分配给队列首进程，并让其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序根据这个请求停止该进程的运行，将它送到就绪队列的末尾，再把处理机分给就绪队列中新的队列首进程，同时让它也执行一个时间片。</p>
<p><strong>主要用于分时系统中的进程调度</strong>。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在CPU上运行一个时间片的时间。时间片是一个小的时间单位，通常为10~100ms数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把CPU分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。</p>
<p>采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度程序总是选择就绪队列中的第一个进程，也就是说按照先来先服务原则调度，但一旦进程占用<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>则仅使用一个时间片。在使用先一个时间片后，进程还没有完成其运行，它必须释放出处理机给下一个就绪的进程，而被抢占的进程返回到就绪队列的末尾重新排队等待再次运行。</p>
<p>假设某分时系统采用简单时间片轮转法，当系统中的用户数为n,时间片为q时，系统对每个用户的响应时间T=（ ）。</p>
<ul>
<li>n*q</li>
</ul>
<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><h3 id="背"><a href="#背" class="headerlink" title="背"></a>背</h3><blockquote>
<p>USB是是英文Universal Serial Bus（通用串行总线）的缩写，是一个外部总线标准。<br>UART（Universal Asynchronous Receiver/Transmitter）通用异步接收/发送装置，是一个并行输入成为串行输出的芯片。<br>PCI是Peripheral Component Interconnect（外设部件互连标准）的缩写，它是个人电脑中使用最为广泛的接口，是<strong>并行</strong>通信方式。<br>2C总线由数据线SDA和时钟线SCL两条线构成通信线路，是串行通信方式。</p>
</blockquote>
<p>下列I/O接口类型中，采用并行总线的是()。C<br>A.USB<br>B.UART<br>C.PCI<br>D.L2C</p>
<p>中断向量可提供中断程序的入口地址</p>
<p>虚拟存储器由主存-辅存两级存储器组成</p>
<p>CPU响应DMA请求是在一个<strong>总线周期</strong>结束</p>
<p>计算机系统的主存主要是由（）构成的。DRAM动态随机存储器</p>
<p>操作系统内核功能通常包含以下几部分：</p>
<ul>
<li> 系统调用接口（System call interface）。</li>
<li> 程序管理（Process control）。</li>
<li> 内存管理（Memory management）。</li>
<li> 文件系统管理（FileSystem management）。</li>
<li> 设备驱动（Device driver）。</li>
<li> <strong>但不包括版本管理。</strong></li>
</ul>
<p>在程序执行过程中，Cache与主存的地址映像由 （ ） 。硬件自动完成</p>
<h3 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h3><p>内存按字节编址从A5000H到DCFFFH的区域其存储容量为 224KB</p>
<p>A5000H-DCFFFH+1H =  38FFFH</p>
<blockquote>
<ol>
<li>求编码个数时，需要用最大编号减去最小编号，再加一；</li>
<li>因为编码时两端都有编码，用最大编码减去最小编码时相当于丢掉了最小编码，所以还需要加回来。</li>
</ol>
</blockquote>
<p>如果主存容量为16M字节，且按<strong>字节</strong>编址，表示该主存地址至少应需要 （ ） 位。</p>
<ul>
<li>24,16M=16 * 1024 * 1024 = 2^24</li>
</ul>
<p>采用n位补码(包含一个符号位)表示数据，可以直接表示数值(1)。D</p>
<p>（1）A.2n      B.-2n      C.2n-1      D.-2n-1</p>
<p>解析：补码的取值范围：$-2^{n-1} \sim 2^{n-1}-1$</p>
<p>采用n位补码表示数据时，用1位表示数的符号（0为正1为负），其余n-1位表示数值。若表示整数，可表示的最大整数的二进制形式为n-1个1，最小数为1之后跟n-1个0.</p>
<p>某计算机系统中互斥资源R的可用数为8，系统中有3个进程P1、P2 和P3竞争R，且每个进程都需要i个R，该系统<strong>可能会发生死锁的最小i值</strong>为（  ）。</p>
<p><em><em>利用公式（i-1）</em> 3+1&gt;R；i每个进程需要的资源，R总共有的资源</em>*     </p>
<p>（i-1）*  3+1&gt;8，得出i最小为4。</p>
<blockquote>
<p>不发生死锁的资源数R<br>M个进程 ，每个进程要N个资源，不发生死锁：R = M ×（N－1）+1</p>
</blockquote>
<p>若在系统中有若干个互斥资源R，6个并发进程，每个进程都需要2个资源R，那么使系统<strong>不发生死锁的资源R的最少数目</strong>为  （ ）  。7</p>
<p>死锁的发生是由于并发进程竞争资源而出现相互等待的现象。那么如果每个进程需要2个资源的话，即进程必须获得到2个资源才可以顺利的运行。那么在极端的情况下，6个进程每个都只获得了1个资源，这时6个进程都不能运行，而处于等待，这个时候就会等待其它进程释放1个资源，而获取到该释放的资源，才凑齐2个资源，得以运行，那么如果想保证不发生死锁的话，即只要在极端情况下，再多增加一个资源，就可以打破死锁了。6X1+1=7.</p>
<p>设X、Y为逻辑变量，与逻辑表达式<img src="http://www.cnitpm.com/upload/image/zidongup/20171214113132_9708.png" alt="img">等价的是（  )。X+Y</p>
<img src="http://pic.cnitpm.com/upload/img2013/2016-09-02/wlgcs-201211-4.jpg" alt="img" style="zoom:150%;" />



<p>若每一条指令都可以分解为取指、分析和执行三步。已知取指时间t取指=5△t，分析时间t分析=2△t，执行时间t执行=5△t。如果按顺序方式从头到尾执行完 500 条指令需 （1） △t。如果按照[执行]k、[分析]k+1、[取指]k+2重叠的流水线方式执行指令，从头到尾执行完 500 条指令需 （2） △t。</p>
<ul>
<li><p>顺序执行很简单，500*12</p>
</li>
<li><p>重叠流水线方式参考下图：</p>
<p><img src="http://pic.cnitpm.com/upload/image/20160708/20160708094238_9429.jpg" alt="img"></p>
</li>
</ul>
<p>将一条指令的执行过程分解为取指、分析和执行三步，按照流水方式执行，若取指时间t取指=4△t、分析时间t分析=2△t、执行时间t执行=3△t，则执行完100条指令，需要的时间为（5） △t.</p>
<p>假设执行 n 条指令，<strong>使用流水时间最长的乘以 n-1</strong>，再加上一条指令的执行时间，即（ 100-1） ＊4△t +（ 4△t + 2△t + 3△t） =396△t + 9△t ＝ 405△t</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>主存容量和内存地址关系</p>
<p>当计算机的地址总线为32时,也就是说该计算机的寻址范围为2^32,即主存容量为4GB。</p>
<p>计算机可以找到4GB个储存单元，但是一个储存单元到底是8位还是16位还是32位，不一定（不同的计算机定义不同）</p>
<p>八位机一个储存单元就是八位，十六位机就是十六位，32位机就是32位。因为32位机的数据总线是32位的，也就意味着每读取一次，可以获得32位的数据。所以将内存划分成32位为一格一格的比较好。</p>
<p>计算机采用分级存储体系的主要目的是为了解决（ ）的问题。存储容量，成本和速度之间的矛盾</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>网络把许多计算机连接在一起，而互联网把许多网络通过路由器连接到一起</p>
<img src="https://upload-images.jianshu.io/upload_images/20308335-49d950f7c713929a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img" style="zoom: 50%;" />

<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/06%E5%A4%A7%E6%B6%9B%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E7%A5%9E%E5%9B%BE.jpg" alt="06大涛网络协议神图"></p>
<h3 id="数据通信流程"><a href="#数据通信流程" class="headerlink" title="数据通信流程"></a>数据通信流程</h3><p><strong>数据通信</strong> <code>data communication</code> 是在两台设备之间通过「诸如线缆的某种形式的传输介质」进行的数据交换。</p>
<p>数据通信系统的效率取决于四个关键因素：传递性、准确性、及时性和抖动性。</p>
<ul>
<li><p>传递性 Delivery 。系统必须将数据传递到正确的目的地。数据必须由而且只能由预定的设备或用户接收。</p>
</li>
<li><p>准确性 Accuracy 。系统必须准确地传递数据。在传递过程中发生改变和不正确的数据，都是不可用的。</p>
</li>
<li><p>及时性 Timeliness 。系统必须以及时的方式传递数据。传递延误的数据是无用的。就视频和音频数据而言，及时传递意味着在数据产生时就传递数据，所传递数据的顺序和产生时的顺序相同，而且没有明显的延迟。这种传递称为实时传输。</p>
</li>
<li><p>抖动性 Jitter 。抖动是指分组到达时间的变化，音频或视频的分组在传递过程中延迟各不相同。</p>
<p>比如，假定每 30 ms发送一个视频的分组，其中某些分组到达延时 30 ms，而另一些分组延时 40 ms，就引起视频不均匀后果。</p>
</li>
</ul>
<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><p><img src="https://img-blog.csdnimg.cn/2bf8dbb4747d4ddb95aed598259193fd.png" alt="图1.1数据通信的五个组成部分"></p>
<p>报文 message 是进行通信的信息（数据），它可以是文本、数字、图片、声音、视频等信息形式。<br>发送方 sender 是指发送数据报文的设备，它可以是计算机、工作站、手机、摄像机等。<br>接收方 receiver 是指接收报文的设备，它可以是计算机、工作站、手机、电视等。<br>传输介质 transmission medium 是报文从发送方到接收方之间所经过的物理通路，它可以是双绞线、同轴电缆 光纤和无线电波。<br>协议 protocol 是管理数据通信的一组规则，它表示通信设备之间的一组约定。如果没有协议，即使两台设备之间可能是连接的，那也无法通信，就像一个说法语的人无法被一个只说日语的人理解一样。</p>
<h4 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h4><ul>
<li><p>文本：在数据通信中，文本表示为位模式，即位 0 00 或 1 11序列。模式中位的数目取决于该文本中的符号数目。每一种位模式称为一种编码 code ，<strong>表示符号的过程称为编码过程</strong>。当前流行的编码系统是统一码 Unicode ，用 32 3232 位表示一个符号或字符，它可表示世界上任何一种语言。几十年前，美国制定的美国信息交换标准代码 American Standard Code for Information Interchange, ASCII 现在是统一码前面的 127 127127 个字符，也称为基本拉丁字符集 Basic Latin 。</p>
</li>
<li><p>数字：数字也用位模式表示。但诸如ASCII的编码不是用来表示数字的。数字直接转换为二进制数。原因是简化数字的数学运算。</p>
</li>
<li><p>图像：现在，图像 image 也采用位模式表示。就最简单的形式而言，图像被划分成像素（图片的基本元素）矩阵，每个像素是一个小点。像素的多少取决于称为分辨率的因素。例如，一幅图像可以划分成 1000像素或 10000 像素，后一种有更清晰的图像表示（更高分辨率），但需要更多的内存来存储图像。</p>
<p>将图像划分成像素，对每个像素分配一个位模式。模式的大小和值取决于该图像，就一幅仅由黑白点（例如棋盘）构成的图像而言，1位模式就足以表示一个像素。</p>
<p>如果像素不是由纯白或纯黑的像素构成，则可通过增加位模式的大小来包含更多的灰度范围。例如，可以采用 2位模式来表示 4个级别的灰度 。 黑像素可以用 00表示，深灰像素用 01 ，浅灰像素用 10，白像素用 11 来表示制。</p>
<p>有几种方法表示彩色图像：一种方法是每个颜色像素被分解为三原色 three primary colors ：红、绿、蓝 RGB ，然后测量每种色彩的浓度，并为其赋予一种位模式；另一种方法是每个颜色像素被分解为三原色：黄、紫、青 yellow, cyan, and magenta, YCM 。</p>
</li>
<li><p>音频 audio ：指录音带、声音广播或音乐等声音的表示。<strong>音频与文本、数字或图像有本质的不同。它是连续的、非离散的</strong>。即使用麦克风将声音或音乐转换成电信号，所产生的也是一个连续的信号。【计算机网络】第二部分 物理层和介质(4) 数字传输和【计算机网络】第二部分 物理层和介质(5) 模拟传输介绍，如何将声音或音乐转换成数字或模拟信号。</p>
</li>
<li><p>视频 video ：指录像带、图像或动画的合成，既可以由一个连续实体（如电视摄像机 TV camera）产生，也可以由一组图像或动画合成，这些图像的每一幅都是一个离散的实体，组织起来即可表示运动的意思。正如第4章和第5章所述，同样可以将视频转换为数字或模拟信号。</p>
</li>
</ul>
<h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><img src="https://img-blog.csdnimg.cn/b460ed62004b4f0eb81e13d131a6f164.png" alt="图1.2 数据流(单工、半双工和全双工)" style="zoom:50%;" />

<h4 id="网络准则"><a href="#网络准则" class="headerlink" title="网络准则"></a>网络准则</h4><ul>
<li>性能</li>
<li>可靠性</li>
<li>安全性</li>
</ul>
<h4 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h4><h5 id="连接类型"><a href="#连接类型" class="headerlink" title="连接类型"></a>连接类型</h5><ul>
<li>点到点 point-to-point 连接提供两台设备之间专用的链路。链路全部的能力均为两台设备之间的传输所共用。大多数点到点连接，采用实际长度的线或电缆来连接两端，但诸如微波或卫星链路的其他选择也是可行的（见图1.3a）。当使用红外线遥控器切换电视频道时，就在遥控器和电视控制系统之间建立了一条点到点连接。</li>
<li>多点连接 multipoint connection 也称为多站连接 multidrop connection 是两台以上设备共享单一链路的情形（见图1.3b）。在多点环境中，通道的能力在空间或时间上共享。如果同时可以有多台设备使用链路，这是空间上共享连接；如果用户必须轮流使用，这是时间上共享连接。</li>
</ul>
<h5 id="物理拓扑结构"><a href="#物理拓扑结构" class="headerlink" title="物理拓扑结构"></a>物理拓扑结构</h5><p><strong>物理拓扑结构</strong> <code>physical topology</code> 一词指的是<strong>网络在物理上分布的方式</strong>。两台或更多的设备连接到一条链路，两条或更多的链路组成拓扑结构。<strong>网络拓扑结构</strong>是<strong>所有链路及其互相连接的设备</strong>（通常称为节点）<strong>之间关系的几何表示</strong>。有四种可能的基本拓扑结构：网状、星型、总线和环状</p>
<h3 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h3><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><p>光纤传输介质由可以传送光波的玻璃纤维或透明塑料制成，<strong>外包一层比玻璃折射率低的材料</strong>。光波在光纤中以什么模式传播，这与芯线和包层的相对折射率、芯线的真径以及工作波长有关</p>
<ul>
<li>多模光纤：进入光纤的光波在两种材料的介面上形成全反射，从而不断地向前传播。 光波在光导纤维中以多种模式传播，不同的传播模式有不同的电磁场分布和不同的传播路径。多模光纤的带宽约为2.5Gbps</li>
<li>单模光纤： 芯线的直径小到光波波长大小，则光纤就成为波导，光在其中无反射地沿直线传播，很少反射，所以色散减小、带宽增加，传输距离也得到加长。但是与之配套的光端设备价格较高，单模光纤的带宽超过10Gbps。</li>
</ul>
<p><strong>单模光纤比多模光纤的数据速率高，但价格更昂贵。</strong>光导纤维作为传输介质，其优点是很多的。首先是它具有很高的数据速率、极宽的频带、低误码率和低延迟。典型数据 速率是100 Mb/s，甚至可达1000 Mb/s，而误码率比同轴电缆可低两个数量级，只有10 。其次是光传输不受电磁于扰，不可能被偷听，因而安全和保密性能好。最后，光纤重 量轻、体积小、铺设容易。</p>
<h4 id="无源光网络-PON"><a href="#无源光网络-PON" class="headerlink" title="无源光网络 (PON)"></a>无源光网络 (PON)</h4><p>无源光网络 (PON)是一种纯介质网络，避免了外部设备的 电磁于扰和雷电影响， 减少了线路和外部设备的故障率， 提高了系统可靠性，同时节省了维护成本。 分光器就是连接OLT和ONU的无源设备， 它的功能是分发 下行数据，并集中上行数据。分光器带有一个上行光接口， 若干下行光接口,实现点对多点的通讯。</p>
<h4 id="RJ-45端口和双绞线"><a href="#RJ-45端口和双绞线" class="headerlink" title="RJ-45端口和双绞线"></a>RJ-45端口和双绞线</h4><p><strong>百兆用4根，千兆用8根</strong></p>
<p>双绞线的4、5线对为正极为PD设备供电，7、8线对为负极为PD设备供电，<strong>3、6是用于传输数据的</strong>。</p>
<blockquote>
<p> RJ-45端口：这种端口通过双绞线连接以太网。</p>
<p> 10Base-T的RJ-45端口标识为“ETH”，而100Base-TX的RJ-45端口标识为“10/100bTX”。</p>
</blockquote>
<p>双绞线可按其是否外加金属网丝套的屏蔽层而区分为屏蔽双绞线（STP）和非屏蔽双绞线（UTP）。从性价比和可维护性出发，大多数局域网使用非屏蔽双绞线（UTP -Unshielded Twisted pair） 作为布线的传输介质来组网。 UTP网线由一定长度的双绞线和RJ45水晶头组成 </p>
<p>双绞线由8根不同颜色的线分成4对绞合在一起，<strong>成对扭绞的作用是尽可能减少电磁辐射与外部电磁干扰的影响。</strong></p>
<p>网线的线序又分为两种：568A与568B。</p>
<ul>
<li>  标准568A线序：1-绿白，2-绿，3-橙白，4-蓝，5-蓝白，6-橙，7-棕白，8-棕；</li>
<li>  标准568B线序：1-橙白，2-橙，3-绿白，4-蓝，5-蓝白，6-绿，7-棕白，8-棕；</li>
</ul>
<blockquote>
<p>直连线，同一根网线的两端使用同样的线序；</p>
<p>交叉线，同一根网线的两段使用不同的线序。</p>
<p>即，网线的两端都使用568A或568B的是直连线；网线两端，一端用568A，一端用568B的是交叉线。在实际运用中一般都使用568B，通常认为568B对电磁干扰的屏蔽比较好。</p>
</blockquote>
<p>计算机网络中直连电缆和交叉电缆的区别</p>
<p>以太网电缆中，收、发各由一对双绞线承当，对于所连接的两台设备，要做到收发对应才能正常工作。 普通以太网电缆就是常用的直连线，两头是完全一样的。一般用于网络设备与终端设备之间的连接（比如交换机与电脑），因为它们的收发定义刚好是反过来的。 以太网交叉电缆就是交叉线，两头的1、2与3、6是交叉连接的。用于同类设备之间连接（比如电脑连电脑、交换机连交换机等），因为它们的收发定义是相同的，用交叉线使收发对应起来。 不过现在很多设备都有收发自动反转功能，在大多数情况下都可以用直连线。</p>
<blockquote>
<p>同种设备用交叉线，异种设备用直连线。</p>
</blockquote>
<h4 id="DTE和DCE"><a href="#DTE和DCE" class="headerlink" title="DTE和DCE"></a>DTE和DCE</h4><p>数据终端设备，所有具有作为<a href="https://so.csdn.net/so/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&spm=1001.2101.3001.7020">二进制</a>数字数据源点或终点能力的单元。就是与我们直接接触的一些设备，如计算机、打印机、传真机等等，我们需要通信的信息都可以通过它转化为数字世界中的01信号。</p>
<p>DTE产生了包含一定信息的二进制数字数据，但这种数据不适合<strong>直接</strong>在通信双方之间的介质(或网络)上传输，<strong>因此引入了DCE来对二进制数字数据进行调制或转换等工作，使其适于远距离传输</strong></p>
<p>DCE：数据电路终接设备，任何能够通过网络发送和接收模拟或数字数据的功能单元。</p>
<h4 id="高速同步串口"><a href="#高速同步串口" class="headerlink" title="高速同步串口"></a>高速同步串口</h4><p>高速同步串口（Synchronous Serial Port）：在路由器与广域网的连接中，应用最多的是高速同步串行口，这种端口用于连接DDN、<strong>帧中继</strong>、X.25和PSTN等网络。</p>
<h4 id="Console端口"><a href="#Console端口" class="headerlink" title="Console端口"></a>Console端口</h4><p>Console端口：Console端口通过专用电缆连接至计算机串行口，利用终端仿真程序对路由器进行本地配置。路由器的Console端口为RJ-45口。</p>
<h3 id="特殊ip"><a href="#特殊ip" class="headerlink" title="特殊ip"></a>特殊ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">224.0.0.1 所有主机</span><br><span class="line">224.0.0.2 所有路由器</span><br><span class="line">224.0.0.5 所有运行OSPF路由器</span><br><span class="line">224.0.0.6 OSPF DR/BDR</span><br><span class="line">224.0.0.9 RIPv2 路由器</span><br><span class="line">224.0.0.18 VRRP（虚拟路由器冗余协议）</span><br><span class="line">如果都没有得到**DHCP服务器端**的回应，客户机会从**169.254.0.0/16**这个自动保留的私有IP地址中选用一个IP地址</span><br></pre></td></tr></table></figure>

<h3 id="协议端口"><a href="#协议端口" class="headerlink" title="协议端口"></a>协议端口</h3><ul>
<li><p>ICMP 1</p>
</li>
<li><p>FTP 数据20控制21 </p>
</li>
<li><p>Telnet 23 </p>
</li>
<li><p>SMTP简单邮件传输 25 </p>
</li>
<li><p>RSVP 46</p>
</li>
<li><p>DNS 53(TCP和UDP都可调用)  </p>
</li>
<li><p>DHCP 67、68   </p>
</li>
<li><p>TFTP 69</p>
</li>
<li><p>HTML  80  </p>
</li>
<li><p>ospf:89</p>
</li>
<li><p>x2.5 93</p>
</li>
<li><p>pop3  110  ，建立连接用TCP</p>
</li>
<li><p>VRRP 112</p>
</li>
<li><p>SQL services 118  </p>
</li>
<li><p>IS-IS 124</p>
</li>
<li><p>IMAP 143</p>
</li>
<li><p>SQL server  156</p>
</li>
<li><p>SNMP协议实体发送请求和应答报文的默认端口号是161，SNMP代理发送陷阱报文(<strong>Trap</strong>) 的默认端口号是162。</p>
</li>
<li><p>BGP 149</p>
</li>
<li><p>IKE端口是udp的500</p>
</li>
<li><p>rip: 520</p>
</li>
<li><p>https/ssl  443</p>
</li>
</ul>
<h3 id="从IPv4向IPv6过渡的策略"><a href="#从IPv4向IPv6过渡的策略" class="headerlink" title="从IPv4向IPv6过渡的策略"></a>从IPv4向IPv6过渡的策略</h3><p>两种向IPv6过渡的策略，即使用双协议栈和隧道技术。</p>
<p><strong>双协议栈（dual stack）</strong>是指在完全过渡到IPv6之前，使一部分主机（或路由器）装有两个协议栈，一个IPv4和一个IPv6。因此双协议栈主机（或路由器）既能够和IPv6的系统通信，又能够和IPv4的系统进行通信。双协议栈的主机（或路由器）记为IPv6/ IPv4，表明它具有两种IP地址：一个IPv6地址和一个IPv4地址。</p>
<p><strong>隧道技术（tunneling）</strong>。这种方法的要点就是在IPv6数据报要进入IPv4网络时，将IPv6数据报封装成为IPv4数据报（整个的IPv6数据变成了IPv4数据报的数据部分）。然后IPv6数据报就在IPv4网络的隧道中传输。当IPv4的数据报离开IPv4网络中的隧道时再将其数据部分（即原来的IPv6数据报）交给主机的IPv6协议栈。</p>
<h3 id="网络交换技术"><a href="#网络交换技术" class="headerlink" title="网络交换技术"></a>网络交换技术</h3><p>采用交换网络——将多个<a href="https://so.csdn.net/so/search?q=%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C&spm=1001.2101.3001.7020">计算机网络</a>或通信网络相互连接，以实现信息交换和资源共享的技术叫网络互联技术，也即<strong>网络交换技术</strong>。交换网络由一系列互联的节点构成，这些节点称为<strong>交换机</strong> <code>switch</code> ，交换机能在链接到交换机的两台或多条设备之间，建立起临时连接（即组建局域网和VLAN）</p>
<p>交换方式：电路交换、分组交换、报文交换，前两种目前普遍使用。第三种（<strong>在报文交换中，每个交换机存储整个报文，并转发到下一个交换机</strong>）在一般通信中已逐步淘汰——尽管在低层看不见报文的交换，但它仍然存在于某些网络应用中，如电子邮件 <code>E-mail</code> 。</p>
<img src="https://img-blog.csdnimg.cn/7dbd7ca7636b4bbcb92c295b484f555e.png" alt="在这里插入图片描述" style="zoom:50%;" />

<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>物理层的作用：连接不同的物理设备，传输<strong>比特流</strong>。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。</p>
<p>物理层考虑以下一系列问题：</p>
<ul>
<li>接口与介质的物理特性。物理层定义了设备与传输介质之间的接口特性，也定了传输介质的类型。</li>
<li>位的表示。物理层的数据是没有任何解释的位 bit 流（由 0 和 1  所组成的序列）。要进行传输，位必须编码成信号一一电信号或光信号。物理层定义编码 encoding 的类型（如何将 0 和 1 转换成信号）。</li>
<li>数据速率。传输速率 transmisson rate ，即每秒发送的位数，也在物理层定义。换言之，物理层也定义一个位持续多长时间。</li>
<li>位同步。发送方与接收方不仅使用相同的比特率，还必须位同步。换言之，发送方的时钟与接收方的时钟必须同步。</li>
<li>线路配置。物理层涉及设备与介质的连接。在点到点配置中，两个设备通过一条专用链路连接。在多点配置中，许多设备共享一条链路。</li>
<li>物理拓扑结构。物理拓扑结构定义如何将设备连接成网络。设备的连接方式可以是网状拓扑结构（每台设备均与其他设备连接）、星型拓扑结构（通过中心设备与其他设备连接）、环状拓扑结构（每台设备与下一台设备连接以组成一个环）和总线拓扑结构（每台设备都在一条公共链路上）。</li>
<li>传输方式。物理层也定义两台设备之间的传输方向：单工、半双工和全双工。在单工方式中，只有一个设备能发送，另一个设备只能接收。单工方式是单向通信。在半双工方式中，两台设备都能发送和接收，但不能在同一时刻。在全双工（或双工）方式中，两个设备能在同一时刻发送与接收。</li>
</ul>
<h3 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h3><p>网络拓扑(Network Topology)结构是指用传输介质互连各种设备的物理布局。指构成网络的成员间特定的物理的即真实的、或者逻辑的即虚拟的排列方式。如果两个网络的连接结构相同我们就说它们的网络拓扑相同，尽管它们各自内部的物理接线、节点间距离可能会有不同。</p>
<p><strong>五种网络拓扑结构</strong></p>
<ul>
<li><p>网状拓扑结构：网络的每台设备之间均有点到点的链路连接，<strong>常用于广域网</strong>。</p>
</li>
<li><p>总线型结构：各工作站和服务器均挂在一条总线上，各工作站地位平等，无中心节点控制，公用总线上的信息多以基带形式串行传递，其传递方向总是从发送信息的节点开始向两端扩散，各节点在接受信息时都进行地址检查，看是否与自己的工作站地址相符，相符则接收网上的信息,<strong>多用于同轴电缆架构的以太网</strong>。</p>
</li>
<li><p>环型结构：由网络中若干节点通过点到点的链路首尾相连形成一个闭合的环，这种结构使公共传输电缆组成环型连接，数据在环路中沿着一个方向在各个节点间传输，信息从一个节点传到另一个节点，<strong>多用于令牌环网、城域网FDDI网</strong>。</p>
</li>
<li><p>星型结构：星型结构是指各工作站以星型方式连接成网。网络有中央节点，其他节点（工作站、服务器）都与中央节点直接相连，这种结构以中央节点为中心，因此又称为集中式网络。</p>
</li>
<li><p>树型结构：网络的每台设备之间均有点到点的链路连接，层次级网络，每个节点可能采用其他拓扑结构，比如星型结构。</p>
</li>
</ul>
<h3 id="DSL"><a href="#DSL" class="headerlink" title="DSL"></a>DSL</h3><blockquote>
<p>DSL是介于物理层和数据链路层之间</p>
</blockquote>
<p>数字用户线路（Digital Subscriber Line），DSL允许用户在传 统电话线上提供高速的传输，用户计算机借助于DSL调制解调器连接到电话线上，通过DSL连接访问互联网络或者企业网络。 DSL技术存在多种类型，以下是常见的技术类型： </p>
<p>ADSL：<strong>非对称DSL</strong>，用户的上下行流量不对称，一般 具有三个信道，分别为1.544-9Mb/s的高速下行信道， 16-</p>
<p>640Kb/s的双工信道，64Kb/s的语音信道。 </p>
<p>SDSL: <strong>对称DSL</strong>，用户的上下行流量对等，最高可以达到 <strong>1.544Mb/s</strong>。 </p>
<p>HDSL：高比特率DSL，是在两个线对上提供1.544Mb/s或在 三个线对上提供2.048Mb/s<strong>对称</strong>通信的技术， 其最大特点是 可以运行在低质量线路上，最大距离为3700-4600m。 </p>
<p>VDSL:_甚高比特率DSL，一种快速<strong>非对称</strong>DSL业务，可以 在一对电话线上提供数据和语音业务。</p>
<p>xDSL</p>
<p>①HDSL中断距离可达3-5KM、传输速率2.048Mbits/s</p>
<p>②ADSL是一种非对称的DSL技术</p>
<p>③VDSL是一种非对称的技术，也是DSL中<strong>传输速度最快的技术</strong></p>
<p>④SDSL：单线路数字用户技术是对称的</p>
<p>⑤RADSL：速率自适应数字用户线技术，是采用非对称技术。</p>
<h4 id="ADSL"><a href="#ADSL" class="headerlink" title="ADSL"></a>ADSL</h4><p><strong>下面是家庭用户安装 ADSL 宽带网络时的拓扑结构图，图中左下角的 X 是（）设备，为了建立虚拟拨号线路，在用户终端上应安装（）协议。</strong><br><img src="https://img-blog.csdnimg.cn/2019082720054018.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VuZGVybWFuX3hpYW9oZWk=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 67%;" /><br><strong>问题1：</strong><br>A. DSLAM<br>B. HUB<br>C. ADSL Modem<br>D. IP Router<br><strong>问题2：</strong><br>A. <a href="https://so.csdn.net/so/search?q=ARP&spm=1001.2101.3001.7020">ARP</a><br>B. HTTP<br>C. PPTP<br>D. PPPoE<br><strong>答案</strong>：<br>A<br>D<br><strong>解析</strong>：<br>在 ADSL 宽带拓扑结构中，来自用户线路的流量若要进入 IP 网络，需要在局端经过数字用户线路进入 IP 网络，需要在局端经过数字用户线路接入复用器（DSLAM）设备进行解调，还原成数字信号，再经由宽带接入服务器（BAS）进入到因特网。</p>
<p>ADSL采用的两种接入方式是 （ ） 。<strong>虚拟拨号接入和专线接入</strong></p>
<p>ADSL用于连接公共交换电话网PSTN，PSTN属于电路交换网，<strong>所以ADSL是电路交换网的一部分。X.25，FRN和ATM都是分组交换网。</strong> </p>
<h3 id="设备-1"><a href="#设备-1" class="headerlink" title="设备"></a>设备</h3><ul>
<li>中继器【Repeater，也叫放大器】：同一局域网的再生信号；两端口的网段必须同一协议；5-4-3规程：10BASE-5以太网中，最多串联4个中继器，5段中只能有3个连接主机；</li>
</ul>
<ul>
<li>集线器：同一局域网的再生、放大信号（多端口的中继器）；半双工，不能隔离冲突域也不能隔离广播域。</li>
</ul>
<h4 id="传输介质-1"><a href="#传输介质-1" class="headerlink" title="传输介质"></a>传输介质</h4><p>同轴电缆：</p>
<ul>
<li>基带同轴电缆</li>
<li>宽带同轴电缆</li>
</ul>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层 data link layer 将「物理层对数据不做任何改动的传输通道」变成可靠的链路，这样可以将物理层的数据无差错地传递给上层（网络层）。基本数据单位为<strong>帧</strong>；</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><h4 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h4><p>封装成帧：“帧”是数据链路层数据的基本单位,在数据报添加首部和尾部构成一个帧，帧最少64</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatS5GsjuaSqdgs1OfpTOtW1dxYB4G5cuTSWW9klKtCQOFAoicgMceo7pFA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSL5Apq9cibxzMEh1iaYUdnLt4ficSKia5q4hu7OrLTGBAQQAEuJ2hh2le5Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>网络层的IP数据报传到数据链路层就成为帧的数据部分，首部和尾部包括许多必要的控制信息和进行帧定界的作用。<strong>为了提高帧的传输效率，应尽量使帧的数据部分长度大于首部和尾部的长度</strong>，而每一种链路层协议也都规定了帧的数据部分上限最大传送单元MTU</p>
<p><strong>最大传输单元MTU</strong></p>
<p>最大传输单元MTU(Maximum Transmission Unit)，数据链路层的数据帧不是无限大的，数据帧长度受MTU限制。</p>
<p><strong>路径MTU:由链路中MTU的最小值决定</strong></p>
<h4 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h4><p><strong>物理寻址</strong>。如果帧是发送给网络中不同系统，则数据链路层在帧的头部添加发送方的物理地址与接收方的物理地址。如果帧要发往发送方网络之外的系统，那么接收方的地址就是「连接一个网络到下一个网络的设备的地址」。</p>
<h4 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h4><p>“透明”是指即使<strong>控制字符</strong>在帧数据中，但是要当做不存在去处理。即在控制字符前加上转义字符ESC。<img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSIts4DUr0olxbibAaAljneYvLtEh3QymanlbuhVKfpLDUpHkxicns5sbQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="差错监测"><a href="#差错监测" class="headerlink" title="差错监测"></a>差错监测</h4><p>由于<strong>信道噪声</strong>等各种原因，帧在传输过程中可能会出现错误。用以使发送方确定接收方是否正确收到由其发送的数据的方法称为差错控制。通常，错误可分为位错和帧错：</p>
<ul>
<li>位错指帧中某些位出现了差错。</li>
<li>帧错指帧的丢失、重复或失序等错误</li>
</ul>
<p>差错检测：奇偶校验码、循环冗余校验码CRC、海明码</p>
<ul>
<li><p>奇偶校验码</p>
<ul>
<li>局限性：当出错两位时，检测不到错误。</li>
</ul>
</li>
<li><p>循环冗余检验码：根据传输或保存的数据而产生固定位数校验码。</p>
</li>
<li><p>海明码</p>
</li>
</ul>
<h5 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h5><p>在待发送的数据后面添加1位奇偶校验位，使整个数据(包括所添加的校验位在内)中”1”的个数为奇数(奇校验)或偶数(偶校验)</p>
<p>若有奇数个位发生误码，奇偶性发生变化，可检查出误码；</p>
<p>若有偶数个位发生误码，奇偶性不发生变化，则不能检查出误码</p>
<p><img src="https://img-blog.csdnimg.cn/9bd2f62012674b229a27e11850cdc2e3.png" alt="img"></p>
<h5 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h5><p>收发双方约定好一个生成多项式G(x)；</p>
<p>发送方基于待发送的数据和生成多项式计算出差错检测码(冗余码)，将其添加到待传输数据的后面一起传输；接收方通过生成多项式来计算收到的数据是否产生了误码</p>
<p><img src="https://img-blog.csdnimg.cn/d87b00cffe674c52970cfeaf62cce102.png" alt="img"></p>
<ul>
<li>1001多项式为x^3 + x^0</li>
<li>1001的阶r为3，加3个0</li>
<li><strong>模二除法</strong>，数据加0后除以多项式G（x），余数为冗余码</li>
</ul>
<img src="https://pic1.zhimg.com/80/v2-b001898a1eba986a956998dd9758a268_1440w.webp" alt="img" style="zoom:50%;" />

<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230329230051455.png" alt="image-20230329230051455"></p>
<h5 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h5><p>实现原理，是在m个数据位之外加上k个校验位，从而形成一个m+k位的新的码字，使新的码字的码距比较均匀地拉大。把数据的每一个二进制位分配在几个不同的偶校验位的组合中，当某一位出错后，就会引起相关的几个校验位的值发生变化，这不但可以发现出错，还能指出是哪一位出错，为进一步自动纠错提供了依据。</p>
<p><strong>假设校验位有k位，那么校验码最多有2^k个，显然其中有一个校验码是正确的，那么就能校验出 $2^k-1$个错位。所以，如果能满足一个则n和k的关系必须满足以下关系：</strong></p>
<p><strong>2^k -1 &gt;= n+k</strong></p>
<p><a href="https://blog.csdn.net/konley233/article/details/108134466">https://blog.csdn.net/konley233/article/details/108134466</a></p>
<ul>
<li><p>原始数据：1011，求校验码个数</p>
<p>这样 n=4 , 将 k=1,2,3,… 代入公式很容发现 k=3就满足条件，2^3-1 &gt;=4+3</p>
<p>所以校验码位数为3位，数据和校验码一共7位。</p>
</li>
<li><p>确认校验码位置</p>
<p><strong>海明码的长度 = 原始信息码 + 校验码</strong>。此题中，海明码长度 = 4 + 3 = 7位</p>
<p><strong>分配校验码的位置</strong>：校验位的位置一般为2^n（n≥0），针对此题来说就是1、2、4、8的位置上。</p>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th><strong>位数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td></td>
<td>1</td>
<td></td>
<td></td>
<td><strong>信息位</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>r2</td>
<td></td>
<td>r1</td>
<td>r0</td>
<td><strong>校验位</strong></td>
</tr>
</tbody></table>
</li>
<li><p>计算校验码</p>
<p>① <strong>将每个信息位数拆分成n个校验位数之和</strong></p>
<p>在本题中，信息位是：7、6、5、3，校验位是：4、2、1，则</p>
<p><strong>7 = 4 + 2 + 1</strong>，表示第7位的信息码由第4、2、1位的校验码所校验，下同</p>
<p><strong>6 = 4 + 2</strong>，</p>
<p><strong>5 = 4 + 1</strong></p>
<p><strong>3 = 2 + 1</strong></p>
<p><strong>② 分组</strong></p>
<p>将上面等式中，各个校验码所校验的位数进行分组</p>
<p>如r2是第4位，而4校验了上面的7、6、5位，可以写成</p>
<p>r2（7，6，5）</p>
<p>r1（7，6，3）</p>
<p>r0（7，5，3）</p>
<p>③计算</p>
<p>将分组的元素转为该位置对应的信息码再进行异或运算即可</p>
<p>注意，是异或运算，即同0异1的原则</p>
<p>r2 = 1 ⊕ 0 ⊕ 1 = 0</p>
<p>r1 = 1 ⊕ 0 ⊕ 1 = 0</p>
<p>r0 = 1 ⊕ 1 ⊕ 1 = 1</p>
<p>到这里基本就算完了，可以知道r2 = 0，r1 = 0，r0 = 1</p>
<table>
<thead>
<tr>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th><strong>位数</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td><strong>信息位</strong></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>r2</td>
<td></td>
<td>r1</td>
<td>r0</td>
<td><strong>校验位</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="IEEE802标准"><a href="#IEEE802标准" class="headerlink" title="IEEE802标准"></a>IEEE802标准</h3><blockquote>
<p>IEEE于1980年2月成立了局域网标准委员会（简称IEEE802委员会），专门从事局域网标准化工作，并制定了IEEE802标准。</p>
<p>802标准所描述的局域网参考模型只对应OSI参考模型的数据链路层与物理层，它将数据链路层划分为逻辑链路层LLC子层和介质访问控制MAC子层。</p>
<p><strong>其中IEEE802.2LAN标准定义了逻辑链路控制LLC子层的功能与服务，并且是基标准。</strong></p>
</blockquote>
<p>IEEE 802委员会的任务是制定局域网和城域网标准，目前有20多个分委员会，如下。</p>
<ul>
<li><p>802.1研究局域网体系结构、寻址、网络互联和网络管理。</p>
<ul>
<li><strong>IEEE802.1d 冗余链路stp协议</strong></li>
<li><strong>IEEE802.1W 快速stp协议</strong></li>
<li><strong>IEEE802.1q 虚拟局域网VLAN</strong><ul>
<li><strong>最多可以配置4049个 VLAN</strong></li>
<li>GVRP协议所支持的VLANID范围为1-4094，而VTP协议只支持1-1001号的VLAN。</li>
</ul>
</li>
<li><strong>IEEE802.1x 认证系统</strong></li>
<li><strong>IEEE802.1p Qos</strong></li>
<li><strong>IEEE802.1g 网桥</strong></li>
</ul>
</li>
<li><p>802.2研究<strong>逻辑链路控制子层</strong>（LLC）的定义。</p>
</li>
<li><p>802.3研究<strong>以太网</strong>介质访问控制协议<strong>CSMA/CD</strong>及物理层技术规范。</p>
<ul>
<li><strong>IEEE802.3u 快速/百兆以太网</strong>  LAN<ul>
<li>100Base-TX 两对五类UTP<strong>无屏蔽双绞线</strong>  100m</li>
<li>100Base-FX 一对单模光纤SMF 40Km<ul>
<li>采用的编码技术为( )。4B/5B+NRZI</li>
</ul>
</li>
<li>100Base-T4四对3类UTP（淘汰）100m</li>
</ul>
</li>
<li><strong>IEEE802.3z 千兆以太网</strong>  LAN<ul>
<li>1000 base-cx标准使用的是屏蔽双绞线（2对STP），双绞线长度可以达到25m；</li>
<li>1000 base-sx标准使用的是波长为850nm的多模光纤（短波），光纤长度可以达到300～<strong>550m</strong>。</li>
<li>1000 base-lx标准使用的是波长为1300nm的单模光纤（长波），光纤长度可以达到3000m；<strong>支持1000m以上传输距离</strong></li>
</ul>
</li>
<li>**IEEE802.3ae 万兆以太网 ** MAN</li>
<li>ieee 802.3ab <strong>千兆以太网</strong> MAN<ul>
<li>1000 base-T：1000BaseT是一种使用<strong>4对UTP</strong>作为网络传输介质的千兆以太网技术，最长有效距离与100BaseTX一样可以达到100米。可以采用这种技术在原有的快速以太网系统中实现从100Mb/s~1000Mb/s的平滑升级。与前面介绍的其他3种网络介质不同，<strong>1000BaseT不支持8B/10B编码方案</strong>，需要采用专门的更加先进的编码/译码机制。</li>
</ul>
</li>
</ul>
</li>
<li><p>802.4研究<strong>令牌总线网</strong>（Token-Bus）的介质访问控制协议及物理层技术规范。</p>
</li>
<li><p>802.5研究<strong>令牌环网</strong>（Token-Ring）的介质访问控制协议及物理层技术规范。</p>
</li>
<li><p>802.6研究城域网介质访问控制协议DQDB及物理层技术规范。</p>
</li>
<li><p>802.7宽带技术咨询组，提供有关宽带联网的技术咨询。</p>
</li>
<li><p>802.8光纤技术咨询组，提供有关光纤联网的技术咨询。</p>
</li>
<li><p>802.9研究综合声音数据的局域网（IVDLAN）介质访问控制协议及物理层技术规范.</p>
</li>
<li><p>802.10<strong>局域网安全机制</strong>，网络安全技术咨询组，定义了网络互操作的认证和加密方法。</p>
</li>
<li><p>802.11研究<strong>无线局域网（WLAN）</strong>的介质访问控制协议及物理层技术规范。</p>
<ul>
<li>802.11b   2.4GHz</li>
<li>802.11g   2.4GHz</li>
<li><strong>802.11n   2.4&amp;5</strong></li>
<li><strong>802.11a  5.0GHz</strong></li>
<li>802.11ac  5.0GHz</li>
</ul>
</li>
<li><p>802.12研究需求优先的介质访问控制协议（100VG-AnyLAN）。</p>
</li>
<li><p>802.14研究采用线缆调制解调器（Cable Modem）的交互式电视介质访问控制协议及物理层技术规范。</p>
</li>
<li><p>802.15 研究采用<strong>蓝牙技术</strong>的无线个人网（Wireless Personal Area Network,WPAN)技术规范。</p>
</li>
<li><p>802.16 <strong>无线城域网</strong>，宽带无线接入工作组，开发2~66GHz的无线接入系统空中接口。</p>
</li>
<li><p>802.17弹性分组环（RPR）工作组，制定了弹性分组环网访问控制协议及有关标准。</p>
</li>
<li><p>802.18宽带无线局域网技术咨询组（Radio Regulatory）。</p>
</li>
<li><p>802.19多重虚拟局域网共存（Coexistence）技术咨询组。</p>
</li>
<li><p>802.20移动宽带无线接入（MBWA)工作组，正在制定宽带无线接入网的解决方案。（20)802.21研究各种无线网络之间的切换问题，正在制定与介质无关的切换业务（MIH)标准。</p>
</li>
<li><p>802.22无线区域网（Wireless Regional Area Network，WRAN）工作组，正在制定利用感知无线电技术，在广播电视频段的空白频道进行无干扰无线广播的技术标准。</p>
</li>
</ul>
<h4 id="IEEE-802-11"><a href="#IEEE-802-11" class="headerlink" title="IEEE 802.11"></a>IEEE 802.11</h4><p>IEEE802.11定义了无线局域网的两种工作模式，其中的  （1）  模式是一种点对点连接的网络，不需要无线接入点和有线网络的支持。IEEE802.11g的物理层采用了扩频技术，工作在  （2）  频段。</p>
<p>AD HOC,2.4GHZ</p>
<p>无线局域网的新标准IEEE802.11n提供的最高数据速率可达到（67）Mb/S。300</p>
<h3 id="MAC和LLC"><a href="#MAC和LLC" class="headerlink" title="MAC和LLC"></a>MAC和LLC</h3><blockquote>
<p>由于局域网是分组广播式网络，网络层的路由功能是不需要的，所以在IEE802标准中，网络层简化成了上层协议的服务访问点SAP。又由于局域网使用多种传输介质，而介质访问控制协议与具体的传输介质和拓扑结构有关，所以，IEEE802 标准把数据链路层划分成了两个子层。与物理介质相关的部分叫作介质访问控制（Medium Access Control，MAC）子层，与物理介质无关的部分叫作逻辑链路控制（Logical Link Control，LLC）子层。<strong>LLC提供标准的OSI数据链路层服务，这使得任何高层协议（例如TCP/IP、SNA 或有关的OSI 标准）都可运行于局域网标准之上。</strong>局域网的物理层规定了传输介质及其接口的电气特性、机械特性、接口电路上和信具速率等。</p>
</blockquote>
<p>一、实现不同</p>
<p>1、MAC子层：MAC子层是由网络接口卡（NIC:网卡）来实现。</p>
<p>2、LLC子层：LLC子层是由传输驱动程序实现的。</p>
<p>二、依赖体不同</p>
<p>1、MAC子层：MAC子层依赖于各自的物理层。</p>
<p>2、LLC子层：LLC子层在IEEE802.2标准中定义，为802标准系列共用。</p>
<p>三、主要功能不同</p>
<p>1、MAC子层：MAC子层的的主要功能为数据帧的封装/卸装，帧的寻址和识别，帧的接收与发送，链路的管理，帧的差错控制。MAC子层的存在屏蔽了不同物理链路种类的差异性</p>
<p>2、LLC子层：LLC子层的主要功能为负责识别网络层协议，传输可靠性保障和控制，数据包的分段与重组，数据包的顺序传输。</p>
<h4 id="LLC层"><a href="#LLC层" class="headerlink" title="LLC层"></a>LLC层</h4><p><strong>逻辑链路控制</strong>（logical link control，LLC）层位于OSI网络模型的数据链路层，<strong>由IEEE802.2标准定义</strong>，用户的数据链路服务通过LLC子层为上层（IP层）提供统一的接口，提供给其他802协议（e.g. 802.3, 802.11,etc）使用。MAC可以在LLC层的支持下执行寻址方式和网络层协议识别功能，然后进行封装。</p>
<p>LLC定义了三种数据通信操作类型：</p>
<ul>
<li>类型1：无连接。该方式对信息的发送通常无法保证接收。</li>
<li>类型2：面向连接。该方式提供了四种服务：连接的建立、确认和承认响应、差错恢复（通过请求重发接收到的错误数据实现）以及<strong>滑动窗口（系数：128）</strong>。通过改变滑动窗口可以提高数据传输速率。</li>
<li>类型3：无连接承认响应服务。</li>
</ul>
<h4 id="介质访问控制MAC层"><a href="#介质访问控制MAC层" class="headerlink" title="介质访问控制MAC层"></a>介质访问控制MAC层</h4><h5 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA/CA"></a>CSMA/CA</h5><blockquote>
<p>IEEE802.11的MAC子层协议，CSMA/CA<strong>用于无线局域网</strong></p>
<p>CSMA/CA采用能量检测（ED）、载波检测（CS）和能量载波混合检测三种检测信道空闲的方式</p>
</blockquote>
<h5 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h5><blockquote>
<p>IEEE802.3的MAC子层协议，CSMA/CD用于总线式以太网</p>
<p>CSMA/CD通过电缆中电压的变化来检测，当数据发生碰撞时，电缆中的电压就会随着发生变化</p>
</blockquote>
<p>CSMA/CD即载波监听多路访问/碰撞检测</p>
<ul>
<li><p>载波监听（carrier sense），意思就是以太网络上的各个工作站在发送数据前，都要监听总线上有没有数据正在传输。若有数据传输 （称总线为忙），则不发送数据，需要等待；若无数据传输（称总线为空），可以立即发送准备好的数据。</p>
</li>
<li><p>多路访问（multiple access)，意思就是以太网络上的各个工作站在发送数据时，共同使用一条总线，且发送数据是广播式的。</p>
</li>
<li><p>冲突（collision），意思就是，若以太网上有两个或两个以上工作站同时发送数据，在总线上就会产生信号的冲突；多个工作站都同时发送数据，在总线上就会产生信号的冲突，哪个工作站接收到的数据都辨别不出真正的信息。这种情况称冲突或者碰撞。为了减少冲突发生的影响，工作站在发送数据过程中还要不停地检测自己发送的数据，检测自己传输过程中有没有其他工作站在发送数据，在传输过程中与其它工作站的数据发生冲突，这就是冲突检测（collision detected）。</p>
</li>
</ul>
<blockquote>
<p>当初学习的时候，对于为什么要监听空闲和检测碰撞一直很疑惑，其实原因很简单，对于总线型网络来说，如果有多个主机同时发送信号，那么是很难从中分辨出信息的。举个栗子就是一堆不同频率相位的正弦混合在一起，让你从波形图中画出某条正弦曲线，是不是感觉非常的困难？为了避免在网络中遇到这个问题，所以采用载波监听和碰撞检测的方法。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/c32b807a6d5641a4978483a68971038e.png#pic_center" alt="CSMA/CD工作原理"></p>
<ul>
<li>载波监听用处</li>
</ul>
<p>载波监听其实就是检测信道是不是为空，如果是，那么就可以发送自己的信息了。如果信道正忙，那么只能等到信道空闲，才能发送自己的信息。那么，是不是只要空闲发送自己的信息就永远不会出错呢？当然不是，我们联系生活中的一个栗子就能知道，当开会讨论的时候，如果一片安静，那么之后就可能会有两个或者多个人同时开始说话发言。信道上也是如此，甚至更加明显。因为载波监听只能是在自己的位置监听，而从别的主机发送过来的信号需要时间。这就不可避免的会出现主机B明明发送了信息，但是主机A没有发现，也发送一个信息出来，这样便会发生碰撞，导致数据信号失真。</p>
<ul>
<li>碰撞检测用处</li>
</ul>
<p>碰撞检测就是为了解决上面说的同时发送，或者说在很短时间（B发送信号尚未到达A）内同时发送引发的碰撞问题。<strong>碰撞检测适配器</strong>在发送数据的过程中也要<strong>检测信道信号变化</strong>，若发现<strong>信号电压</strong>变化幅度增大超过某个阈值，则认为发生碰撞。</p>
<h5 id="二进制指数退避算法"><a href="#二进制指数退避算法" class="headerlink" title="二进制指数退避算法"></a>二进制指数退避算法</h5><p>以太网采用截断二进制指数退避算法来解决碰撞问题。截断二进制算法并不复杂，这种算法让发生碰撞的站在停止发送数据后，不是等待信道变为空闲后就立即再发送数据，而是推迟一个随机的时间。这样做是为了使的重传时再次发生冲突的概率减少。当重传次数达<strong>16次</strong>仍不能成功时，则表明同时打算发送数据的站太多，以至连续发生冲突，则丢弃该帧，并向高层报告。</p>
<h5 id="如何确定碰撞后的重传时机"><a href="#如何确定碰撞后的重传时机" class="headerlink" title="如何确定碰撞后的重传时机"></a>如何确定碰撞后的重传时机</h5><p><a href="https://juejin.cn/post/7101509003724881928">https://juejin.cn/post/7101509003724881928</a></p>
<p><a href="https://www.modb.pro/db/221017">https://www.modb.pro/db/221017</a></p>
<h5 id="最小帧长问题"><a href="#最小帧长问题" class="headerlink" title="最小帧长问题"></a>最小帧长问题</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为什么先监听后发数据还是会发生冲突呢？</span><br><span class="line">答：因为电磁波在总线上总是以有限的速率传播的，加上传输数据的信道可能很长(出现传播时延)，因而会发生冲突。</span><br></pre></td></tr></table></figure>

<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e11084477ae44e5a90698e61ed1fc623~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c90ccceb6742e7ad16b6402895386c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"></p>
<h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>局域网（Local Area Network）：简称LAN，是指在某一区域内由多台计算机，外部设备（例如打印机）互联成的网络，使用广播信道。在这个网络之间，每个设备都可以完成文件管理、资源共享。</p>
<ul>
<li><p>覆盖的地理范围较小，只在一个相对独立的局部范围内联，如一座或几种的建筑群内</p>
</li>
<li><p>使用专门铺设的传输介质（双绞线、同轴电缆）进行联网，数据传输速率高（10Mb/s~10Gb/s）</p>
</li>
<li><p>通信延迟时间短，误码率低，可靠性较高</p>
</li>
<li><p>各站为平等关系，共享传输信道</p>
</li>
<li><p>多采用分布式控制和广播式信道，能进行广播和组播</p>
</li>
<li><p><strong>星型和总线形</strong>是局域网最常用的拓扑结构。</p>
</li>
</ul>
<p><strong>决定局域网的主要要素为：网络拓扑，传输介质与介质访问控制方法</strong></p>
<h4 id="局域网的分类"><a href="#局域网的分类" class="headerlink" title="局域网的分类"></a>局域网的分类</h4><ul>
<li><p>以太网</p>
</li>
<li><p>令牌环网。物理上采用了环形拓扑结构</p>
</li>
<li><p>FDDI网（Fiber Distributed Data Interface）。物理上采用了双环拓扑结构，逻辑上是环形拓扑结构</p>
</li>
<li><p>ATM网（Asynchronous Transfer Mode）。较新型的单元交换技术，使用53字节固定长度的单元进行交换</p>
</li>
<li><p>无线局域网（Wireless Local Area Network, WLAN）采用了IEEE802.11标准</p>
</li>
</ul>
<h5 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h5><p>以太网。以太网是应用最为广泛的局域网，包括标准以太网（10Mbps）、快速以太网（100Mbps）、千兆以太网（1000Mbps）和10G以太网，它们都符合<strong>IEEE802.3</strong>系列标准规范。</p>
<ul>
<li>以太网第一个广泛部署的高速局域网；</li>
</ul>
<ul>
<li>以太网数据速率快；</li>
</ul>
<ul>
<li><p>以太网硬件价格便宜，网络造价成本低。</p>
</li>
<li><p>拓扑结构</p>
<ul>
<li>逻辑拓扑总线型</li>
<li>物理拓扑是星型或拓展星型</li>
</ul>
</li>
<li><p>特点</p>
<ul>
<li>造价低廉（以太网网卡不到100块）</li>
<li>是应用最广泛的局域网技术</li>
<li>比令牌环网、ATM网更便宜，简单</li>
<li>满足网络速率要求：10Mb/s~10Gb/s</li>
</ul>
</li>
<li><p>以太网两个标准：</p>
<ol>
<li>DIX Ethernet V2：第一个局域网产品（以太网）规约</li>
<li>IEEE 802.3：IEEE 802委员会802.3工作组制定的第一个IEEE的以太网标准。802.3局域网即以太网</li>
</ol>
</li>
</ul>
<h5 id="ATM网"><a href="#ATM网" class="headerlink" title="ATM网"></a>ATM网</h5><p>如果网络需求对QoS要求很高，应考虑采用 （ ） 网络。ATM</p>
<h4 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h4><p>采用同轴电缆</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><h4 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h4><blockquote>
<p>高级数据链路控制（High-Level Data Link Control或简称HDLC），是一个在同步网上传输数据、<strong>面向比特</strong>的<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&spm=1001.2101.3001.7020">数据链路层</a>协议</p>
</blockquote>
<p><strong>HDLC特点</strong></p>
<ul>
<li><p><strong>1</strong> HDLC协议不依赖于任何一种字符编码集；</p>
</li>
<li><p><strong>2</strong> 数据报文可透明传输，用于实现透明传输的“0比特插入法”易于硬件实现；</p>
</li>
<li><p><strong>3</strong>全双工通信，有较高的数据链路传输效率；</p>
</li>
<li><p><strong>4</strong>所有帧采用CRC检验，对信息帧进行顺序编号，可防止漏收或重份，传输可靠性高；</p>
</li>
<li><p><strong>5</strong>传输控制功能与处理功能分离，具有较大灵活性。</p>
</li>
</ul>
<p><strong>帧类型</strong></p>
<ul>
<li>信息帧</li>
<li>管理帧：流量和差错控制</li>
<li>无编号帧：用于链路控制</li>
</ul>
<p><strong>数据链路控制规程功能</strong></p>
<p>数据链路层是OSI参考模型的第二层，它在物理层提供的通信接口与电路连接服务的基础上，将易出错的数据电路构筑成相对无差错的数据链路，以确保DTE与DTE之间、DTE与网络之间有效、可靠地传送数据信息。为了实现这个目标，数据链路控制规程的功能应包括以下几个部分：</p>
<p><strong>1</strong>帧控制</p>
<p>数据链路上传输的基本单位是帧。帧控制功能要求发送站把网络送来的数据信息分成若干码组，在每个码组中加入地址字段、控制字段、校验字段以及帧开始和结束标志，组成帧来发送；要求接收端从收到的帧中去掉标志字段，还原成原始数据信息后送到网络层。</p>
<p><strong>2</strong>帧同步</p>
<p>在传输过程中必须实现帧同步，以保证对帧中各个字段的正确识别。</p>
<p><strong>3</strong>差错控制</p>
<p>当数据信息在物理链路中传输出现差错，数据链路控制规程要求接收端能检测出差错并予以恢复，通常采用的方法有自动请求重发ARQ和前向纠错两种。采用ARQ方法时，为了防止帧的重收和漏收，常对帧采用编号发送和接收。当检测出无法恢复的差错时，应通知网络层做相应处理。</p>
<p><strong>4</strong>流量控制</p>
<p>流量控制用于克服链路的拥塞。它能对链路上信息流量进行调节，确保发送端发送的数据速率与接收端能够接收的数据速率相容。常用的流量控制方法是滑动窗口控制法。</p>
<p><strong>5</strong>链路管理</p>
<p>数据链路的建立、维持和终止，控制信息的传输方向，显示站的工作状态，这些都属于链路管理的范畴。</p>
<p><strong>6</strong>透明传输</p>
<p>规程中采用的标志和一些字段必须独立于要传输的信息，这就意味着数据链路能够传输各种各样的数据信息，即传输的透明性。</p>
<p><strong>7</strong>寻址</p>
<p>在多点链路中，帧必须能到达正确的接收站。</p>
<p><strong>8</strong>异常状态恢复</p>
<p>当链路发生异常情况时，如收到含义不清的序列或超时收不到响应等，能自动重新启动，恢复到正常工作状态。</p>
<h4 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h4><p>PPP可以用于同步传输也可以用于异步传输，而HDLC只能用在同步网上；PPP是面向字节的，而HDLC是面向比特位的。可以说HDLC是PPP的前身。PPP，可以在多种链路上支持点对点的通信，而且支持多种网络层协议，并且PPP和以太网相结合产生的PPPoE</p>
<h3 id="vtp协议"><a href="#vtp协议" class="headerlink" title="vtp协议"></a>vtp协议</h3><blockquote>
<p>是VLAN中继协议，也被称为虚拟局域网干道协议。<strong>它是思科私有协议</strong>。作用是十几台交换机在企业网中，配置VLAN工作量大，可以使用VTP协议，把一台交换机配置成VTP Server, 其余交换机配置成VTP Client,这样他们可以自动学习到Server 上的VLAN 信息。</p>
</blockquote>
<p><strong>VLAN中继协议</strong>（VLAN Trunking Protocol，VTP）是Cisco公司的专利协议。VTP在交换网络中建立了多个管理域，同以管理域中的所有交换机共享VLAN信息。一台交换机只能参加一个管理域，不同管理域中的交换机不共享VLAN信息。通过VTP协议，可以在一台交换机上配置所有的VLAN，配置信息<strong>通过VTP报文可以传播到管理域中的所有交换机。</strong><br>按照VTP协议，交换机的运行模式分为3种：</p>
<ul>
<li>服务器模式（Server）：交换机在此模式下创建、添加、删除和修改VLAN配置，并从中继端口发出VTP组播帧，把配置信息分发到整个管理域中的所有交换机。一个管理域中可以有多个服务器。</li>
<li>客户机模式（Client）：在此模式下不允许创建、修改或删除VLAN，但可以监听本管理域中其他交换机的VTP组播信息，并据此修改自己的VLAN配置。</li>
<li>透明模式（Transparent）：在此模式下可以进行VLAN配置，但配置信息不会传播到其他交换机，在透明模式下，可以接收和转发VTP帧，但是并不能据此更新自己的VLAN配置，知识起到通路的作用。</li>
</ul>
<h3 id="帧中继协议-虚电路"><a href="#帧中继协议-虚电路" class="headerlink" title="帧中继协议(虚电路)"></a>帧中继协议(虚电路)</h3><p><a href="https://zhuanlan.zhihu.com/p/392346480">https://zhuanlan.zhihu.com/p/392346480</a></p>
<p><a href="https://www.qingsword.com/qing/675.html">https://www.qingsword.com/qing/675.html</a></p>
<p><strong>帧中继Frame Relay，简称FR，可以将它看做X.25协议的简化版本</strong>，帧中继网络中不考虑传输差错问题，其中的结点<strong>只做帧的转发操作</strong>，不需要执行接收确认和请求重发等操作；帧中继是一种严格意义上的二层协议。</p>
<p>在帧中继网络中使用VC（Virtual Circuit，虚电路）来互连各个分支，并不需要两个分支之间有单独的物理链路。下面是物理专线和帧中继虚电路的示意图：</p>
<p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-Framerelay-1.jpg" alt="Cisco-CCNA-Framerelay-1"></p>
<p>使用虚电路的最主要好处就是配置方便，建立和拆除虚电路只需要使用命令配置即可，所以虚电路并非真正的物理链路，只是在现有网络的基础上添加的一系列转发规则，就好像在源和目的间存在一条专线一样；相比之下专线则需要综合布线施工，建立和拆除难度较大。</p>
<ul>
<li><p>工作原理</p>
<p>帧中继能够在单一物理传输线路上提供多条虚电路，<strong>每条虚电路采用数据链路连接标识符DLCI来进行标识。</strong></p>
<p>DLCI只在本地接口和与之直接相连的对端DCE接口有效，不具有全局有效性，实现的是一种逻辑的点到点连接</p>
</li>
<li><p>帧中继的工作范围</p>
<p>在DTE设备和帧中继交换机之间</p>
</li>
<li><p>特点</p>
<p>价格昂贵、传输带宽低、响应速度慢、配置复杂、部署难度大、排错困难；只支持单播流量通行。</p>
</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-a1df47e4b6b01da6d463a5c3fd137d57_1440w.webp" alt="img"></p>
<h4 id="帧中继帧格式"><a href="#帧中继帧格式" class="headerlink" title="帧中继帧格式"></a>帧中继帧格式</h4><p>帧中继的帧和以太网帧一样，也工作在数据链路层，帧的格式如下图：</p>
<p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-Framerelay-4.jpg" alt="Cisco-CCNA-Framerelay-4"></p>
<p>帧中继帧的各字段解释如下：</p>
<ul>
<li><p>Flag标志：标志帧的开始和结束</p>
</li>
<li><p>地址：地址字段2个字节中包含了DLCI号（帧中继的帧中只有一个DLCI号，即去往的目的地的DLCI号，2个字节中的10个比特用来储存这个DLCI号）；拥塞控制（Congestion Control）占3比特，其中包括1比特的FECN位，1比特的BECN位和1比特的DE位；除此之外地址域中还包含3个比特的其他值。</p>
</li>
<li><p>数据：是一个可变长的字段，包含了封装的上层协议数据。</p>
</li>
<li><p>帧效验序列：用来保证传输数据的完整性</p>
</li>
</ul>
<h4 id="帧转发方式"><a href="#帧转发方式" class="headerlink" title="帧转发方式"></a>帧转发方式</h4><p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-Framerelay-3.jpg" alt="Cisco-CCNA-Framerelay-3"></p>
<p>在图三中，假设R1要将数据发往R3，R1封装DLCI号103（至于为什么R1知道发往R3要封装103这个在下面的帧中继寻址方式中会详细的介绍），将封装好的帧发往帧中继交换机FR1。根据FR1上管理员的配置，FR1知道如果从接口1接收到DLCI号为103的帧，应该将DLCI号修改成112并从接口3发出。此时帧到达FR3，FR3也根据配置得知，从自己的1接口接收到的DLCI号为112的帧，应该将DLCI号修改成301，并从3号接口发出。此时R3接收到FR3发过来的帧中继帧，解封装后交给上层处理。<br>从上面的工作方式中可以看出，只要R1封装DLCI号103的帧，就能将数据发往R3，帧中继网云使用DLCI号103和DLCI号301在R1和R3之间建立了一条永久虚电路（PVC），同理R1到R4可以封装104，R4到R1可以封装401。</p>
<p>帧中继交换表</p>
<p>在图三的帧中继网络中，FR1-3三台帧中继交换机上都维护着一个帧中继交换表，下面是FR1的帧中继交换表的样式：</p>
<p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-Framerelay-5.jpg" alt="Cisco-CCNA-Framerelay-5"></p>
<h4 id="帧中继术语"><a href="#帧中继术语" class="headerlink" title="帧中继术语"></a>帧中继术语</h4><p>VC（Virtual Circuit，虚电路）帧中继网络中两台DTE设备之间的连接称为虚电路，现在常用的虚电路为PVC（Permanent Virtual Circuit，永久虚电路），PVC由运营商预先配置。</p>
<p>帧中继是一种面向连接的技术，在通信之前必须建立连接，DTE之间建立的连接称为虚电路。帧中继虚电路有两种类型：PVC和SVC。</p>
<p><strong>永久虚电路PVC</strong>：是指给用户提供的固定的虚电路，该虚电路一旦建立，则永久生效，除非管理员手动删除。</p>
<p>PVC一般用于两端之间频繁的、流量稳定的数据传输。目前在帧中继中使用最多的方式是永久虚电路方式</p>
<p><strong>交换虚电路SVC</strong>：是指通过协议自动分配的虚电路。在通信结束后，该虚电路会被自动取消</p>
<p>由于帧中继收敛速度慢，链路初始建立时间较长，因此使用的很少。</p>
<p>2）DLCI（Data Link Connection Identifier，数据链路连接标识符）</p>
<p><img src="https://www.qingsword.com/qing/images/Cisco-CCNA-Framerelay-2.jpg" alt="Cisco-CCNA-Framerelay-2"></p>
<p>DLCI是源设备和目的设备之间标识逻辑电路的一个数据值，该数据值只具有本地意义。在图二中，R1上的DLCI号103标识的是R1到R3的连接，R1上的DLCI号104标识的是R1到R4的连接。不同DTE设备上的DLCI号可以相同，但在同一台DTE设备上不能用相同的DLCI号来标识到不同的连接。<br>DLCI号的范围是0-1023，其中0-15以及1008-1023被保留用作特殊用途，所以用户可以配置的DLCI号为16-1007。</p>
<p>3）LMI（Local Management Interface，本地管理接口）</p>
<p>LMI是用户端和帧中继交换机之间的信令标准，负责管理设备之间的连接，维护设备的状态。LMI被用来获知路由器被分配了哪些DLCI，确定PVC的操作状态，有哪些可用的PVC，另外还用来发送维持分组，确保PVC处于激活状态。<br>LMI的类型有三种：ANSI、Cisco、Q933A，DTE端的LMI配置要和帧中继上的一致，否则LMI不能正常工作，进而导致PVC失败。思科路由上默认的LMI类型为Cisco。</p>
<h4 id="拥塞控制功能"><a href="#拥塞控制功能" class="headerlink" title="拥塞控制功能"></a>拥塞控制功能</h4><p>帧中继网络<strong>没有采用流量控制机制，只有拥塞控制功能</strong>。采用显式信令控制时，如果LAP-D帧中的FECN比特置1，则表示 （ ） 。</p>
<p>FECN（Forward Explicit Congestion Notification，<strong>前向</strong>显式拥塞通知）：当一台帧中继交换机意识到网络上发生拥塞的时候，会向目的设备发送FECN分组，此时FECN比特置为1，告知网络上发生了拥塞。</p>
<p>BECN（Backward Explicit Congestion Notification，后向显式拥塞通知）：当一台帧中继交换机意识到网络上发生拥塞的时候，会向源路由器发送BECN分组，此时BECN比特置为 1，指示路由器降低分组的发送速率。如果路由器在当前的时间间隔内接收到任何BECN，它会按照25%的比例降低分组的发送速率。所以A是正确的。</p>
<h3 id="设备-2"><a href="#设备-2" class="headerlink" title="设备"></a>设备</h3><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><p>交换机有多个网络端口，它通过识别数据帧的<strong>目标 MAC 地址</strong>，根据 <strong>MAC 地址表</strong>决定从哪个端口发送数据。MAC 地址表不需要在交换机上手工设置，而是可以自动生成的。</p>
<p><img src="https://pic1.zhimg.com/80/v2-2e9606f05c1c778ac23df0ae3ac699ec_720w.webp" alt="img"></p>
<blockquote>
<p>交换机是如何添加、更新、删除 MAC 地址表条目的？</p>
</blockquote>
<p>在初始状态下，交换机的 MAC 地址表是空的，不包含任何条目。当交换机的某个端口接收到一个数据帧时，它就会将这个数据帧的源 MAC 地址、接收数据帧的端口号作为一个条目保存在自己的 MAC 地址表中，同时在接收到这个数据帧时重置这个条目的老化计时器时间。这就是交换机自动添加 MAC 地址表条目的方式。</p>
<p><img src="https://pic4.zhimg.com/80/v2-94c4fdb3a308f405a7b6cc7d7b02ca33_720w.webp" alt="img"></p>
<p>在新增这一条 MAC 地址条目后，如果交换机再次从同一个端口收到相同 MAC 地址为源 MAC 地址的数据帧时，交换机就会<strong>更新</strong>这个条目的老化计时器，确保活跃的的条目不会老化。但是如果在老化时间内都没收到匹配这个条目的数据帧，交换机就会将这个老化的条目从自己的 MAC 地址表中<strong>删除</strong>。</p>
<p><img src="https://pic2.zhimg.com/80/v2-182787b10366b2981075f003c4b1f6f1_720w.webp" alt="img"></p>
<p>还可以手动在交换机的 MAC 地址表中添加<strong>静态条目</strong>。静态添加的 MAC 地址条目优先动态学习的条目进行转发，而且静态条目没有老化时间，会一直保存在交换机的 MAC 地址表中。</p>
<blockquote>
<p>如何使用 MAC 地址表条目进行转发？</p>
</blockquote>
<p>当交换机的某个端口收到一个单播数据帧时，它会查看这个数据帧的二层头部信息，并进行两个操作。一个操作是根据源 MAC 地址和端口信息添加或更新 MAC 地址表。另一个操作是查看数据帧的目的 MAC 地址，并根据数据帧的目的 MAC 地址查找自己的 MAC 地址表。在查找 MAC 地址表后，交换机会根据查找结果对数据帧进行处理，这里有 3 中情况</p>
<ul>
<li>交换机没有在 MAC 地址表中找到这个数据帧的目的 MAC 地址，因此交换机不知道自己的端口是否有连接这个 MAC 地址的设备。于是，交换机将这个数据帧从除了接收端口之外的所有端口<strong>泛洪</strong>出去。</li>
<li>交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口不是接收到这个数据帧的端口，交换机知道目的设备连接在哪个端口上，因此交换机会根据 MAC 地址表中的条目将数据帧从对应端口单播<strong>转发</strong>出去，而其它与交换机相连的设备则不会收到这个数据帧。</li>
<li>交换机的 MAC 地址表中有这个数据帧的目的 MAC 地址，且对应端口就是接收到这个数据帧的端口。这种情况下，交换机会认为数据帧的目的地址就在这个端口所连接的范围内，因此目的设备应该已经收到数据帧。这个数据帧与其它端口的设备无关，不会将数据帧从其它端口转发出去。于是，交换机会<strong>丢弃</strong>数据帧。</li>
</ul>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSibMOyJ0PXMZKsQ1EXK68yiaFHnWxQsLk9XiciaJDhA5KFV2uic3bSNNU6Vg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li>基本数据单位为<strong>IP数据报</strong>；</li>
<li>iP协议（Internet Protocol，因特网互联协议）提供不可靠、无连接的传送服务。</li>
<li>IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。</li>
</ul>
<h3 id="IP协议的转发流程"><a href="#IP协议的转发流程" class="headerlink" title="IP协议的转发流程"></a>IP协议的转发流程</h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSXCzDk0nQTv7LsiaabCTibVcNXl8P9epXIgps8PVibPt91Uy0UNuacibckA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="网络地址转换NAT技术"><a href="#网络地址转换NAT技术" class="headerlink" title="网络地址转换NAT技术"></a>网络地址转换NAT技术</h3><p>用于多个主机通过一个公有IP访问访问互联网的私有网络中，减缓了IP地址的消耗，但是增加了网络通信的复杂度。<br><strong>NAT工作原理：</strong>从内网出去的IP数据报，将其IP地址替换为NAT服务器拥有的合法的公共IP地址，并将替换关系记录到NAT转换表中；<br>从公共互联网返回的IP数据报，依据其目的的IP地址检索NAT转换表，并利用检索到的内部私有IP地址替换目的IP地址，然后将IP数据报转发到内部网络。</p>
<h3 id="ARP协议与RARP协议"><a href="#ARP协议与RARP协议" class="headerlink" title="ARP协议与RARP协议"></a>ARP协议与RARP协议</h3><p>地址解析协议 ARP（Address Resolution Protocol）：<strong>为网卡（网络适配器）的IP地址到对应的硬件地址提供动态映射</strong>。可以把网络层32位地址映射为数据链路层MAC48位地址。ARP协议建立了主机IP地址和MAC地址的映射关系。<br>ARP 是即插即用的，一个ARP表是自动建立的，不需要系统管理员来配置。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSLiaOwHXoickiatsbLhslZ9gXia2Iyq4tdobAO7jzhVptKlQwJmPWRPSISg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>RARP(Reverse Address Resolution Protocol)协议指<strong>逆地址解析协议</strong>，可以把数据链路层MAC48位地址转化为网络层32位地址。</p>
<h3 id="IGMP"><a href="#IGMP" class="headerlink" title="IGMP"></a>IGMP</h3><p>因特网组管理协议</p>
<p>组播：在同一网络可达范围内，一个网络设备与关心其数据的部分设备进行通信就是组播。通过IGMP协议去申请加入或者离开这个组</p>
<h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>ICMP（Internet Control Message Protocol）封装在IP数据报中传输，是一种面向无连接的协议，是TCP/<a href="https://so.csdn.net/so/search?q=IP%E5%8D%8F%E8%AE%AE&spm=1001.2101.3001.7020">IP协议</a>簇中的一个重要子协议，<strong>传送有关网络层通信问题的信息</strong>。ICMP常见应用有：</p>
<ul>
<li>报告访问失效（报告源主机网络不可达）；</li>
<li>报告网络拥塞（发送源抑制报文给源主机，降低发送速率）；</li>
<li>帮助排错（利用ICMP回声功能，ping工具）；</li>
<li>声明报文超时（TraceRoute工具，利用较小的TTL值发现中间设备）。</li>
</ul>
<p><strong>ICMP报文封装在IP数据报当中。</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSxJ0WwicaX3xAnlFK7U99gr4Zw6z3FtcfLtxIBUBaIDPCeEpZBPfMG4g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>ICMP协议的应用</p>
<ul>
<li>Ping应用：网络故障的排查；</li>
</ul>
<ul>
<li><p>Traceroute应用： <strong>Tracert</strong>程序主要用于查看数据包从源端到目的端的路径信息，从而检查网络连接是否可用。当网络出现故障时，用户可以使用该命令定位故障点。</p>
<p>tracert是利用ICMP和TTL进行工作的。首先，tracert会发出TTL为1的ICMP数据包(包含40字节数据，包括源地址、目标地址和发出的时间标签)。当到达路径上的第一个路由器时，路由器会将TTL减1，此时TTL为0，该路由器会将此数据包丢弃，并返回一个超时回应数据包(包括数据包的源地址、内容和路由器的IP地址)。当tracert收到该数据包时，它便获得了这个路径上的第一个路由器。接着tracert在发送另一个TTL为2的数据包，第一个路由器会将此数据包转发给第二个路由器，而第二个路由器收到数据包时，TTL为0。第二个路由器便会返回一个超时回应数据包，从而tracert便发现了第二个路由器。tIacert每次发出数据包时便将TTL加1，来发现下一个路由器。这个动作一直重复，直到到达目的地或者确定目标主机不可到达为止。当数据包到达目的地后，目标主机并不会返回超时回应数据包。tracert在发送数据包时，会选择一个一般应用程序不会使用的号码(3000以上)来作为接收端口号，所以当到达目的地后，目标主机会返回一个IcMP port un-reachable(端口不可到达)的消息。当tracert收到这个消息后，就知道目的地已经到达了。</p>
</li>
</ul>
<h3 id="设备-3"><a href="#设备-3" class="headerlink" title="设备"></a>设备</h3><h4 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h4><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><ul>
<li>负责向两台主机<strong>进程之间</strong>的通信提供通用的数据传输服务</li>
<li>提供端到端的、可靠的TCP协议（Transmission Control Protocol，传输控制协议）或不可靠的UDP协议（User Datagram Protocol，用户数据报协议）传输以及端到端的差错控制和流量控制</li>
<li>数据单元称为<strong>段或报文</strong></li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSbbZ8zclxaPPdk7VzOOebRMlEcOIBmibIlRrRZeUtJVmClhz8yDXmuGg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatShJAYqYSYwSriaR8UAJzqSDwwFDeHg8XccGvmQk7KLGJzX5TEKoKRicDg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP(Transmission Control Protocol: 传输控制协议)，是计算机网络中非常复杂的一个协议。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSM15YwnRuWpq4lDQ9aP9laSQ5UcMLn1q97bLUSibiaJEGMrFVlxAg0SKw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a><strong>TCP协议的特点</strong></h4><p>TCP是面向连接的协议；</p>
<p>TCP是面向字节流的协议；</p>
<p>TCP的一个连接有两端，即点对点通信；</p>
<p>TCP提供可靠的传输服务；</p>
<p>TCP协议提供全双工通信（<strong>每条TCP连接只能一对一</strong>）。</p>
<h4 id="TCP协议的功能"><a href="#TCP协议的功能" class="headerlink" title="TCP协议的功能"></a><strong>TCP协议的功能</strong></h4><ul>
<li>对应用层报文进行分段和重组；</li>
</ul>
<ul>
<li>面向应用层实现复用与分解；</li>
</ul>
<ul>
<li>实现端到端的流量控制；</li>
</ul>
<ul>
<li>拥塞控制；</li>
</ul>
<ul>
<li>传输层寻址；</li>
</ul>
<ul>
<li>对收到的报文进行差错检测（首部和数据部分都检错）；</li>
</ul>
<ul>
<li>实现进程间的端到端可靠数据传输控制。</li>
</ul>
<h5 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h5><p><strong>基本原理：</strong></p>
<p>不可靠传输信道在数据传输中可能发生的情况：比特差错、乱序、重传、丢失；</p>
<p>基于不可靠信道实现可靠数据传输采取的措施。</p>
<p>差错检测：利用编码实现数据包传输过程中的比特差错检测。<br>确认：接收方向发送方反馈接收状态。<br>重传：发送方重新发送接收方没有正确接收的数据。<br>序号：确保数据按序提交。<br>计时器：解决数据丢失问题。<br>停止等待协议：是最简单的可靠传输协议，但是该协议对信道的利用率不高。<br>连续ARQ(Automatic Repeat reQuest：自动重传请求)协议：滑动窗口+累计确认，大幅提高了信道的利用率。</p>
<p><strong>TCP协议的可靠传输：</strong></p>
<p>基于连续ARQ协议，在某些情况下，重传的效率并不高，会重复传输部分已经成功接收的字节。</p>
<h5 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h5><p>流量控制：让发送方发送速率不要太快，TCP协议使用滑动窗口实现流量控制。<img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSZ3od32GXsqN82x7N2myh1sVbCfav2GVamsOFPmQPCNfF7d7jrBD1pA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h5 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h5><p><strong>拥塞控制与流量控制的区别：</strong>流量控制考虑点对点的通信量的控制，而拥塞控制考虑整个网络，是全局性的考虑。拥塞控制的方法：慢启动算法+拥塞避免算法。</p>
<p><strong>慢开始和拥塞避免：</strong></p>
<p>【慢开始】拥塞窗口从1指数增长；</p>
<p>到达阈值时进入【拥塞避免】，变成+1增长；</p>
<p>【超时】，阈值变为当前cwnd的一半（不能&lt;2）；</p>
<p>再从【慢开始】，拥塞窗口从1指数增长。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatS5l0GhSTyDDDczJo1V22Axp820Koj6MUjszdMibuQUEWrnHiar0DLbPOQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br><strong>快重传和快恢复：</strong></p>
<p>发送方连续收到3个冗余ACK，执行【快重传】，不必等计时器超时；</p>
<p>执行【快恢复】，阈值变为当前cwnd的一半（不能&lt;2），并从此新的ssthresh点进入【拥塞避免】。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSQ87FsWYEgkB8KPHEylg6iaXPqeIv2ZrtzmuHBQXhmOQbq9bTFssdNjg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="通信流程"><a href="#通信流程" class="headerlink" title="通信流程"></a>通信流程</h4><h5 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSm1pK1zkqib6PvOGC8WuYSKgR0RCNpCKCJCeBZYibRW1aNwSW439bcWkQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><p>SYN <strong>同步序列号，TCP建立连接时将这个位置1</strong>。SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0</p>
</li>
<li><p>ACK 是TCP报头的控制位之一，对数据进行确认。确认<strong>由目的端发出</strong>， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。</p>
</li>
<li><p>FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1。</p>
</li>
<li><p>rst：在建立tcp连接过程中，出现错误连接时，rst标志字段置1 </p>
</li>
</ul>
<h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p><img src="https://img-blog.csdnimg.cn/d5b2eba7e0eb4de0b2a6f4a7b6ba4595.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA572X572X55qEMTAyNA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<p>第一次握手：客户向服务器发送连接请求段，建立连接请求控制段（SYN=1），seq=x表示传输的报文段的第一个数据字节的序列号是x，此序列号代表整个报文段的序号；客户端进入 SYN_SEND （同步发送状态）</p>
<p>第二次握手：服务器发回确认报文段，<strong>同意建立新连接的确认段（SYN=1）</strong>，<strong>确认序号字段有效（ACK=1）</strong>，服务器告诉客户端报文段序号是y（seq=y），表示服务器已经收到客户端序号为x的报文段，准备接受客户端序列号为x+1的报文段（ack=x+1）；服务器由LISTEN进入SYN_RCVD （同步收到状态）;</p>
<p>第三次握手：客户对服务器的连接进行确认。确认序号字段有效(ACK=1),客户此次的报文段的序列号是x+1(seq=x+1),客户期望接受服务器序列号为y+1的报文段(ack_seq=y+1);当客户发送ack时，客户端进入ESTABLISHED 状态;当服务收到客户发送的ack后，也进入ESTABLISHED状态;第三次握手可携带数据。</p>
<p>第一次握手：标志位SYN = 1，随机生成一个客户端序列号seq1 = x<br>第二次握手：标志位SYN ,ACK = 1，确认客户端序列号ack = x + 1，随机生成一个服务端序列号seq2=y<br>第三次握手：标志位ACK = 1, 确认服务端序列号ack = y + 1，客户端序列号seq2= x + 1</p>
<p><strong>3次握手的特点</strong><br>没有应用层的数据 ,SYN这个标志位只有在TCP建立连接时才会被置1 ,握手完成后SYN标志位被置0。</p>
<h5 id="4次挥手"><a href="#4次挥手" class="headerlink" title="4次挥手"></a>4次挥手</h5><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSF59Al0aZmIFDpukSICzdGxGFc0w1X8f7icicem04r5Q5w1xnsa5LlDibA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>第一次：客户向服务器发送释放连接报文段，发送端数据发送完毕，请求释放连接（FIN=1），传输的第一个数据字节的序号是x（seq=x）；客户端状态由ESTABLISHED进入FIN_WAIT_1（终止等待1状态）；</p>
<p>第二次：服务器向客户发送确认段，确认字号段有效（ACK=1），服务器传输的数据序号是y（seq=y），服务器期望接收客户数据序号为x+1（ack_seq=x+1）;服务器状态由ESTABLISHED进入CLOSE_WAIT（关闭等待）；客户端收到ACK段后，由FIN_WAIT_1进入FIN_WAIT_2；</p>
<p>第三次：服务器向客户发送释放连接报文段，请求释放连接（FIN=1），确认字号段有效（ACK=1），表示服务器期望接收客户数据序号为x+1（ack_seq=x+1）;表示自己传输的第一个字节序号是y+1（seq=y+1）；服务器状态由CLOSE_WAIT 进入 LAST_ACK （最后确认状态）；</p>
<p>第四次：客户向服务器发送确认段，确认字号段有效（ACK=1），表示客户传输的数据序号是x+1（seq=x+1），表示客户期望接收服务器数据序号为y+1+1（ack_seq=y+1+1）；客户端状态由FIN_WAIT_2进入TIME_WAIT，等待2MSL时间，进入CLOSED状态；服务器在收到最后一次ACK后，由LAST_ACK进入CLOSED。</p>
<p>由TCP的三次握手和四次断开可以看出，TCP使用面向连接的通信方式， 大大提高了数据通信的可靠性，使发送数据端和接收端在数据正式传输前就有了交互， 为数据正式传输打下了可靠的基础。</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP(User Datagram Protocol: 用户数据报协议)</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSD31ib9SYBwTtY6fNjV65tGISicIsb97VApKrtd4zSPlo9ecOO0KWibPicQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>UDP协议的特点：</strong></p>
<ul>
<li><p>UDP是无连接协议；</p>
</li>
<li><p>UDP不能保证可靠的交付数据；</p>
</li>
<li><p>UDP是面向报文传输的；</p>
</li>
<li><p><strong>UDP没有拥塞控制；</strong></p>
</li>
<li><p>UDP首部开销很小。</p>
</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li><strong>TCP是面向连接的、可靠的、基于字节流</strong>的传输层协议；<strong>UDP是一个面向无连接</strong>的传输层协议，即发送数据前不需要先建立链接。</li>
<li><strong>可靠性：TCP是基于连接的，无差错，不丢失，不重复，且按序到达，可靠性高</strong>（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源）；<strong>UDP是基于无连接的，尽最大努力交付，即不保证可靠交付，可靠性较低</strong>；</li>
<li><strong>安全性：</strong>由于TCP是连接的通信，需要有三次握手、重新确认等连接过程，会有延时，实时性差，由于协议所致，安全性较高；而UDP无连接，无建立连接的过程，因而实时性较强，安全略差；<strong>如果对实时性要求高和高速传输的场景下需要使用UDP；如果需要传输大量数据且对数据可靠性要求高的场景使用TCP；</strong></li>
<li><strong>开销方面：</strong>在传输相同大小的数据时，<strong>TCP首部开销20字节；UDP首部开销只有8个字节</strong>，TCP报头比UDP复杂，故实际包含的用户数据较少。TCP无丢包，而UDP有丢包，故TCP开销大，UDP开销较小；</li>
<li><strong>连接数：</strong>每条tcp连接只能是点到点的；udp支持一对一、一对多、多对一、多对多的交互通信。</li>
</ul>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><ul>
<li><p>应用层：直接面向用户和应用程序，提供文件下载、电子邮件等方面的服务。</p>
</li>
<li><p>表示层：提供数据格式翻译、数据加密与解密、数据压缩与解压缩的服务。</p>
</li>
<li><p>会话层：提供增强会话服务。</p>
</li>
</ul>
<p>应用层(application-layer）<strong>的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。</p>
<p>数据传输基本单位为报文</p>
<p><strong>应用层包括:</strong></p>
<ul>
<li>超文本传输协议（HTTP）:万维网的基本协议；</li>
<li>文件传输（TFTP简单文件传输协议）；</li>
<li>远程登录（Telnet），提供远程访问其它主机功能, 它允许用户登录internet主机，并在这台主机上执行命令；</li>
<li>网络管理（SMTP简单网络管理协议），该协议提供了监控网络设备的方法， 以及配置管理,统计信息收集,性能管理及安全管理等；</li>
</ul>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。<br>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p>
<p>HTTP三点注意事项：</p>
<ul>
<li>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li>
<li>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</li>
<li>HTTP是无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。无状态协议，即：服务器不需要知道客户端是谁,只认请求（一次请求request,一次相应response）</li>
</ul>
<p><img src="https://img-blog.csdn.net/20140610210038140?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvamF2YW5kcm9pZA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/2019022420515851.png" alt="img"></p>
<h4 id="HTTP请求响应报文"><a href="#HTTP请求响应报文" class="headerlink" title="HTTP请求响应报文"></a>HTTP请求响应报文</h4><p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p>
<img src="https://upload-images.jianshu.io/upload_images/12603307-27e3bf8fde18f443.png?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img" style="zoom:50%;" />



<p>响应报文与请求报文一样,由三个部分组成(响应行,响应头,响应体)</p>
<img src="https://upload-images.jianshu.io/upload_images/12603307-cf75b41f632499a3.png?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp" alt="img" style="zoom: 67%;" />



<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><ul>
<li><p>1XX：信息状态码</p>
<ul>
<li><code>100 Continue</code> 继续，一般在发送<code>post</code>请求时，已发送了<code>http header</code>之后服务端将返回此信息，表示确认，之后发送具体参数信息</li>
</ul>
</li>
<li><p>2XX：成功状态码</p>
<table>
<thead>
<tr>
<th>200</th>
<th>OK</th>
<th>请求成功。一般用于GET与POST请求</th>
</tr>
</thead>
<tbody><tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
</li>
<li><p>3XX：重定向</p>
<table>
<thead>
<tr>
<th>300</th>
<th>Multiple Choices</th>
<th>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</th>
</tr>
</thead>
<tbody><tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
</li>
<li><p>4XX：客户端错误</p>
<table>
<thead>
<tr>
<th>400</th>
<th>Bad Request</th>
<th>客户端请求的语法错误，服务器无法理解</th>
</tr>
</thead>
<tbody><tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
</tbody></table>
</li>
<li><p>5XX:服务器错误</p>
<table>
<thead>
<tr>
<th>500</th>
<th>Internal Server Error</th>
<th>服务器内部错误，无法完成请求</th>
</tr>
</thead>
<tbody><tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中。服务器的问题，找网管</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="请求头和响应头"><a href="#请求头和响应头" class="headerlink" title="请求头和响应头"></a>请求头和响应头</h4><p><img src="https://img2018.cnblogs.com/blog/1301998/201906/1301998-20190621104932351-2057147169.png" alt="img"></p>
<h5 id="HTTP消息头"><a href="#HTTP消息头" class="headerlink" title="HTTP消息头"></a>HTTP消息头</h5><p><code>HTTP消息头</code>是指，在超文本传输协议（ Hypertext Transfer Protocol ，HTTP）的请求和响应消息中，协议头部分的那些组件。HTTP消息头用来准确描述正在获取的资源、服务器或者客户端的行为，定义了HTTP事务中的具体操作参数。</p>
<p>Query Params：常用是<strong>get</strong>方式请求，query是指<strong>请求行</strong>中请求的参数，一般是指URL中？后面的参数</p>
<p>Body Params：常用是<strong>post</strong>方式请求，body是指<strong>请求体</strong>中的数据</p>
<h5 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h5><p><strong>HTTP协议使用TCP协议进行传输，在应用层协议发起交互之前，首先是TCP的三次握手。完成了TCP三次握手后，客户端会向服务器发出一个请求报文</strong></p>
<ul>
<li><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>由于TCP的可靠性，每条独立的TCP连接都会进行一次三次握手，从上面的Network的分析中可以得到握手往往会消耗大部分时间，真正的数据传输反而会少一些(当然取决于内容多少)。HTTP1.0和HTTP1.1为了解决这个问题在header中加入了<code>Connection: Keep-Alive</code>，<code>keep-alive</code>的连接会保持一段时间不断开，后续的请求都会复用这一条TCP，不过由于管道化的原因也会发生<strong>队头阻塞</strong>的问题。HTTP1.1默认开启Keep-Alive，HTTP1.0可能现在不多见了，如果你还在用，可以升级一下版本，或者带上这个header。connection keep-alive</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>协议头</th>
<th>说明</th>
<th>示例</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>Accept</td>
<td>可接受的响应内容类型（<code>Content-Types</code>）。</td>
<td><code>Accept: text/plain</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>可接受的字符集</td>
<td><code>Accept-Charset: utf-8</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>可接受的响应内容的编码方式。</td>
<td><code>Accept-Encoding: gzip, deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>可接受的响应内容语言列表。</td>
<td><code>Accept-Language: en-US</code></td>
<td>固定</td>
</tr>
<tr>
<td>Accept-Datetime</td>
<td>可接受的按照时间来表示的响应内容版本</td>
<td>Accept-Datetime: Sat, 26 Dec 2015 17:30:00 GMT</td>
<td>临时</td>
</tr>
<tr>
<td>Authorization</td>
<td>用于表示HTTP协议中需要认证资源的认证信息</td>
<td>Authorization: Basic OSdjJGRpbjpvcGVuIANlc2SdDE==</td>
<td>固定</td>
</tr>
<tr>
<td>Cache-Control</td>
<td>用来指定当前的请求/回复中的，是否使用缓存机制。</td>
<td><code>Cache-Control: no-cache</code>              max-age：缓存无法返回缓存时间长于max-age规定秒的文档</td>
<td>固定</td>
</tr>
<tr>
<td>Connection</td>
<td>客户端（浏览器）想要优先使用的连接类型</td>
<td><code>Connection: keep-alive``Connection: Upgrade</code></td>
<td>固定</td>
</tr>
<tr>
<td>Cookie</td>
<td>由之前服务器通过<code>Set-Cookie</code>（见下文）设置的一个HTTP协议Cookie</td>
<td><code>Cookie: $Version=1; Skin=new;</code></td>
<td>固定：标准</td>
</tr>
<tr>
<td>Content-Length</td>
<td>以8进制表示的请求体的长度</td>
<td><code>Content-Length: 348</code></td>
<td>固定</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>请求体的内容的二进制 MD5 散列值（数字签名），以 Base64 编码的结果</td>
<td>Content-MD5: oD8dH2sgSW50ZWdyaIEd9D==</td>
<td>废弃</td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的MIME类型 （用于POST和PUT请求中）</td>
<td>Content-Type: application/x-www-form-urlencoded</td>
<td>固定</td>
</tr>
<tr>
<td>Date</td>
<td>发送该消息的日期和时间（以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来发送）</td>
<td>Date: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Expect</td>
<td>表示客户端要求服务器做出特定的行为</td>
<td><code>Expect: 100-continue</code></td>
<td>固定</td>
</tr>
<tr>
<td>From</td>
<td>发起此请求的用户的邮件地址</td>
<td><code>From: user@itbilu.com</code></td>
<td>固定</td>
</tr>
<tr>
<td>Host</td>
<td>表示服务器的域名以及服务器所监听的端口号。如果所请求的端口是对应的服务的标准端口（80），则端口号可以省略。</td>
<td><code>Host: www.itbilu.com:80``Host: www.itbilu.com</code></td>
<td>固定</td>
</tr>
<tr>
<td>If-Match</td>
<td>仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要用于像 PUT 这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。</td>
<td>If-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td>固定</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>把浏览器端缓存页面的最后修改时间发送到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行对比。如果时间一致，那么返回304，客户端就直接使用本地缓存文件。如果时间不一致，就会返回200和新的文件内容。客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示在浏览器中.</td>
<td>If-Modified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td><strong>固定</strong></td>
</tr>
<tr>
<td><strong>If-None-Match</strong></td>
<td>If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能</td>
<td>If-None-Match: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td>固定</td>
</tr>
<tr>
<td>If-Range</td>
<td>如果该实体未被修改过，则向返回所缺少的那一个或多个部分。否则，返回整个新的实体</td>
<td>If-Range: “9jd00cdj34pss9ejqiw39d82f20d0ikd”</td>
<td>固定</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>仅当该实体自某个特定时间以来未被修改的情况下，才发送回应。</td>
<td>If-Unmodified-Since: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td>固定</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>限制该消息可被代理及网关转发的次数。</td>
<td><code>Max-Forwards: 10</code></td>
<td>固定</td>
</tr>
<tr>
<td>Origin</td>
<td>发起一个针对<a href="http://itbilu.com/javascript/js/VkiXuUcC.html">跨域资源共享</a>的请求（该请求要求服务器在响应中加入一个<code>Access-Control-Allow-Origin</code>的消息头，表示访问控制所允许的来源）。</td>
<td><code>Origin: http://www.itbilu.com</code></td>
<td>固定: 标准</td>
</tr>
<tr>
<td>Pragma</td>
<td>与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生。</td>
<td><code>Pragma: no-cache</code></td>
<td>固定</td>
</tr>
<tr>
<td>Proxy-Authorization</td>
<td>用于向代理进行认证的认证信息。</td>
<td>Proxy-Authorization: Basic IOoDZRgDOi0vcGVuIHNlNidJi2==</td>
<td>固定</td>
</tr>
<tr>
<td>Range</td>
<td>表示请求某个实体的一部分，字节偏移以0开始。</td>
<td><code>Range: bytes=500-999</code></td>
<td>固定</td>
</tr>
<tr>
<td>Referer</td>
<td>表示浏览器所访问的前一个页面，可以认为是之前访问页面的链接将浏览器带到了当前页面。<code>Referer</code>其实是<code>Referrer</code>这个单词，但RFC制作标准时给拼错了，后来也就将错就错使用<code>Referer</code>了。</td>
<td>Referer: <a href="http://itbilu.com/nodejs">http://itbilu.com/nodejs</a></td>
<td>固定</td>
</tr>
<tr>
<td>TE</td>
<td>浏览器预期接受的传输时的编码方式：可使用回应协议头<code>Transfer-Encoding</code>中的值（还可以使用”trailers”表示数据传输时的分块方式）用来表示浏览器希望在最后一个大小为0的块之后还接收到一些额外的字段。</td>
<td><code>TE: trailers,deflate</code></td>
<td>固定</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器的身份标识字符串</td>
<td><code>User-Agent: Mozilla/……</code></td>
<td>固定</td>
</tr>
<tr>
<td>Upgrade</td>
<td>要求服务器升级到一个高版本协议。</td>
<td>Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td>固定</td>
</tr>
<tr>
<td>Via</td>
<td>告诉服务器，这个请求是由哪些代理发出的。</td>
<td>Via: 1.0 fred, 1.1 itbilu.com.com (Apache/1.1)</td>
<td>固定</td>
</tr>
<tr>
<td>Warning</td>
<td>一个一般性的警告，表示在实体内容体中可能存在错误。</td>
<td>Warning: 199 Miscellaneous warning</td>
<td>固定</td>
</tr>
</tbody></table>
<h5 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h5><p><strong>响应报文</strong>：<strong>当收到get或post等方法发来的请求后，服务器就要对报文进行响应。</strong></p>
<table>
<thead>
<tr>
<th align="left">响应头</th>
<th align="left">说明</th>
<th align="left">示例</th>
<th align="left">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Access-Control-Allow-Origin</td>
<td align="left">指定哪些网站可以<code>跨域源资源共享</code></td>
<td align="left"><code>Access-Control-Allow-Origin: *</code></td>
<td align="left">临时</td>
</tr>
<tr>
<td align="left">Accept-Patch</td>
<td align="left">指定服务器所支持的文档补丁格式</td>
<td align="left">Accept-Patch: text/example;charset=utf-8</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">服务器所支持的内容范围</td>
<td align="left"><code>Accept-Ranges: bytes</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Age</td>
<td align="left">响应对象在代理缓存中存在的时间，以秒为单位</td>
<td align="left"><code>Age: 12</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Allow</td>
<td align="left">对于特定资源的有效动作;</td>
<td align="left"><code>Allow: GET, HEAD</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒</td>
<td align="left"><code>Cache-Control: max-age=3600</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">针对该连接所预期的选项</td>
<td align="left"><code>Connection: close</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Disposition</td>
<td align="left">对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。</td>
<td align="left">Content-Disposition: attachment; filename=”fname.ext”</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">响应资源所使用的编码类型。</td>
<td align="left"><code>Content-Encoding: gzip</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">响就内容所使用的语言</td>
<td align="left"><code>Content-Language: zh-cn</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">响应消息体的长度，用8进制字节表示</td>
<td align="left"><code>Content-Length: 348</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">所返回的数据的一个候选位置</td>
<td align="left"><code>Content-Location: /index.htm</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">响应内容的二进制 MD5 散列值，以 Base64 方式编码</td>
<td align="left">Content-MD5: IDK0iSsgSW50ZWd0DiJUi==</td>
<td align="left">已淘汰</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">如果是响应部分消息，表示属于完整消息的哪个部分</td>
<td align="left">Content-Range: bytes 21010-47021/47022</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">当前内容的<code>MIME</code>类型</td>
<td align="left">Content-Type: text/html; charset=utf-8</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">此条消息被发送时的日期和时间(以<a href="http://tools.ietf.org/html/rfc7231#section-7.1.1.1">RFC 7231</a>中定义的”HTTP日期”格式来表示)</td>
<td align="left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">ETag</td>
<td align="left">对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列</td>
<td align="left">ETag: “737060cd8c284d8af7ad3082f209582d”</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">指定一个日期/时间，超过该时间则认为此回应已经过期</td>
<td align="left">Expires: Thu, 01 Dec 1994 16:00:00 GMT</td>
<td align="left">固定: 标准</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)</td>
<td align="left">Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Link</td>
<td align="left">用来表示与另一个资源之间的类型关系，此类型关系是在<a href="https://tools.ietf.org/html/rfc5988">RFC 5988</a>中定义</td>
<td align="left"><code>Link: </code>; rel=”alternate”</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">用于在进行重定向，或在创建了某个新资源时使用。</td>
<td align="left">Location: <a href="http://www.itbilu.com/nodejs">http://www.itbilu.com/nodejs</a></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">P3P</td>
<td align="left">P3P策略相关设置</td>
<td align="left">P3P: CP=”This is not a P3P policy!</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果</td>
<td align="left"><code>Pragma: no-cache</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">要求在访问代理时提供身份认证信息。</td>
<td align="left"><code>Proxy-Authenticate: Basic</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Public-Key-Pins</td>
<td align="left">用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值</td>
<td align="left">Public-Key-Pins: max-age=2592000; pin-sha256=”……”;</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Refresh</td>
<td align="left">用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。</td>
<td align="left">Refresh: 5; url=<a href="http://itbilu.com/">http://itbilu.com</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Retry-After</td>
<td align="left">如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。</td>
<td align="left">示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">服务器的名称</td>
<td align="left"><code>Server: nginx/1.6.3</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Set-Cookie</td>
<td align="left">设置<code>HTTP cookie</code></td>
<td align="left">Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1</td>
<td align="left">固定标准</td>
</tr>
<tr>
<td align="left">Status</td>
<td align="left">通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。</td>
<td align="left"><code>Status: 200 OK</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Trailer</td>
<td align="left"><code>Trailer</code>用户说明传输中分块编码的编码信息</td>
<td align="left"><code>Trailer: Max-Forwards</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">用表示实体传输给用户的编码形式。包括：<code>chunked</code>、<code>compress</code>、 <code>deflate</code>、<code>gzip</code>、<code>identity</code>。</td>
<td align="left">Transfer-Encoding: chunked</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">要求客户端升级到另一个高版本协议。</td>
<td align="left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。</td>
<td align="left"><code>Vary: *</code></td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">告知代理服务器的客户端，当前响应是通过什么途径发送的。</td>
<td align="left">Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">Warning</td>
<td align="left">一般性警告，告知在实体内容体中可能存在错误。</td>
<td align="left">Warning: 199 Miscellaneous warning</td>
<td align="left">固定</td>
</tr>
<tr>
<td align="left">WWW-Authenticate</td>
<td align="left">表示在请求获取这个实体时应当使用的认证模式。</td>
<td align="left"><code>WWW-Authenticate: Basic</code></td>
<td align="left">固定</td>
</tr>
</tbody></table>
<h4 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h4><h5 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h5><p>HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。</p>
<p>在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。 多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。多路复用通过更小的二进制帧构成多条数据流，交错的请求和响应可以<strong>并行传输</strong>而不被阻塞，这样就解决了HTTP1.1时复用会产生的<strong>队头阻塞</strong>的问题</p>
<blockquote>
<p>队头堵塞：</p>
<p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
</blockquote>
<h5 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h5><p>HTTP2有首部压缩的功能，如果两个请求首部(headers)相同，那么会省去这一部分，只传输不同的首部字段，进一步减少请求的体积。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 请求1</span><br><span class="line">:authority: unpkg.zhimg.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /za-js-sdk@2.16.0/dist/zap.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36</span><br><span class="line"></span><br><span class="line">// 请求2</span><br><span class="line">:authority: zz.bdstatic.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /linksubmit/push.js</span><br><span class="line">:scheme: https</span><br><span class="line">accept: */*</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: no-cache</span><br><span class="line">pragma: no-cache</span><br><span class="line">referer: https://www.zhihu.com/</span><br><span class="line">sec-fetch-dest: script</span><br><span class="line">sec-fetch-mode: no-cors</span><br><span class="line">sec-fetch-site: cross-site</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.122 Safari/537.36</span><br></pre></td></tr></table></figure>

<p>从上面两个请求可以看出来，有很多数据都是重复的。如果可以把相同的首部存储起来，仅发送它们之间不同的部分，就可以节省不少的流量，加快请求的时间。</p>
<p>HTTP/2 在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。</p>
<p>下面再来看一个简化的例子，假设客户端按顺序发送如下请求首部：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header1:foo</span><br><span class="line">Header2:bar</span><br><span class="line">Header3:bat</span><br></pre></td></tr></table></figure>

<p>当客户端发送请求时，它会根据首部值创建一张表：</p>
<p><img src="https://pic2.zhimg.com/80/v2-be170562d69da5c67cfc40aa591a722d_1440w.jpg" alt="img"></p>
<p>如果服务器收到了请求，它会照样创建一张表。 当客户端发送下一个请求的时候，如果首部相同，它可以直接发送这样的首部块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">62 63 64</span><br></pre></td></tr></table></figure>

<p>服务器会查找先前建立的表格，并把这些数字还原成索引对应的完整首部。</p>
<h5 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h5><p>HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。</p>
<h5 id="流量控制-1"><a href="#流量控制-1" class="headerlink" title="流量控制"></a>流量控制</h5><p>由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。</p>
<h5 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h5><p>HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。</p>
<p>例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。</p>
<h4 id="HTTPS协议"><a href="#HTTPS协议" class="headerlink" title="HTTPS协议"></a>HTTPS协议</h4><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL/TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10885a9d4d574d7caf3fee1416f623ca~tplv-k3u1fbpfcp-zoom-1.image" alt="img" style="zoom:33%;" /></p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS/SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<h4 id="不同HTTP的协议"><a href="#不同HTTP的协议" class="headerlink" title="不同HTTP的协议"></a>不同HTTP的协议</h4><p><strong>HTTP和HTTPS协议的区别</strong></p>
<ul>
<li>HTTS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<p><strong>HTTP 1.0和 HTTP 1.1 有以下区别</strong></p>
<ul>
<li>连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li>资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li>缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。 </li>
</ul>
<p><strong>HTTP 1.1 和 HTTP 2.0 的区别</strong></p>
<ul>
<li>二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li>多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li>数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li>头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li>服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>
</ul>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>Dynamic Configuration Protocol动态主机设置协议：是应用UDP协议的应用层协议。</p>
<p>作用：为临时接入局域网的用户自动分配IP地址。</p>
<p>DHCP有三种机制分配IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1) 自动分配方式(Automatic Allocation)，DHCP服务器为主机指定一个永久性的IP地址，一旦DHCP客户端第一次成功从DHCP服务器端租用到IP地址后，就可以永久性的使用该地址。</span><br><span class="line">2) 动态分配方式(Dynamic Allocation)，DHCP服务器给主机指定一个具有时间限制的IP地址，时间到期或主机明确表示放弃该地址时，该地址可以被其他主机使用。</span><br><span class="line">3) 手工分配方式(Manual Allocation)，客户端的IP地址是由网络管理员指定的，DHCP服务器只是将指定的IP地址告诉客户端主机。</span><br></pre></td></tr></table></figure>

<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230521095541370.png" alt="image-20230521095541370"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230521095904408.png" alt="image-20230521095904408"></p>
<p>在50%租期时客户端未得到原服务器端的回应，则客户端在87.5%租期时会停止租约，并广播发送DHCP Request，任意一台DHCP服务器端都可回应，该过程称为重绑定。100%租期，重新DHCP Discover。</p>
<blockquote>
<p>当<strong>DHCP客户机</strong>第一次登录网络的时候（也就是客户机上没有任何IP地址数据时），它会通过<strong>UDP 67端口</strong>向网络上发出一个<strong>DHCPDISCOVER</strong>数据包（包中包含客户机的MAC地址和计算机名等信息）。因为客户机还不知道自己属于哪一个网络，所以<strong>封包的源地址为0.0.0.0，目标地址为255.255.255.255</strong>，然后再附上DHCP discover的信息，向网络进行广播。</p>
<p>DHCP discover的等待时间预设为1秒，也就是当客户机将第一个DHCP discover封包送出去之后，在1秒之内没有得到回应的话，就会进行第二次DHCP discover广播。若一直没有得到回应，客户机会将这一广播包重新发送四次（以2，4，8，16秒为间隔，加上1-1000毫秒之间随机长度的时间）。如果都没有得到<strong>DHCP服务器端</strong>的回应，客户机会从<strong>169.254.0.0/16</strong>这个自动保留的私有IP地址中选用一个IP地址，并且每隔5分钟重新广播一次，如果收到某个服务器的响应，则继续IP租用过程。</p>
</blockquote>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统（DNS），主机的域名到 IP 地址的映射</p>
<p><strong>域名解析的顺序：</strong></p>
<ul>
<li><p>浏览器缓存；</p>
</li>
<li><p>找本机的hosts文件；</p>
</li>
<li><p>路由缓存；</p>
</li>
<li><p>找DNS服务器（本地域名、顶级域名、根域名）-&gt;迭代解析、递归查询。</p>
</li>
<li><p>顶级域（com，cn，net，gov，org）、二级域（baidu,taobao,qq,alibaba）、三级域（www）(12-2-0852)。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSQYoX1g3iboXfSY2oPtU9libeqiaFnebwhZCt93cStJibZJ4tLCP2ZWjKVQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
</li>
</ul>
<h2 id="各数据封包格式"><a href="#各数据封包格式" class="headerlink" title="各数据封包格式"></a>各数据封包格式</h2><p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E7%BB%84%E8%A3%85%E3%80%81%E6%8B%86%E8%A7%A3" alt="image-20230112104410667"></p>
<h3 id="链路层封包格式"><a href="#链路层封包格式" class="headerlink" title="链路层封包格式"></a>链路层封包格式</h3><p>由图：<strong>一帧为1518B，数据字段的最大长度为1500字节</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B0%81%E5%8C%85%E6%A0%BC%E5%BC%8F" alt="image-20230112104429870"></p>
<ul>
<li><p>DMAC（DestinationMAC）是目的MAC地址。DMAC字段长度为6个字节，标识帧的接收者。</p>
</li>
<li><p>SMAC（SourceMAC）是源MAC地址。SMAC字段长度为6个字节，标识帧的发送者。</p>
</li>
<li><p>类型字段（Type）用于标识数据字段中包含的高层协议，该字段长度为2个字节。类型字段取值为0x0800的帧代表IP协议帧；类型字段取值为0806的帧代表ARP协议帧。</p>
<ul>
<li><p>类型：确定以太网头后面跟的是哪个协议</p>
<p>0x0800 ip协议</p>
<p>0x0806 arp协议</p>
<p>0x0835 rarp协议</p>
</li>
</ul>
</li>
<li><p>数据字段(Data)是网络层数据，最小长度必须为46字节以保证<strong>帧长至少为64字节</strong>（46+18），数据字段的最大长度为1500字节。</p>
</li>
<li><p>循环冗余校验字段（CRC）提供了一种错误检测机制。该字段长度为4个字节。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>1、IEEE802.2/802.3封装常用在无线</p>
<p>2、以太网封装常用在有线局域网</p>
<p>vlan帧结构</p>
<p><strong>以太网帧长度最大为：1518b</strong>。 <strong>vlan帧会在源mac地址后增加4b的标记字段，长度范围最大为1522b。最小64b</strong> </p>
<p>其中4字节标记字段包括： </p>
<p>（1）类型tpid，叫做标记协议id值。占16位，对于以太网，设置为十六进制0x8100。 </p>
<p>（2）用户优先级tci：标签控制信息字段、包括用户优先级priority，规范格式指示器cfi、vid。 </p>
<p>（3）priority（简称PRI）定义数据帧的优先级。 </p>
<p>（4）规范格式标识符cfi：指出mac地址为以太网还是令牌环格式。在以太网交换机中，规范格式指示器总是设置为0。 </p>
<p>（5）vlan id：12位，vlan标识符（vid），指出帧的源vlan。一共支持4096个v…… </p>
<p><img src="https://img-blog.csdn.net/20180809182227606?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaWp1cWllMDY5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p><strong>VLAN帧的最小帧长是(1)字节，其中表示帧优先级的字段是(2)。 64，PRI</strong></p>
<h3 id="网络层封包格式"><a href="#网络层封包格式" class="headerlink" title="网络层封包格式"></a>网络层封包格式</h3><p><img src="http://c.biancheng.net/uploads/allimg/191106/6-191106153044K1.gif" alt="IP数据报格式示意图"></p>
<ol>
<li><p>版本（version）<br>占 4 位，表示 IP 协议的版本。通信双方使用的 IP 协议版本必须一致。目前广泛使用的IP协议版本号为 4，即 IPv4。</p>
</li>
<li><p>首部长度（网际报头长度IHL）<br><strong>占 4 位，可表示的最大十进制数值是 15</strong>。这个字段所表示数的单位是 32 位字长（1 个 32 位字长是 4 字节）。因此，当 IP 的首部长度为 1111 时（即十进制的 15），首部长度就达到 60 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。</p>
<p>数据部分永远在 4 字节的整数倍开始，这样在实现 IP 协议时较为方便。首部长度限制为 60 字节的缺点是，长度有时可能不够用，之所以限制长度为 60 字节，是希望用户尽量减少开销。最常用的首部长度就是 20 字节（即首部长度为 0101），这时不使用任何选项。</p>
</li>
</ol>
<ol start="3">
<li>区分服务（tos）<br>也被称为服务类型，占 8 位，用来获得更好的服务。这个字段在旧标准中叫做服务类型，但实际上一直没有被使用过。1998 年 IETF 把这个字段改名为区分服务（Differentiated Services，DS）。只有在使用区分服务时，这个字段才起作用。</li>
<li>总长度（totlen）<br>首部和数据之和，单位为字节。总长度字段为 16 位，因此数据报的最大长度为 2^16-1=65535 字节。</li>
<li>标识（identification）<br>用来标识数据报，占 16 位。IP 协议在存储器中维持一个计数器。每产生一个数据报，计数器就加 1，并将此值赋给标识字段。当数据报的长度超过网络的 MTU，而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。具有相同的标识字段值的分片报文会被重组成原来的数据报。</li>
<li>标志（flag）<br>占 3 位。第一位未使用，其值为 0。第二位称为 DF（不分片），表示是否允许分片。取值为 0 时，表示允许分片；取值为 1 时，表示不允许分片。第三位称为 MF（更多分片），表示是否还有分片正在传输，设置为 0 时，表示没有更多分片需要发送，或数据报没有分片。</li>
<li>片偏移（offsetfrag）<br>占 13 位。当报文被分片后，该字段标记该分片在原报文中的相对位置。片偏移以 8 个字节为偏移单位。所以，除了最后一个分片，其他分片的偏移值都是 8 字节（64 位）的整数倍。</li>
</ol>
<ol start="8">
<li><strong>生存时间（TTL）</strong>表示数据报在网络中的寿命，占 8 位。该字段由发出数据报的源主机设置。其目的是<strong>防止无法交付的数据报无限制地在网络中传输</strong>，从而消耗网络资源。路由器在转发数据报之前，先把 TTL 值减 1。<strong>若 TTL 值减少到 0，向IP报文的源地址发送一个出错信息，并丢弃该报文，不再转发</strong>。因此，TTL 指明数据报在网络中最多可经过多少个路由器。<strong>TTL 的最大数值为 255。若把 TTL 的初始值设为 1，则表示这个数据报只能在本局域网中传送。</strong> </li>
</ol>
<ol start="9">
<li><p>协议<br>表示该数据报文所携带的数据所使用的协议类型，占 8 位。该字段可以方便目的主机的 IP 层知道按照什么协议来处理数据部分。不同的协议有专门不同的协议号。例如，TCP 的协议号为 6，UDP 的协议号为 17，ICMP 的协议号为 1。</p>
</li>
<li><p>首部检验和（checksum）<br>用于校验数据报的首部，占 16 位。数据报每经过一个路由器，首部的字段都可能发生变化（如TTL），所以需要重新校验。而数据部分不发生变化，所以不用重新生成校验值。</p>
</li>
<li><p>源地址<br>表示数据报的源 IP 地址，占 32 位。</p>
</li>
<li><p>目的地址<br>表示数据报的目的 IP 地址，占 32 位。该字段用于校验发送是否正确。</p>
</li>
<li><p>可选字段<br>该字段用于一些可选的报头设置，主要用于测试、调试和安全的目的。这些选项包括严格源路由（数据报必须经过指定的路由）、网际时间戳（经过每个路由器时的时间戳记录）和安全限制。</p>
</li>
<li><p>填充<br>由于可选字段中的长度不是固定的，使用若干个 0 填充该字段，可以保证整个报头的长度是 32 位的整数倍。</p>
</li>
<li><p>数据部分<br>表示传输层的数据，如保存 TCP、UDP、ICMP 或 IGMP 的数据。数据部分的长度不固定。</p>
</li>
</ol>
<h3 id="IPv6报文格式"><a href="#IPv6报文格式" class="headerlink" title="IPv6报文格式"></a>IPv6报文格式</h3><p><img src="file:///C:\Users\liming\AppData\Local\Temp\ksohtml6620\wps584.jpg" alt="img"> </p>
<p><strong>IPv6数据报的格式</strong></p>
<p>IPv6包头长度固定为40字节，去掉了IPv4中一切可选项，只包括8个必要的字段，因此尽管IPv6地址长度为IPv4的四倍，IPv6包头长度仅为IPv4包头长度的两倍。</p>
<p>其中的各个字段分别为：　　</p>
<p><strong>·****Version（版本号）：</strong>4位，IP协议版本号，值= 6。</p>
<p><strong>·****Traffice Class（通信类别）：</strong>8位，指示IPv6数据流通信类别或优先级。功能类似于IPv4的服务类型（TOS）字段。 </p>
<p><strong>·****Flow Label（流标记）：</strong>20位，IPv6新增字段，标记需要IPv6路由器特殊处理的数据流。该字段用于某些对连接的服务质量有特殊要求的通信，诸如音频或视频等实时数据传输。在IPv6中，同一信源和信宿之间可以有多种不同的数据流，彼此之间以非“0”流标记区分。如果不要求路由器做特殊处理，则该字段值置为“0”。 </p>
<p><strong>·****Payload Length（负载长度）：</strong>16位负载长度。负载长度包括扩展头和上层PDU，16位最多可表示65，535字节负载长度。超过这一字节数的负载，该字段值置为“0”，使用扩展头逐个跳段（Hop-by-Hop）选项中的巨量负载（Jumbo Payload）选项。 </p>
<p><strong>·****Next Header（下一包头）：</strong>8位，识别紧跟IPv6头后的包头类型，如扩展头（有的话）或某个传输层协议头（诸如TCP，UDP或着ICMPv6）。　 </p>
<p><strong>·****Hop Limit（跳段数限制）：</strong>8位，类似于IPv4的TTL（生命期）字段。与IPv4用时间来限定包的生命期不同，IPv6用包在路由器之间的转发次数来限定包的生命期。包每经过一次转发，该字段减1，减到0时就把这个包丢弃。</p>
<p><strong>·****Source Address（源地址）：</strong>128位，发送方主机地址。 </p>
<p><strong>·****Destination Address（目的地址）：</strong>128位，在大多数情况下，目的地址即信宿地址。但如果存在路由扩展头的话，目的地址可能是发送方路由表中下一个路由器接口。</p>
<p><strong>· 扩展首部：</strong>IPv6包头设计中对原IPv4包头所做的一项重要改进就是将所有可选字段移出IPv6包头，置于扩展头中。由于除Hop-by-Hop选项扩展头外，其他扩展头不受中转路由器检查或处理，这样就能提高路由器处理包含选项的IPv6分组的性能。</p>
<p>通常，一个典型的IPv6包，没有扩展头。仅当需要路由器或目的节点做某些特殊处理时，才由发送方添加一个或多个扩展头。与IPv4不同，IPv6扩展头长度任意，不受40字节限制，以便于日后扩充新增选项，这一特征加上选项的处理方式使得IPv6选项能得以真正的利用。 但是为了提高处理选项头和传输层协议的性能，扩展头总是8字节长度的整数倍。</p>
<p>目前，RFC 2460中定义了以下6个IPv6扩展头：Hop-by-Hop（逐个跳段）选项包头、目的地选项包头、路由包头、分段包头、认证包头和ESP协议包头。</p>
<h3 id="传输层封包格式"><a href="#传输层封包格式" class="headerlink" title="传输层封包格式"></a>传输层封包格式</h3><h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a><strong>TCP报文段结构</strong></h4><p>最大报文段长度：报文段中封装的应用层数据的最大长度。<br><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSqxMs25nbfkicXjw3iclM3VRyThLhnu7HtGbG6T7ibIultic7krO5la4C2g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"><br><strong>TCP首部：</strong></p>
<p>序号字段：TCP的序号是对每个应用层数据的每个字节进行编号；</p>
<p>确认序号字段：期望从对方接收数据的字节序号，即该序号对应的字节尚未收到。用ack_seq标识；</p>
<p>TCP段的首部长度最短是20B ，最长为60字节。但是长度必须为4B的整数倍。</p>
<p><strong>TCP标记的作用：</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSz1YOnG3azGNkmj4icYicvkE3kB1jb8sA8G809bkUwqndWnIaMAAb1QibQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h4 id="UDP格式"><a href="#UDP格式" class="headerlink" title="UDP格式"></a><strong>UDP格式</strong></h4><p><strong>UDP数据报结构：</strong></p>
<p>首部:8B，四字段/2B【源端口 | 目的端口 | UDP长度 | 校验和】</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSpAgaJKic7LTJAsLI1HjLicc1pgr7yicPamK1HT4Au7z3dia6eyyLf6FbuQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p><strong>UDP报文格式</strong></p>
<p>源端口(Source Port)和目的端口(Destination Port)字段包含了16比特的UDP协议端口号，它使得多个应用程序可以多路复用同一个传输层协议 – UDP协议，仅通过不同的端口号来区分不同的应用程序。 </p>
<p>长度(Length)字段记录了该UDP数据包的总长度(以字节为单位)，包括8字节的UDP头和其后的数据部分。最小值是8(即报文头的长度)，最大值为65,535字节。 </p>
<p>UDP检验和(Checksum)的内容超出了UDP数据报文本身的范围，实际上，它的值是通过计算UDP数据报及一个伪包头而得到的。但校验和的计算方法与通用的一样，都是累加求和。</p>
<p>所谓“伪首部”是因为这种伪首部并不是UDP用户数据报的真正首部。只是在计算检验和时，临时和UDP用户数据报连接在一起，得到一个过渡的UDP用户数据报。检验和就是按照这个过渡的UDP用户数据报来计算的。伪首部既不向下传送也不向上递交，而仅仅是为了计算检验和。</p>
<h3 id="HDLC"><a href="#HDLC" class="headerlink" title="HDLC"></a>HDLC</h3><p>HDLC协议的全称是高级链路控制协议（High Level Data Link Control），是一种在网上同步传输数据，面向比特的数据链路层协议，广泛用于公用数据网，支持全双工或半双工传输，使用后退N帧ARQ流控方案。HDLC定义了3种类型的站（主站、从站、复合站），两种链路配置（不平衡配置、平衡配置），3种数据传输方式（NRM、ABM、ARM）。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps1.png" alt="img"></p>
<p><strong>帧标志F：</strong>HDLC用一种特殊的位模式01111110作为标志以确定帧的边界，采用位填充技术来区分是标志字段还是数据字段，发送站的数据比特序列一旦发现0后有5个1，则在第7位插入0。</p>
<p>**地址字段A:**地址字段用于标识从站的地址，用在点对多点的链路中，地址通常是8位长。</p>
<p><strong>控制字段C：</strong>帧编号N(S),捎带的肯定应答序号N(R),PF位，P询问、F终止 </p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps74.jpg" alt="img"></p>
<p><strong>帧校验序列FCS：</strong>含有除标志字段之外的所有其他字段的校验和。通常使用16比特的CRC-CCITT（G(x)=X16+X12+X5+1）标准产生校验序列，有时也采用CRC-32产生32位的校验序列。</p>
<h3 id="X．25"><a href="#X．25" class="headerlink" title="X．25"></a>X．25</h3><p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps165.png" alt="img"></p>
<p>X.25是CCITT公布的用于连接数据终端至分组交换数据网络的推荐标准，X.25是一个面向连接的接口，采用虚电路传递数据分组至网络上的适当终点处。在X.25的网络中，用户的计算机终端设备将与分组/拆装设备（PAD）连接，负责完成分割分组、寻址、重组装分组的工作，而不同的X.25网络之间则要使用X.75协议互联。X.25是一个基于分组交换技术构建的网络，分组交换本身是适于无连接业务的，要为用户提供面向连接的接口服务，则必须借助虚拟电路技术（VC），虚电路服务具有两种形式，一种是交换虚电路SVC，一种是永久虚电路PVC。最常见的X.25协议支持的最大传输速率为<strong>64Kb/s</strong>。</p>
<p><strong>X.25的三层结构</strong></p>
<table>
<thead>
<tr>
<th><strong>X.25层次结构</strong></th>
<th><strong>对应OSI层</strong></th>
<th><strong>相应标准</strong></th>
</tr>
</thead>
<tbody><tr>
<td>分组层</td>
<td>网络层</td>
<td>X.25 PLP 通过建立虚拟连接，提供点对点、面向连接服务。X.25 PLP 层采用后退N帧 ARQ流控协议。PLP协议把用户数据分成一定大小的块 ，一般为128字节，再加上24位或32的分组头组成数据分组</td>
</tr>
<tr>
<td>链路访问层</td>
<td>数据链路层</td>
<td>使用平衡式链路访问规程LAPB，LAPB是源于HDLC的一种面向位的协议，实际上是平衡的异步方式类别下的HDLC。LAPB是HDLC的一个子集</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
<td>X.21，但可以使用RS-232C和V.35代替</td>
</tr>
</tbody></table>
<p><strong>相关知识点</strong></p>
<p><strong>选择重发ARQ协议</strong>（有噪声环境双工）：滑动窗口协议与自动请求重发技术的结合，当收到否定应答（NAK）时，只重发出错的帧。W发=W收≤2K-1。</p>
<p><strong>后退N帧ARQ协议</strong>（有噪声环境双工）：滑动窗口协议与自动请求重发技术的结合，当收到否定应答（NAK）时，将从出错处重发已发出过的N个帧。接收窗口W收=1，同时W收≤2K -1。（K为帧编号的位数）</p>
<h3 id="帧中继"><a href="#帧中继" class="headerlink" title="帧中继"></a>帧中继</h3><p>帧中继是综合业务数字网络（ISDN）的一个产物，没有专门定义物理层接口（可以使用X.21，V.35等接口协议），帧中继在第二层建立虚电路，因而第三层被简化掉了，FR的帧层也比HDLC操作简单，只做检错，不再重传，没有滑动窗口式的流控，只有拥塞控制，把复杂的检错丢给高层去处理。帧中继使用的核心协议是LAPD，它比LAPB简单，省去了控制字段。帧中继是基于分组（帧）交换的透明传输，可以承载IP数据报；可提供面向连接的服务，支持交换虚电路（SVC）和永久虚电路（PVC）；帧长可变，长度可达1600～4096字节，可以承载各种局域网的数据帧；可以应付突发的数据传输，可以提供2～45Mb/s的数据率；帧中继不适于延迟较敏感的应用（音频和视频），无法保证可靠提交。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps255.png" alt="img"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps407.png" alt="img"></p>
<p><strong>标志字段：</strong>LAPD的帧头和帧尾都是一个字节的帧标志字段，编码为01111110，与HDLC一样。</p>
<p>地址字段：</p>
<ul>
<li><strong>·EA：</strong>地址扩展比特。该比特为0时表示地址向后扩展一个字节，为1时表示最后一个字节。</li>
<li><strong>·C/R：</strong>命令/响应比特。协议本身不使用这个比特，用户可以用这个比特区分不同的帧。</li>
<li><strong>·FECN：</strong>向前拥塞比特。若网络置该位为1，则表示在帧的传送方向上出现了拥塞，该帧到达接收端后，接收方可根据此调整发送方的数据率。</li>
<li><strong>·BECN：</strong>向后拥塞比特。若网络置该位为1，则表示在帧传送相反的方向上出现了拥塞，该帧到达发送端后，发送方可据此调整发送数据速率。</li>
<li><strong>·DE：</strong>优先丢弃比特。当网络发生拥塞时，DE位置1的帧会优先丢弃。</li>
<li><strong>·DLCI：</strong>数据链路连接标识符。帧中继使用虚拟电路的方式提供面向连接的服务，在帧头中包括DLCI字段，每个DLCI都标识一个虚电路，其中DLCI0用于信令传输。</li>
<li><strong>信息字段：</strong>信息字段长度可变，1600是默认最大长度。</li>
</ul>
<p>帧校验序列：与HDLC相同。</p>
<p><strong>帧中继的拥塞控制</strong></p>
<p>在帧中继承载业务中，使用显式信令和隐式信令来避免拥塞的发生。显示信令利用FECN和BECN比特位置1来向端用户发出拥塞警告，以避免拥塞的发生。隐式信令是指上层协议对网络拥塞的监控，当网络开始丢帧时，上层协议就自动降低发送速率，以便网络从拥塞中恢复正常运行。帧中继还可以利用CLLM（强化链路层管理）的方法，缓解拥塞。</p>
<p><strong>ATM问题</strong></p>
<p>ATM是一种可以将局域网功能、广域网功能、语音、视频和数据，集成进一个统一的协议设计。ATM标准最早是作为B-ISDN标准的一部分而出现的，它在QoS方面有突出表现。在ATM传输中，ATM把用户数据组成53B的信元作为分组交换的信息单位，采用统计时分复用模式，提供面向连接的虚电路服务。ATM连接可以是点到点的连接，也可以是点到多点的连接，分为PVC和SVC两种虚电路。ATM通常是在光纤的基础上建立的，典型的数据速率为155.5Mb/s，因此它是不提供应答的，将少量的错误交给高层处理。ATM的目的是实现实时通信，对于偶然的信元错误是不重传的，对于要重传的信息由高层处理。</p>
<p><strong>ATM的分层体系结构</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps457.png" alt="img"></p>
<table>
<thead>
<tr>
<th><strong>层 次</strong></th>
<th><strong>子 层</strong></th>
<th><strong>功 能</strong></th>
<th><strong>与OSI对应</strong></th>
</tr>
</thead>
<tbody><tr>
<td>高  层</td>
<td></td>
<td>对用户数据的控制</td>
<td>高  层</td>
</tr>
<tr>
<td>ATM适配层（AAL）</td>
<td>汇聚子层（CS）</td>
<td>为高层数据提供统一接口</td>
<td>第四层</td>
</tr>
<tr>
<td>拆装子层（SAR）</td>
<td>分割和合并用户数据</td>
<td></td>
<td>第四层</td>
</tr>
<tr>
<td>ATM层</td>
<td></td>
<td>VPI和VCI的管理；信元头的组装和拆分；信元的多路复用；流量控制</td>
<td>第三层</td>
</tr>
<tr>
<td>物理层</td>
<td>传输汇聚子层（TC）</td>
<td>信元校验和速率控制；数据帧的组装和拆分</td>
<td>第二层</td>
</tr>
<tr>
<td>物理层</td>
<td>物理介质子层（PMD）</td>
<td>比特定时；物理网络接入</td>
<td>第一层</td>
</tr>
</tbody></table>
<p><strong>ATM信元头结构</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps510.png" alt="img"></p>
<p><strong>流控标志（GFC）：</strong>用于主机和网络之间的流控或优先级控制。</p>
<p><strong>·虚通路标识符（VPI）：</strong>8位（UNI）或12位（NNI），常用是8位，因此一个主机上的虚通路数256个。</p>
<p><strong>·虚信道标识符（VCI）：</strong>16位，理论上每个主机上的虚通路可以包含65536个虚信道，不过部分信道是用于控制的，并不传送用户数据。</p>
<p>*****在ATM中，虚电路有两级：虚通路（VP）和虚信道（VC），虚通路是由多条虚信道捆绑在一起形成的。在ATM逻辑通道中，是使用VPI+VCI的组合来标识连接的，在做VP交换或交叉连接时，只需交换VP，无需改变VCI的值。</p>
<p><strong>·负载类型（PTI）：</strong>区分不同的拥塞信息。</p>
<p><strong>·信元丢失优先级（CLP）：</strong>这一位用于区分信息的优先级，如果出现拥塞，交换机优先丢弃CLP被置1的信元。</p>
<p><strong>·头校验和（HEC）：</strong>它支队信元头进行校验，采用的是X8+X2+X+1的8位CRC校验。</p>
<h3 id="PPP的帧格式"><a href="#PPP的帧格式" class="headerlink" title="PPP的帧格式"></a>PPP的帧格式</h3><p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps511.png" alt="img"></p>
<h3 id="局域网的帧格式"><a href="#局域网的帧格式" class="headerlink" title="局域网的帧格式"></a>局域网的帧格式</h3><p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps512.jpg" alt="img"> </p>
<h2 id="名词解释-1"><a href="#名词解释-1" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="mac地址"><a href="#mac地址" class="headerlink" title="mac地址"></a>mac地址</h3><blockquote>
<p><strong>网卡</strong></p>
<p>又称为网络适配器或网络接口卡NIC，但是现在更多的人愿意使用更为简单的名称“网卡”。通过网卡能够使不同的计算机之间连接，从而完成数据通信等功能</p>
</blockquote>
<p>每个网卡或三层网口都有一个 <strong>MAC 地址</strong>， MAC 地址是烧录到硬件上，因此也称为<strong>硬件地址</strong>。MAC 地址作为数据链路设备的地址标识符，需要保证网络中的每个 MAC 地址都是<strong>唯一</strong>的，才能正确识别到数据链路上的设备。</p>
<p>每一个网卡在出厂时，都会给分配一个编号，这个编号就称之为mac地址。MAC地址,用于标识网络设备,类似于身份证号，且唯一</p>
<p><strong>组成：</strong>以太网内的MAC地址是一个48bit（<strong>6</strong> 个字节）的值，前 3 个字节表示<strong>厂商识别码</strong>，每个网卡厂商都有特定唯一的识别数字。后 3 个字节由厂商给每个网卡进行分配。厂商可以保证生产出来的网卡不会有相同 MAC 地址的网卡。</p>
<p><img src="https://pic3.zhimg.com/80/v2-d584588e213aaa731cb5ba545a14e43e_720w.webp" alt="img"></p>
<h3 id="广播域和冲突域"><a href="#广播域和冲突域" class="headerlink" title="广播域和冲突域"></a>广播域和冲突域</h3><p>1.广播域<br>【概念】接收同样广播消息的节点的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p>
<p>【设备】第三层设备能划分广播域。即<strong>路由器的每一个端口就是一个广播域。</strong></p>
<p>2.冲突域<br>【概念】连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。</p>
<p>【设备】第二层设备能划分冲突域。即<strong>交换机的每一个端口就是一个冲突域。</strong></p>
<p>　　　　集线器Hub是物理层设备，不能划分冲突域。所以Hub下面连接的所有主机组成一个冲突域</p>
<h3 id="单播、组播、广播"><a href="#单播、组播、广播" class="headerlink" title="单播、组播、广播"></a>单播、组播、广播</h3><p>单播：在同一网络内，两个设备点对点的通信就是单播通信。</p>
<p>组播：在同一网络可达范围内，一个网络设备与关心其数据的部分设备进行通信就是组播。通过IGMP协议去申请加入或者离开这个组</p>
<p>广播：在同一网络可达范围内，一个网络设备向本网络内所有设备进行通信就是广播。</p>
<img src="https://img-blog.csdnimg.cn/20210131152237152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmd5eDEyMzQ=,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;" />



<p>众所周知，TCP是可靠传输（先与另一个通信端点建立可靠连接，再传输数据），因此TCP一般只支持单播这种通信方式，而UDP通信不需要建立连接就可以发送数据，因此，通常我们说的广播、组播</p>
<p>IP地址由主机号和网络号组成，主机号全为“0”的是网络地址，主机号全为“1”的是<strong>广播地址</strong> </p>
<p><strong>组播的地址是保留的D类地址从 224.0.0.0—239.255.255.255</strong> </p>
<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a><strong>IP地址</strong></h3><p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatSwPRtszVezacBN9SojUia54Tfw66g9IdVSgViaoCmeF0p9ruwnhiaV9LnQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<ul>
<li><p>A类（8网络号+24主机号)</p>
</li>
<li><p>B类（16网络号+16主机号）</p>
</li>
<li><p>C类（24网络号+8主机号）可以用于标识网络中的主机或路由器</p>
</li>
<li><p><strong>D类地址作为组播地址</strong></p>
</li>
<li><p>E类是地址保留</p>
</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/QqekpIUjYsPnvK8PhW33a8cX6m7O8iatS5CzKR4JN7J9Fz0xeVTyF32Bc9WWLU1n3ETzkN8icutqWLAPH6iczrN7Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<p>网络号+主机号</p>
<p>A类：默认8bit子网ID，第一位为0，最大为127，0-127。前面一个字节做网络号/网段</p>
<p>B类：默认16bit子网ID，前两位为10，最大为191，128-191。前面两个字节做网络号/网段</p>
<p>C类：默认24bit子网ID，前三位为110，最大为224，192-224。前面三个字节做网络号/网段</p>
<ul>
<li><p><strong>公有IP</strong></p>
<p>公有IP（可直接连接Internet）,经由InterNIC所统一规划的IP</p>
</li>
<li><p><strong>私有ip地址</strong></p>
<p>私有IP（不可直接连接Internet ）,主要用于局域网络内的主机联机规划</p>
</li>
</ul>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%A7%81%E6%9C%89ip%E5%9C%B0%E5%9D%80" alt="image-20230112103800179"></p>
<ul>
<li><strong>回环ip地址</strong><ul>
<li><strong>通常 127.0.0.1 称为回环地址。</strong>回环地址主要用于本地网络接口的测试和诊断。通过将网络数据包发送到本地回环地址，可以测试网络协议栈的正常运行，以及确保计算机网络接口卡的驱动程序和硬件设备都能够正常工作。在实际应用中，回环地址可以用于各种网络诊断和测试工具，例如ping、traceroute、telnet等</li>
<li>回环地址可以在不需要其他计算机或网络连接的情况下进行测试，使其成为网络接口测试和网络应用程序开发的有用工具。可以用于模拟一些网络服务，例如Web服务器、FTP服务器、邮件服务器等。</li>
</ul>
</li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a><strong>子网掩码</strong></h3><p>子网掩码（subnet mask，又叫网络掩码、地址掩码）是一个32bit由1和0组成的数值，<strong>并且1和0分别连续</strong></p>
<blockquote>
<p>子网划分，在主机号上按位进行子网络的划分，主机号=子网号+主机号</p>
<p>子网掩码划分最多30位，因为一个规定<strong>子网里最少容纳2台主机</strong>，30位的掩码就是2个主机位</p>
</blockquote>
<p>子网掩码的分类</p>
<ul>
<li><p>缺省子网掩码</p>
<p>也叫默认子网掩码，即未划分子网，对应的网络号的位都置 1 ，主机号都置 0 。</p>
<p>未做子网划分的IP地址：网络号＋主机号，则：</p>
<p>A类网络缺省子网掩码： 255.0.0.0，用CIDR表示为/8<br>B类网络缺省子网掩码： 255.255.0.0，用CIDR表示为/16<br>C类网络缺省子网掩码： 255.255.255.0，用CIDR表示为/24</p>
</li>
<li><p>自定义子网掩码</p>
<p>将一个网络划分子网后，把原本的主机号位置的一部分给了子网号，余下的才是给了子网的主机号。其形式如下：</p>
<p>做子网划分后的IP地址：网络号＋子网号＋子网主机号，举个例子：</p>
<p>192.168.1.100/25，其子网掩码表示：255.255.255.128，意思就是将192.168.1.0这个网段的主机位的最高1位划分为了子网。</p>
</li>
</ul>
<p><strong>子网掩码，与ip地址相与，得到对应的网络号</strong></p>
<p>子网ID:IP地址中由子网掩码中1覆盖的<strong>连续位</strong></p>
<p>主机ID:IP地址中由子网掩码中0覆盖的<strong>连续位</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP%E5%9C%B0%E5%9D%80" alt="image-20230112103453592"></p>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p><strong>网关地址就是一个IP地址，是分配给路由器/vlan一个接口的IP地址</strong></p>
<blockquote>
<p>网关地址就是一个IP地址，是分配给路由器一个接口的IP地址<br>比方说：<br>我有一个电脑，IP是192.168.1.1，子网掩码是24位的，那么他的网络号就是192.168.1.0，我在给他指定一个网关是192.168.1.254<br>这个时候，我的这台电脑想要和同网的192.168.1.2 通信，那么他就不用网关了，直接发到局域网上就可以了。<br>但是如果我想要发给远程的主机，比方说IP是192.168.2.1 同样24位的， 他的网络号就是192.168.2.0 这时网关就起作用了，我的电脑就会把数据发给网关由网关再转发一直到达目的地也就是IP 是192.168.2.1的主机上。</p>
</blockquote>
<p>网关是一种充当转换重任的计算机系统或设备。使用在不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求，网关的作用就是对两个网络段中的使用不同传输协议的数据进行互相的翻译转换。</p>
<p>在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器），但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连。</p>
<p><img src="https://img-blog.csdnimg.cn/3c24c76df3814341add247b842adbedf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAVEFCRV8=,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p>
<h3 id="自治系统AS"><a href="#自治系统AS" class="headerlink" title="自治系统AS"></a>自治系统AS</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">224.0.0.1 所有主机</span><br><span class="line">224.0.0.2 所有路由器</span><br><span class="line">224.0.0.5 所有运行OSPF路由器</span><br><span class="line">224.0.0.6 OSPF DR/BDR</span><br><span class="line">224.0.0.9 RIPv2 路由器</span><br><span class="line">224.0.0.18 VRRP（虚拟路由器冗余协议）</span><br></pre></td></tr></table></figure>

<p><strong>自治系统AS：</strong>指处于一个管理机构下的网络设备群，AS内部网络自治管理，对外提供一个或多个出入口</p>
<ul>
<li><strong>自治系统内部</strong>的路由协议为内部网关协议，如RIP、OSPF等；</li>
<li><strong>自治系统外部</strong>的路由协议为外部网关协议，如BGP。</li>
</ul>
<p><strong>静态路由：</strong>人工配置，难度和复杂度高。</p>
<p><strong>动态路由：</strong></p>
<ul>
<li><p>链路状态路由选择算法LS：向所有隔壁路由发送信息收敛快；全局式路由选择算法，每个路由器计算路由时，需构建整个网络拓扑图；利用Dijkstra算法求源端到目的端网络的最短路径；Dijkstra(迪杰斯特拉)算法；</p>
</li>
<li><p>距离-向量路由选择算法DV：向所有隔壁路由发送信息收敛慢、会存在回路；基础是Bellman-Ford方程（简称B-F方程）。</p>
</li>
</ul>
<p><img src="../../%E8%80%83%E8%AF%95/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B%E5%B8%88/img/image-20230518211049074.png" alt="image-20230518211049074"></p>
<h4 id="内部网关路由协议IGP"><a href="#内部网关路由协议IGP" class="headerlink" title="内部网关路由协议IGP"></a>内部网关路由协议IGP</h4><p>路由器之间实现路由信息共享的机制</p>
<h5 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h5><p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230518211516272.png" alt="image-20230518211516272"></p>
<p>路由信息协议 RIP(Routing Information Protocol)【应用层】，<strong>基于距离矢量的路由选择算法</strong>，较小的AS（自治系统），<strong>适合小型网络；RIP报文，封装进UDP数据报（端口520）。</strong></p>
<ul>
<li><p>RIPv1属于有类路由协议，不携带子网掩码，不支持VLSM，以<strong>广播</strong>形式进行路由信息的更新，<strong>周期性更新（30秒）</strong>；</p>
</li>
<li><p>RIPv2属于无类路由协议(CIDR)，携带子网掩码，支持VLSM，以<strong>组播（组播地址224.0.0.9）</strong>形式进行路由更新，<strong>触发更新</strong>（有更改即可更新）来加速路由收敛。</p>
</li>
</ul>
<p><strong>功能特性：</strong></p>
<p>RIP是距离矢量路由协议，只以跳数作为度量值，且最大跳数为15跳（跳数最大为16跳，意味不可达），并通过邻居路由器间的周期性(每隔30s)广播发送路由表更新并计算路由，收敛速度慢，V1版本只支持有类网络，V2版本才支持VLSM，路由协议优先级为100，可信任度不高，容易产生路由环路。</p>
<blockquote>
<h5 id="IGRP"><a href="#IGRP" class="headerlink" title="IGRP"></a>IGRP</h5><p><strong>是Cisco公司开发的路由协议</strong>。它也是一个<strong>距离矢量协议</strong>，但是与RIP相比，它有下列优点：<br>①使用了带宽和延迟等参数作为路由度量标准；</p>
<p>②利用触发更新来加快路由收敛；</p>
<p>③支持不等费用通路的负载均衡；</p>
<p>④最大跳步数扩充到255，可以支持更大的网络。</p>
<p><strong>IGRP不使用跳步数作为路由度量</strong>，虽然在一般情况下可以简化为跳步数。IGRP的路由度量因素包括带宽、延迟、可靠性、负载和MTU，其中前两者是默认的，但是可以通过配置加入其他参数。可靠性和负载划分为1~255级，可靠性1是最低的，可靠性255是最高的，负载！使用最少，负载255是百分之百利用的。MTU指最大帧长度，在实际运行中，它是一个常数值，通常采用一条通路中最小的MTU值。这些因素综合起来作为路由费用的度量，使得IGRP可以选择更好的路由。相对于RIP的跳步计数，IGRP协议的路由选择更加合理。</p>
<p><strong>IGRP的路由更新周期是90秒，持有时间是280秒</strong>，为了加速收敛，<strong>采用了触发更新技术</strong>。</p>
</blockquote>
<h5 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h5><p>开放最短路径优先协议 OSPF(Open Shortest Path First)【网络层】，<strong>基于链路状态的路由选择算法</strong>（即Dijkstra算法/SPF），较大规模的AS ，<strong>适合中大型网络，直接封装在IP数据报传输(端口89)。</strong></p>
<p><strong>功能特性：</strong></p>
<p>OSPF是基于链路状态的路由协议，以COST开销作为其度量值，并采用SPF算法计算出最佳路由，支持VLSM，支持触发更新，收敛速度快，路由协议优先级为10，可信任度高。</p>
<h5 id="IS-IS协议"><a href="#IS-IS协议" class="headerlink" title="IS-IS协议"></a>IS-IS协议</h5><p>IS-IS（Intermediate system to intermediate system，中间系统到中间系统）是内部网关协议，是电信运营商普遍采用的内部网关协议之一，也是一个<strong>分级的链路状态路由协议</strong>。<strong>封装在链路层</strong></p>
<p>与OSPF相似，它也使用<strong>Hello协议寻找毗邻节点</strong>。</p>
<p><strong>和ospf不同的是一个路由器只属于一个区域。ospf路由器的不同端口属于不同区域</strong></p>
<p>IS-IS具有层次性，分为两层Level-1和Level-2</p>
<ul>
<li><strong>Level-1（L1）是普通区域（Area），Level-2（L2）是骨干区（Backbone）。</strong></li>
<li>骨干区Backbone是连续的Level-2路由器的集合，由所有的L2（含L1/L2）路由器组成，L1和L2运行相同的SPF算法，一个路由器可能同时参与L1和L2。</li>
</ul>
<h4 id="外部网关路由协议EGP"><a href="#外部网关路由协议EGP" class="headerlink" title="外部网关路由协议EGP"></a>外部网关路由协议EGP</h4><blockquote>
<p>生成 BGP 路由有 宣告network 与 引入import 两种方式</p>
<p>A.Network 方式逐条精确匹配路由</p>
<p>B.Network 方式优先级高</p>
<p>C.Import 方式按协议类型引入路由</p>
</blockquote>
<p>在<strong>不同自治系统之间</strong>用外部网关协议（Exterior Gateway Protocol，EGP）交换路由信息。最新的EGP协议叫做BGP（Border Gateway Protocol）。BGP的主要功能是控制路由策略，例如是否愿意转发过路的分组等。BGP的4种报文表示在下表中，这些报文通过TCP连接传送。BGP支持CIDR技术。</p>
<p><strong>BGP封装在TCP数据报传输(端口179)</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230518221206018.png" alt="image-20230518221206018"></p>
<h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p>CIDR（<a href="https://zhidao.baidu.com/search?word=%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%C2%B7%EF%BF%BD%EF%BF%BD&fr=iknow_pc_qb_highlight">无类别域间路由</a>，Classless Inter-Domain Routing）是一个在Internet上创建附加地址的方法，这些地址提供给服务提供商（ISP），再由ISP分配给客户。</p>
<p>/8掩码是A类，/16掩码是B类,/24掩码是C类等等。但是/12，/18，/25呢？这就是无类的概念了，CIDR的作用就是支持IP地址的无类规划，把IP的网段规划成更细的方式来表示，这样可以有效的节约IP地址的使用和方便管理。</p>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>TCP/IP协议采用端口标识通信的进程，用于区分一个系统里的多个进程</p>
<p><strong>特点</strong></p>
<p>1、对于同一个端口，在不同系统中对应着不同的进程</p>
<p>2、对于同一个系统，一个端口只能被一个进程拥有</p>
<p>3、一个进程拥有一个端口后，传输层送到该端口的数据全部被该进程接收，同样，进程送交传输层的数据也通过该端口被送出</p>
<h3 id="vlan"><a href="#vlan" class="headerlink" title="vlan"></a>vlan</h3><p>VLAN是指在一个物理网段内，进行<strong>逻辑的划分</strong>，划分成若干个虚拟局域网（广播域）。VLAN最大的特性是<strong>不受物理位置的限制</strong>，可以进行灵活的划分。VLAN具备了一个物理网段所具备的特性。相同VLAN内的主机可以相互直接通信，不同VLAN间的主机之间互相访问必须经由路由设备进行转发。广播数据包只可以在本VLAN内进行广播，不能传输到其他VLAN中</p>
<h2 id="考点-1"><a href="#考点-1" class="headerlink" title="考点"></a>考点</h2><h3 id="背-1"><a href="#背-1" class="headerlink" title="背"></a>背</h3><p><a href="https://zhuanlan.zhihu.com/p/515239767">https://zhuanlan.zhihu.com/p/515239767</a></p>
<p><strong>帧经过交换机时，其源、目标MAC是不会变的（数据帧在交换机之间转发）</strong></p>
<p><strong>原因：</strong>交换机内部的CPU会在每个端口成功连接时，通过将MAC地址和端口对应，形成一张MAC表。在今后的通讯中，发往该MAC地址的数据包将仅送往其对应的端口，而不是所有的端口。因此，交换机可用于划分数据链路层广播，即冲突域；但它不能划分网络层广播，即广播域。</p>
<p>这种情况只需要坚持一个原则，<strong>数据帧在交换机之间转发不更改源MAC地址和目标MAC地址；</strong></p>
<p>就好比主机A和主机B通过若干个交换机相连（并没有路由器在中间），那么此时的MAC地址是什么？源MAC地址自然是主机A的网卡所对应的MAC地址，目标MAC地址则是主机B的网卡所对应的MAC地址；</p>
<p><img src="https://pic3.zhimg.com/80/v2-50c80a463d5afe918bef9b3a82011b46_1440w.webp" alt="img"></p>
<p><strong>帧经过路由器时，进行路由转发，IP地址不会变的，但MAC地址一定会变（数据帧在路由器之间转发）；</strong></p>
<p>当主机A发向主机B的数据流在网络层封装成IP数据包，IP数据包的首部包含了源地址和⽬标地址。主机A会⽤本机配置的24位IP网络掩码255.255.255.0与目标地址进⾏与运算，得出⽬标网络地址与本机的⽹络地址是不是在同⼀个⽹段中。如果不是将IP数据包转发到网关。</p>
<p>在发往⽹关前主机A还会通过ARP的请求获得默认⽹关的MAC地址。在主机A数据链路层IP数据包封装成以太网数据帧，然后才发住到网关……也就是路由器上的⼀个端⼝。</p>
<p>当网关路由器接收到以太网数据帧时，发现数据帧中的目标MAC地址是自己的某⼀个端⼝的物理地址，这时<strong>路由器会把以太网数据帧的封装去掉</strong>。路由器认为这个IP数据包是要通过自己进行转发，接着它就在匹配路由表。匹配到路由项后，它就将包发往下⼀条地址。</p>
<p>路由器转发数据包就是这样，<strong>所以它始终是不会改IP地址的。只会改MAC。</strong></p>
<p>根域名服务器采用的<strong>迭代查询</strong>，中介域名服务器采用的是递归查询,辅助域名服务器配置了<strong>迭代算法</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230523164516189.png" alt="image-20230523164516189"></p>
<p>对于CSMA/CD，线路利用率越高，冲突越高，平均传输延迟就越大；而且<strong>平均传输延迟的增加速度远高于线路利用率的提高速度。</strong></p>
<p>对于令牌环，线路利用率的提高虽然也会造成平均传输延迟的提高，但对平均传输延迟的提高影响不太大。</p>
<p>以太网帧结构中<strong>填充式保持最小帧长</strong></p>
<p>采用以太网链路聚合技术将  （ ）  。</p>
<p>在局域网应用中，由于数据通信量的快速增长，交换机带宽往往不够用，于是出现了将<strong>多条物理链路当作一条逻辑链路</strong>使用的链路聚合技术，这时网络通信由聚合到逻辑链路中的所有物理链路共同承担。</p>
<p>传统以太网使用的是<strong>曼彻斯特编码</strong>，效率50％。</p>
<p>如果网络需求对QoS要求很高，应考虑采用 （ ） 网络。ATM</p>
<p>HDLC是一种 （ ） 协议。面向比特的同步链路控制</p>
<p>五类、六类网线的标准是由（）制定的。ISO/IEC JTC1 SC25委员会</p>
<p>ATM 适配层的功能是 （ ） 。分割和合并用户数据 </p>
<p>IS-IS 路由协议中的路由器的不同接口可以属于不同的区域（×）ospf才是</p>
<p>所谓移动IP是指（1）；实现移动IP的关键技术是（2）。</p>
<ul>
<li><p>移动主机在离开家乡网络的远程站点可以联网工作</p>
</li>
<li><p>移动主机具有一个家乡网络地址并获取一个外地转交地址</p>
</li>
</ul>
<p>在以太网中发生冲突时采用退避机制，（）优先传输数据。冲突域中<strong>重传计时器首先过期的设备</strong></p>
<p>存储区域网络(StorageAreaNetwork，SAN）是一种专 用网络，可以把一个或多个系统连接到存储设备和子系统。 SAN可以被看作是负责存储传输的“后端”网络， 而“前端”网 络（或称数据网络）负责正常的TCP/IP传输。 </p>
<p>与NAS相比，SAN具有下面几个特点。 </p>
<p>SAN具有无限的扩展能力。 由于SAN采用了网络结构，服务器可以访问存储网络上的 任何一个存储设备，因此用户可以自由增加磁盘阵列、带库 和服务器等设备，r使得整个系统的存储空间和处理能力得以 按客户需求不断扩大。 </p>
<p>（2）SAN具有更高的连接速度和处理能力</p>
<p>ARP 协议数据单元封装在(  )中传送。以太网数据帧</p>
<p>MIB-2的系统组中，（ ）对象以7位二进制数表示，每一位对应OSI/RM 7层协议中的一层。</p>
<p>sysservices</p>
<p>在DNS服务器中，区域的邮件服务器及其优先级由()资源记录定义。MX</p>
<p>可以发出SNMP GetRequest的网络实体是()。Manager</p>
<p><strong>SNMP报文中不包括()。优先级</strong></p>
<p>5G网络采用()可将5G网路分割成多张虚拟网路。网路切片技术</p>
<h4 id="IEEE"><a href="#IEEE" class="headerlink" title="IEEE"></a>IEEE</h4><p>4G移动通信标准TD-LTE(即TDD-LTE).与FDD-LTE的主要区别是划分上下行信道的方式不同，前者用时分多路方式，而后者用频分多路方式。其他方面大同小异。</p>
<p>在下面的标准中，定义快速生成树协议的是（1） ，支持端口认证的协议是 （2） 。</p>
<ul>
<li>IEEE802.1w</li>
<li>IEEE802.1x</li>
</ul>
<p>在802.11中采用优先级来进行不同业务的区分，优先级最低的是（）。分布式协调功能竞争访问</p>
<p>Wi-fi联盟认可了802.11i标准，并称之为wap2。Wap2使用了aes-ccmp 机密技术</p>
<p>Wi-Fi联盟制定的安全认证方案WPA（Wi-Fi Protected Access）是  ( )  标准的子集。802.11i</p>
<h3 id="协议-1"><a href="#协议-1" class="headerlink" title="协议"></a>协议</h3><p><strong>PGP</strong>是支持<strong>电子邮件加密</strong>的协议</p>
<p>匿名 FTP 访问通常使用 （ ） 作为用户名。anonymous</p>
<p>路由器出厂时，默认的串口封装协议是HDLC</p>
<h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>地址192.168.37.192/25是(1)  ，地址172.17.17.255/23是(2)。</p>
<p>IP地址由主机号和网络号组成，主机号全为“0”的是网络地址，主机号全为“1”的是广播地址 </p>
<p>192.168.37.192/25  =  192.168.37.1|1000000 </p>
<p>主机号非全“0”，也非全“1”，所以是一主机地址 </p>
<p>172.17.17.255/23  =  172.17.0001000|1.11111111 </p>
<p>主机号全为“1”，此地址为广播地址</p>
<p>IPv6地址的格式前缀用于表达地址类型或子网地址，例如60位地址12AB00000000CD3有多种合法的表示形式，下面的选项中，不合法的是（ ）。12AB:0:0:CD3/60</p>
<blockquote>
<p>IPv6将整个地址分为8节来表示，每节含16个地址位，以4个十六进制数书写，节与节之间用冒号分隔。</p>
<p><strong>如果在4位的十六进数中，如其高位为0，则可省略。连续的一个或者多个全零组可用重叠的冒号“::”表示。</strong></p>
<p>若以零开头零可以省略，全段为0可以用一个0表示，连续的全零的段可用“**::**”表示（只能出现一次） 。</p>
<p>同一个地址不同表示法的例子：</p>
<p>20<strong>20</strong>:0410:0000:0001:0000:0000:0000:abcd</p>
<p>20<strong>20</strong>:410:0:1:0:0:0:abcd</p>
<p>20<strong>20</strong>:410:0:1**::**abcd</p>
</blockquote>
<p>给定一个C类网络192.168.1.0/24，要在其中划分出3个60台主机的网段和2个30台主机的网段，则采用的子网掩码应该分别为（ ）。255.255.255.192和255.255.255.224 </p>
<p> 24位网络号，还剩8位主机号，可以有2的8次方个主机地址，也就是256个，如果要求每个子网60台，那么是不是要分配6位（2的6次方=64，可以满足），所以子网掩码就是255.255.255.192，同样2个30台，就要分配5位（2的5次方=32），所以子网掩码就是255.255.255.224</p>
<p>设IP地址为18.250.31.14，子网掩码为255.240.0.0，则子网地址是  ( )</p>
<p>子网掩码，与ip地址相与，得到对应的网络号。 IP地址18.250.31.14/255.240.0.0的二进制形式为：</p>
<p> 11111111.11110000.00000000.00000000</p>
<p> 00010010.11111010.00011111.00001110</p>
<p> 则子网地址是00010010.11110000.00000000.00000000,即18.240.0.0。</p>
<p>一个局域网中某台主机的IP地址为176.68.160.12，使用22位作为网络地址，那么该局域网的子网掩码为 （1） ，最多可以连接的主机数为 （2） 。</p>
<p>由于22位作为网络地址，因此该局域网的网络地址为176.68.160.0。在子网掩码中，网络地址部分全部置为1，主机地址部分全部置为0。因此，该局域网的子网掩码为255.255.252.0。 （2） 由于该局域网的子网掩码为255.255.252.0，主机地址有10位，因此最多可以连接2^10-2=1022台主机。其中，<strong>减去2是因为网络地址和广播地址不能被分配给主机使用</strong>。 </p>
<p>将地址段172.16.32.0/24，172.16.33.0/24，172.16.34.0/24，172.16.35.0/24进行聚合后得到的地址是（）。</p>
<p>将IP地址转换为二进制：<br>172.16.32.0/24=172.16.00100000.00000000</p>
<p>172.16.33.0/24=172.16.00100001.00000000</p>
<p>172.16.34.0/24=172.16.00100010.00000000</p>
<p>172.16.35.0/24=172.16.00100011.00000000</p>
<p>最长相同网络位为22位，故聚合地址为172.16.00100000.00000000=172.16.32.0/22</p>
<h4 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h4><p>ipv6定义了很多可选的扩展首部。可提供比ipv4更多的功能。基本首部长度是40字节。</p>
<p><img src="C:/Users/liming/AppData/Roaming/Typora/typora-user-images/image-20230509155605683.png" alt="image-20230509155605683"></p>
<p>IPv6协议数据单元由一个固定头部和若干个扩展头部以及上层协议提供的负载组成，其中用于标识松散源路由功能的扩展头是 （1） 。如果有多个扩展头部，<strong>第一个扩展头部</strong>为 （2） 。路由选择头部 ,逐跳头部 </p>
<p>ipv6地址的格式前缀（fp）用于表示<strong>地址类型或子网地址</strong>。为了实现ip地址的自动配置，ipv6主机将<strong>mac地址</strong>附加在地址前缀1111 1110 10之后，产生一个链路本地地址，如果通过了邻居发现协议的验证，则表明自我配置的链路本地地址是有效的。</p>
<p><strong>IPv6中没有“校验和”字段。</strong>        </p>
<p>IPv6链路本地单播地址的前缀为（59），可聚集全球单播地址的前缀为（60）1111 1110 10, 001</p>
<h4 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h4><blockquote>
<p>为减小多路访问网络中的OSPF流量，OSPF会在每一个Ma网络（多路访问网络）选举一个指定路由器（DR）和一个备用指定路由器（BDR）</p>
<p>DR选举规则：最高OSPF接口优先级拥有者被选为DR，<strong>如果优先级相等（默认为1），具有最高OSPF RouterlD的路由器被选举为DR</strong>，并且DR具有非抢占性。[<strong>优先级0不参与选举</strong>]</p>
<p>备用指定路由器（BDR）：监控DR状态，并在当前DR发生故障后接替其角色。具有最高OSPF RouterlD的路由器被选举为BDR</p>
</blockquote>
<p>在OSPF的广播网络中，有4台路由器Router A、Router B、Router C和Router D，其优先级分别为2、1、1和0，Router ID分别为192.168.1.1、192.168.2.1、192.168.3.1和192.168.4.1、若在此4台路由器上同时启用OSPF协议，OSPF选出的BDR为（47）。C<br>A.Router A </p>
<p>B.Router B </p>
<p>C.Router C </p>
<p>D.Router D</p>
<p>OSPF协议适用于4种网络。下面选项中，属于广播多址网络的是  (1)  ，属于非广播多址网络的是  (2)  。</p>
<ul>
<li>Ethernet </li>
<li>Frame Relay </li>
</ul>
<p>运行 OSPF 协议的路由器每 10 秒钟向它的各个接口发送 Hello 分组，接收到 Hello 分组的路由器就知道了邻居的存在。如果在 （ ） 秒内没有从特定的邻居接收到这种分组，路由器就认为那个邻居不存在了。</p>
<p><strong>40。OSPF规定路由器失效时间是Hello分组间隔时间的4倍</strong></p>
<h4 id="DHCP-1"><a href="#DHCP-1" class="headerlink" title="DHCP"></a>DHCP</h4><p>DHCP协议的功能是 （1） 。在Linux中提供DHCP服务的<strong>程序</strong>是 （2） ；DHCP服务将主机的MAC地址和IP地址绑定在一起的方法是在 （3） 文件中添加“host主机名{hardware Ethernetxx xx.xx.xx.xx.xx fixed-address 192.168.0.9}”配置项；创建DHCP租用文件的命令是 （4） ；通过运行 （5） 命令可以设置在操作系统启动时自动运行DHCP服务。</p>
<ul>
<li>为客户机自动配置IP地址 </li>
<li>/usr/sbin/dhcpd</li>
<li>/etc/dhcpd.conf </li>
<li>touch  /var/state/dhcp/dhcpd.leases </li>
<li>chkconfig</li>
</ul>
<blockquote>
<p>当<strong>DHCP客户机</strong>第一次登录网络的时候（也就是客户机上没有任何IP地址数据时），它会通过UDP 67端口向网络上发出一个<strong>DHCPDISCOVER</strong>数据包（包中包含客户机的MAC地址和计算机名等信息）。因为客户机还不知道自己属于哪一个网络，所以<strong>封包的源地址为0.0.0.0，目标地址为255.255.255.255</strong>，然后再附上DHCP discover的信息，向网络进行广播。</p>
<p>DHCP discover的等待时间预设为1秒，也就是当客户机将第一个DHCP discover封包送出去之后，在1秒之内没有得到回应的话，就会进行第二次DHCP discover广播。若一直没有得到回应，客户机会将这一广播包重新发送四次（以2，4，8，16秒为间隔，加上1-1000毫秒之间随机长度的时间）。如果都没有得到<strong>DHCP服务器端</strong>的回应，客户机会从<strong>169.254.0.0/16</strong>这个自动保留的私有IP地址中选用一个IP地址，并且每隔5分钟重新广播一次，如果收到某个服务器的响应，则继续IP租用过程。</p>
</blockquote>
<p><strong>DhcpDiscover</strong>。当主机启动时需要自动分配IP地址，又不知道DHCP服务器地址，故请求报文DhcpDiscover中目的IP地址为 <strong>255.255.255.255</strong>。</p>
<h4 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h4><p>许多网络通信需要进行组播，以下选项中不采用组播协议的应用是 （1） 。在IPv4中把 （2） 类地址作为组播地址。<strong>FTP,D</strong></p>
<h4 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h4><p>SNMP 是专门设计用于在 IP 网络管理网络节点（服务器、工作站、路由器、交换机及HUBS等）的一种标准协议，它是一种应用层协议。 SNMP 使网络管理员能够管理网络效能，发现并解决网络问题以及规划网络增长。通过 SNMP 接收随机消息（及事件报告）网络管理系统获知网络出现问题</p>
<p>SNMP协议实体发送请求和应答报文的默认端口号是161，SNMP代理发送陷阱报文(Trap) 的默认端口号是162。</p>
<p> 在SNMP v2中，一个实体发送一个报文一般要经过下面4个步骤。</p>
<p> （1）根据要实现的协议操作构造PDU； （2）把PDU、源和目标端口地址以及团体名传送给认证服务，认证服务产生认证码或对数据进行加密，返回结果； （3）加入版本号和团体名，构造报文； （4）进行BER编码，产生0/1比特串，发送出去。</p>
<h3 id="计算-1"><a href="#计算-1" class="headerlink" title="计算"></a>计算</h3><p>在重负载时，令牌环网比以太网的利用率高</p>
<p>ITU V.90调制解调器（Modem）的下载速度为56kb/s，上 传速率是33.6kb/s。</p>
<p>路由收敛是指网络设备路由表和网络拓扑结构一致</p>
<p>客户机会在租期过去50%的时候，直接向为其提供IP地址的DHCP Server发送DHCP REQUEST消息包。满了是发DHCP DISCOVER。</p>
<p>某局域网采用CSMA/CD协议实现介质访问控制，数据传输速率为10Mbps，主机甲和主机乙之间的距离为2km，信号传播速度是200m/μs。若主机甲和主机乙发送数据时发生冲突。从开始发送数据起，到两台主机均检测到冲突时刻为止，<strong>最短</strong>需经过的时间是（ ）μs。</p>
<blockquote>
<p>基带CSMA/CD:传输时延&gt;=2倍于传播时延</p>
<p>宽带CSMA/CD:传输时延&gt;=4倍于传播时延</p>
</blockquote>
<p>在以太网中为了确保发送数据站点在传输时能检测到可能存在的冲突，数据帧的<strong>传输时延至少要两倍与传播时延</strong>（因为宽带CSMA/CD是单向传输）。由此可以算出传输时延≥2*2000/200=20μs。当冲突刚好发生在链路中间的时候，时间是最短的，所以是20μs/2=10μs。</p>
<p>以100Mb/s以太网连接的站点A和B相距2000m，通过停等机制进行数据传输，传播速度为200m/us，最高的有效传输速率为（14）Mb/s。82.9</p>
<p>解析：<strong>以太网数据帧最大1518字节，最小64字节</strong>。<strong>停等机制</strong>说的就是，发送方把数据发过去，要停下来不能再发了，要等接收方发确认帧，收到之后再发。这里需要<strong>计算两个时间，一个是发送时间，一个是传输时间</strong>。</p>
<p>以太网数据帧最大为1518字节，姑且按最大帧计算，则<strong>帧发送时间</strong>：</p>
<p>1518*8/100mb/s=121.44us</p>
<p>数据<strong>帧传播时间</strong>=2000m/(200m/us)=10us</p>
<p>题目指出采用停等传输机制，即收到确认帧后再发下一帧，<strong>确认帧是64B</strong>，则确认帧发送时间：64*8/100Mb/s=5.12us</p>
<p>总时间：121.44us+5.12us+10us+10us=146.56us</p>
<p>则有效速率为：1518*8/146.56=82.9Mb/s（直接用1518，不用考虑MTU静载荷1500），故选B</p>
<p>海明码构造办法是:在数据位之间插入k个校验位,通过扩大码距来实现检错和纠错。设数据位是n位,校验位是k位,则n和k必要满足如下关系。</p>
<p>$2^k-1&gt;=n+k$</p>
<p>数据为16位时,至少需要5位校验位</p>
<h1 id="通信"><a href="#通信" class="headerlink" title="通信"></a>通信</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/4311d3b6b5c5d1dba959ef3322f29d45.png" alt="图片说明" style="zoom:150%;" />通信的目的就是传递信息。通信中产生和发送信息的一端叫作信源，接收信息的一端叫作信宿，信源和信宿之间的通信线路称为信道。信息在进入信道时要变换为适合信道传输的形式，在进入信宿时又要变换为适合信宿接收的形式。信道的物理性质不同，对通信的速率和传输质量的影响也不同。另外，信息在传输过程中可能会受到外界的干扰，把这种干扰称为噪声。不同的物理信道受各种干扰的影响不同，例如，如果信道上传输的是电信号，就会受到外界电磁场的干扰，光纤信道则基本不受电磁场干扰。</p>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="载波"><a href="#载波" class="headerlink" title="载波"></a>载波</h3><p>载波是指被调制以传输<a href="https://www.elecfans.com/v/tag/106/">信号</a>的波形，一般为正弦波，也可以是非正弦波（如周期性脉冲序列）。载波信号，就是把普通信号（声音、图象）加载到一定频率的高频信号上，在没有加载普通信号的高频信号时，高频信号的波幅是固定的，加载之后波幅就随着普通信号的变化而变化（调幅），还可以调相，调频。载波信号一般要求正弦载波的频率远远高于调制信号的带宽，否则会发生混叠，使传输信号失真</p>
<blockquote>
<p>因为有用信息一般都是低频信号，不利于传播，所以要用一个高频的或者振幅更大的波（载波）来作为载体传播出去（频率越高越好传播）</p>
</blockquote>
<p>作用包括：</p>
<p>1、减小传输中的噪声；</p>
<p>2、<a href="https://baike.baidu.com/item/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8/7626706?fromModule=lemma_inlink">频分复用</a>，即同一频率之间同一信道传输多路信号而不<a href="https://baike.baidu.com/item/%E6%B7%B7%E5%8F%A0/6996184?fromModule=lemma_inlink">混叠</a>；</p>
<p>3、可传播更远距离，有利于接收。</p>
<p>E1：E1由32个子信道组成， 30个传送话音数据，2个子信道</p>
<ul>
<li><p>在<strong>E1载波</strong>中，E1信道的速率(0),每个子信道(话音信道)的数据速率是 （1） ，E1载波的控制开销占 （2），E1基本帧的传送时间为（19） 。 </p>
<ul>
<li><p>2.048Mb/s</p>
</li>
<li><p>64kb/s</p>
</li>
<li><p>6.25% = 2/32*100%</p>
</li>
<li><p>125us</p>
</li>
</ul>
</li>
<li><p>E2由4个E1组成</p>
</li>
<li><p>E3由4个E2组成</p>
<ul>
<li>E3数据速率是<strong>34.368Mb/s</strong> (约为34)</li>
</ul>
</li>
</ul>
<p>T1载波的数据速率1.544mb/s，每个信道的数据速率是 （ ） kb/s。64</p>
<p>T3数据速率为<strong>44.736Mb/s</strong></p>
<h2 id="频段"><a href="#频段" class="headerlink" title="频段"></a>频段</h2><p>频段：无线通信使用的是电磁波，既然是波，那就有频率，通过将电磁波的频率划分为不同的 “段”，即是频段（是指一个连续电磁波的频率范围）</p>
<p><img src="https://pic2.zhimg.com/80/v2-5561011e61f9ea85c44e0e524615d289_720w.webp" alt="img"></p>
<p>通常无线路由器都会有两个频段：2.4GHz和5GHz。之所以叫2.4G，是因为这个频段的频率范围为：2.4GHZ~2.4835GHZ。5G频率范围是5.15-5.825GHz</p>
<p><strong>波长=波速 * 周期=波速/频率，所以频率越高，波长越短</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-e676b3d47ba6bbcd13e540194ccc27b7_720w.webp" alt="img"></p>
<h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道就是在频段基础上的更进一步的划分。信道是指的通过时间、频率来切分出来的可以分配给不同终端使用的资源。目的是为了避免很多个设备之间的竞争</p>
<blockquote>
<p><strong>既然是避免冲突，为什么不多划分很多信道呢？</strong></p>
<p>首先，信道越多，那每个信道的宽度就很窄了，信道里边终端的冲突概率就变得更大了，如果想要避免或是减少冲突，那么则需要花费更多的时间来监测冲突，有问题的情况下，还需要重发数据包，那么速度肯定也提不上去。</p>
</blockquote>
<p>2,4G频段一共有14个信道，但在中国只允许使用前13个信道。每个信道22MHZ宽，实际使用来传输数据的只有20MHZ宽，其余的2MHZ用来隔离信道，就好比马路两侧的绿化带</p>
<p><img src="https://pic1.zhimg.com/80/v2-58eb2cd9b6aadf439bb27435b88c3c30_720w.webp" alt="img"></p>
<p>在2.4GHz频段，1、6和11是唯一不重叠的频道。所以，两个设备要相隔5个信道才不会相互干扰，即1、6、11相互隔开，致使一个区域只能有3个无线设备</p>
<p><img src="https://img-blog.csdnimg.cn/ac5bd1e651dd47c79e00a536d61e375a.png" alt="在这里插入图片描述"></p>
<h3 id="信道带宽"><a href="#信道带宽" class="headerlink" title="信道带宽"></a>信道带宽</h3><p>信道包括模拟信道和数字信道。在模拟信道，带宽按照信号频带范围公式W=f2-f1 计算；数字信道的带宽为信道能够达到的最大数据速率</p>
<p>传输速率：传输速度的单位是每秒比特（<strong>bit/s</strong>）或每秒字节（<strong>Byte/s</strong>）</p>
<h3 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h3><p>多路复用技术是把多个低速信道组合成一个高速信道的技术。这种技术要用到两个设备，其中，多路复用器（Multiplexer）在发送端根据某种约定的规则把多个低带宽的信号复合成个高带宽的信号；多路分配器（Demultiplexer）在接收端根据同一规则把高带宽信导分解成您个低带宽信号。多路复用器和多路分配器统称多路器，简写为MUX</p>
<h4 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h4><p>频分复用是将所给的信道带宽分割成互不重叠的许多小区间，每个小区间能顺利通过一路信号，在一般情况下可以通过正弦波调制的方法实现频分复用。频分复用的多路信号在频率上不会重叠，但在时间上是重叠的。</p>
<h5 id="OFDM"><a href="#OFDM" class="headerlink" title="OFDM"></a>OFDM</h5><p>OFDM(Orthogonal Frequency Division Multiplexing)即正交频分复用技术，实际上OFDM是MCM(Multi Carrier Modulation)，多载波调制的一种。<strong>通过频分复用实现高速串行数据的并行传输</strong>, 它具有较好的抗多径衰落的能力，能够支持多用户接入。 [1]</p>
<h4 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h4><p>时分多路复用（TDM）是按传输信号的时间进行分割的，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Slot time，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。</p>
<blockquote>
<p><strong>SONET采用的成帧方法</strong></p>
</blockquote>
<h4 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h4><p>码分复用是一种以<strong>扩频技术</strong>为基础的复用技术</p>
<h4 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h4><p>使用在光纤通信中，不同的信道用不同的波长的光波承载。在同一根光纤中同时传输两个或众多不同波长光信号的技术，称为波分复用。</p>
<h2 id="信号调制编码"><a href="#信号调制编码" class="headerlink" title="信号调制编码"></a>信号调制编码</h2><p>电(电压或电流),有直流和交流之分。在通信应用中,用作信号传输的一般都是<a href="https://baike.baidu.com/item/%E4%BA%A4%E6%B5%81%E7%94%B5/1023508?fromModule=lemma_inlink">交流电</a>。呈正弦变化的交流<a href="https://baike.baidu.com/item/%E7%94%B5%E4%BF%A1%E5%8F%B7/1594125?fromModule=lemma_inlink">电信号</a>,随着时间的变化,其幅度时正、时负以一定的能量和速度向前传播。</p>
<p>信号的“频率”：<a href="https://baike.baidu.com/item/%E6%AD%A3%E5%BC%A6%E6%B3%A2/8995467?fromModule=lemma_inlink">正弦波</a>幅度在1秒钟内的重复变化次数</p>
<p>周期：信号波形变化一次所需的时间,以秒为单位。</p>
<p><strong>波行进一个周期所经过的距离称为“波长”</strong>，用λ表示,以米为单位。　</p>
<p>f（频率）、T（周期）和λ（波长）存在如下关系:</p>
<p>c=λ/T=λ×f</p>
<p>其中,c是<a href="https://baike.baidu.com/item/%E7%94%B5%E7%A3%81%E6%B3%A2/102449?fromModule=lemma_inlink">电磁波</a>的<a href="https://baike.baidu.com/item/%E4%BC%A0%E6%92%AD%E9%80%9F%E5%BA%A6/5920231?fromModule=lemma_inlink">传播速度</a>,等于3x10^8米/秒。</p>
<p>根据脉冲编码调制方案，采样的频率决定了恢复的模拟信号的质量。尼奎斯特采样定理说明，为了恢复原来的模拟信号，<strong>采样领率必须大于模拟信号最高频率的二倍</strong></p>
<p>$f=\frac{1}{T}\geq2f_{max}$</p>
<h3 id="数字调制"><a href="#数字调制" class="headerlink" title="数字调制"></a>数字调制</h3><blockquote>
<p>数字信号调制成模拟信号</p>
</blockquote>
<p><strong>数据的三种调制方法：</strong>调幅、调频、调相，分别称为振幅键控ASK、移频键控FSK、移相键控PSK。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a18bdd923a9699851c4e0013236bc8d4.png" alt="图片说明"></p>
<p>ASK——幅移键控，通过调整振幅来表示不同数据；</p>
<p>FSK——频移键控，通过调整频率来表示不同数据；</p>
<p>PSK——相移键控，通过调整相位来表示不同数据；</p>
<p>DPSK——相对相移键控调制，信息是通过连续信号之间的载波信号的相位差别被传输的</p>
<h4 id="DPSK"><a href="#DPSK" class="headerlink" title="DPSK"></a>DPSK</h4><p>DPSK（Differential Phase Shift Keying，差分移相键控）是利用调制信号<strong>前后码元之间载波相对相位的变化</strong>来传递信息的。</p>
<p>DPSK调制技术即差分相移键控，采用了2种相位，通过前沿有无相位的改变来表示数据“0”和“1”。</p>
<h4 id="4相调制"><a href="#4相调制" class="headerlink" title="4相调制"></a>4相调制</h4><p>数据速率是码元速率的两倍</p>
<h3 id="脉冲编码调制PCM"><a href="#脉冲编码调制PCM" class="headerlink" title="脉冲编码调制PCM"></a>脉冲编码调制PCM</h3><blockquote>
<p><strong>属于基带传输</strong></p>
</blockquote>
<p>PCM 即脉冲编码调制 (Pulse Code Modulation)。在PCM过程中，将输入的模拟信号进行采样、量化和编码，用二进制进行编码的数来代表模拟信号的幅度</p>
<p>抽样是把时间连续的模拟信号转换成<strong>时间上离散、幅度连续的抽样信号</strong>；</p>
<p>量化是把时间离散、幅度连续的抽样信号转换成<strong>时间离散、幅度离散的数字信号</strong>；</p>
<p>编码是将量化后的信号编码形成多位二进制码组成的码组表示抽样值，完成模拟信号到数字信号的转换。编码后的二进制码组经数字信道传输，在接收端，经过译码和滤波，还原为模拟信号。</p>
<h4 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h4><p>抽样是把<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7?fromModule=lemma_inlink">模拟信号</a>以其信号带宽2倍以上的频率提取样值，变为在时间轴上离散的抽样信号的过程。例如，话音信号带宽被限制在0.3～3.4kHz内，用 8kHz的抽样频率（fs），就可获得能取代原来连续话音信号的抽样信号。对一个正弦信号进行抽样获得的抽样信号是一个<a href="https://baike.baidu.com/item/%E8%84%89%E5%86%B2%E5%B9%85%E5%BA%A6%E8%B0%83%E5%88%B6/7878538?fromModule=lemma_inlink">脉冲幅度调制</a>（PAM）信号，对抽样信号进行检波和平滑滤波，即可还原出原来的模拟信号。</p>
<h4 id="量化"><a href="#量化" class="headerlink" title="量化"></a>量化</h4><p>抽样信号虽然是时间轴上离散的信号，但仍然是<a href="https://baike.baidu.com/item/%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7?fromModule=lemma_inlink">模拟信号</a>，其样值在一定的取值范围内，可有无限多个值。显然，对无限个样值一一给出数字码组来对应是不可能的。为了实现以数字码表示样值，必须采用“四舍五入”的方法把样值分级“取整”，使一定取值范围内的样值由无限多个值变为有限个值。这一过程称为量化。</p>
<p><a href="https://baike.baidu.com/pic/pcm%E7%BC%96%E7%A0%81/10865033/0/faedab64034f78f00a6b440077310a55b2191ce5?fr=lemma&fromModule=lemma_content-image&ct=single"><img src="https://bkimg.cdn.bcebos.com/pic/faedab64034f78f00a6b440077310a55b2191ce5?x-bce-process=image/resize,m_lfit,w_440,limit_1" alt="pcm编码"></a>pcm编码</p>
<p>量化后的抽样信号与量化前的抽样信号相比较，当然有所失真，且不再是模拟信号。这种量化失真在接收端还原模拟信号时表现为噪声，并称为量化噪声。量化噪声的大小取决于把样值分级“取整”的方式，分的级数越多，即量化级差或间隔越小，量化噪声也越小。</p>
<h4 id="编码-2"><a href="#编码-2" class="headerlink" title="编码"></a>编码</h4><p>量化后的抽样信号在一定的取值范围内仅有有限个可取的样值，且信号正、负幅度分布的对称性使正、负样值的个数相等，正、负向的量化级对称分布。若将有限个 量化样值的绝对值从小到大依次排列，并对应地依次赋予一个十进制数字代码（例如，赋予样值0的十进制数字代码为0），在码前以“+”、“－”号为前缀，来 区分样值的正、负，则量化后的抽样信号就转化为按抽样时序排列的一串十进制数字码流，即十进制数字信号。简单高效的数据系统是二进制码系统，因此，应将十 进制数字代码变换成<a href="https://baike.baidu.com/item/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%BC%96%E7%A0%81?fromModule=lemma_inlink">二进制编码</a>。根据十进制数字代码的总个数，可以确定所需二进制编码的位数，即<a href="https://baike.baidu.com/item/%E5%AD%97%E9%95%BF?fromModule=lemma_inlink">字长</a>。这种把量化的抽样信号变换成给定字长的二进制码流的 过程称为编码。</p>
<img src="https://bkimg.cdn.bcebos.com/pic/30adcbef76094b364591a2eaa3cc7cd98d109db2?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2UxNTA=,g_7,xp_5,yp_5" alt="img" style="zoom:50%;" />

<ul>
<li>不归零码<ul>
<li>高电平代表1，低电平代表0</li>
</ul>
</li>
<li><a href="https://baike.baidu.com/item/%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%A0%81/8932867?fromModule=lemma_inlink">曼彻斯特码</a>，又叫数字双相码<ul>
<li>电位由高到底代表1，电位由低到高代表0</li>
</ul>
</li>
<li><a href="https://baike.baidu.com/item/%E5%B7%AE%E5%88%86%E6%9B%BC%E5%BD%BB%E6%96%AF%E7%89%B9%E7%A0%81/4010212?fromModule=lemma_inlink">差分曼彻斯特码</a>，又叫条件双相码（CDP码）<ul>
<li>两个相邻的波形，如果后一个波形和前一个的波形相同，则后一个波形表示0，如果波形不同，则表示1</li>
</ul>
</li>
<li>4B/5B编码（todo）</li>
</ul>
<blockquote>
<p>双相码：抗干扰性好，实现自同步。</p>
<p><strong>曼彻斯特：用于以太网编码，效率为50%</strong></p>
<p><strong>差分曼彻斯特：用于令牌环网，效率为50%。</strong></p>
<p>双相码的每一个码元都要调制为两个不同的电平，因而<strong>调制速率是码元速率的2倍</strong></p>
</blockquote>
<h2 id="通信方式和交换方式"><a href="#通信方式和交换方式" class="headerlink" title="通信方式和交换方式"></a>通信方式和交换方式</h2><ul>
<li>单工通信</li>
<li>半双工</li>
<li>全双工</li>
</ul>
<p>同步方式</p>
<ul>
<li>异步传输（发送和接受不在同一时钟下）：在字符前后插入起始位（0）和停止位（1）.但是加入的同时会造成速率的降低</li>
<li>同步传输</li>
</ul>
<h2 id="考点-2"><a href="#考点-2" class="headerlink" title="考点"></a>考点</h2><h3 id="背-2"><a href="#背-2" class="headerlink" title="背"></a>背</h3><p>telnet协议是一种()的远程登录协议。TCP</p>
<p>我国自行研制的移动通信3G标准是 （ ） 。TD-SCDMA</p>
<p>4G无线通信采用的载波调制技术是OFDM， 5G采用改进的 F-OFDM</p>
<p>不属于4G标准的是WCDMA</p>
<p>LTE、LTE-Advanced、WIMAXII、Wireless MAN、UMB等属于4G标准</p>
<p>RS-232-C的电气特性采用V.28标准电路，允许的数据速率是  （1）  ，传输距离不大于  （2）  </p>
<p>20kb/s,15m</p>
<p>同步数字系列SDH (Synchronous Digital Hierarchy)中最常用的是</p>
<p>STM-1(155.520 Mb/s、</p>
<p>STM-4(622.080 Mb/s、</p>
<p>STM-16（2488.320 Mb/s</p>
<p>STM-64（10Gb/s</p>
<p>在光纤通信标准中，OC-3的数据速率是  （ ）  。155Mb/s</p>
<p>按照美国制定的光纤通信标准SONET，OC-48的线路速率是 （ ） Mb/s。2488.32</p>
<p>无线漫游是由无线客户端而不是AP发起的(AP:<strong>无线访问接入点</strong>)</p>
<p>利用SDH实现广域网互联，如果用户需要的数据传输速率较小，可以用准同步数字系列（PDH）兼容的传输方式在每个STM-1帧中封装　（ ）　个E1信道。63</p>
<p> ITU V.90调制解调器（Modem）的下载速度为56kb/s，上传速率是33.6kb/s。</p>
<p>跳频扩频是在时间周期后跳到另一个载频上，减少了干扰，并不能扩大通信的范围，选项b错误。</p>
<h3 id="计算-2"><a href="#计算-2" class="headerlink" title="计算"></a>计算</h3><p>8 个9600b/s 的信道按时分多路复用在一条线路上传输，在统计TDM 情况下，假定每个子信道有80%的时间忙，复用线路的控制开销为5%，那么复用线路的带宽为 （15） 。</p>
<p>（15）A．32kb/s B．64 kb/s C．72 kb/s D．96 kb/s</p>
<p>试题解析：</p>
<p>（8 * 9600）* 80% / （1-5%）≈ 64kb/s。</p>
<p>5个64kb/s 的信道按统计时分多路复用在一条主线路上传输，主线路的开销为4% ，假定每个子信道利用率为90% ，那么这些信道在主线路上占用的带宽为（）kb/s。</p>
<p>子信道利用率为90%,）因此复用后速率为： 5 * 64kbps * 90%=288kbps，又因为开销占了4%,t因此实际传送的数据只占96%，所以实际要占288/0.96=300kbps。</p>
<p>在PCM中，若对模拟信号的采样值使用64级量化，则至少需使用( )位二进制。</p>
<p>量化，就是把经过抽样得到的瞬时值将其幅度离散，即用一组规定的电平，把瞬时抽样值用最接近的电平值来表示，离散值的个数决定了量化的精度。64级量化，需要使用的二进制位数是6，因为2的6次方=64。</p>
<p>设信道带宽为3400HZ，采用PCM编码，采样周期为125μs，每个样本量化为256个等级，则信道的数据速率为( )。</p>
<p>采样周期125μs，f=1s/125us=8000Hz ,每秒采样8000次，256个量化级是8b，速率=8×8000=64Kb/s.</p>
<p>8条模拟信道采用TDM复用成1条数字信道，TDM帧的结构为8字节加1比特同步开销(每条模拟信道占1个字节)。若模拟信号频率范围为10~16kHz. 样本率至少为（ ）样本/秒，此时数字信道的数据速率为（ ） Mbps。 </p>
<p>采样频率应为信道最高频率的2倍，所以模拟信号频率范围为10~16kHz，那么样本率至少为16k * 2 =32kHz。 题干中声明，8条模拟信道采用TDM复用成1条数字信道，TDM帧的结构为8字节加1比特同步开销，其中1B为8 b，即一共有8 B * 8 b+1 b=65b。1个采样样本占65比特，则数据速率为32k*65b=2080kbps=2.08mbps </p>
<p>点拨： 其中32kHz是每秒采样的样本数，即每秒采样32k个样本</p>
<p>若<strong>8进制</strong>信号的信号速率是4800Baud，则信道的数据速率为()kb/s。<br>A.9.6<br>B.14.4<br>C.19.2<br>D.38.4<br>信管网参考答案：B</p>
<h3 id="传输"><a href="#传输" class="headerlink" title="传输"></a>传输</h3><p>在地面上相隔2000KM的两地之间通过卫星信道传送4000比特长的数据包，如果数据速率为64Kb/S，则从开始发送到接收完成需要的时间是 （ ） 。</p>
<p>卫星信道的传输延迟为270ms，4000比特数据包 发送时间为4000b/64kb/s=62.5ms，二者相加 270+62.5=332.5ms。</p>
<p>两个部件的可靠度R均为0.8，由这两个部件串联构成的系统的可靠度为 （1） ；由这两个部件并联构成的系统的可靠度为 （2） 。 （1）</p>
<p>本题知识点：广域通信网 Cnitpm.com, 串联的可靠度=R*R=0.64。 并行的可靠度=1-(1-R)(1-R)=1-0.04=0.96</p>
<p>在地面上相距2000公里的两地之间通过电缆传输4000比特长的数据包，数据速率为64Kb/s，从开始发送到接收完成需要的时间为（ ）。72.5ms</p>
<p>电缆传播速度20km/ms</p>
<h1 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h1><h2 id="网络安全威胁的类型"><a href="#网络安全威胁的类型" class="headerlink" title="网络安全威胁的类型"></a>网络安全威胁的类型</h2><p>网络威胁是对网络安全缺陷的潜在利用，这些缺陷可能导致非授权访问、信息泄露、资源耗尽、资源被盗或者被破坏等。网络安全所面临的威胁可以来自很多方面，并且随着时间的变化而变化。网络安全威胁有以下几类。</p>
<p>（1）窃听。在广播式网络系统中，每个节点都可以读取网上传输的数据，例如搭线窃听、安装通信监视器和读取网上的信息等。网络体系结构允许监视器接收网上传输的所有数据帧而不考虑帧的传输目标地址，这种特性使得偷听网上的数据或非授权访问很容易而且不易发现。</p>
<p>（2）假冒。当一个实体假扮成另一个实体进行网络活动时就发生了假冒。</p>
<h3 id="重放"><a href="#重放" class="headerlink" title="重放"></a>重放</h3><p>重放。重复一份报文或报文的一部分，以便产生一个被授权效果。</p>
<p>措施：随机数，时间戳</p>
<h3 id="拒绝服务-DDoS"><a href="#拒绝服务-DDoS" class="headerlink" title="拒绝服务(DDoS)"></a>拒绝服务(DDoS)</h3><p>分布式拒绝服务（Distributed Denial of Service，简称DDoS）将多台计算机联合起来作为攻击平台，通过远程连接，利用恶意程序对一个或多个目标发起DDoS攻击，消耗目标服务器性能或网络带宽，从而造成服务器无法正常地提供服务。</p>
<h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>通常，攻击者使用一个非法账号将DDoS主控程序安装在一台计算机上，并在网络上的多台计算机上安装代理程序。在所设定的时间内，主控程序与大量代理程序进行通讯，代理程序收到指令时对目标发动攻击，主控程序甚至能在几秒钟内激活成百上千次代理程序的运行。</p>
<h4 id="常见的DDoS攻击类型"><a href="#常见的DDoS攻击类型" class="headerlink" title="常见的DDoS攻击类型"></a>常见的DDoS攻击类型</h4><p><img src="https://img-blog.csdnimg.cn/img_convert/f8153905c6e3ca28cb91de73f24bd8bf.webp?x-oss-process=image/format,png" alt="image-20221118093423876"></p>
<table>
<thead>
<tr>
<th align="left">DDoS攻击分类</th>
<th align="left">攻击子类</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">畸形报文</td>
<td align="left">畸形报文主要包括Frag Flood、Smurf、Stream Flood、Land Flood、IP畸形报文、TCP畸形报文、UDP畸形报文等。</td>
<td align="left">畸形报文攻击指通过向目标系统发送有缺陷的IP报文，使得目标系统在处理这样的报文时出现崩溃，从而达到拒绝服务的攻击目的。</td>
</tr>
<tr>
<td align="left">传输层DDoS攻击</td>
<td align="left">传输层DDoS攻击主要包括<strong>Syn Flood</strong>、Ack Flood、UDP Flood、ICMP Flood、RstFlood等。</td>
<td align="left">以Syn Flood攻击为例，它利用了TCP协议的三次握手机制，当服务端接收到一个Syn请求时，服务端必须使用一个监听队列将该连接保存一定时间。因此，通过向服务端不停发送Syn请求，但<strong>不响应Syn+Ack报文</strong>，从而消耗服务端的资源。当监听队列被占满时，服务端将无法响应正常用户的请求，达到拒绝服务攻击的目的。</td>
</tr>
<tr>
<td align="left">DNS DDoS攻击</td>
<td align="left">DNS DDoS攻击主要包括DNS Request Flood、DNS Response Flood、虚假源+真实源DNS Query Flood、权威服务器攻击和Local服务器攻击等。</td>
<td align="left">以DNS Query Flood攻击为例，其本质上执行的是真实的Query请求，属于正常业务行为。但如果多台傀儡机同时发起海量的域名查询请求，服务端无法响应正常的Query请求，从而导致拒绝服务。</td>
</tr>
<tr>
<td align="left">连接型DDoS攻击</td>
<td align="left">连接型DDoS攻击主要是指TCP慢速连接攻击、连接耗尽攻击、Loic、Hoic、Slowloris、 Pyloris、Xoic等慢速攻击。</td>
<td align="left">以Slowloris攻击为例，其攻击目标是Web服务器的并发上限。当Web服务器的连接并发数达到上限后，Web服务即无法接收新的请求。Web服务接收到新的HTTP请求时，建立新的连接来处理请求，并在处理完成后关闭这个连接。如果该连接一直处于连接状态，收到新的HTTP请求时则需要建立新的连接进行处理。而当所有连接都处于连接状态时，Web将无法处理任何新的请求。Slowloris攻击利用HTTP协议的特性来达到攻击目的。HTTP请求以<code>\r\n\r\n</code>标识Headers的结束，如果Web服务端只收到<code>\r\n</code>，则认为HTTP Headers部分没有结束，将保留该连接并等待后续的请求内容。</td>
</tr>
<tr>
<td align="left">Web应用层DDoS攻击</td>
<td align="left">Web应用层攻击主要是指HTTP Get Flood、HTTP Post Flood、CC等攻击。</td>
<td align="left">通常应用层攻击完全模拟用户请求，类似于各种搜索引擎和爬虫一样，这些攻击行为和正常的业务并没有严格的边界，难以辨别。Web服务中一些资源消耗较大的事务和页面。例如，Web应用中的分页和分表，如果控制页面的参数过大，频繁的翻页将会占用较多的Web服务资源。尤其在高并发频繁调用的情况下，类似这样的事务就成了早期CC攻击的目标。由于现在的攻击大都是混合型的，因此模拟用户行为的频繁操作都可以被认为是CC攻击。例如，各种刷票软件对网站的访问，从某种程度上来说就是CC攻击。CC攻击瞄准的是Web应用的后端业务，除了导致拒绝服务外，还会直接影响Web应用的功能和性能，包括Web响应时间、数据库服务、磁盘读写等。</td>
</tr>
</tbody></table>
<h4 id="措施"><a href="#措施" class="headerlink" title="措施"></a>措施</h4><p>配置最小特权访问策略、部署IPS防护、启用防火墙的防DDOS功能、购买流量清洗服务、停止不必要的服务端口等。</p>
<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><p>SQL注入攻击：黑客从正常的网页端口，进行网站访问，通过巧妙构建SQL语句，获取数据库敏感信息，或直接向数据库插入恶意语句。</p>
<p>SQL注入攻击防范的主要方法如下：</p>
<ul>
<li>对用户输入做严格检查，防止恶意SQL输入。</li>
<li>部署DBS数据库审计系统、WAF，进行安全阻断。</li>
</ul>
<h3 id="跨站脚本攻击"><a href="#跨站脚本攻击" class="headerlink" title="跨站脚本攻击"></a>跨站脚本攻击</h3><p>跨站脚本攻击（Cross Site Script，为了区别在CSS简称为XSS）指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到恶意用户的特殊目的。</p>
<p>XSS跨站脚本攻击核心都是利用了脚本注入，</p>
<p>因此解决办法其实很简单：</p>
<p>部署WAF，防火墙，自动过滤攻击报文。<br>对用户输入进行过滤，对特殊字符如”&lt;”，”&gt;”转义，可以从根本上防止这一问题。</p>
<h3 id="病毒"><a href="#病毒" class="headerlink" title="病毒"></a>病毒</h3><p>计算机病毒的分类方法有许多种，按照最通用的区分方式，即根据其感染的途径以及采用的技术区分，计算机病毒可分为文件型计算机病毒、引导型计算机病毒、宏病毒和目录型计算机病毒。</p>
<ul>
<li> 文件型计算机病毒感染可执行文件（包括EXE和COM文件。</li>
<li> 引导型计算机病毒影响软盘或硬盘的引导扇区。</li>
<li> 目录型计算机病毒能够修改硬盘上存储的所有文件的地址。</li>
<li> 宏病毒感染的对象是使用某此程序创建的文本文档、数据库、电子表格等文件，从文件名可以看出Macro.Melissa是一种宏病毒。</li>
</ul>
<h4 id="病毒的分类和命名规则"><a href="#病毒的分类和命名规则" class="headerlink" title="病毒的分类和命名规则"></a>病毒的分类和命名规则</h4><p>病毒名称的一般格式为&lt;病毒前缀&gt;.&lt;病毒名&gt;.&lt;病毒后缀&gt;。病毒前缀是指病毒的种类，不同种类的病毒其前缀是不同的。比如常见的木马病毒的前缀为Trojan，蠕虫病毒的前缀是Worm等。病毒名是指一个病毒的家族特征，例如CIH 病毒的家族名是“CIH”，振荡波蠕虫病毒的家族名是”Sasser”。病毒后缀是用来区别某个家族病毒的不同变种的，一般都采用英文字母来表示，如Worm.Sasser.b就是指振荡波蠕虫病毒的变种b。如果病毒变种非常多，可以采用数字与字母混合表示。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230516171734479.png" alt="image-20230516171734479"></p>
<p>杀毒软件报告发现病毒Macro.Melissa，由该病毒名称可以推断出病毒类型是  （1）  ，这类病毒主要感染目标是  （2）  。宏病毒，word/excel</p>
<p>硬件和兼容部件并不能保证正常而有效地工作，除非用户选择了适当的安全策略和打开了能增加其系统安全的部件。</p>
<h4 id="木马"><a href="#木马" class="headerlink" title="木马"></a>木马</h4><p>C&amp;C</p>
<p>一句话木马：eval（）</p>
<h4 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h4><h2 id="安全技术"><a href="#安全技术" class="headerlink" title="安全技术"></a>安全技术</h2><p>任何形式的网络服务都会导致安全方面的风险，问题是如何将风险降低到最低程度，目前的网络安全措施有数据加密、数字签名、身份认证、防火墙和入侵检测等。<br>（1）数据加密。数据加密是通过对信息的重新组合，使得只有收发双方才能解码并还原信息的一种手段。随着相关技术的发展，加密正逐步被集成到系统和网络中。在硬件方面，已经在研制用于 PC 和服务器主板的加密协处理器。<br>（2）数字签名。数字签名可以用来证明消息确实是由发送者签发的，而且，当数字签名用于存储的数据或程序时，可以用来验证数据或程序的完整性。<br>（3）身份认证。有多种方法来认证一个用户的合法性，例如密码技术、利用人体生理特征（如指纹）进行识别、智能IC卡和USB盘等。</p>
<p>（4）防火墙。防火墙是位于两个网络之间的屏障，一边是内部网络（可信赖的网络），另一边是外部网络（不可信赖的网络）。按照系统管理员预先定义好的规则控制数据包的进出。<br>（5）内容检查。即使有了防火墙、身份认证和加密，人们仍担心遭到病毒的攻击。</p>
<h3 id="信息加密和摘要技术"><a href="#信息加密和摘要技术" class="headerlink" title="信息加密和摘要技术"></a>信息加密和摘要技术</h3><h4 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h4><p><strong>加密密钥和解密密钥相同的算法</strong>，称为对称加密算法，对称加密算法相对非对称加密算法加密的效率高，适合大量数据加密。常见的对称加密算法有DES、3DES、RC5、IDEA</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230516172103081.png" alt="image-20230516172103081"></p>
<p>数据加密标准（DES）：一种分组密码，在加密前，先对整个明文进行分组。每一个分组为64位，之后进行16轮迭代，产生一组64位密文数据，使用的<strong>密钥是56位</strong>。</p>
<p>3DES：使用两个密钥，执行三次DES算法，<strong>密钥长度是112位</strong>。56*2=112</p>
<p>IDEA明文、密文均为 <strong>64 位，密钥长度128位</strong></p>
<p>RC4常用<strong>流密码，密切长度可变</strong></p>
<h4 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h4><p>加密密钥和解密密钥不相同的算法，称为非对称加密算法，这种方式又称为公钥密码体制，解决了对称密钥算法的密钥分配与发送的问题。在非对称加密算法中，私钥用于解密和签名，公钥用于加密和认证。</p>
<p>RSA</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230516172356421.png" alt="image-20230516172356421"></p>
<blockquote>
<p>邮件加密pgp</p>
<p>pgp（pretty good privacy），是一个基于rsa公钥加密体系的邮件加密软件。可以用它对邮件保密以防止非授权者阅读，它还能对邮件加上数字签名从而使收信人可以确认邮件的发送者，并能确信邮件没有被篡改。它可以提供一种安全的通讯方式，而事先并不需要任何保密的渠道用来传递密匙。它采用了一种rsa和传统加密的杂合算法，用于数字签名的邮件文摘算法，加密前压缩等，还有一个良好的人机工程设计。它的功能强大，有很快的速度。而且它的源代码是免费的。</p>
</blockquote>
<h4 id="报文摘要-Hash算法"><a href="#报文摘要-Hash算法" class="headerlink" title="报文摘要-Hash算法"></a>报文摘要-Hash算法</h4><blockquote>
<p>将一段数据（任意长度）经过一道计算，转换为一段定长的数据（<strong>MD5 128位，SHA 160位</strong>）</p>
</blockquote>
<ul>
<li><p>特点</p>
<ul>
<li><p><strong>不可逆性（单向）</strong>：几乎无法通过Hash结果推导出原文，即无法通过x的Hash值推导出x</p>
</li>
<li><p>碰撞性：几乎没有可能找到一个y，使得y的Hash值等于x的Hash值</p>
</li>
<li><p>雪崩效应：输入轻微变化，Hash输出值产生巨大变化</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p><strong>报文摘要</strong></p>
<ul>
<li><p>MD5：对任意长度报文进行运算，先把报文按<strong>512</strong>位分组，最后得到<strong>128</strong>位报文摘要。</p>
</li>
<li><p>SHA：对<strong>512</strong>位长的数据块进行复杂运行，最终产生<strong>160</strong>位散列值，比MD5更安全，计算比MD5慢。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>作用：</p>
<ul>
<li>文件完整信校验</li>
</ul>
</li>
</ul>
<ul>
<li><p>账号密码存储</p>
</li>
<li><p>用户身份认证</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230516180120088.png" alt="image-20230516180120088"></p>
</li>
</ul>
<h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>认证又分为实体认证和消息认证两种。</p>
<ul>
<li>实体认证是识别通信对方的身份，防止假冒，可以使用<strong>数字签名</strong>的方法。</li>
<li>消息认证是验证消息在传送或存储过程中有没有被篡改，通常使用<strong>报文摘要</strong>的方法。下面介绍3种身份认证的方法，前两种是基于共享密钥的，最后一种是基于公钥的认证。</li>
</ul>
<blockquote>
<p>BYOD（Bring Your Own Device，自带设备），即通过Wi-Fi的接入方式自带设备，提高工作效率，这已成为业界的趋势。而目前我们所了解的无感知认证，就是通过BYOD的方式无需用户介入自动接入Wi-Fi网络。无感知认证主要分为Portal、802.1x以及MAC等多种方式。</p>
</blockquote>
<h5 id="web-Portal认证"><a href="#web-Portal认证" class="headerlink" title="web/Portal认证"></a>web/Portal认证</h5><p>Portal认证的基本过程是：客户机首先通过DHCP协议获取到IP地址（也可以使用静态IP地址），但是客户使用获取到的IP地址并不能登上Internet，在认证通过前只能访问特定的IP地址，这个地址通常是PORTAL服务器的IP地址。采用Portal认证的接入设备必须具备这个能力。一般通过修改接入设备的访问控制表（ACL）可以做到。</p>
<p>用户登录到Portal Server后，可以浏览上面的内容，比如广告、新闻等免费信息，同时用户还可以在网页上输入用户名和密码，它们会被WEB客户端应用程序传给 Portal Server，再由Portal Server与NAS之间交互来实现用户的认证。</p>
<h5 id="802-1x"><a href="#802-1x" class="headerlink" title="802.1x"></a>802.1x</h5><p>802.1x协议为二层协议，不需要到达三层，而且接入层交换机无需支持802.1q的VLAN，对设备的整体性能要求不高，可以有效降低建网成本。</p>
<p>IEEE802.1x是IEEE（美国电气电子工程师学会）802委员会制定的应用于<strong>LAN交换机和无线LAN接入点</strong>的用户认证技术。</p>
<h5 id="PPPOE"><a href="#PPPOE" class="headerlink" title="PPPOE"></a>PPPOE</h5><p>以太网上点对点协议（PPP over Ethernet）</p>
<h5 id="MAC认证"><a href="#MAC认证" class="headerlink" title="MAC认证"></a>MAC认证</h5><p>以终端MAC地址作为身份认证的凭据，进行系统认证。适用于<strong>哑终端认证和免认证场景</strong>。</p>
<blockquote>
<p>计算机科学中，哑终端表示一个相对于其他种类比较“聪明”的计算机终端来说，功能较为有限的计算机终端。打印机</p>
</blockquote>
<p>MAC旁路认证：适用于802.1x中无法启用802.1x的哑终端。将MAC地址作为用户和密码来接入网络。</p>
<p>MAC认证的用户名格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.MAC地址：将用户的MAC地址作为用户名，同时使用MAC地址或自定义的字符串作为PASSWORD</span><br><span class="line"></span><br><span class="line">2.固定用户名形式：不论用户的MAC何值，所有用户均使用接入控制设备上指定的一个固定用户名和密码来替代MAC地址作为身份信息认证。</span><br><span class="line"></span><br><span class="line">3.DHCP：获取用户的DHCP选项字段以及一个固定密码来代替MAC地址作为认证信息。</span><br></pre></td></tr></table></figure>

<h3 id="数字签名和证书"><a href="#数字签名和证书" class="headerlink" title="数字签名和证书"></a>数字签名和证书</h3><blockquote>
<p>数字签名好比现实中你的签字</p>
<p>数字证书好比现实中你的身份证 </p>
</blockquote>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名的作用就是确认发送者身份和消息完整</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230516172652011.png" alt="image-20230516172652011"></p>
<h4 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h4><p>数字证书确认发送者身份</p>
<blockquote>
<p>场景：A 声明自己是某银行办事员向客户索要账户和密码，客户验证了 A 的签名，确认索要密码的信息是 A 发过来的，那么客户就愿意告诉A用户名和密码么？<br>显然不会。因为客户仅仅证明信息确实是 A 发过来的没有经过篡改的信息，但不能确认 A 就是银行职员、做的事情是否合法。这时需要有一个权威中间部门M（如政府、银监会等），该部门向 A 颁发了一份证书，确认其银行职员身份。这份证书里有这个权威机构 M 的数字签名，以保证这份证书确实是 M 所发。<br>数字证书采用公钥体制进行加密和解密。每个用户有一个私钥来解密和签名：同时每个用户还有一个公钥来加密和验证。</p>
</blockquote>
<ul>
<li>注册机构RA:/负责受理用户申请证书，对申请人的合法性进行认证，并决定是批准或拒绝证书申请。<strong>注册机构并不给用户签发证书而只是对用户 进行资格审查。</strong></li>
<li>证书颁发机构CA:负责给用户颁发、管理和撤销证书。<strong>较小的机构，可以由CA兼任RA的工作</strong></li>
</ul>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230516181412560.png" alt="image-20230516181412560"></p>
<h2 id="VPN虚拟专用网"><a href="#VPN虚拟专用网" class="headerlink" title="VPN虚拟专用网"></a>VPN虚拟专用网</h2><p>虚拟专用网络（Virtual Private Network，VPN）是在公用网络上建立专用网络的技术。由于整个 VPN 网络中的任意两个节点之间的连接并没有传统专网所需的端到端的物理链路，而是架构在公用网络服务商ISP所提供的网络平台，所以称之为虚拟网。</p>
<p>实现VPN 的关键技术主要有以下几种。</p>
<ul>
<li><p>隧道技术（Tunneling）实现 VPN 的最关键部分是在公网上建立虚信道，而建立虚信道是利用隧道技术实现的，IP 隧道的建立可以在链路层和网络层。</p>
<p>VPN主要隧道协议有PPTP、L2TP、IPsec、SSL VPN、TLS VPN.</p>
</li>
<li><p>加解密技术（Encryption&amp;Decryption）。VPN可以利用已有的加解密技术实现保密通信，保证公司业务和个人通信的安全。</p>
</li>
<li><p>密钥管理技术（Key Management），建立隧道和保密通信都需要密钥管理技术的支撑，密钥管理负责密钥的生成、分发、控制和跟踪，以及验证密钥的真实性等。</p>
</li>
<li><p>身份认证技术（Authentication），加入VPN的用户都要通过身份认证，通常使用用户名和密码，或者智能卡来实现用户的身份认证。</p>
</li>
</ul>
<h3 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h3><p>企业对网络安全性的需求日益提升，而传统的TCP/IP协议缺乏有效的安全认证和保密机制。IPSec（Internet Protocol Security）作为一种开放标准的安全框架结构，可以<strong>用来保证IP数据报文在网络上传输的机密性、完整性和防重放。</strong></p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><img src="img/计算机/计算机网络/image-20230524104858373.png" alt="image-20230524104858373" style="zoom:67%;" />

<ul>
<li><strong>AH：数据完整性</strong></li>
<li><strong>ESP：数据加密</strong>，ip端口50<ul>
<li>3des</li>
<li>aes-128</li>
<li>aes-192</li>
<li>aes-256</li>
<li>des</li>
<li>sml</li>
</ul>
</li>
<li><strong>IKE：密钥</strong>，端口是udp的500</li>
</ul>
<h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><p>隧道模式 ：隧道模式是对整个IP数据包提供安全传输机制。是在一个IP数据报的后面和前面都添加一些控制字段，构成IPsec数据报</p>
<p><strong>在隧道模式下，IPSec会另外生成一个新的IP报头，并封装在AH或ESP之前</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/image-20230524105902121.png" alt="image-20230524105902121"></p>
<p>传输模式：在传输模式下，IPsec包头增加在原IP包头和数据之间，在整个传输层报文段的后面和签名添加一些控制字段，构成IPsec数据报。这种方式是把整个传输层报文段都保护起来。因此<strong>只能保证原IP包数据部分的安全性</strong></p>
<p><strong>在传输模式下，AH或ESP报头位于IP报头和传输层报头之间。</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8/image-20230524110117521.png" alt="image-20230524110117521"></p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>企业分支可以通过IPSec VPN接入到企业总部网络。</li>
</ul>
<h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><p>SSL VPN是<strong>基于应用层</strong>的VPN技术。</p>
<p><strong>SSL认证过程</strong></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wps585.jpg" alt="img"></p>
<p>安全套接字协议SSL（Secure Socket Layer）工作在应用层和传输层之间，提供身份认证和保密通信功能。SSL所包含的协议有SSL握手协议、SSL修改密文协议、SSL警告协议和SSL记录协议。</p>
<ul>
<li>SSL握手协议负责身份认证和密钥生成。</li>
<li>SSL记录协议负责接收应用层报文，并将数据划分成可管理的块（214个字节），选择性地压缩数据，应用报文认证码（MAC）对数据进行加密，并增加首部，通过TCP报文段传输数据；接收者将数据进行解密、验证、解压，重装配成应用报文，然后交付更高级的用户。</li>
</ul>
<p>在客户端与服务器间传输的数据是通过使用对称算法（如 DES 或 RC4）进行加密的。公用密钥算法（通常为 RSA）是用来获得加密密钥交换和数字签名的，此算法使用服务器的SSL数字证书中的公用密钥。有了服务器的SSL数字证书，客户端也可以验证服务器的身份。SSL 协议的版本 1 和 2 只提供服务器认证。版本 3 添加了客户端认证，此认证同时需要客户端和服务器的数字证书。</p>
<p><strong>SSL安全连接建立在TCP443端口，统一资源定位器使用HTTPS://开头。</strong></p>
<h3 id="SSL和IPSec"><a href="#SSL和IPSec" class="headerlink" title="SSL和IPSec"></a>SSL和IPSec</h3><p>IPSec适用于<strong>网对网</strong>的VPN连接（Site-Site），广泛应用于VPN路由器部署中。IPSecVPN用户通常需要有相应的客户端软件。</p>
<p>SSL比较适用于<strong>移动用户的远程接入</strong>（Client-Site），广泛应用于网络安全交易和远程控制。SSLVPN通常无需安装客户端，浏览器即可。</p>
<h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><p>随着Internet的广泛应用，人们在扩展了获取和发布信息能力的同时也带来了信息被污染和破坏的危险。这些安全问题主要是由网络的开放性、无边界性和自由性等因素造成的。<br>（1）计算机操作系统本身有一些缺陷。</p>
<p>（2）各种服务，如Telnet、NFS、DNS和Active X等存在安全漏洞。</p>
<p>（3）TCP/IP 协议几乎没有考虑安全因素。</p>
<p>（4）追查黑客的攻击很困难，因为攻击可能来自 Internet 上的任何地方。<strong>对于一组相互信任的主机，其安全程度是由最弱的一台主机</strong></p>
<p><strong>所决定的</strong>，一旦被攻破，就会殃及其他主机。出于对以上问题的考虑，应该把被保护的网络与开放的、无边界的、不可信任的网络</p>
<p>隔离起来，使其成为可管理、可控制、安全的内部可信任网络。要做到这一点，最基本的隔离手段就是使用防火墙。</p>
<p>“防火墙”一词来自建筑物中的同名设施，从字面意思上说，它用于防止火灾从建筑物的一部分蔓延到其他部分。Internet防火墙也要起到</p>
<p>同样的作用，<strong>防止 Internet上的不安全因素蔓延到企业或组织的内部网</strong>。</p>
<p>从狭义上说，防火墙是指安装了防火墙软件的主机或路由器系统；从广义上说，防火墙还包括整个网络的安全策略和安全行为。</p>
<p>AT&amp;T的两位工程师William Cheswich和Steven Bellovin给出了防火墙的明确定义。</p>
<p>（1）所有的从外部到内部或从内部到外部的通信都必须经过它。</p>
<p>（2）只有内部访问策略授权的通信才能被允许通过。</p>
<p>（3）系统本身具有很强的可靠性。</p>
<p>总而言之，防火墙是一种网络安全防护手段，<strong>其主要目标就是通过控制进/出一个网络的权限，并对所有经过的数据包都进行检查，防止内网络受到外界因素的干扰和破坏</strong>。在逻辑上，防火墙是一个分离器，一个限制器，也是一个分析器，能有效地监视内部网络和</p>
<p>Internet之间的任何活动，保证内部网络的安全；在物理实现上，防火墙是位于网络特殊位置的一组硬件设备——路由器、计算机或其</p>
<p>他特别配置的硬件设备。防火墙可以是一个独立的系统，也可以在一个经过特别配置的路由器上实现防火墙。</p>
<h3 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h3><ul>
<li>交换模式 (二层模式)</li>
</ul>
<p>交换模式的防火墙其实等于从数据链路层开始解析的基于包过滤原理 / 状态机制的网络级防火墙；如果防护墙支持路由模式，则即等于带有加强的过滤规则和状态机制的路由器。</p>
<ul>
<li>路由模式 (三层模式）</li>
</ul>
<p>当防火墙位于内部网络和外部网络之间时，需要将<strong>防火墙与内部网络、外部网络以及 DMZ 三个区域</strong>相连的接口分别配置成不同网段的 IP 地址，重新规划原有的网络拓扑，此时相当于一台路由器。</p>
<ul>
<li>混合模式</li>
</ul>
<p>如果防火墙既存在工作在路由模式的接口（接口具有 IP 地址），又存在工作在透明模式的接口（接口无 IP 地址），则防火墙工作在混合模式下。混合模式主要用于透明模式作双机备份的情况，此时启动 VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）功能的接口需要配置 IP 地址，其它接口不配置 IP 地址。</p>
<h2 id="背-3"><a href="#背-3" class="headerlink" title="背"></a>背</h2><p>X.509数字证书标准推荐使用的密码算法是(43)，而国密SM2数字证书采用的公钥密码算法是(44)RSA，ECC</p>
<p>报文摘要算法生成报文摘要的目的是防止发送的报文被篡改</p>
<p><em>DHCP Snooping</em>是 DHCP 的一种安全特性，主要应用在 交换机 上，作用是<strong>屏蔽接入网络中的非法的 DHCP 服务器</strong>。即开启 <em>DHCP Snooping</em> 功能后，网络中的客户端只有从管理员指定的 DHCP 服务器获取 IP 地址。</p>
<p>IPSec是网络层安全协议，L2TP和PPTP是链路层安全协议，TLS是传输层安全协议。</p>
<p>下图所示为一种数字签名方案，网上传递的报文是  (1)  ，防止A抵赖的证据是  (2)  。$E_B(D_A(P))$,$D_A(P)$</p>
<p><img src="http://pic.cnitpm.com/upload/image/20131130/20131130183644_1093.png" alt="img"></p>
<p>题图中所示为一种利用公钥加密算法实现的数字签名方案，发送方A要发送给接收方B的报文P经过A的私钥签名和B的公钥加密后形成报文$E_B(D_A(P))$发送给B，B利用自己的私钥$D_B$和A的公钥$E_A$对消息$E_B(D_A(P))$进行解密和认证后得到报文P，并且保存经过A签名的消息$D_A(P)$作为防止A抵赖的证据。</p>
<p>无线局域网通常采用的加密方式是<strong>WPA2</strong>，其安全加密算法是（）。<strong>AES和TKIP</strong></p>
<h1 id="网络规划"><a href="#网络规划" class="headerlink" title="网络规划"></a>网络规划</h1><h2 id="综合布线系统"><a href="#综合布线系统" class="headerlink" title="综合布线系统"></a>综合布线系统</h2><ul>
<li>综合布线系统就是为了顺应发展需求而特别设计的一套布线系统</li>
<li>对于现代化的大楼来说，就如体内的神经，它采用了一系列高质量的标准材料</li>
<li>以模块化的组合方式，把语音、数据、图像和部分控制信号系统用统一的传输媒介进行综合</li>
<li>经过统一的规划设计，综合在一套标准的布线系统中，将现代建筑的三大子系统有机地连接起来，为现代建筑的系统集成提供了物理介质</li>
<li>可以说，结构化布线系统的成功与否直接关系到现代化的大楼的成败，选择一套高品质的综合布线系统是至关重要的</li>
</ul>
<img src="https://img-blog.csdnimg.cn/718cef935f224e6389b5cd06b19a5e81.jpeg#pic_center" alt="在这里插入图片描述" style="zoom: 80%;" />



<p>综合布线系统采用的是<strong>星型结构，主要由6个子系统</strong>构成，而</p>
<p>这6个子系统每一个都可以独立的、不受其他影响的进入到PDS（综合布线系统）终端中，这6个子系统分别是</p>
<ul>
<li><p><strong>工作区子系统</strong></p>
<p>工作区子系统由<strong>终端设备连接到信息插座之间的设备组成</strong>。包括：信息插座、插座盒、连接跳线和适配器组成。</p>
<p>水平区子系统应由工作区用的信息插座，楼层分配线设备至信息插座的水平电缆、楼层配线设备和跳线等组成。水平子系统根据整个综合布线系统的要求，应在二级交接间、交接间或设备间的配线设备上进行连接，以构成电话、数据、电视系统和监视系统，并方便地进行管理。</p>
</li>
<li><p><strong>水平布线子系统</strong></p>
<p>本系统主要负责将管理子系统配线架的电缆从干线子系统延伸至信息插座位置，一般来说这些系统都处在同一楼层</p>
</li>
<li><p><strong>管理子系统</strong><br>管理子系统设置在<strong>一层楼</strong>分配线设备的房间内。管理间子系统应由交接间的配线设备，输入/输出设备等组成，也可应用于设备间子系统中。管理子系统应采用单点管理双交接。</p>
</li>
<li><p><strong>垂直干线子系统</strong></p>
<p>是综合布线系统的中心系统，主要负责<strong>连接楼层</strong>配线架系统与主配线架系统</p>
</li>
<li><p><strong>设备间子系统</strong><br>设备间是在<strong>每一幢大楼</strong>的适当地点设置进线设备，进行网络管理以及管理人员值班的场所。设备间子系统应由综合布线系统的建筑物进线设备、电话、数据、计算机等各种主机设备及其保安配线设备等组成。</p>
</li>
<li><p><strong>建筑群子系统</strong></p>
<p>建筑群子系统将一栋建筑的线缆延伸到<strong>建筑群</strong>内的其它建筑的通信设备和设施。它包括铜线、光纤、以及防止其它建筑的电缆的浪涌电压进入本建筑的保护设备。</p>
</li>
</ul>
<h2 id="网络分层设计模型"><a href="#网络分层设计模型" class="headerlink" title="网络分层设计模型"></a>网络分层设计模型</h2><p><strong>核心层</strong>：核心层是网络主干部分，是整个网络性能的保障，其设备包括路由器、防火墙、核心层交换机等等，相当于公司架构里的管理高层。<strong>核心层的主要功能是实现骨干网络之间的优化传输，负责整个网络的连通和快速交换</strong>。骨干层设计任务的重点通常是冗余能力、可靠性和高速传输。核心层一直被认为是所有流量的最终承受者和汇聚者。</p>
<p><strong>汇聚层：</strong>汇聚层是网络接入层和核心层的”中介”，就是在工作站接入核心层前先做汇聚，以减轻核心层设备的负荷。汇聚层具有实施策略、安全、工作组接入、虚拟局域网（VLAN）之间的路由、源地址或目的地址之间的过滤等功能。</p>
<p><strong>接入层：</strong>通常将网络中直接面向用户连接或访问网络的部分称为接入层，也就相当于公司架构里的基层员工，因此接入层交换机具有低成本和高端口密度特性。接入层通过光纤、双绞线、同轴电缆、无线接入技术等传输媒介，实现与用户的对接，并进行业务和带宽的分配。</p>
<p><img src="https://img-blog.csdnimg.cn/20210819143727211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE0OTc5Nw==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在网络的分层设计模型中，对核心层工作规程的建议是（69） 。<strong>尽量避免使用访问控制列表以减少转发延迟</strong> </p>
<p>EIA/TIA-568标准规定，在综合布线时，如果信息插座到网卡之间使用无屏蔽双绞线，布线距离最大为 （ ） 米。10米</p>
<p>HFC网络中，从运营商到小区采用的接入介质为（ ），小区入户采用的接入介质为（ ）。</p>
<p>光纤，同轴电缆</p>
<p>通过HFC网络实现宽带接入，用户端需要的设备是（1），局端用于控制和管理用户的设备是（2） 。</p>
<ul>
<li>cable modem</li>
<li>cmts</li>
</ul>
<p>电缆调制解调器（Cable Modem，CM）是基于HFC网络的宽带接入技术。用于调制解调以及作为以太网接口 。CM是用户设备与同轴电缆网络的接口。在下行方向，它接收前端设备CMTS（Cable Modem Termination System）发送来的QAM信号，经解调后传送给PC的以太网接口。在上行方向，CM把PC发送的以太帧封装在时隙中，经Q调制后，通过上行数据通路传送给CMTS。</p>
<p>三层交换机包括二层交换机和三层交换机转发，<strong>均由硬件实现</strong>；通常三层交换机用在单位内部，路由器放置在出口；三层交换机除了存储转发外，还可以采用直通交换技术。</p>
<h2 id="网络常见部署模式"><a href="#网络常见部署模式" class="headerlink" title="网络常见部署模式"></a>网络常见部署模式</h2><p>网络有四种常见的部署模式：单臂模式部署、路由模式部署、网桥模式部署、旁路模式部署</p>
<p><img src="https://pic3.zhimg.com/80/v2-56dcf82c65a65d2fe90ad0b206b585a6_1440w.webp" alt="img"></p>
<h1 id="无线"><a href="#无线" class="headerlink" title="无线"></a>无线</h1><p>1、AP：</p>
<p>无线AP即<a href="https://zhidao.baidu.com/search?word=%EF%BF%BD%EF%BF%BD%EF%BF%BD%DF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&fr=iknow_pc_qb_highlight">无线接入点</a>，它用于<a href="https://zhidao.baidu.com/search?word=%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD%EF%BF%BD&fr=iknow_pc_qb_highlight">无线网络</a>的无线交换机，也是无线网络的核心，简单的说就是功能增强版无线路由器</p>
<p>2、AC：</p>
<p>AC是用来管理AP用的，可以对AP进行集中式管理</p>
<p>3、WIFI：</p>
<p>Wi-Fi是一种可以将个人电脑、手持设备等终端以无线方式互相连接的技术。Wi-Fi是一个无线网路通信技术的品牌，由Wi-Fi联盟所持有。</p>
<p>4、WLAN：</p>
<p>WLAN是Wireless Local Area Network的简称，指应用无线通信技术将计算机设备互联起来，构成可以互相通信和实现资源共享的网络体系。</p>
<h2 id="无线通信网"><a href="#无线通信网" class="headerlink" title="无线通信网"></a>无线通信网</h2><p>无线网主要使用 3 种通信技术：红外线、扩展频谱和窄带微波技术。<br>红外通信</p>
<ul>
<li>红外线（Infrared Ray，<strong>IR</strong>）通信技术可以用来建立 WLAN，IR 通信分为 3 种技术：<ul>
<li>①定向红外光来：用于点对点链路，可以连接几座大楼中的网络，每幢大楼的路由器或网桥在视距范围内通过IR收发器互相连接。</li>
<li>② 全方向广播红外线：基站置于天花板上，基站上的发射器向各个方向广播信号，所有终端的IR收发器都用定位光束瞄准天花板上的基站，可以接收基站发出的信号，或向基站发送信号。</li>
<li>③ 浸反射红外线：在这种配置中，所有的发射器都集中瞄准天花板上的一点。红外线射到天花板上后被全方位地漫反射回来，并被房间内所有的接收器接收。</li>
</ul>
</li>
<li>扩展频谱通信<br>扩展频谱通信技术起源于军事通信网络，其主要想法是将信号散布到更宽的带宽上以减少发生阻塞和干扰的机会。早期的扩频方式是频率跳动扩展频谱（FHSS），更新的版本是直接序列扩展频谱（<strong>DSSS</strong>），这两种技术在IEEE 802.11定义的WLAN中都有应用。</li>
<li>窄带微波通信<br>窄带微波（Narrowband Microwave）是指使用微波无线电频带（RF）进行数据传输.<br>其带宽刚好能容纳传输信号。以前所有的窄带微波无线网产品都需要申请许可证，现在已经出现了ISM 频带内的窄带微波无线网产品</li>
</ul>
<h2 id="wlan数据转发方式"><a href="#wlan数据转发方式" class="headerlink" title="wlan数据转发方式"></a>wlan数据转发方式</h2><p><strong>数据转发方式</strong></p>
<p>WLAN网络中的数据包括控制报文（管理报文）和数据报文。</p>
<p>控制报文是通过CAPWAP的控制隧道转发的</p>
<p>用户的数据报文分为</p>
<ul>
<li>隧道转发（又称为“集中转发”）方式</li>
<li>直接转发（又称为“本地转发”）方式</li>
<li>Soft-GRE转发方式。</li>
</ul>
<p><strong>隧道转发方式</strong></p>
<p>隧道转发方式是指用户的数据报文到达AP后，需要经过<strong>CAPWAP</strong>数据隧道封装后发送给AC，然后由AC再转发到上层网络，如下图</p>
<p><img src="https://img-blog.csdnimg.cn/918f38f95fab457b92b63cbd760faa67.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a-M6LS15a2Z5oKf56m6,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p> <strong>直接转发方式</strong></p>
<p>直接转发方式是指用户的数据报文到达AP后，不经过CAPWAP的隧道封装而直接转发到上层网络，如下图</p>
<p><img src="https://img-blog.csdnimg.cn/71b623e65235495288178948e5b07b38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5a-M6LS15a2Z5oKf56m6,size_8,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p>直接转发方式的集中认证</p>
<p>如果采用直接转发方式，业务数据不经过AC转发。当无线用户接入网络需要进行用户接入认证（例如，802.1X认证等）且接入控制点部署在AC上时，用户的认证报文就无法通过AC集中管理，这就给管理员对用户的统一控制造成了不便。所以在直接转发方式下AC会将用户的<strong>认证报文</strong>通过CAPWAP隧道集中到AC转发，如图3。</p>
<p><img src="https://download.huawei.com/mdl/image/download?uuid=03ca07e497124b379faa4b3e0d1cefc2" alt="img"></p>
<p>隧道转发方式、直接转发方式优缺点：</p>
<table>
<thead>
<tr>
<th>数据转发方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>隧道转发</td>
<td>AC集中转发数据报文，<strong>安全性更高，方便集中管理和控制</strong>，新增设备部署配置方便，对现网改动小。</td>
<td>业务数据必须经过AC封装转发，报文转发效率比直接转发方式低，AC所受压力大。</td>
</tr>
<tr>
<td>直接转发</td>
<td>业务数据不需要经过AC封装转发，报文转发效率高，AC所受压力小。</td>
<td>业务数据不便于集中管理和控制，新增设备部署对现网改动大。</td>
</tr>
</tbody></table>
<h2 id="背-4"><a href="#背-4" class="headerlink" title="背"></a>背</h2><p>POE (Power Over Ethernet)指的是在现有的以太网Cat.5布线基础架构不作任何改动的情况下，在为一些基于IP的终端（如IP电话机、无线局域网接入点AP、网络摄像机等）传输数据信号的同时，还能为此类设备提供直流供电的技术。 <strong>POE也被称为基于局域网的供电系统。</strong></p>
<h1 id="组网技术"><a href="#组网技术" class="headerlink" title="组网技术"></a>组网技术</h1><p>组网技术是部署和配置网络设备</p>
<h2 id="优先级-1"><a href="#优先级-1" class="headerlink" title="优先级"></a>优先级</h2><p>优先级：直连 0、静态 60、rip 100、ospf 10/150</p>
<ul>
<li><strong>Router ID的选取顺序：</strong><ul>
<li><strong>手工配置最优先</strong></li>
<li>第二优先级：从loopback接口里，选择IP地址最大的</li>
<li>第三优先级：在物理接口中，选择IP地址最大的</li>
</ul>
</li>
</ul>
<h2 id="cisco"><a href="#cisco" class="headerlink" title="cisco"></a>cisco</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="常规"><a href="#常规" class="headerlink" title="常规"></a>常规</h4><p>退回到上一级模式（exit）；</p>
<p>直接退回到特权模式（end）；</p>
<p>帮助信息（如？、co？、copy？）</p>
<p>命令自动补齐（Tab）；</p>
<p>Reload重启。</p>
<h4 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h4><ul>
<li>用户模式 Swtich&gt;</li>
<li>特权模式 Swtich#    en<ul>
<li>show interface显示接口状态</li>
<li>show run查看当前生效的配置信息</li>
<li>show vlan</li>
<li>show ip rou</li>
<li>show ip nat translations </li>
<li>show spanning-tree查看生成树协议</li>
</ul>
</li>
</ul>
<ul>
<li>全局配置模式Swtich（config）#   conf t</li>
</ul>
<ul>
<li>修改交换机名称（hostname X）；</li>
<li>交换机线路视图模式 line console 0</li>
</ul>
<ul>
<li><p>交换机端口视图模式 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int f0/1 </span><br><span class="line">int range f0/1-5  //同时配置多个端口1-5 加个range即可</span><br></pre></td></tr></table></figure>

<ul>
<li>no sh  //打开端口</li>
<li>配置交换机端口参数（speed、duplex（双工模式：全双工，半双工））；</li>
<li>查看交换机版本信息（show  version）；</li>
<li><strong>将交换机端口分配到VLAN</strong> switchport access vlan &lt;1-4094&gt;</li>
<li><strong>配置Tag VLAN</strong> switchport mode trunk</li>
<li>ip address  IP subnetmask //给端口如VLAN1配置IP地址以及子网掩码</li>
</ul>
</li>
</ul>
<blockquote>
<p>no shutdown代表什么意思,为什么<strong>每次为端口分配ip后都需要这句话</strong>,是不是必须得?</p>
<p>No shutdown是开启端口的意思,路由器启机以后端口默认的状态是shutdown的,所以必须用no shutdown来开启端口。接口如果被shutdown了，即使接了网线，网络也是无法通行的</p>
</blockquote>
<h4 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h4><p>技术原理</p>
<p>交换机的管理方式基本分为两种：带内管理和带外管理。</p>
<ul>
<li><p>通过远程Telnet、拨号等方式属于带内管理。</p>
</li>
<li><p>通过交换机的Console端口管理交换机属于带外管理；这种管理方式不占用交换机的网络端口，<strong>第一次配置交换机必须利用Console端口进行配置</strong>。</p>
</li>
</ul>
<img src="img/计算机/计算机网络/image-20230222103603882.png" alt="image-20230222103603882" style="zoom:67%;" />

<blockquote>
<p>line vty 0 4 </p>
<p>line vty 0 4，该命令是允许用户远程登陆，即不用用户插Console线缆，只要设备连接网络，配置了接口IP地址即可远程使用Telnet、或者<a href="https://so.csdn.net/so/search?q=ssh&spm=1001.2101.3001.7020">ssh</a>的方式登陆到设备上，，CISCO设备一般支持16个并行的远程虚拟终端，按照编号就是：0 - 15.， Line vty 0 4 就是指同时允许5个虚拟终端登陆进行配置,需注意这里配置完成后一定要注意配置enable的密码，要不Telnet是上不去的</p>
</blockquote>
<ul>
<li>switch（config）#enable password 888 //设置进入特权模式进的密码；</li>
</ul>
<ul>
<li>Switch（config）#line console 0 //可以设置通过console端口连接设备及telnet远程登录时所需要的密码。</li>
<li>Switch（config-line）#password 777</li>
<li>Switch（config）#login  //允许登录</li>
<li>Switch（config）#line vty 04 ////设置最多可以有16终端接入,如果命令是line vty 0 4表示是最多允许5个接入</li>
<li>Switch（config-line）#password 123//设置远程（telnet）登录密码为123</li>
<li>Switch（config）#login</li>
</ul>
<h4 id="三层交换机和路由配置"><a href="#三层交换机和路由配置" class="headerlink" title="三层交换机和路由配置"></a>三层交换机和路由配置</h4><blockquote>
<p>交换机端口添加ip可作为管理，互联，网关使用（网关就是去往其它网段的时候需要网关来进行转发）。<strong>没配置ip的一般当作二层接入端口来使用,配置了就是三层交换机</strong></p>
</blockquote>
<p><strong>三层交换机开启路由功能W1(config)#ip routing</strong></p>
<blockquote>
<p>当Router2想要访问Router1后面的许多的网段的时候，不可能手动去添加静态路由，因为那样工作量太大，也容易配置错误，所以这个时候就只用在Router2上面添加一条简单的默认路由就可以了。</p>
</blockquote>
<ul>
<li><p>默认路由：是对IP数据包中的目的地址找不到存在的其他路由时，路由器所选择的路由（默认路由代表所有网段，不过同时它的优先级也是最低的。）</p>
<p>ip route 0.0.0.0 0.0.0.0 <strong>10.0.0.2</strong></p>
</li>
<li><p>静态路由：一种路由的方式，路由项（routing entry）由手动配置，而非动态决定</p>
<p>ip route 192.168.2.0(目标网段) 255.255.255.0 192.168.3.2（下一条地址）</p>
</li>
</ul>
<h3 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="交换机接口工作模式"><a href="#交换机接口工作模式" class="headerlink" title="交换机接口工作模式"></a>交换机接口工作模式</h5><ul>
<li><p><strong>access是指定接口连接的是主机</strong></p>
</li>
<li><p><strong>trunk是指定接口连接的是交换机，可以通过多个VLAN的数据。</strong></p>
</li>
</ul>
<p><a href="https://betheme.net/qianduan/39145.html?action=onClick">https://betheme.net/qianduan/39145.html?action=onClick</a></p>
<ul>
<li><p>TRUNK是端口汇聚的意思，通过配置软件的设置，将2个或多个物理端口组合在一起成为一条逻辑的路径从而增加在交换机和网络节点之间的带宽，将属于这几个端口的带宽合并，给端口提供一个几倍于独立端口的独享的高带宽。</p>
</li>
<li><p>Trunk是一种封装技术，它是一条点到点的链路袭，链路的两端可以都是交换机，也可以是交换机和路由器，还可以是主机和交换机或路由器。基于端口汇聚（Trunk）功能，允许交换机与交换机、交换机与路由器、主机与交换机或路由器之间通过两个或多个端口并行连接同时传输以提供更高带宽、更大吞吐量， 大幅提供整个网络能力。</p>
</li>
<li><p>核心技术：打标（给信息打上标签）</p>
<p>带有VLAN标签的以太网帧在交换机间传递<br>主机不管是发送还是接受的信息都是不带标签的。<br>标签只存在串口线路上。</p>
</li>
<li><p><strong>目的：通过一根网线，传递不同VLAN信息。</strong></p>
</li>
</ul>
<h4 id="交换机划分VLAN配置"><a href="#交换机划分VLAN配置" class="headerlink" title="交换机划分VLAN配置"></a>交换机划分VLAN配置</h4><p><strong>实验目标</strong><br>理解虚拟 LAN（VLAN）基本原理；掌握一般交換机按端口划分 VLAN 的配置方法；掌握Tag VLAN配置方法。</p>
<p><strong>实验背景</strong><br>某一公司内财务部、销售部的PC通过2台交换机实现通信；要求财务部和销售部内的PC可以互通，但为了数据安全起见，销售部和财务部需要进行互相隔离，现要在交换机上做适当配置来实现这一目的。</p>
<p><strong>技术原理</strong></p>
<p>VLAN是指在一个物理网段内，进行<strong>逻辑的划分</strong>，划分成若干个虚拟局域网。VLAN最大的特性是<strong>不受物理位置的限制</strong>，可以进行灵活的划分。VLAN具备了一个物理网段所具备的特性。相同VLAN内的主机可以相互直接通信，不同VLAN间的主机之间互相访问必须经由路由设备进行转发。广播数据包只可以在本VLAN内进行广播，不能传输到其他VLAN中。</p>
<ul>
<li><p>Port VLAN是实现VLAN的方式之一，它利用交换机的端口进行VLAN的划分，一个端口只能属于一个VLAN.</p>
</li>
<li><p>Tag VLAN是基干交换机端口的另外一种类型，主要用于使交换机的相同Vlan内的主机之间可以直接访问，同时对于不同Vlan的主机进行隔离。</p>
<p>Tag VLAN遵循IEEE802.1Q协议的标准。在使用配置了Tag VLAN的端口进行数据传输时，需要在数据帧内添加4个字节的802.1Q标签信息，用于标示该数据帧属于那个VLAN，便于对端交换机接收到数据帧后进行准确的过滤。</p>
</li>
</ul>
<h4 id="三层交换机实现不同vlan路由转发功能"><a href="#三层交换机实现不同vlan路由转发功能" class="headerlink" title="三层交换机实现不同vlan路由转发功能"></a>三层交换机实现不同vlan路由转发功能</h4><p>三层交换的工作原理可以用以下通信实现过程来描述：</p>
<p>①假设两个使用IP协议的站点A、B通过第三层交换机进行通信，发送站点A在开始发送时，把自己的IP地址与目的站点B的IP地址比较，判断B是否与自己在同一子网内。若目的站B与发送站A在同一子网内，则直接进行二层的转发。<br>②若两个站点不在同一子网内，发送站A则要向“默认网关”发出ARP（地址解析）封包，而“默认网关”的IP地址其实是三层交换机的三层交换模块。<br>③当发送站A对“默认网关”的IP地址广播出一个ARP请求时，若三层交换模块在以前的通信过程中已经知道B站的MAC地址，则向发送站A回复B的MAC地址；否则，三层交换模块根据路由信息向B站广播一个ARP请求。<br>④B站得到此ARP请求后向三层交换模块回复其MAC地址，由三层交换模块保存此地址并回复给发送站A；同时将B站的MAC地址发送到二层交换引擎的MAC地址表中。<br>⑤此后，A向B发送的数据帧便全部交给二层交换处理，信息得以高速交换。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20220616151120.png" alt="微信图片_20220616151120"></p>
<p>实验目标<br>掌握交換机Tag VLAN的配置；掌握三层交換机基本配置方法；掌握三层交換机VLAN路由的配置方法通过三层交换机实现VLAN间相互通信；</p>
<p>实验背景<br>某企业有两个主要部门，技术部和销售部，分处于不同的办公室，为了安全和便于管理对两个部门的主机进行了VLAN的划分，技术部和销售部分处于不同的VLAN。现由于业务的需求需要销售部和技术部的主机能够相互访问，获得相应的资源，两个部门的交换机通过一台三层交换机进行了连接。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230220171200809.png" alt="image-20230220171200809"></p>
<blockquote>
<p>二层交换以mac作为通信手段，三层交换路由，以IP作为通信手段</p>
</blockquote>
<p>pc:</p>
<ul>
<li>ip:192.168.1.2</li>
<li>网关：192.168.1.1</li>
</ul>
<p>二层：</p>
<ul>
<li>int f0/2 vlan 2<ul>
<li>switchport access vlan 2</li>
<li>no sh</li>
</ul>
</li>
<li>int int f0/3 vlan 3<ul>
<li>switchport access vlan 3</li>
<li>no sh</li>
</ul>
</li>
<li>int f0/1<ul>
<li>sw mode trunk</li>
</ul>
</li>
</ul>
<p>三层</p>
<ul>
<li><p>ip routing</p>
</li>
<li><p>int vlan 2</p>
<ul>
<li>no sh</li>
<li>ip address 192.168.1.1</li>
</ul>
</li>
<li><p>int vlan 3</p>
<ul>
<li>no sh</li>
<li>ip address 192.168.2.1</li>
</ul>
</li>
</ul>
<h3 id="快速生成树"><a href="#快速生成树" class="headerlink" title="快速生成树"></a>快速生成树</h3><p><strong>什么是环路问题</strong></p>
<p>就是两个交换机连接的网络形成了一个环，比如图中的情况：<br>电脑A发了一个<strong>广播</strong>的数据包，数据包从网络1出来的广播包从交换机A出去走了一圈，从交换机B走回来了，同时这个包也可以从交换机B走出去，然后又从交换机A走回来。</p>
<img src="https://img-blog.csdnimg.cn/cf828721c1b041ee818fc36ced7cd161.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5Y-q6KaB5L2g5LiA55u06LeR,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述" style="zoom:33%;" />

<p>从LAN1出来的广播包，从绿色的线走到交换机A，此时交换机A看MAC地址就知道了，电脑是在LAN1里面的<br>与此同时LAN1出来的广播包从红色的线走到了交换机B，交换机B看MAC地址也可以知道电脑是在LAN1里面的<br>数据包过了交换机A，在LAN2中广播，沿着绿色的线继续走，走到了交换机B，交换机B看了MAC地址，发现这个MAC地址从别的网络过来了，就以为电脑换位置了，于是更新自己的转发表，电脑在LAN2<br>同样的，交换机A收到了从交换机B过来的数据包，也会以为电脑换位置了，电脑换成LAN2了</p>
<p>这会带来两个问题：</p>
<ol>
<li>给交换机的学习带来困难，甚至无法学习到准确的结果</li>
<li>交换机无法学习导致，或者学习结果不准确会导致这个包要一直在网络上广播，太多包在广播了就会导致性能问题。</li>
</ol>
<p><strong>实验目标</strong></p>
<p>理解生成树协议工作原理；掌握快速生成树协议RSTP基本配置方法；</p>
<p>实验背景<br>学校为了开展计算机教学和网络办公，建立了一个计算机教室和一个校办公区，这两处的计算机网络通过两台交换机互连组成内部校园网，为了提高网络的可靠性，作为网络管理员，你要用2条链路将交换机互连，现要求在交换机上做适当配置，使网络避免环路。</p>
<p><strong>技术原理</strong></p>
<p>生成树协议（spanning-tree），作用是在交换网络中提供冗余各份链路，并且解决交换网络中的环路问题；</p>
<p>生成树协议是利用SPA算法，<strong>在存在交换环路的网络中生成一个没有环路的树形网络。</strong>运用该算法将交换网络的冗余备份链路从<strong>逻辑</strong>上断开，<strong>当主链路出现故障时，能够自动的切换到备份链路</strong>，保证数据的正常转发；</p>
<p>生成树协议版本：<strong>STP、RSTP（快速生成树）、MSTP（多生成树协议）</strong></p>
<ul>
<li>生成树协议的特点，收敛时间长。从主要链路出现故障到切换至备份链路需要50秒的时间。</li>
</ul>
<ul>
<li>快速生成树在生成树协议的基础上增加了两种端口角色：替换端口和备份端口，分别做为根端口和指定端口的冗余端口。<strong>当根端口或指定端口出现故障时，冗余端口不需要经过50秒的收敛时间，可以直接切换到替换端口或备份端口</strong>，从而实现RSTP协议小于1秒的快速收敛。</li>
</ul>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230222095532285.png" alt="image-20230222095532285"></p>
<p>Switch#show spanning-tree </p>
<p>s1</p>
<ul>
<li><p>0/1和0/2 trunk</p>
</li>
<li><p>Switch(config)#:spanning-tree mode rapid-pvst</p>
</li>
</ul>
<p>s2</p>
<ul>
<li>0/1和0/2 trunk</li>
<li>Switch(config)#:spanning-tree mode rapid-pvst</li>
</ul>
<p>测试</p>
<ul>
<li>关闭f0/1，f0/2启动</li>
</ul>
<h3 id="路由器-1"><a href="#路由器-1" class="headerlink" title="路由器"></a>路由器</h3><h4 id="单臂路由配置"><a href="#单臂路由配置" class="headerlink" title="单臂路由配置"></a>单臂路由配置</h4><p>实验目标<br>掌握单臂路由配置方法；通过单臂路由实现不同VLAN间互相通信；</p>
<p>实验背景<br>某企业有两个主要部门，技术部和销售部，分处于不同的办公室，为了安全和便于管理对两个部门的主机进行了VLAN的划分，技术部和销售部分处于不同的VLAN。现由于业务的需求需要销售部和技术部的主机能够相互访问，获得相应的资源，两个部门的交换机通过一台路由器进行了连接。</p>
<p>技术原理<br>单臂路由：是为实现VLAN间通信的三层网络设备路由器，它只需要一个以太接口，通过创建子接口可以承担所有VLAN的网关，而在不同的VLAN间转发数据。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230223095212436.png" alt="image-20230223095212436"></p>
<p>交换机</p>
<ul>
<li>0/1，mode trunck</li>
<li>0/2,vlan 2</li>
<li>0/3,vlan 3</li>
</ul>
<p>子接口</p>
<ul>
<li><p>0/0 no shut</p>
</li>
<li><p>int f0/0.1 //进入路由器0模块第0端口第1子接口</p>
<p>encapsulation dot1Q 2 //绑定vlan中继协议,封装协议设置为dot1q允许通过的vlan为2</p>
<p>ip address 192.168.1.1 255.255.255.0</p>
</li>
<li><p>int f0/0.2</p>
<p>encapsulation dot1Q 3 //封装协议设置为dot1q允许通过的vlan为2</p>
<p>ip address 192.168.2.1 255.255.255.0</p>
</li>
</ul>
<h4 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h4><p>实验目标<br>掌握静态路由的配置方法和技巧；掌握通过静态路由方式实现网络的连通性；<strong>熟悉广域网线缆的连接方式；</strong></p>
<p>实验背景<br>学校有新旧两个校区，每个校区是一个独立的局域网，为了使新旧校区能够正常相互通讯，共享资源。每个校区出口利用一台路由器进行连接，两台路由器间学校申请了一条2M的DDN专线进行相连，要求你做适当配置实现两个校区间的正常相互访问。</p>
<p>技术原理<br>路由器属于网路层设备，能够根据IP包头的信息，选择一条最佳路径，将数据包转发出去。实现<strong>不同网段的主机之间的互相访问</strong>。路由器是根据路由表进行选路和转发的。而路由表里就是由一条条路由信息组成。<br><strong>生成路由表主要有两种方法：手工配置和动态配置，即静态路由协议配置和动态路由协议配置。</strong><br>静态路由是指由网络管理员手工配置的路由信息。<br>静态路由除了具有简单、高效、可靠的优点外，它的另一个好处是网络安全保密性高。<br><strong>缺省路由</strong>可以看作是静态路由的一种特殊情况。当数据在查找路由表时，没有找到和目标相匹配的路由表项时，为数据指定的路由。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230227154903322.png" alt="image-20230227154903322"></p>
<p>r1</p>
<ul>
<li><p>int f1/0</p>
<ul>
<li>no shutdown</li>
<li>ip address 192.168.1.1 255.255.255.0</li>
</ul>
</li>
<li><p>int serial 2/0</p>
<ul>
<li>ip address 192.168.3.1 255.255.255.0</li>
<li>clock rate 64000</li>
<li>no shutdown</li>
</ul>
</li>
<li><p>ip route 192.168.2.0 255.255.255.0 192.168.3.2 （匹配192.168.2.0网段的下一条地址192.168.3.2）</p>
</li>
</ul>
<ul>
<li><p>show ip route</p>
<blockquote>
<p>C    192.168.1.0/24 is directly connected, FastEthernet1/0</p>
<p>S    192.168.2.0/24 [1/0] via 192.168.3.2</p>
<p>C    192.168.3.0/24 is directly connected, Serial2/0</p>
</blockquote>
</li>
</ul>
<p>r2</p>
<ul>
<li><p>int s 2/0</p>
<ul>
<li>ip address 192.168.3.2 255.255.255.0</li>
</ul>
</li>
<li><p>int f1/0</p>
<ul>
<li>ip address 192.168.2.1 255.255.255.0</li>
</ul>
</li>
<li><p>ip route 192.168.1.0 255.255.255.0 192.168.3.1</p>
</li>
<li><p>show ip route</p>
<blockquote>
<p>S    192.168.1.0/24 [1/0] via 192.168.3.1</p>
<p>C    192.168.2.0/24 is directly connected, FastEthernet1/0</p>
<p>C    192.168.3.0/24 is directly connected, Serial2/0</p>
</blockquote>
</li>
</ul>
<h4 id="rip动态路由配置"><a href="#rip动态路由配置" class="headerlink" title="rip动态路由配置"></a>rip动态路由配置</h4><p>实验目标<br>掌握RIP协议的配置方法；掌握查看通过动态路由协议RIP学习产生的路由；熟悉<strong>广域网</strong>线缆的连接方式；</p>
<p>实验背景<br>假设校园网通过一台三层交换机连到校园网出口路由器上，路由器再和校园外的另一台路由器连接。现要做适当配置，实现校园网内部主机与校园网外部主机之间的相互通信。为了简化网管的管理维护工作，学校决定采用RIP V2协议实现互通。</p>
<p>技术原理<br>RIP（Routing Information Protocols，路由信息协议）是应用较早、使用较普通的IGP内部网关协议，适用用于小型同类网络，是距离矢量协议；RIP协议跳数做为衡量路径开销的，RIP协议里规定最大跳数为15<br>RIP协议有两个版本：RIPv1和RIPv2，</p>
<p>RIPv1属于有类路由协议，不支持VLSM，以<strong>广播</strong>形式进行路由信息的更新，<strong>更新周期为30秒</strong>；</p>
<p>RIPv2属于无类路由协议，支持VLSM，以<strong>组播</strong>形式进行路由更新。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230301232659899.png" alt="image-20230301232659899"></p>
<p>router rip 激活rip协议</p>
<ul>
<li><p>version 2 启用rip版本2</p>
</li>
<li><p>network 邻近网络段</p>
</li>
</ul>
<p>交换机</p>
<ul>
<li>f0/10 vlan10 192.168.1.1</li>
<li>f0/20 vlan20 192.168.3.1</li>
<li>router rip 启动RIP路由协议<ul>
<li>network 192.168.1.0 设置发布路由</li>
<li>network 192.168.3.0</li>
<li>version 2</li>
</ul>
</li>
</ul>
<p>r1</p>
<ul>
<li>f0/0 192.168.3.2</li>
<li>s2/0 192.168.4.1</li>
<li>router rip<ul>
<li>network 192.168.3.0</li>
<li>network 192.168.4.0</li>
<li>version 2</li>
<li>clock rate 64000(dce线缆需要配置时钟)</li>
</ul>
</li>
</ul>
<p>r2</p>
<ul>
<li>f0/0 192.168.2.1</li>
<li>s2/0 192.168.4.2</li>
<li>router rip<ul>
<li>version 2</li>
<li>network 192.168.2.0</li>
<li>network 192.168.4.0</li>
</ul>
</li>
</ul>
<h4 id="OSPF动态路由配置"><a href="#OSPF动态路由配置" class="headerlink" title="OSPF动态路由配置"></a>OSPF动态路由配置</h4><ul>
<li><p>实验目标</p>
<p>掌握OSPF协议的配置方法；掌握查看通过动态路由协议OSPF学习产生的路由；熟悉广域网线缆的连接方式；</p>
</li>
<li><p>实验背景</p>
<p>假设某公司通过一台三层交换机连到公司出口路由器上，路由器再和公司外的另一台路由器连接。现要做适当配置，实现公司内部主机与公司外部主机之间的相互通信。为了简化网管的管理维护工作，公司决定采用OSPF协议实现互通。</p>
</li>
<li><p>技术原理</p>
<p>OSPF开放式最短路径优先协议，是目前网络中应用最广泛的路由协议之一。属于内部网关路由协议，能够适应各种规模的网络环境，是典型的链路状态协议。OSPF路由协议通过向全网扩散本设备的链路状态信息，<strong>使网络中每台设备最终同步一个具有全网链路状态的数据库，然后路由器采用SPF算法，以自己为根，计算到达其他网络的最短路径，最终形成全网络路由信息。</strong></p>
</li>
</ul>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230320112402010.png" alt="image-20230320112402010"></p>
<p>交换机</p>
<ul>
<li><p>vlan 10</p>
<ul>
<li>int f0/10 </li>
<li>switchport vlan 10</li>
<li>ip address  192.168.1.1</li>
</ul>
</li>
<li><p>vlan 20</p>
<ul>
<li>int f0/20</li>
<li>ip address 192.168.3.1</li>
<li>switchport vlan 20</li>
</ul>
</li>
<li><p>router ospf 1</p>
<ul>
<li>network 192.168.1.0 0.0.0.255 area 0</li>
<li>network 192.168.3.0 0.0.0.255 area 0</li>
</ul>
</li>
</ul>
<p>路由器1</p>
<ul>
<li><p>int f0/0</p>
<ul>
<li>ip address 192.168.3.2 255.255.255.0</li>
</ul>
</li>
<li><p>int serial 2/0</p>
<ul>
<li>no shutdown </li>
<li>clock rate 64000</li>
<li>ip address 192.168.4.1 255.255.255.0</li>
</ul>
</li>
<li><p>router ospf 1</p>
<ul>
<li>network 192.168.3.0  0.0.0.255  area 0</li>
<li>network 192.168.4.0  0.0.0.255  area 0</li>
</ul>
</li>
</ul>
<p>路由器2</p>
<ul>
<li><p>int f0/0</p>
<ul>
<li>ip address 192.168.2.1 255.255.255.0</li>
</ul>
</li>
<li><p>int serial 2/0</p>
<ul>
<li>no shutdown </li>
<li>clock rate 64000</li>
<li>ip address 192.168.4.2 255.255.255.0</li>
</ul>
</li>
<li><p>router ospf 1</p>
<ul>
<li>network 192.168.2.0  0.0.0.255  area 0</li>
<li>network 192.168.4.0  0.0.0.255  area 0</li>
</ul>
</li>
</ul>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>NAT分为两种类型：</p>
<ul>
<li><p>NAT（网络地址转换）</p>
<ul>
<li>静态NAT：实现内部地址与外部地址一对一的映射。现实中，一般都用于服务器；</li>
<li>动态NAT：定义一个地址池，自动映射，也是一对一的。现实中，用得比较少；</li>
</ul>
</li>
<li><p>NAPT（<strong>网络端口</strong>地址转换IP地址对应一个全局地址）。</p>
<p><strong>NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，多对一。</strong></p>
</li>
</ul>
<h4 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h4><p>实验目标<br>理解NAT网络地址转换的原理及功能；掌握静态NAT的配置，实现局域网访问互联网；</p>
<p>实验背景<br>你是某公司的网络管理员，欲发布公司的WWW服务。现要求将<strong>内网Web服务器IP地址映射为全局IP地址，实现外部网络可访问公司内部Web服务器</strong>。</p>
<p>技术原理</p>
<p>网络地址转换NAT（Network Address Translation），被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，<strong>NAT不仅完美地解决了IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机</strong>。</p>
<p>默认情况下，内部IP地址是无法被路由到外网的，内部主机10.1.1.1要与外部internet通信，IP包到达NAT路由器时，IP包头的源地址10.1.1.1被替换成一个合法的外网IP，并在NAT转换表中保存这条记录。当外部主机发送一个应答到内网时，NAT路由器收到后，查看当前NAT转换表，用10.1.1.1替换掉这个外网地址。</p>
<p>NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包；</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230320215916055.png" alt="image-20230320215916055"></p>
<p>r1</p>
<ul>
<li><p>int f0/0</p>
<ul>
<li>ip address 192.168.1.1 255.255.255.0</li>
</ul>
</li>
<li><p>int s 2/0</p>
<ul>
<li>ip address 222.0.1.1 255.255.255.0</li>
<li>clock rate 64000</li>
</ul>
</li>
<li><p>静态路由</p>
<ul>
<li>ip route 222.0.2.0 255.255.255.0 222.0.1.2（下一条地址）</li>
</ul>
</li>
<li><p><strong>指定内外部端口</strong></p>
<ul>
<li><p>int f 0/0</p>
<ul>
<li>ip nat inside</li>
</ul>
</li>
<li><p>int s 2/0</p>
<ul>
<li>ip nat outside</li>
</ul>
</li>
<li><p>ip nat inside source static 192.168.1.2 222.0.1.3(将内部IP地址转为外部IP 222.0.1.3)</p>
</li>
</ul>
</li>
</ul>
<p>r2</p>
<ul>
<li>int s 2/0<ul>
<li>ip address 222.0.1.2 255.255.255.0</li>
</ul>
</li>
<li>int f0/0<ul>
<li>ip address 222.0.2.1 255.255.255.0</li>
</ul>
</li>
<li>静态路由<ul>
<li>ip route 192.168.1.0 255.255.255.0 222.0.1.1</li>
<li><strong>配置默认路由：ip route 0.0.0.0 255.255.255.255 0.0.0.0</strong></li>
</ul>
</li>
</ul>
<p><strong>配置静态路由的命令的格式为：</strong></p>
<p>router(config)# ip route network [mask] {address | interface} [distance] [permanent]</p>
<p><strong>其中各参数含义如下：</strong></p>
<p>network：目标网络的网络ID。</p>
<p>mask：目标网络的子网掩码。</p>
<p>address：到达目标网络经过的下一跳路由器的入口IP地址。</p>
<p>interface：到达目标网络的必经的本地路由器的出口的接口名称。</p>
<p>distance：管理开销，不需要改变默认管理开销时，使用该参数进行修改。</p>
<p>permanent：永久有效。如果配置了该选项，即使该接口被关闭，这条静态路由也不会被删除。</p>
<p>例：ip route 192.168.1.0 255.255.255.0 192.168.2.1</p>
<p>其中，192.168.1.0是目标网络的网络ID；255.255.255.0是目标网络的子网掩码；192.168.2.1是下一跳路由器的与本路由器直连的那个接口的IP地址。</p>
<h4 id="网络端口地址转换NAPT配置"><a href="#网络端口地址转换NAPT配置" class="headerlink" title="网络端口地址转换NAPT配置"></a>网络端口地址转换NAPT配置</h4><p>实验目标</p>
<p>理解NAT网络地址转换的原理及功能；掌握NAPT的配置，实现局域网访问互联网；</p>
<p>实验背景</p>
<p>你是某公司的网络管理员，公司办公网需要接入互联网，公司只向ISP申请了一条专线，该专线分配了三个公网IP地址，配置实现全公司的主机都能访问外网。</p>
<p>技术原理<br>NAT将网络划分为内部网络和外部网络两部分，局域网主机利用NAT访问网络时，是将局域网内部的本地地址转换为全局地址（互联网合法的IP地址）后转发数据包；NAT分为两种类型：NAT（网络地址转换）和NAPT（网络端口地址转换IP地址对应一个全局地址）。<br>NAPT：使用不同的端口来映射多个内网IP地址到一个指定的外网IP地址，<strong>多对一</strong>。<br>NAPT采用<strong>端口多路复用</strong>方式。内部网络的所有主机均可共享一个合法外部IP地址实现对Internet的访问，从而可以最大限度地节约IP地址资源。同时，又可隐藏网络内部的所有主机，有效避免来自internet的攻击。因此，目前网络中应用最多的就是端口多路复用方式。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230326212508144.png" alt="image-20230326212508144"></p>
<p><strong>指定内外部端口</strong></p>
<ul>
<li><p>int f 0/0</p>
<ul>
<li>ip nat inside</li>
</ul>
</li>
<li><p>int s 2/0</p>
<ul>
<li>ip nat outside</li>
</ul>
</li>
<li><p>access-list 1 permit 192.168.1.0 0.0.0.255</p>
</li>
<li><p>ip nat pool 5ijsj 200.1.1.3 200.1.1.3 netmask 255.255.255.0</p>
</li>
<li><p>ip nat inside source list 1 pool 5ijsj overload </p>
</li>
</ul>
<h3 id="路由器综合路由配置"><a href="#路由器综合路由配置" class="headerlink" title="路由器综合路由配置"></a>路由器综合路由配置</h3><p>实验目标<br>掌握综合路由的配置方法；掌握查看通过路由重分布学习产生的路由；熟悉广域网线缆的连接方式；</p>
<p>实验背景<br>假设某公司通过一台三层交换机连到公司出口路由器R1上，路由器R1再和公司外的另一台路由器R2连接。<strong>三层交换机与R1间运行RIPV2路由协议，R1与R2间运行OSPF路由协议。现要做适当配置，实现公司内部主机与公司外部主机之间的相互通信。</strong></p>
<p>技术原理<br>为了支持本设备能够运行多个路由协议进程，系统软件提供了路由信息从一个路由进程重分布到另外一个路由进程<br>的功能。比如你可以将OSPF路由域的路由重新分布后通告RIP 路由域中，也可以将RIP 路由域的路由重新分布后通告到OSPF 路由域中。路由的相互重分布可以在所有的IP 路由协议之间进行。<br>要把路由从一个路由域分布到另一个路由域，并且进行控制<strong>路由重分布</strong>，在路由进程配置模式中执行以下命令：</p>
<p>redistribute protocol<br>[metric metric] [metricpe metric-type] [match internal | external type | nssa-external type] [tag tag] [route-map route-map-name] [subnets]</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230327091914476.png" alt="image-20230327091914476"></p>
<p>S1</p>
<ul>
<li>vlan 2 f0/10 192.168.2.1</li>
<li>vlan 1 f0/1   192.168.1.1</li>
</ul>
<p>r1</p>
<ul>
<li>int 0/0 192.168.2.2</li>
<li>int 1/0 192.168.3.1</li>
<li>router rip<ul>
<li>network 192.168.2.0</li>
<li>version 2</li>
</ul>
</li>
<li>router ospf 1<ul>
<li>network 192.168.3.0 0.0.0.255 area 0</li>
</ul>
</li>
</ul>
<p>r2</p>
<ul>
<li><p>int 1/0 192.168.3.2</p>
</li>
<li><p>int 0/0 192.168.4.1</p>
</li>
<li><p>router ospf 1</p>
<ul>
<li>network 192.168.3.0 0.0.0.255 area 0</li>
<li>network 192.168.4.0 0.0.0.255 area 0</li>
</ul>
</li>
<li><p>路由重分布</p>
<ul>
<li>router rip<ul>
<li>redistribute ospf 1</li>
</ul>
</li>
<li>router ospf 1<ul>
<li>redistribute rip subnets </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="ACL控制列表配置"><a href="#ACL控制列表配置" class="headerlink" title="ACL控制列表配置"></a>ACL控制列表配置</h3><p>实验目标<br>理解标准IP访问控制列表的原理及功能；掌握编号的标准IP访问控制列表的配置方法；</p>
<p>实验背景<br>你是公司的网络管理员，公司的经理部、财务部门和销售部分别属于不同的3个网段，三部门之间用路由器进行信息传递，为了安全起见，公司领导要求销售部门不能对财务部进行访问，但经理部可以对财务部进行访问。<br>PC1代表经理部的主机、PC2代表销售部的主机、PC3代表财务部的主机。</p>
<p>技术原理<br>ACLs的全称为接入控制列表（Access Control Lists），<strong>也称为访问列表（Access Lists），俗称为防火墙，在有的文档中还称之为包过滤</strong>。ACLs通过定义一些规则对网络设备接口上的数据报文进行控制：允许通过或丢弃，从而提高网络可管理性和安全性；<strong>IP ACL分为两种：标准IP访问列表和扩展IP访问列表</strong>，编号范围分别为1~ 99、1300~ 1999，100~ 199，2000~2699；</p>
<p>标准IP访问列表可以根据数据包的源IP地址定义规则，进行数据包的过滤；</p>
<p>扩展IP访问列表可以根据数据包的源IP、目的IP、源端口、目的端口、协议来定义规则，进行数据包的过滤；IP ACL基于接口进行规则的应用，分为：入栈应用和出栈应用；</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230517154011558.png" alt="image-20230517154011558"></p>
<p>配置静态路由</p>
<p>r1</p>
<ul>
<li>ip route 172.16.4.0 255.255.255.0 172.16.3.2</li>
</ul>
<p>r2</p>
<ul>
<li>ip route 0.0.0.0 0.0.0.0 172.16.3.1</li>
</ul>
<p>r1</p>
<ul>
<li><p>ip access-list standard 5ijsj</p>
<ul>
<li>permit 172.16.1.0 0.0.0.255(或者deny 172.16.2.0 0.0.0.255)</li>
</ul>
</li>
<li><p>int s2/0</p>
<ul>
<li>ip access-group 5ijsj out</li>
</ul>
</li>
</ul>
<h2 id="华为命令"><a href="#华为命令" class="headerlink" title="华为命令"></a>华为命令</h2><p>安装ensp virtualbox:<a href="https://www.virtualbox.org/wiki/Download_Old_Builds_5_2">https://www.virtualbox.org/wiki/Download_Old_Builds_5_2</a></p>
<blockquote>
<p>命令尽量不要缩写</p>
</blockquote>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230519170915387.png" alt="image-20230519170915387"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230520231727257.png" alt="image-20230520231727257"></p>
<h3 id="名词解释-2"><a href="#名词解释-2" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong>Router ID唯一的标识一台OSPF路由器，是OSPF路由器的身份证</strong>Router ID和IP地址一样，采用点分十进制格式来表示</p>
<h3 id="模式-2"><a href="#模式-2" class="headerlink" title="模式"></a>模式</h3><h4 id="系统视图"><a href="#系统视图" class="headerlink" title="系统视图"></a>系统视图</h4><ul>
<li><p>system-view进入系统视图</p>
</li>
<li><p>查看</p>
<ul>
<li>display interface brief 查看接口</li>
<li>display ip interface brief 查看接口ip</li>
<li>display vlan</li>
<li>display ip routing-table 查看路由表</li>
<li>display this 查看最近命令</li>
<li>dis current-configuration | b display vlan 查看从display vlan开始后面的所有配置命令</li>
</ul>
</li>
<li><p>设置</p>
<ul>
<li><p>sysname name更改设备名字</p>
</li>
<li><p>telnet server enable//开启设备telnet功能</p>
</li>
<li><p>设置时间</p>
<ul>
<li>clock timezone<br>设置所在时区<br>clock datetime<br>设置当前时间和日期<br>clock daylight-saving-time<br>设置采用夏时制</li>
</ul>
</li>
<li><p>undo info-center enable 阻断提示信息</p>
</li>
</ul>
</li>
<li><p>创建</p>
<p>- </p>
</li>
<li><p>int g0/0/0</p>
<ul>
<li>ip address 192.168.2.2 24 添加端口地址</li>
<li>undo ip add 192.168.2.2 2 24取消端口地址</li>
<li>display ip interface brief</li>
</ul>
</li>
</ul>
<h4 id="用户接口视图"><a href="#用户接口视图" class="headerlink" title="用户接口视图"></a>用户接口视图</h4><blockquote>
<p>AAA是Authentication（认证）、Authorization（授权）和Accounting（计费）的简称，是<a href="https://cloud.tencent.com/product/ns?from=20065&from_column=20065">网络安全</a>的一种管理机制，提供了认证、授权、计费三种安全功能</p>
<p>这三种安全功能的具体作用如下：</p>
<p>• 认证：验证用户是否可以获得网络访问权。</p>
<p>• 授权：授权用户可以使用哪些服务。</p>
<p>• 计费：记录用户使用网络资源的情况。</p>
</blockquote>
<ul>
<li><p>telnet server enable//开启设备telnet功能</p>
</li>
<li><p>user-interface vty  0 4 //开启登录端口0-4</p>
<ul>
<li>[Huawei-ui-vty0-4]authentication-mode password </li>
<li>[Huawei-ui-vty0-4]protocol inbound telnet //通过telnet协议登录</li>
<li>[Huawei-ui-vty0-4]authentication-mode aaa//认证方式为aaa</li>
</ul>
</li>
<li><p>[Huawei]aaa //启用aaa</p>
<ul>
<li><p>配置用户</p>
<ul>
<li><p>local-user admin123 privilege level 0 password cipher admin123//配置用户名密码，用户等级</p>
<ul>
<li>[Huawei-aaa]local-user admin123 password admin123 //配置用户名密码</li>
<li>[Huawei-aaa]local-user admin123 privilege level 15 //用户等级为15</li>
</ul>
</li>
<li><p>[Huawei-aaa]local-user admin123 service-type telnet //用户用于telnet</p>
</li>
</ul>
</li>
<li><p>设置登录信息</p>
<ul>
<li>header login<br>用户登录前显示的标题消息</li>
<li>header shell<br>用户登录后显示的标题消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="交换机-2"><a href="#交换机-2" class="headerlink" title="交换机"></a>交换机</h3><h4 id="配置交换机的远程管理IP地址"><a href="#配置交换机的远程管理IP地址" class="headerlink" title="配置交换机的远程管理IP地址"></a>配置交换机的远程管理IP地址</h4><p>[huawei] interface Vlanif 1 //进入 vlan1</p>
<p>[huawei-Vlanif1] ip address 192.168.1.254 24 //配置 IP</p>
<p>[huawei-Vlanif1] undo shutdown // 开启接口</p>
<p>[huawei] dns domain dtwlxy.com //设置域名</p>
<p>[huawei] dns server 192.168.254.254 //设置域名 ip</p>
<p>display vlan //显示 vlan</p>
<p>save //保存 reboot //重启设备</p>
<p>display curr //显示当前配置</p>
<h4 id="配置交换机端口速率，双工，ARP"><a href="#配置交换机端口速率，双工，ARP" class="headerlink" title="配置交换机端口速率，双工，ARP"></a>配置交换机端口速率，双工，ARP</h4><p>[huawei] int g 0/0/1 //进入端口</p>
<p>[huawei- g0/0/1] description negotiation auto //取消协商</p>
<p>[huawei- g0/0/1]duplex full //全双工</p>
<p>[huawei- gigabitEthernet 0/0/1] auto duplex full //自动</p>
<p>[huawei- gigabitEthernet 0/0/1] speed 10 //速率 10M</p>
<p>[huawei- gigabitEthernet 0/0/1] auto speed 100 //自动</p>
<p>[huawei] arp static 192.168.1.8 5489-98cf-2603 //绑定</p>
<p>[huawei] display arp</p>
<p>[huawei] display arp all //查看 ARP</p>
<h4 id="VLAN和VLANIF地址配置"><a href="#VLAN和VLANIF地址配置" class="headerlink" title="VLAN和VLANIF地址配置"></a>VLAN和VLANIF地址配置</h4><blockquote>
<p>[huawei-g0/0/2]port trunk allow-pass vlan 10 20</p>
</blockquote>
<ul>
<li><p>vlan 100  //创建vlan 100（批量创建命令：vlan batch/10 20, vlan batch 30 to 40 //批量创建连续 VLAN）</p>
<ul>
<li>[huawei-vlan10] description dt //VLAN 描述</li>
<li>[Switch-vlan100]quit//退出vlan模式</li>
</ul>
</li>
<li><p>[Switch]interface gigabitethernet 0/0/1//进入接口</p>
</li>
<li><p>[Switch-GigabitEthernet0/0/1]port link-type access //把交换机接口模式设置为access(trunk)</p>
</li>
<li><p>[Switch-GigabitEthernet0/0/1]port default vlan 100 //把接口划入vlan100</p>
</li>
<li><p>[Switch-GigabitEthernet0/0/1]quit //退出</p>
</li>
<li><p>[Switch]interface vlanif 100 //进入三层vlanif接口</p>
</li>
<li><p>[Switch-Vlanif100]ip address 172.16.1.1 24//配置IP地址</p>
</li>
<li><p>[Switch-Vlanif100]quit//退出</p>
</li>
</ul>
<h4 id="单臂路由-VLAN-间通信"><a href="#单臂路由-VLAN-间通信" class="headerlink" title="单臂路由 VLAN 间通信"></a>单臂路由 VLAN 间通信</h4><p>首先基本配置，ip，VLAN 等。</p>
<p>[huawei-GigabitEthernet0/0/1.1] ip address 192.168.1.254 24 //配置 ip</p>
<p>[huawei-GigabitEthernet0/0/1.1] dot1q termination vid 10//封装</p>
<p>[huawei-GigabitEthernet0/0/1.1] arp broadcast enable//开启 arp</p>
<p>[huawei] display ip interface brief //查看接口</p>
<p>[huawei]display ip routing-table //查看路由表</p>
<p>[huawei] display current-configuration //查看配置</p>
<h4 id="链路聚合"><a href="#链路聚合" class="headerlink" title="链路聚合"></a>链路聚合</h4><blockquote>
<ul>
<li>增加带宽</li>
<li>提高可靠性</li>
<li>提供备份功能</li>
</ul>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/a7b75962cd5a44579fb18f4d49d05335.png" alt="img"></p>
<p>链路聚合手动模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SW1]int Eth-Trunk 10  //创建聚合组序号为10</span><br><span class="line">[SW1-Eth-Trunk10]trunkport GigabitEthernet 0/0/1 to 0/0/3 //把g0/0/1到0/0/3添加到组</span><br><span class="line">Info: This operation may take a few seconds. Please wait for a moment...done.</span><br><span class="line">[SW1-Eth-Trunk10]port link-type trunk //把三个端口设置为Trunk口</span><br><span class="line">[SW1-Eth-Trunk10]port trunk allow-pass vlan all //允许所有的VLAN通过</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SW2]int Eth-Trunk 10</span><br><span class="line">[SW2-Eth-Trunk10]trunkport GigabitEthernet 0/0/1 to 0/0/3</span><br><span class="line">Info: This operation may take a few seconds. Please wait for a moment...done.</span><br><span class="line">[SW2-Eth-Trunk10]port link-type trunk </span><br><span class="line">[SW2-Eth-Trunk10]port trunk allow-pass vlan all </span><br></pre></td></tr></table></figure>

<p>链路聚合LACP模式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> [SW1]int Eth-Trunk 10  //创建链路聚合组10</span><br><span class="line">[SW1-Eth-Trunk10]mode lacp-static //配置链路聚合模式LACP</span><br><span class="line">[SW1-Eth-Trunk10]trunkport GigabitEthernet 0/0/1 to 0/0/3 //把g0/0/1-0/0/3添加到组</span><br><span class="line">Info: This operation may take a few seconds. Please wait for a moment...done.</span><br><span class="line">[SW1-Eth-Trunk10]quit</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SW2]int Eth-Trunk 10</span><br><span class="line">[SW2-Eth-Trunk10]mode lacp-static</span><br><span class="line">[SW2-Eth-Trunk10]trunkport GigabitEthernet 0/0/1 to 0/0/3</span><br><span class="line">Info: This operation may take a few seconds. Please wait for a moment...done.</span><br><span class="line">[SW2-Eth-Trunk10]quit</span><br></pre></td></tr></table></figure>

<p>在SW1上修改最大活动接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SW1-Eth-Trunk10]max active-linknumber 5  //设置最大活动端口数为5</span><br></pre></td></tr></table></figure>

<p>在SW1上修改LACP抢占功能并且查看信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[SW1]int Eth-Trunk 10</span><br><span class="line">[SW1-Eth-Trunk10]lacp preempt enable//启用LACP抢占功能</span><br><span class="line">[SW1-Eth-Trunk10]lacp preempt delay 10//抢占延迟为10</span><br><span class="line">[SW1-Eth-Trunk10]quit</span><br></pre></td></tr></table></figure>



<h3 id="DHCP配置"><a href="#DHCP配置" class="headerlink" title="DHCP配置"></a>DHCP配置</h3><h4 id="配置基于全局-DHCP协议"><a href="#配置基于全局-DHCP协议" class="headerlink" title="配置基于全局 DHCP协议"></a>配置基于全局 DHCP协议</h4><ul>
<li><SwitchA> system-view//进入系统模式</li>
<li>[SwitchA] dhcp enable//启用dhcp服务</li>
<li>[SwitchA] interface vlanif 20<ul>
<li>[SwitchA] dhcp select  global</li>
</ul>
</li>
<li>[SwitchA]ip pool 1 //系统视图下创建全局IP地址池1（1是地址池名字）</li>
<li>[SwitchA-ip-pool-1]network 192.168.20.0 mask 24 //配置地址池范围</li>
<li>[SwitchA-ip-pool-1]gateway-list 192.168.20.254 //配置PC电脑网关，即vlan20的ip地址</li>
<li>[SwitchA-ip-pool-1]dns-list 8.8.8.8//配置DNS</li>
<li>[SwitchA-ip-pool-1]excluded-ip-address 192.168.20.151 192.168.20.253//保留IP地址</li>
<li>[SwitchA-ip-pool-1]lease 10//配置租期</li>
<li>[SwitchA-ip-pool-1]display this</li>
<li>[SwitchA-ip-pool-1]quit//退出</li>
</ul>
<ul>
<li>配置VLANIF10接口下的客户端从全局地址池ip pool 1中获取IP地址。<ul>
<li>[SwitchA]interface vlanif 20//进入VLAN10接口</li>
<li>[SwitchA-Vlanif20]ip address 10.1.1.254 255.255.255.128//配置VLAN网关</li>
<li>[SwitchA-Vlanif20]dhcp select global/interface//全局或接口dhcp服务器</li>
</ul>
</li>
<li><strong>如何指定vlan10和vlan20使用不同地址池</strong><ul>
<li>在不同vlan视图中创建地址池，即可绑定</li>
</ul>
</li>
</ul>
<h4 id="配置基于接口-DHCP-协议"><a href="#配置基于接口-DHCP-协议" class="headerlink" title="配置基于接口 DHCP 协议"></a>配置基于接口 DHCP 协议</h4><ul>
<li><p>[huawei] dhcp enable //开启 dhcp 接口</p>
</li>
<li><p>[huawei] int g0/0/1 //<strong>进入接口，或者vlan</strong></p>
</li>
<li><p>[huawei-G0/0/1] dhcp select interface //基于接口</p>
</li>
<li><p>[huawei-G0/0/1] dhcp server dns-list 8.8.8.8 //DNS</p>
</li>
<li><p>[huawei-G0/0/1] dhcp server lease day 2 //租约默认为 1</p>
</li>
<li><p>[huawei-G0/0/1] dhcp server excluded-ip-address 192.168.1.1 192.168.1.10 <strong>//排除范围，网关是默认排除的</strong></p>
</li>
<li><p>[huawei-G0/0/1] display this</p>
</li>
<li><p>[huawei] display ip pool //查看 dhcp</p>
</li>
</ul>
<h4 id="DHCP的配置（vlanif下配置）"><a href="#DHCP的配置（vlanif下配置）" class="headerlink" title="DHCP的配置（vlanif下配置）"></a>DHCP的配置（vlanif下配置）</h4><img src="https://img-blog.csdnimg.cn/6b613b420d89464b9607b2ffa22aaef4.png" alt="img" style="zoom:50%;" />

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Huawei&gt;system-view #进入系统模式</span><br><span class="line">[Huawei]vlan 10 </span><br><span class="line">#创建vlan10 和 vlan 20 </span><br><span class="line">#或用vlan batch 10 20 （同时创建vlan 10和 vlan 20）</span><br><span class="line">[Huawei-vlan10]quit </span><br><span class="line">[Huawei]vlan 20</span><br><span class="line">[Huawei-vlan20]quit #退出</span><br><span class="line">[Huawei]display vlan summary #查看vlan 信息</span><br><span class="line">[Huawei]interface vlanif 10 #进入vlan 10</span><br><span class="line">[Huawei-Vlanif10]ip address 192.168.10.254 24 #配置IP及掩码</span><br><span class="line">[Huawei-Vlanif10]interface vlanif 20</span><br><span class="line">[Huawei-Vlanif20]ip address 192.168.20.254 24</span><br><span class="line">[Huawei-Vlanif20]quit </span><br><span class="line">[Huawei]interface gigabitether 0/0/1#进入g0/0/1接口</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port link-type access #配置链路为access模式</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]port default vlan 10 #讲链路接入vlan10</span><br><span class="line">[Huawei-GigabitEthernet0/0/1]interface gigabitether 0/0/2</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port link-type access</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]port default vlan 20</span><br><span class="line">[Huawei-GigabitEthernet0/0/2]quit </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Huawei]interface vlanif 10#进入vlan 10</span><br><span class="line">[Huawei-Vlanif10]dhcp select interface #配置为接口DHCP</span><br><span class="line">[Huawei-Vlanif10]dhcp server dns-list 8.8.8.8 #配置dns</span><br><span class="line">[Huawei-Vlanif10]dhcp server excluded-ip-address 192.168.10.100 192.168.10.253 #配置排除地址，网关是默认排除的</span><br><span class="line">[Huawei-Vlanif10]dhcp server lease day 10 #配置租期</span><br><span class="line">[Huawei-Vlanif10]quit </span><br><span class="line">[Huawei]interface vlanif 20</span><br><span class="line">[Huawei-Vlanif20]dhcp select interface </span><br><span class="line">[Huawei-Vlanif20]dhcp server dns-list 8.8.8.8</span><br><span class="line">[Huawei-Vlanif20]dhcp server excluded-ip-address 192.168.20.100 192.168.20.253</span><br><span class="line">[Huawei-Vlanif20]dhcp server lease day 10</span><br><span class="line">[Huawei-Vlanif20]quit </span><br></pre></td></tr></table></figure>

<h3 id="ACL访问控制列表配置"><a href="#ACL访问控制列表配置" class="headerlink" title="ACL访问控制列表配置"></a>ACL访问控制列表配置</h3><blockquote>
<p>ACL是一个匹配工具，能够对报文进行匹配和区分。ACL技术总是与防火墙、路由策略、QoS、流量过滤等其他技术结合使用。</p>
</blockquote>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230521153517393.png" alt="image-20230521153517393"></p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230521153651525.png" alt="image-20230521153651525"></p>
<p><strong>可以匹配IP或者网段</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>编号范围</th>
<th>规则定义描述</th>
</tr>
</thead>
<tbody><tr>
<td>基本ACL</td>
<td>2000-2999</td>
<td>仅使用报文的源IP地址、分片信息和生效时间段信息来定义规则。</td>
</tr>
<tr>
<td>高级ACL</td>
<td>3000-3999</td>
<td>可使用IPv4报文的源IP地址、目的IP地址、IP协议类型、ICMP类型、TCP源/目的端口号、UDP源/目的端口号、生效时间段等来定义规则。</td>
</tr>
</tbody></table>
<h4 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h4><p>[Huawei]time-range workday 8：30 to 18：00 working-day//配置时间段，工作日下的8.30-18<br>[Huawei-acl-basic-2000]rule permit source 192.168.1.10 0 time-range workday//只允许192.168.1.10这个用户在工作日可以telnet交换机</p>
<h4 id="配置路由器基本ACL-2000-2999"><a href="#配置路由器基本ACL-2000-2999" class="headerlink" title="配置路由器基本ACL:2000-2999"></a>配置路由器基本ACL:2000-2999</h4><p>huawei] acl 2000 //启用编号为2000的ACL</p>
<p>[huawei-acl-basic-2000] rule 5 permit/deny source 1.1.1.1 0  //注意<strong>反掩码</strong> 0，默认步长为 5</p>
<p>[huawei-acl-basic-2000]rule 10 deny any <strong>//拒绝任意</strong></p>
<h4 id="配置路由器高级-ACL：3000-3999"><a href="#配置路由器高级-ACL：3000-3999" class="headerlink" title="配置路由器高级 ACL：3000-3999"></a>配置路由器高级 ACL：3000-3999</h4><p>[huawei] acl 3000//启用编号为3000的ACL</p>
<p>[huawei-acl-adv-3000] rule 10 deny ip source 192.168.1.0 0.0.0.255（反掩码） destination 192.168.3.100 0（反掩码） //拒绝</p>
<p>192.168.1.0网段访问192.168.3.100这个服务器</p>
<p>[huawei-acl-adv-3000] rule 20 permit ip source 192.168.2.0 0.0.0.255 destination  192.168.3.100 0//允许192.168.2.0网段访问192.168.3.100这个服务器</p>
<p>[huawei-acl-adv-3000] rule 30 deny ip source any destination 192.168.3.100 0//拒绝所有ip访问192.168.3.100这个服务器</p>
<p>[huawei] int g0/0/1 //进入接口</p>
<p>[huawei-G0/0/1] traffic-filter inbound acl 3000 //应用进入的规则</p>
<p>[huawei-G0/0/1] traffic-filter outbound acl 3000 //应用出去的规则</p>
<p>[huawei] display acl all //查看所有的 acl</p>
<h4 id="配置用户访问路由器权限"><a href="#配置用户访问路由器权限" class="headerlink" title="配置用户访问路由器权限"></a>配置用户访问路由器权限</h4><p>[huawei]user-interface vty 0 4</p>
<p>[huawei-ui-vty0-4]acl 2000 inbound //应用 acl</p>
<p>[huawei] dis acl all //查看 acl 全部消息</p>
<p>[huawei] dis acl 2000 //查看 acl2000</p>
<p>[Huawei-acl-basic-2000]rule deny**//这个地方rule deny可以不用写，acl在这种场景下最后隐含有一条deny any的语句**</p>
<p>[Huawei]user-interface vty 0 4//进入虚拟接口0-4</p>
<p>[Huawei-ui-vty0-4]acl 2000 inbound//应用ACL，只允许匹配acl数据流的的用户telent登陆交换机，没有被permit的全部被deny</p>
<h3 id="NAT地址转换配置"><a href="#NAT地址转换配置" class="headerlink" title="NAT地址转换配置"></a>NAT地址转换配置</h3><p>NAT类型：</p>
<ul>
<li><p>NAT（网络地址转换）</p>
<ul>
<li>静态NAT：内网中一个主机的私有IP地址与一个公网IP地址相绑定。现实中，一般都用于服务器；</li>
<li>动态NAT：定义一个地址池，自动映射，也是一对一的。现实中，用得比较少；</li>
</ul>
</li>
<li><p>easy ip</p>
</li>
<li><p>NAPT：“内部网络主机的IP＋端口号”和“公网IP＋端口号”执行一对一绑定</p>
</li>
</ul>
<h4 id="一对一：静态"><a href="#一对一：静态" class="headerlink" title="一对一：静态"></a>一对一：静态</h4><p>[huawei-GigabitEthernet0/0/1] nat static global <strong>12.1.1.3 inside 10.1.0.100</strong> //一对一转换</p>
<p>[huawei-router]interface LoopBack 0 //回环地址，配置一个IP地址为 2.2.2.2的环回接口，用以模拟Internet中的地址</p>
<ul>
<li>ip address 2.2.2.2 32</li>
</ul>
<p>[router]<strong>ip route-static 0.0.0.0 0.0.0.0 12.1.1.2</strong> //配置静态路由</p>
<p>PC的IP地址10.1.0.100会被转换的Global IP是<strong>12.1.1.3</strong></p>
<h4 id="多对一：动态"><a href="#多对一：动态" class="headerlink" title="多对一：动态"></a>多对一：动态</h4><p>[huawei] nat address-group  1  202.169.10.50 202.169.10.60  //<strong>设置NAT地址池</strong>，编号为1，范围从202.169.10.50开始，至202.169.10.60结束</p>
<p>[huawei] acl 2000 //配置 acl(过滤 抓流量)</p>
<p>[huawei-acl-basic-2001] rule 5 permit source 172.17.1.0 0.0.0.255 ////设置ACL200编号为5的规则，允许上述源地址通过</p>
<p>[huawei] interface g0/0/1 //进入接口</p>
<p>//意为当符合ACL 2000的数据从g0/0/0端口出去时，会将从地址池1中取出地址取代原地址成为新的源地址</p>
<p>[huawei-gigabitEthernet0/0/1] nat outbound 2000 address-group 1 no-pat </p>
<p>[huawei] display nat outbound //查看 NAT</p>
<h4 id="Easy-IP"><a href="#Easy-IP" class="headerlink" title="Easy IP"></a>Easy IP</h4><blockquote>
<p><strong>没有地址池的概念，因为外网随时会变，适用于不具备固定公网ip地址的场景</strong></p>
</blockquote>
<p>Easy-IP是NAPT的一种方式，<strong>直接借用路由器出接口IP地址作为公网地址</strong>，将不同的内部地址映射到同一公有地址的不同端口号上，实现多对一地址转换，我们将R1的g0/0/0接口配置为Easy-IP接口。</p>
<p>[R1]int g0/0/0<br>//首先将先前在g0/0/0端口设定的NAT地址池模式关闭<br>[R1-GigabitEthernet0/0/0]undo nat outbound 2000 address-group 1 no-pat<br>//重新在g0/0/0端口上绑定规则2000，此时配置的就是Easy-IP特性<br>[R1-GigabitEthernet0/0/0]nat outbound 2000</p>
<h4 id="nat-server"><a href="#nat-server" class="headerlink" title="nat server"></a>nat server</h4><blockquote>
<p>解决安全问题，负载均衡</p>
</blockquote>
<p>指定[公有地址：端口]与[私有地址：端口]的一对一映射关系。将内网服务器映射到公网。外网主机主动访问[公有地址：端口]实现对内网服务器的访问。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230522152835133.png" alt="image-20230522152835133"></p>
<p>在R1上配置NAT Server将内网服务器192.168.1.10的80端口映射到公有地址122.1.2.1的80端口。</p>
<p>[R1] interface GigabitEthernet0/0/1<br>[R1-GigabitEthernet0/0/1] ip address 122.1.2.1 24<br>[R1-GigabitEthernet0/0/1] nat server protocol tcp global 122.1.2.1 80 inside 192.168.1.10 80</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230518110122600.png" alt="image-20230518110122600"></p>
<p>开销：rip为例，路由器跳数作为开销。ospf用$100M/接口带宽$作为开销</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230518110253311.png" alt="image-20230518110253311"></p>
<p>内部network宣告的路由优先级为10，而外部用import宣告的优先级为150</p>
<h4 id="静态路由配置"><a href="#静态路由配置" class="headerlink" title="静态路由配置"></a>静态路由配置</h4><ul>
<li>静态路由的配置（关联下一跳IP的方式）[Router]ip route-static 网络号 掩码 下一跳IP地址 [preference 60 权重是60]</li>
<li>静态路由的配置（关联出接口的方式）[Router）ip route-static 网络号 掩码 出接口</li>
<li>静态路由的配置（关联出接口和下一跳IP的方式）[Router]ip route-static 网络号 掩码 出接口 下一跳IP地址</li>
</ul>
<blockquote>
<p>配置示例：<br>[R1]ip route-static 192.168.100.0 255.255.255.0 192.168.12.2<br>[R1]ip route-static 192.168.100.0 24                     192.168.12.2</p>
</blockquote>
<h4 id="默认路由配置"><a href="#默认路由配置" class="headerlink" title="默认路由配置"></a>默认路由配置</h4><p>[R1]ip route-static 0.0.0.0 0.0.0.0 192.168.12.2<br>或<br>[R1]ip route-static 0.0.0.0 0 192.168.12.2</p>
<h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><blockquote>
<p>动态路由是外网学习内网的路径，而不是内网学习外网路由路径，因为外网的服务器有几百万个，如果去学习的话会对内部交换机路由器资源损耗</p>
</blockquote>
<h5 id="配置路由器RIP协议：RIPv1-RIPv2"><a href="#配置路由器RIP协议：RIPv1-RIPv2" class="headerlink" title="配置路由器RIP协议：RIPv1 RIPv2"></a>配置路由器RIP协议：RIPv1 RIPv2</h5><p><img src="https://img-blog.csdnimg.cn/c94db87c571040b6a900e6d3cb828f4c.png" alt="img"></p>
<p>配置各台设备的IP地址</p>
<p>配置RIPv2，实现网络连通</p>
<p>[AR1]rip        //启用RIP的进程</p>
<p>[AR1-rip-1]version 2          //修改RIP的版本为2，默认版本号为1</p>
<p>[AR1-rip-1]<strong>network 10.0.0.0</strong>       <strong>//宣告网段，RIP只能宣告直连网络的主类网络号，这个是a类</strong></p>
<p>[AR1-rip-1]network 172.16.0.0    //b类</p>
<p>[AR2]rip</p>
<p>[AR2-rip-1]version 2</p>
<p>[AR2-rip-1]network 172.16.0.0</p>
<p>[AR2-rip-1]network 192.168.1.0        //c类</p>
<h5 id="配置路由器OSPF-协议"><a href="#配置路由器OSPF-协议" class="headerlink" title="配置路由器OSPF 协议"></a>配置路由器OSPF 协议</h5><blockquote>
<p><strong>Router ID唯一的标识一台OSPF路由器</strong></p>
<p>接触过OSPF的小伙伴都知道，Router ID非常重要，它用来唯一的标识一台OSPF路由器，是OSPF路由器的身份证</p>
<blockquote>
<p>router-id选举规则</p>
<p>（1）优选手工配罩的router-id。<br>①ospf进程手工配置的router-id具有最高优先级（不能配置为255.255.255.255和0.0.0.0）<br>②在全局模式下配置的公用router-id的优先级仅次于直接给OSPF进程手工配置router-id，即它具有第二优先级。<br>（2）在没有手工配置的前提下，优选loopback接口地址中最大的地址作为routekid。<br>（3）在没有配置loopback接口地址的前提下，优选其他接口的IP地址中选择最大的地址作为router-id（不考虑接口的Up/Dow状态）。s</p>
</blockquote>
</blockquote>
<blockquote>
<p>区域号是0，通常被称为骨干区域</p>
<p>骨干区域负责区域之间的路由，非骨干区域之间的路由信息必须通过骨干区域来转发</p>
</blockquote>
<p>[huawei] ospf 1 //查看 ospf 默认是进程 1</p>
<p>[huawei-ospf-1] area 0 //进入区域 0</p>
<p>[huawei-ospf-1-area-0.0.0.0] network 192.168.3.0 0.0.0.255//发布直连网段</p>
<p>[huawei-ospf-1] silent-interface g0/0/2 //被动接口</p>
<p>[huawei] dis ospf interface //查看 ospf 通告</p>
<p>[huawei] dis ospf peer //查看 ospf 邻居</p>
<p>[huawei] dis ip routing-table //查看路由表</p>
<p>[huawei] dis ospf routing //查看 ospf 路由表</p>
<h4 id="BGP配置"><a href="#BGP配置" class="headerlink" title="BGP配置"></a>BGP配置</h4><img src="https://img-blog.csdnimg.cn/img_convert/67594bdb904548d47a3b9d50f35a2156.png" alt="img" style="zoom: 80%;" />

<p>[R1] int LoopBack 0 #进入回环接口0。</p>
<p>[R1-LoopBack0] ip address 1.1.1.1 32 #配置IP地址为1.1.1.1，掩码为255.255.255.255。</p>
<p>[R1] bgp 100 #配置BGP的AS域100。</p>
<p>[R1-bgp] router-id 1.1.1.1 #配置router-id为1.1.1.1。</p>
<p><strong>[R1-bgp] peer 192.168.10.2 as-number 200 #配置EBGP对等体为192.168.10.2，AS号为200。</strong></p>
<p>[R1-bgp] network 10.1.1.0 24 #通告10.1.1.0网段的路由；把业务网段10.1.1.0变成BGP路由。</p>
<p>[R1-bgp] network 10.1.2.0 24 #通告10.1.2.0网段的路由；把业务网段10.1.2.0变成BGP路由。</p>
<p>[R2-bgp] peer 3.3.3.3 as-number 200 #配置IBGP对等体为R3，AS号为200。</p>
<p>[R2-bgp] peer 3.3.3.3 next-hop-local #对3.3.3.3配置下一跳为本地。</p>
<p>[R2-bgp] peer 3.3.3.3 connect-interface LoopBack 0 #对3.3.3.3配置更新源接口为环回接口Looback 0。</p>
<p>[R2-bgp] preference 200 100 100 #配置EBGP路由优先级200，IBGP路由优先级100，本地产生的路由优先级100，BGP默认优先级为255。</p>
<p>[R2-bgp] peer 3.3.3.3 default-route-advertise #对3.3.3.3下发默认路由。</p>
<p>[R2-bgp] aggregate 10.1.0.0 16 as-set #配置聚合路由为10.1.0.0/16且携带AS属性。</p>
<p>[R2] acl 2000 #创建acl2000。</p>
<p>[R2-acl-basic-2000] rule deny source 10.1.1.0 0.0.0.255 #对源地址段为10.1.1.0的路由执行丢弃。</p>
<p>[R2-bgp] filter-policy 2000 import #调用acl 2000的接收路由方向的过滤列表。</p>
<p>[R3-bgp] peer 4.4.4.4 reflect-client #配置对4.4.4.4的路由反射器；让R4成为R3的客户端，其余路由器可以学习到R4的BGP路由；BGP路由默认只能学习到左右两端的路由所以这个时候就需要来配置一个路由反射。</p>
<p>[R3-bgp] display bgp peer #查看对等体关系。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4c06eaa5202bc95a8032bdfa20dde752.png" alt="img"></p>
<p>BGP属性相关配置。</p>
<p>[R3-bgp] peer 2.2.2.2 preferred-value 100 #对2.2.2.2对等体修改首选值为100。</p>
<p>[R2-bgp] default local-preference 150 #修改默认的本地优先级为150；选路的优先级，长用于边界路由器之上。</p>
<p>[R2] acl 2000 #创建acl 2000。</p>
<p>[R2-acl-basic-2000] rule permit source 10.1.1.0 0.0.0.255 #匹配地址为10.1.1.0/24网段的IP。</p>
<p>[R2] route-policy 1 permit node 1 #创建路由策略列表1，放行规则1。</p>
<p>[R2-route-policy] if-match acl 2000 #匹配ACL 2000。</p>
<p>[R2-route-policy] apply cost 100 #设置cost 为100。</p>
<p>[R2-bgp] peer 3.3.3.3 route-policy 1 export #对3.3.3.3对等体通告路由方向调用路由策略。</p>
<h4 id="路由总结"><a href="#路由总结" class="headerlink" title="路由总结"></a>路由总结</h4><p>静态路由（动态路由相反）</p>
<ul>
<li>配置简单.</li>
<li>手工配置，可控性高。</li>
<li><strong>节省网络带宽</strong>。</li>
<li>网络大，工作量大，比如配置1000条静态路由。</li>
<li>网络故障，<strong>无法响应拓扑动态变化</strong>。</li>
</ul>
<p>默认路由</p>
<ul>
<li>默认路由是一种特殊的静态路由，走投无路的选择。</li>
<li>配置简单，简化管理。</li>
<li>降低路由 CPU、内存资源。</li>
<li>使用场景：网络出口路由器/防火墙/核心交换机。</li>
</ul>
<h3 id="BFD"><a href="#BFD" class="headerlink" title="BFD"></a>BFD</h3><p>配置双向转发检测(Bidirectional Forwarding Deteletion，BFD)实现链路故障快速检测和静态路由的自动切换。 </p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c9d7c7bd6db4578d0cc082d9de4ead3c.png" alt="img"></p>
<p>BFD检测。首先做静态路由使全网互通。</p>
<p>[R1] bfd #开启BFD功能。</p>
<p>[R1] bfd 1 bind peer-ip 192.168.20.2 <strong>source-ip 192.168.10.1</strong> auto #BFD 1 绑定的对端IP为192.168.20.2，<strong>源IP</strong>为192.168.10.1，auto是自动协商标识符的意思。</p>
<p>[R1] bfd 2 bind peer-ip 192.168.20.2 source-ip 192.168.10.1 #BFD 2 绑定的对端IP为192.168.20.2，源IP为192.168.10.1。</p>
<p>[R1-bfd-session-2] discriminator local 10 #本地标识符10。</p>
<p>[R1-bfd-session-2] discriminator remote 20 #远端标识符20。</p>
<p>[R1-bfd-session-2] commit #提交配置。</p>
<h3 id="网关冗余技术VRRP"><a href="#网关冗余技术VRRP" class="headerlink" title="网关冗余技术VRRP"></a>网关冗余技术VRRP</h3><p>通过把几台路由设备联合组成一台虚拟的“路由设备”，使用一定的机制<strong>保证当主路由设备出现故障时，及时将业务切换到备份路由设备，从而保持通讯的连续性和可靠性</strong></p>
<p>VRRP（Virtual Router Redundancy Protocol）虚拟路由冗余协议用来做出口网关的备份</p>
<p><strong>作用：用来做出口网关的备份保证出口网关的高用性</strong></p>
<p>VRRP的好处：</p>
<p>1，主路由失效后，备份路由器立即顶替主路由器的工作，保证数据不会丢失</p>
<p>2，两个不同的路由器成为不同组的主路由器，相互备份</p>
<p>3，跟踪上行链路接口状态，当上行链路接口失效时，自动将备份路由器提升为主路由器，保证数据不会丢失</p>
<p><strong>VRRP工作原理：</strong></p>
<p>通过在<strong>冗余网关间共享虚拟Mac和ip地址</strong>，保证数据转发时并不是转给某一个具体网关ip，而是把数据传给虚拟网关ip，因此不论那个路由器成为主路由器，都不会影响数据通信，通过两个设备间的<strong>心跳线</strong>组播对数据端口进行监控，一旦检测数据转发的端口坏掉，主路由器会停止hello包，备份路由提升为主路由器，由于此切换非常迅速而且不用改变IP地址和MAC地址，实现数据的稳定高效转发。</p>
<ul>
<li><p>创建VRRP备份组并给备份组配置虚拟IP地址</p>
<p>[interface-GigabitEthernet0/0/0]vrrp vrid virtual-router-idName virtual-ip virtual-address注意：<strong>各备份组之间的虚拟IP地址不能重复；同属一个备份组的设备接口需使用相同的VRID。</strong></p>
</li>
<li><p>配置路由器在备份组中的优先级</p>
<p>[interface-GigabitEthernet0/0/0]vrrp vrid virtual-router-idName priority priority-value注意：通常情况下，Master设备的优先级应高于Backup设备。</p>
</li>
<li><p>配置备份组中设备的抢占延迟时间**(主路由器没有问题后，回去抢占，可以配置延长多久时间抢占)**</p>
<p>[interface-GigabitEthernet0/0/0]vrrp vrid virtual-router-id preempt-mode timer delay delay-2 配置VRRP位抢占模式，延时2s抢占</p>
<p>[interface-GigabitEthernet0/0/0]vrrp vrid virtual-router-id preempt-mode disable缺省情况下，抢占模式已被激活。</p>
</li>
<li><p><strong>配置VRRP备份组监视接口</strong><br>[interface-GigabitEthernet0/0/0]vrrp vrid virtual-router-id track interface interface-type interface-number [increased value-increased | reduced value-decreased]<br>可配置设备，当检测到上行接口或链路出现故障时，增加或者减少自身优先级，IP地址拥有者和Eth-trunk成员口不允许配置VRRP监视功能。</p>
</li>
<li><p>配置VRRP备份组联动普通BFD会话（BFD实现毫秒级的切换）<br>[interface-GigabitEthernet0/0/0]vrrp vrid virtual-router-id track bfd-session（bfd-session-id session-name bfd-configure-<br>name}[increased value-increased | reduced value-reduced]<br>如果选择参数session-name bfd-configure-name，可以绑定静态BFD会话或者标识符自协商的静态BFD会话。<br>如果选择参数bfd-session-id，只能绑定静态BFD会话。</p>
</li>
</ul>
<h3 id="策略路由和路由策略"><a href="#策略路由和路由策略" class="headerlink" title="策略路由和路由策略"></a><strong>策略路由和路由策略</strong></h3><p>（1）功能不同。策略路由通过定义策略和应用，实现数据流量按照规划的路径走。路由策略是通过ACL/Route-policy等方式控</p>
<p>制路由发布，让对方学到适当路由条目。<br>（2）作用层面不同。策略路由作用于转发层面（数据报文），路由策略作用于控制层面（路由信息）</p>
<p>（3）与路由表关系不同。策略路由需要手工逐跳配置，以保证报文按策略转发。路由策略可以跟路由表天然集成。</p>
<p>（4）应用工具和命令不同，策略路由使用traffic-policy和，而路由策略使用route-policy和filter-policy</p>
<h3 id="配置安全策略"><a href="#配置安全策略" class="headerlink" title="配置安全策略"></a>配置安全策略</h3><p>通过安全区域区分受信任网络和不受信任网络</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FW]firewall zone trust  //进入trust区域</span><br><span class="line">[FW-zone-trust]add int g1/0/0   //把g1/0/0加入trust区域  undo add int g1/0/0  取消加入</span><br><span class="line">[FW]firewall zone untrust </span><br><span class="line">[FW-zone-untrust]add int g1/0/1</span><br></pre></td></tr></table></figure>

<p>配置安全策略</p>
<p>192.168.5.2和192.168.5.3不能ping通1.1.1.1，<br>192.168.5.0上其余的pc可以ping通（先配置不能ping通的，否则会没有效果）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FW]security-policy  </span><br><span class="line">[FW-policy-security]rule name starry  //配置一个规则</span><br><span class="line">[FW-policy-security-rule-starry]source-zone trust   //源地址</span><br><span class="line">[FW-policy-security-rule-starry]destination-zone untrust  //目的地址</span><br><span class="line">[FW-policy-security-rule-starry]source-address 192.168.5.2 32  //表示5.2这个IP地址</span><br><span class="line">[FW-policy-security-rule-starry]source-address 192.168.5.3 32</span><br><span class="line">[FW-policy-security-rule-starry]action deny  //拒绝动作</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[FW]security-policy </span><br><span class="line">[FW-policy-security]rule name starry1</span><br><span class="line">[FW-policy-security-rule-starry1]source-zone trust</span><br><span class="line">[FW-policy-security-rule-starry1]destination-zone untrust</span><br><span class="line">[FW-policy-security-rule-starry1]source-address 192.168.5.0 24  //表示5.0这个网段</span><br><span class="line">[FW-policy-security-rule-starry1]action permit</span><br></pre></td></tr></table></figure>



<h3 id="IPSec配置"><a href="#IPSec配置" class="headerlink" title="IPSec配置"></a>IPSec配置</h3><p>配置网络可达-》配置acl识别哪些流量加密-》创建安全提议-》创建安全策略-》应用安全策略</p>
<blockquote>
<p><strong>回环ip地址</strong></p>
<ul>
<li><strong>通常 127.0.0.1 称为回环地址。</strong>回环地址主要用于本地网络接口的测试和诊断。通过将网络数据包发送到本地回环地址，可以测试网络协议栈的正常运行，以及确保计算机网络接口卡的驱动程序和硬件设备都能够正常工作。在实际应用中，回环地址可以用于各种网络诊断和测试工具，例如ping、traceroute、telnet等</li>
<li>回环地址可以在不需要其他计算机或网络连接的情况下进行测试，使其成为网络接口测试和网络应用程序开发的有用工具。可以用于模拟一些网络服务，例如Web服务器、FTP服务器、邮件服务器等。</li>
</ul>
</blockquote>
<p>isp(router)</p>
<ul>
<li>g0<ul>
<li>ip add 100.1.1.2 30</li>
</ul>
</li>
<li>g2<ul>
<li>ip add 200.1.1.2 30</li>
</ul>
</li>
<li>interface LoopBack 0 //回环地址<ul>
<li>ip address 2.2.2.2 32</li>
</ul>
</li>
</ul>
<p>r2</p>
<ul>
<li><p>g0</p>
<ul>
<li>ip address 192.168.20.254 24</li>
</ul>
</li>
<li><p>g1</p>
<ul>
<li>ip address 200.1.1.1 30</li>
</ul>
</li>
<li><p>ip route-static 0.0.0.0 0 200.1.1.2</p>
</li>
<li><p>acl 2000</p>
<ul>
<li>rule 10 permit source 192.168.20.0 0.0.0.255</li>
</ul>
</li>
<li><p>int g0/0/1</p>
<ul>
<li>nat outbound 2000</li>
</ul>
</li>
<li><p>acl 3000</p>
<ul>
<li>rule 10 permit ip source 192.168.20.0 0.0.0.255 destination 192.168.10.0 0.0.0.255</li>
</ul>
</li>
</ul>
<p>r1</p>
<ul>
<li><p>g0</p>
<ul>
<li>ip address 192.168.10.254 24</li>
</ul>
</li>
<li><p>g1</p>
<ul>
<li>ip address 100.1.1.1 30</li>
</ul>
</li>
<li><p>ip route-static 0.0.0.0 0 100.1.1.2</p>
</li>
<li><p>acl 2000</p>
<ul>
<li>rule 10 permit source 192.168.10.0 0.0.0.255</li>
</ul>
</li>
<li><p>int g0/0/1</p>
<ul>
<li>nat outbound 2000</li>
</ul>
</li>
<li><p>acl 3000</p>
<ul>
<li>rule 10 permit ip source 192.168.10.0 0.0.0.255 destination 192.168.20.0 0.0.0.255</li>
</ul>
</li>
</ul>
<p><strong>配置ipsec提议</strong></p>
<p>[R1]ipsec proposal cd//ipsec提议名称cd</p>
<p>[R1-ipsec-proposal-cd]esp authentication-algorithm MD5 //<strong>认证</strong>算法采用 MD5</p>
<p>[R1-ipsec-proposal-cd]esp encryption-algorithm des //<strong>加密</strong>算法,用对称加密算法</p>
<p>display ipsec proposal</p>
<p>第三步：配置ipsec手动方式安全策略<br>[R1]ipsec policy chengdu 10 manual //配置IPSEC 策略 chegndu，方式为手动<br>[R1-ipsec-policy-manual-chengdu-10]<strong>security acl 3000</strong> //包含 ac1 3000 的流量<br>[R1-ipsec-policy-manual-chengdu-10]<strong>proposal cd</strong> //采用ipsec 提议 cd<br><strong>[R1-ipsec policy manual-chengdu-10]tunnel local 100.1.1.1//配置隧道本地地址 100.1.1.1</strong><br><strong>[R1-ipsec-policy-manual-chengdu-10]tunnel remote 200.1.1.1//配置隧道远端地址 200.1.1.1</strong><br>[R1-ipsec-policy-manual-chengdu-10]sa spi <strong>inbound</strong> esp 54321//配置入方向 SA编号54321</p>
<p>[R1-ipsec-policy-manual-chengdu-10]sa spi <strong>outbound</strong> esp 12345//配置出方向 SA 编号 54321</p>
<p>[R1-ipsec-policy-manual-chengdu-10]sa string-key inbound esp cipher summer//配置入方向SA的认证密钥为 summer</p>
<p>[R1-ipsec-policy-manual-chengdu-10]string-key outbound esp cipher summer//配置出方向SA 的认证密钥为 summer</p>
<p>R2同理，4，5命令相反。6，7相反，8，9相反</p>
<p>第四步：在接口上应用 ipsec 策略</p>
<p>[R1]interface GigabitEthernet0/0/1</p>
<p>[R1-GigabitEthernet0/0/1]ipsec policy chengdu //在接口上应用 ipsce 策略</p>
<p>g0/0/1: undo acl 2000</p>
<p>acl 3001</p>
<ul>
<li>rule 10 deny ip source 192.168.10.0 0.0.0.255 destination 192.168.20.0(拒绝nat)</li>
<li><strong>rule 20 permit ip</strong></li>
</ul>
<p>int g0/0/1</p>
<ul>
<li>nat outbound 3001</li>
</ul>
<p>r2一样</p>
<h3 id="wlan"><a href="#wlan" class="headerlink" title="wlan"></a>wlan</h3><h3 id="供电"><a href="#供电" class="headerlink" title="供电"></a>供电</h3><p>poe priority是要设置设备的优先级，题目中要求IP Phone的优先级要低于AP的优先级，在华为poe设备中，优先对优先级为critical的端口连接的PD设备进行供电，其次为优先级为high的端口连接的PD设备进行供电，故此处选优先级相对较低的high</p>
<p><strong>优先级：critical&gt;high</strong></p>
<h2 id="交换机-3"><a href="#交换机-3" class="headerlink" title="交换机"></a>交换机</h2><h3 id="交换方式"><a href="#交换方式" class="headerlink" title="交换方式"></a>交换方式</h3><ul>
<li>存储转发</li>
<li>直通式交换</li>
<li>碎片过滤交换</li>
</ul>
<h3 id="交换协议"><a href="#交换协议" class="headerlink" title="交换协议"></a>交换协议</h3><ul>
<li>二层交换，根据MAC地址交换</li>
<li>三层交换，<strong>根据网络地址ip交换</strong></li>
<li>多层交换，根据端口，应用协议交换</li>
</ul>
<h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><blockquote>
<p>交换机之间的连接方式主要有两种方式：级联和堆叠，其中堆叠方式通过专用的堆叠端口使用堆叠电缆进行连接，可以共享背板带宽；级联方式用双绞线通过普通的端口连接在一起，无法共享背板带宽。</p>
</blockquote>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230515234533749.png" alt="image-20230515234533749"></p>
<p><strong>堆叠</strong>型交换机。这种交换机具有专门的堆叠端口，用堆叠电缆把一台交换机的UP口连接到另一台交换机的DOWN口，以实现端口数量的扩充，如图 10-1 所示。一般交换机能够堆叠4~9层，堆叠后的所有交换机可以当作一台交换机来统一管理。</p>
<p> (1) 堆叠技术的优点：</p>
<p> 1.增加网络端口，提高端口密度，扩充网络带宽。</p>
<p> 2.逻辑上变为一台设备，简化了本地管理</p>
<p> 堆叠技术的缺点：</p>
<p> 1.堆叠是一种非标准化的技术，同一组堆叠交换机必须是同一品牌；</p>
<p> 2.堆叠不支持即插即用，物理连接完毕后，还要对交换机进行相应的设置，才能正常运行。</p>
<p> 3.系统升级会造成业务中断</p>
<p><strong>级联</strong>交换机。这种交换机没有堆叠端口，但可以通过级联方式进行扩充。级连模式使用以太网端口（100M FE端口、GE端口或10GE端口）进行层次间互联，如图 10-2 所示。可以通过统一的网管平台实现对全网设备的管理。为了保证网络运行的效率，级连层数一般不要超过4层。</p>
<h3 id="网络的分层结构"><a href="#网络的分层结构" class="headerlink" title="网络的分层结构"></a>网络的分层结构</h3><p>网络的分层结构把复杂的大型网络分解为多个容易管理的小型网络，每一层交换设备分别实现不同的特定任务。分层的网络设计如图10-3所示。</p>
<p><img src="img/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/image-20230515234658605.png" alt="image-20230515234658605"></p>
<ul>
<li>接入层交换机。接入层是工作站连接网络的入口，实现用户的网络访问控制，这一层的交换机应该以低成本提供高密度的接入端口。例如，华为S2700系列最多可以提供52个快速以太网端口，适合中小型企业网络使用。</li>
<li>汇聚层交换机。汇聚层将网络划分为多个广播/组播域，可以实现 VLAN 间的路由选择，并通过访问控制列表实现分组过滤。这一层交换机的端口数量和交换速率要求不是很高，但应提供第三层交换功能。例如，华为S5700-SI系列交换机具有多个10M/100M/1000M Base-T 端口和千兆 SFP 端口，可以支持多种光模块收发器，同时提供先进的服务质量（Qos）管理和速度限制，以及安全访问控制列表、组播管理和高性能的 IP 路由。</li>
<li>核心层交换机。核心层应采用可扩展的高性能交换机组成园区网的主干线路，提供链路冗余、路由冗余、VLAN 中继和负载均衡等功能，并且与汇聚层交换机具有兼容的技术，支持相同的协议。例如，华为 S6700 系列交换机就是一种适合部署到核心网络的交换机。</li>
</ul>
<h3 id="端口类型"><a href="#端口类型" class="headerlink" title="端口类型"></a>端口类型</h3><ul>
<li>双绞线</li>
<li>光纤</li>
<li>GBIC：GBIC端口。交换机上的GBIC（Giga Bit-rate Interface Converter，GBIC）插槽（Slot）<br>用于安装千兆位端口光电转换器。GBIC 模块是将位电信号转换为光信号的热插拔器件，分为用于级连的GBIC模块和用于堆叠的GBIC模块，如图10-6所示。用于级连的GBIC模块又分为适用于多模光纤（MMF）或单模光纤（SMF）的不同类型。</li>
<li>SFP端口。小型机架可插拔设备（Small Form-factor Pluggable，SFP）是GBIC的升级版本，其功能基本和GBIC一致，但体积减少一半，可以在相同的面板上配置更多的端口。有时也称SFP模块为小型化GBIC（MINI-GBIC）模块，如图10-7所示。</li>
</ul>
<h2 id="路由器-2"><a href="#路由器-2" class="headerlink" title="路由器"></a>路由器</h2><h3 id="端口类型-1"><a href="#端口类型-1" class="headerlink" title="端口类型"></a>端口类型</h3><p>路由器不仅能实现局域网之间的连接，还能实现局域网与广域网、广域网与广域网之间的相互连接。路由器与广域网连接的端口称为 WAN 端口，路由器与局域网连接的端口称为 LAN端口。常见的网络端口有以下几种。<br>（1）RJ-45 端口。这种端口通过<strong>双绞线连接以太网</strong>。10Base-T 的 RJ-45 端口标识为 ETH，100Base-TX的RJ-45端口标识为10/100 b TX，这是因为快速以太网路由器采用10/100Mbps自适应电路</p>
<p>（2）AUI 端口。AUI 端口是一种 D 型 15 针连接器，用在令牌环网或总线型以太网中。路由器经 AUI 端口通过粗同轴电缆收发器连接 10Base-5 网络，也可以通过外接的 AUI-to-RJ-45适配器连接 10Base-T以太网，还可以借助其他类型的适配器实现与10Base-2 细同轴电缆或10Base-F 光缆的连接。AUI 端口如图 10-9 所示，</p>
<p>（3）高速同步串口。在路由器与广域网的连接中，应用最多的是高速同步串行口（Synchronous Serial Port），这种端口<strong>用于连接DDN、帧中继、X.25和PSTN等网络</strong>。通过这种端口所连接的网络两端要求同步通信，以很高的速率进行数据传输。高速同步串行口如图10-9所示。</p>
<p>（4）ISDN BRI 端口。ISDN BRI 端口通过 ISDN 线路实现路由器与Internet 或其他网络的远程连接，如图 10-9 所示。ISDN BRI 的 3 个通道（2B+D）的总带宽为 144kbps，端口采用 RJ-45标准，与 ISDN NTI 的连接使用 RJ-45-to-RJ-45 直通线。<br>（5）异步串口.异步串口（ASYNC）主要应用于与Modem或Modem池的连接，以实现远程计算机通过 PSTN 拨号接入。异步端口的速率不是很高，也不要求同步传输，只要求能连续通信。如图 10-10所示为异步串口。</p>
<p>（6）Console 端口。Console 端口通过配置专用电缆连接至计算机串行口，利用终端仿真程序（如Hyper Terminal）对路由器进行本地配置。路由器的Console端口为RJ-45口（如图10-9所示）。Console 端口不支持硬件流控。</p>
<p>（7）AUX 端口。对路由器进行远程配置时要使用 AUX 端口（Auxiliary Prot），如图 10-9所示。AUX 端口在外观上与 RJ-45 端口一样，只是内部电路不同，实现的功能也不一样。通过AUX 端口与 Modem进行连接必须借助 RJ-45 to DB9 或RJ-45 to DB25 适配器进行电路转换。<br>AUX 端口支持硬件流控。</p>
<h3 id="路由器的操作系统"><a href="#路由器的操作系统" class="headerlink" title="路由器的操作系统"></a>路由器的操作系统</h3><p>路由器都有一个操作系统，各个厂家的路由器操作系统不尽相同，但基本的工作原理都是相近似的。例如，华为路由器、交换机等数据网络产品采用的是通用路由平台VRP（Versatile Routing Platform），常用的 VRP 有VRP5 和 VRP8 两个版本。VRP5是目前大多数华为设备使用的组件化设计、高可靠性网络操作系统，而VRP8 支持分布式应用和虚拟化技术，可以适应企业快速扩展的业务需求。<br>IOS软件系统包括“BootROM软件”和“系统软件”两部分，是路由器、交换机等设备启动、运行的必要软件，为网络设备提供支撑、管理、业务等功能。网络设备加电后，<strong>首先运行BootROM软件，初始化硬件并显示的硬件参数信息，然后再运行系统软件</strong>。系统软件一方面提供对硬件的驱动和适配功能，另一方面实现了业务功能特性。<br><strong>路由器或交换机的操作是由配置文件（configuration file或config）控制的。配置文件包含有关设备如何操作的指令，是由网络管理员创建的，一般有几百到几千个字节大小。</strong><br>IOS 命令在所有路由器产品中都是通用的。这意味着只要掌握一个操作界面就可以了，即命令行界面（Command Line Interface，CLI），所以无论是通过控制台端口，或通过一部Modem，还是通过Telnet 连接来配置路由器，用户看到的命令行界面都是相同的。<br>IOS有3种命令级别，即用户视图、系统视图和具体业务视图。在不同的视图中可执行的命令集不同，可实现的管理功能也不同，详见下面的解释。</p>
<h2 id="STP生成树协议"><a href="#STP生成树协议" class="headerlink" title="STP生成树协议"></a>STP生成树协议</h2><p>在所有交换机上选举根桥 (Root Bridge)，BID最小的成为根桥，具体选举规则如下：</p>
<p><strong>BID（桥ID）</strong>：BID由2字节桥<strong>优先级</strong>和6字节的桥<strong>MAC</strong>地址组成</p>
<ul>
<li>a. 先比较BID中的优先级，具有<strong>最小优先级的交换机定为根桥</strong>。</li>
<li>b. 如果优先级一样，再比较BID中的MAC地址，<strong>MAC地址最小的确定为跟桥</strong></li>
</ul>
<blockquote>
<p>交换机默认优先级32768</p>
</blockquote>
<p>在所有非根交换机上选举根端口 (Root Port)，选举规则如下：</p>
<p><strong>PID（端口ID）</strong>：由端口优先级和端口编号组成</p>
<ul>
<li>a. <strong>非根桥交换机上</strong>，到根桥的根路径开销最小的端口，即为该非根交换机的根端口</li>
<li>b. 如果根路径开销相同，则比较<strong>对端交换机的BID</strong>，越小越优</li>
<li>c. 如果对端交换机的BID相同，则比较<strong>对端的PID</strong>，越小越优</li>
<li>d. 如果对端的PID相同，则比较<strong>本端的PID</strong>，越小越优。</li>
</ul>
<p>在所有链路上<strong>选举指定端口</strong>（Designated Port），在链路中间观察两端的端口，到根桥的根路径开销最小的端口成为指定端口。具体选举规则如下：</p>
<ul>
<li><p>a. 在各个链路上，到根桥的根路径开销最小的端口，即为指定端口</p>
</li>
<li><p>b. 如果根路径开销相同，则比较两端交换机的BID，越小越优</p>
</li>
<li><p>c. 如果对端交换机的BID相同，则比较两端交换机的PID，越小越优</p>
</li>
</ul>
<p><strong>阻塞端口</strong></p>
<p>至此，其余既不是根端口也不是指定端口的都是阻塞端口。通过阻塞端口消除环路</p>
<blockquote>
<p>stp阻塞端口消除环路,存在带宽浪费</p>
<p>RSTP在STP基础上改进，实现网络拓扑的快速收敛</p>
<p>MSTP在STP和RSTP基础上改进,实现vlan数据负载均衡</p>
</blockquote>
<h2 id="Qos"><a href="#Qos" class="headerlink" title="Qos"></a>Qos</h2><p><a href="https://www.h3c.com/cn/d_202205/1603716_30005_0.htm">https://www.h3c.com/cn/d_202205/1603716_30005_0.htm</a></p>
<p>QoS（Quality of Service）要求，QoS通常用带宽、时延、时延抖动和分组丢失率来衡量。QoS的关键指标包括可用性、吞吐量、时延、时延变化（包括抖动和漂移）和丢失</p>
<h2 id="ACL访问控制列表"><a href="#ACL访问控制列表" class="headerlink" title="ACL访问控制列表"></a>ACL访问控制列表</h2><p>ping命令主要用于测试网络的连通性。在某台主机上无法访问域名为aaa．13bb．cn的网站，而局域网中的其他主机可正常访问，原因是该计算机连接的网络中网络设备(防火墙)配置了拦截的ACL规则。</p>
<p>访问控制列表(Access Control List，ACL)是路由器的一组指令，用于设置路由器过滤数据包的规则，这种规则可以实现下列功能：</p>
<ul>
<li> . 内部过滤分组；</li>
<li> . 保护内部网络免受外部的攻击；</li>
<li> . 限制对虚拟终端的访问。</li>
</ul>
<p>AS即直连方式存储，英文全称是Direct Attached Storage。中文翻译成“直接附加存储”。顾名思义，在这种方式中，存储设备是通过电缆(通常是SCSI接口电缆)直接到服务器的。</p>
<ul>
<li><p>DAS，也可称为SAS(Server-Attached Storage，服务器附加存储)。它依赖于服务器，其本身是硬件的堆叠，不带有任何存储操作系统。</p>
</li>
<li><p>NAs(Network Attached Storage：<strong>网络附属存储</strong>)是一种将分布、独立的数据整合为大型、集中化管理的数据中心，以便于对不同主机和应用服务器进行访问的技术。按字面简单说就是连接在网络上，具备资料存储功能的装置，因此也称为“网络存储器”。它是一种专用数据存储服务器。它以数据为中心，将存储设备与服务器彻底分离，集中管理数据，从而释放带宽、提高性能、降低总拥有成本、保护投资。其成本远远低于使用服务器存储，而效率却远远高于后者。</p>
</li>
<li><p>SAN存储域网络(Storage Atea Network)的支撑技术是Fibre Channel(FC)技术，这是ANSI为网络和通道I／O接口建立的一个标准集成。支持HlPPI、IPI、SCSI、IP、ATM等多种高级协议，它的最大特性是将网络和设备的通信协议与传输物理介质隔离开。这样多种协议可在同一个物理连接上同时传送，高性能存储体和宽带网络使用单I／0接口使得系统的成本和复杂程度大大降低。</p>
</li>
</ul>
<blockquote>
<p>​    开放系统的数据存储有多种方式，属于网络化存储的是 （ ） 。nas,san</p>
</blockquote>
<p>以下关于交换机获取与其端口连接设备的MAC地址的叙述中，正确的是（） 。交换机获取与其端口连接的设备的mac地址的方法是检验端口流入分组的源地址，并将其记录在地址表中。</p>
<h2 id="网络操作系统和服务器"><a href="#网络操作系统和服务器" class="headerlink" title="网络操作系统和服务器"></a>网络操作系统和服务器</h2><p>在进行域名解析的过程中，若主域名服务器故障，辅助域名服务器启动，但返回结果的是转发域名服务器，说明辅助域名服务器配置了<strong>迭代算法</strong></p>
<p>windows操作系统中<strong>dhcp服务器的租约默认的有线网络8天，无线网络8小时（datacenter版为6小时）</strong></p>
<p>代理服务器为局城网用户提供Internet访问时，不提供（ ）服务。<strong>数据加密</strong></p>
<h3 id="Windows-IIS"><a href="#Windows-IIS" class="headerlink" title="Windows IIS"></a>Windows IIS</h3><blockquote>
<p>IIS是一款由微软公司开发的Web服务器软件，它的全称是Internet Information Services</p>
<p>IIS可以在Windows操作系统上运行，为网站和Web应用程序提供服务。 IIS的主要功能是接收来自客户端的HTTP请求，并将请求发送到相应的Web应用程序。IIS还可以处理其他协议，如FTP、SMTP等。IIS还提供了许多高级功能，如虚拟主机、安全性、负载均衡和故障转移等。</p>
</blockquote>
<p>\1. IIS是一个Web服务器软件，它可以在Windows操作系统上运行。它可以处理来自客户端的HTTP请求，并将请求发送到相应的Web应用程序。</p>
<p>\2. IIS支持多种协议，包括HTTP、FTP、SMTP等。这意味着您可以在同一个服务器上运行多个应用程序，每个应用程序使用不同的协议。</p>
<p>\3. IIS支持虚拟主机。这意味着您可以在同一个服务器上运行多个网站，每个网站都有自己的域名和IP地址。</p>
<p>\4. IIS提供了许多安全功能，如SSL证书、IP地址过滤、访问控制等。这些功能可以帮助您保护您的网站和应用程序免受攻击。</p>
<p>\5. IIS还提供了负载均衡和故障转移功能。这意味着如果一个服务器出现故障，请求会自动转移到另一个服务器上，从而保证您的网站和应用程序的可用性。 除了以上的功能，IIS还有很多其他的功能，如WebDAV、Web服务扩展、ASP.NET等。这些功能可以帮助您更好地管理和扩展您的Web应用程序。</p>
<h4 id="认证-1"><a href="#认证-1" class="headerlink" title="认证"></a>认证</h4><p> Windows IIS服务支持的身份认证方式有四种：.NET Passport身份验证、集成Windows身份验证、摘要式身份验证和基本身份验证。</p>
<ul>
<li> 集成Windows身份验证以Kerberos票证的形式通过网络向用户发送身份验证信息，并提供较高的安全级别。Windows集成身份验证使用Kerberos版本5和NTLM身份验证。<strong>集成windows身份验证是安全级别最高的验证方法</strong></li>
<li> <strong>摘要式身份验证</strong>，将用户凭据作为<strong>MD5</strong>哈希或消息摘要在网络中进行传输，这样就无法根据哈希对原始用户名和密码进行解码。</li>
<li> .NET Passport身份验证，对IIS的请求必须在查询字符串或Cookie中包含有效的.NET Passport凭据，提供了单一登录安全性，为用户提供对Internet上各种服务的访问权限。  </li>
<li> 基本身份验证：<strong>用户凭据以明文形式在网络中发送。</strong>这种形式提供的安全级别很低，因为几乎所有协议分析程序都能读取密码。所以答案是C。</li>
</ul>
<h2 id="背-5"><a href="#背-5" class="headerlink" title="背"></a>背</h2><p>路由器命令“Router(config)# access-list 1 deny 192.168.1.1”的含义是( )。不允许<strong>源地址</strong>为192.168.1.1的分组通过 </p>
<p>Access-list 10 deny tcp any(源地址) host 172.16.30.2(目的地址) eq 23/telnet</p>
<p>禁止任何主机访问10.37.16.30.2的telnet服务</p>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="https://mmbiz.qpic.cn/mmbiz/9aPYe0E1fb12HhSLxYibr9w8y4GKAfhTDsdHVfdSgVaDqKCI68l8x9V4T8eaCrkpdP7pausTQ4IZroibUqVZ20rw/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1" alt="图片"></p>
<h3 id="网络配置文件"><a href="#网络配置文件" class="headerlink" title="网络配置文件"></a>网络配置文件</h3><table>
<thead>
<tr>
<th>配置文件</th>
<th>功能</th>
<th>R舌示例</th>
</tr>
</thead>
<tbody><tr>
<td>/etc/sysconfig/network</td>
<td>包括主机甚本网络信息， 用于系统启动功</td>
<td>NETWORKING=yes/no#网络是否被配置<br/>HOSTNAME= server1#主机名<br/>GATEWAY=192.168.0.1#网关的IP地址<br/>FORWARD_IPV4=yes/no#是否开启IP转发功能<br/>GATEWAYDEV= eth0#网关设备</td>
</tr>
<tr>
<td>/etc/hostname</td>
<td>包含了系统的主机名称.，包括完全的域名</td>
<td>192.168.0.100 serverl.abc.com.en#设置主名为serverl abc.com</td>
</tr>
<tr>
<td>/etc/hosts</td>
<td>存放的是IP地址和主机名之间的映射，如果在该列表中指出某台主机的IP地址，那么访问该主机时将无须进行DNS解析</td>
<td>127.0.0.1 localhost.localdomain localhost<br/>192.168.0.101 server<br/>192.168.0.102 otherpe otheralias</td>
</tr>
<tr>
<td>/etc/host.conf</td>
<td>如何解析主机域名</td>
<td>order hosts，#解析顺序为hosts、bin<br/>bind multi on#允许/etc/hosts中将多个IP指向一台主机<br/></td>
</tr>
<tr>
<td>/etc/resolv.conf</td>
<td>存放域名、域名服务器的 irtfe址</td>
<td>domain abc.com<br/>#设置域名<br/>search abc.com abc.edu.cn<br/>#指明域名查询顺序<br/>nameserver 192.168.0.14<br/>#主域名服务器IP<br/>nameserver 192.168.0.15<br/>#从域名服务器IP</td>
</tr>
<tr>
<td>/etc/protocols</td>
<td>设定系统支拎的协议，一般不要换改</td>
<td>协议名  代码 别名 注释<br/>ip          0      IP    #Internct protocol….<br/></td>
</tr>
<tr>
<td>/etc/serviccs</td>
<td>设定系统提供的服务和使用的端口与协议，一般不要换改</td>
<td>服务  端口号/协议  说明<br/>ftp     20/tcp</td>
</tr>
<tr>
<td>/eic/xinetd.conf</td>
<td>设置超级服务器xinctd</td>
<td></td>
</tr>
</tbody></table>
<h3 id="用户管理配置文件"><a href="#用户管理配置文件" class="headerlink" title="用户管理配置文件"></a>用户管理配置文件</h3><p>（1）/etc/passwd文件：对所有可读，每个用户在此中有一行对应的记录，形式如下：</p>
<p>用户名：加密的口令：用户ID：组ID：用户的命名或描述：登录目录：登录shell</p>
<p>（2）/etc/shadow文件：超级用户可读，包含了系统中所有用户及其口令等相关信息</p>
<p>（3）/etc/group文件：记录了用户组的基本属性信息，形式如下：</p>
<p>用户组名：加密后的组口令：组ID：组成员列表命令</p>
<h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li><p>登录</p>
</li>
<li><p>shutdown关闭系统</p>
</li>
<li><p>reboot重启计算机，等同于shutdown -r now </p>
</li>
<li><p>halt关闭，sync sync halt </p>
</li>
<li><p>exit退出登录</p>
</li>
<li><p>logout重新登录</p>
</li>
<li><p>su临时切换用户</p>
</li>
<li><p>who显示当前用户</p>
</li>
</ul>
<h3 id="目录文件类命令"><a href="#目录文件类命令" class="headerlink" title="目录文件类命令"></a>目录文件类命令</h3><p>cd  切换目录   dir  显示目录内容  ls 显示目录内容   </p>
<p>cat 显示内容，适合小文件   </p>
<p>less  分屏显示，可前后翻   </p>
<p><strong>more  分屏显示内容，不可向前翻阅</strong> </p>
<p>head  显示文件头部内容   </p>
<p>tail  显示文件尾部内容   </p>
<p>touch  创建文件或更新文件访问时间</p>
<p>mkdir   创建目录   </p>
<p>rmdir  删除目录  </p>
<p>rm  删除文件或目录(-r)</p>
<p>cp   复制文件或目录  </p>
<p>mv  移动或改名  </p>
<p><strong>chown  修改文件所有者</strong> </p>
<p><strong>chgrp  修改文件所属组</strong>  </p>
<p><strong>chmod   修改文件目录权限</strong> </p>
<p>find  查找文件或目录  </p>
<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>date<br>显示或设置日期和时间</li>
<li>time<br>取以秒为单位的当前时间</li>
<li>set<br>显示环境变量</li>
</ul>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><ul>
<li>kill中止一个进程</li>
<li>top显示资源使用情况</li>
<li>jobs全部作业</li>
<li>ps查找进程</li>
<li>pstree显示进程树</li>
<li>free内存空间</li>
</ul>
<h3 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><ul>
<li>mount装载一个文件系统</li>
<li>umount卸载一个文件系统</li>
<li>df查看磁盘剩余空间</li>
<li>du查看磁盘使用情况 </li>
</ul>
<h3 id="网络配置命令"><a href="#网络配置命令" class="headerlink" title="网络配置命令"></a>网络配置命令</h3><h4 id="ipconfig"><a href="#ipconfig" class="headerlink" title="ipconfig"></a>ipconfig</h4><p>ipconfig /flushdns是清除DNS缓存记录;</p>
<p>ipconfig /displaydns为显示DNS缓存记录; </p>
<p>ipconfig /release是释放DHCP自动分配的IP地址</p>
<p>ipconfig  /all     自动获得IP地址 </p>
<p>ipconfig  /renew    重新得到新的IP地址 </p>
<h4 id="ifconfig"><a href="#ifconfig" class="headerlink" title="ifconfig"></a>ifconfig</h4><p>网络接口设置命令ifconfig，基本格式：ifconfig Interface-name ip-address up|down</p>
<p>  可以使用ifconfig命令来配置并查看网络接口的配置情况。<br>  　（1） 配置eth0的IP地址， 同时激活该设备。<br>　　#ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up<br>　　（2） 配置eth0别名设备eth0:1的IP地址，并添加路由。<br>　　#ifconfig eth0 192.168.1.3<br>　　#route add –host 192.168.1.3 dev eth0:1<br>　　（3） 激活设备。<br>　　#ifconfig eth0 up<br>　　（4） 禁用设备。<br>　　#ifconfig eth0 down<br>　　（5） 查看指定的网络接口的配置。<br>　　#ifconfig eth0<br>　　（6） 查看所有的网络接口配置。<br>　　#ifconfig</p>
<h4 id="route"><a href="#route" class="headerlink" title="route"></a>route</h4><p>配置路由命令route，基本格式：route[-选项]</p>
<p>   常用对数和选项说明如下：</p>
<p>   ·del:删除一个路由表项</p>
<p>​    ·add:增加一个路由表项</p>
<p>   ·target:配置的目的网段或者生机。可以是IP，或者是网络或主机名</p>
<p>   ·netmask Nm:用来指明要添加的路由表项的子网掩码</p>
<p>   ·gw Gw:任何通往目的地的IP分组都要通过这个网关</p>
<p>可以使用route命令来配置并查看内核路由表的配置情况。<br>　　　（1） 添加到主机的路由。<br>　　#route add –host 192.168.1.2 dev eth0:0<br>　　#route add –host 10.20.30.148 gw 10.20.30.40<br>　　（2） 添加到网络的路由。<br>　　#route add –net 10.20.30.40 netmask 255.255.255.248 eth0<br>　　#route add –net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41<br>　　#route add –net 192.168.1.0/24 eth1<br>　　（3） 添加默认网关。<br>　　#route add default gw 192.168.1.1<br>　　（4） 查看内核路由表的配置。<br>　　#route<br>　　（5）删除路由。<br>　　#route del –host 192.168.1.2 dev eth0:0<br>　　#route del –host 10.20.30.148 gw 10.20.30.40<br>　　#route del –net 10.20.30.40 netmask 255.255.255.248 eth0<br>　　#route del –net 10.20.30.48 netmask 255.255.255.248 gw 10.20.30.41<br>　　#route del –net 192.168.1.0/24 eth1<br>　　#route del default gw 192.168.1.1<br>　　对于1和2两点可使用下面的语句实现：<br>　　Ifconfig eth0 172.16.19.71 netmask 255.255.255.0<br>　　Route 0.0.0.0 gw 172.16.19.254<br>　　Service network restart</p>
<h4 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h4><p>网络测试命令ping </p>
<p>·-t:校验与指定的计算机的连接，直到用户中断</p>
<p>·-a:将地址解析为计算机名</p>
<p>·-n count:发送由count指定数量的ECHO报文，在发送指定数目（默认4）的包后停止</p>
<p>·-l length:发送包含由length指定数据长度的ECHO报文</p>
<p>·-I ttl:将“生存时间”字段设置为ttl指定的数值</p>
<h4 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h4><p>网络查询命令netstat，netstat[-选项][-参数]</p>
<p>·-a:显示所有连接的信息</p>
<p>·-i:显示所有已配置网络设备的统计信息</p>
<p>·-c:持续更新网络状态（每秒一次）直至被人为中止</p>
<p>·-r:显示内核路由表</p>
<p>·-n:以数字（原始）格式而不是已解析的名称显示远程和本地连接</p>
<p>可以使用netstat命令来显示网络状态信息。<br>　　例如：<br>　　（1） 显示网络接口状态信息。<br>　　#netstat –i<br>　　（2） 显示所有监控中的服务器的Socket和正使用Socket的程序信息。<br>　　#netstat –lpe<br>　　（3） 显示内核路由表信息。<br>　　#netstat –r<br>　　#netstat –nr<br>　　（4） 显示TCP/UDP传输协议的连接状态。<br>　　#netstat –t<br>　　#netstat –u</p>
<h4 id="tracert"><a href="#tracert" class="headerlink" title="tracert"></a>tracert</h4><p><strong>可以使用tracert命令显示数据包到达目的主机所经过的路由</strong> </p>
<h4 id="arp"><a href="#arp" class="headerlink" title="arp"></a>arp</h4><p>arp 查看arp缓存。</p>
<p>arp -a 当你需要显示当期ip地址对应的mac地址时使用</p>
<p>arp -s 添加一个IP地址和MAC地址的对应记录</p>
<p>arp –s 192.168.33.15 00:60:08:27:CE:B2　　</p>
<p>arp –d 192.168.33.15</p>
<h2 id="背-6"><a href="#背-6" class="headerlink" title="背"></a>背</h2><p>window用户管理，组策略A-G-DL-P,用户账号-全局组-域本地组-资源权限</p>
<p>安装Liux时必须创建的分区有：/boot分区、swap分区、/根分区。其中，交换分区（swap）用来支持虚拟内存的交换空间，当没有足够的内存来处理系统数据时，就要使用交换分区的空间。</p>
<h1 id="window"><a href="#window" class="headerlink" title="window"></a>window</h1><h2 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h2><h3 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h3><p>DISM.exe /Online /Cleanup-image /Scanhealth</p>
<p>DISM.exe /Online /Cleanup-image /Checkhealth</p>
<p>DISM.exe /Online /Cleanup-image /Restorehealth</p>
<p>sfc /scannow</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>window+r —&gt; sysdm.cpl —&gt; 高级 —&gt;环境变量</p>
<h3 id="任务进程"><a href="#任务进程" class="headerlink" title="任务进程"></a>任务进程</h3><p>查看任务进程：tasklist<br>删除任务pid ：taskkill /f /pid<br>taskkill /f /im 程序名 杀掉对应程序名称的所有进程<br>netstat -ano | find “3306”查看3306端口的任务进程</p>
<h1 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h1><h2 id="命令-3"><a href="#命令-3" class="headerlink" title="命令"></a>命令</h2><p>nslookup为显示域名解析服务器；</p>
<p>ftp命令</p>
<p> “get”命令，用来从服务器端下载一个文件。</p>
<p> “put”命令，用来向FTP服务器端上传一个文件。</p>
<p> “！dir”命令，用来显示客户端当前目录中的文件信息。</p>
<p> “lcd”命令，用来设置客户端当前的目录。</p>
<p> “bye”命令，用来退出FTP连接。</p>
<p>查看OSPF接口的开销、状态、类型、优先级等的命令是( 1 )；查看OSPF在接收报文时出错记录的命令是( 2 )。</p>
<p>display ospf interfacc</p>
<p>display ospf error</p>
<p>使用（）命令可以查看IS-IS协议的概要信息。display isis brief</p>
<p>以下的访问控制列表中， （ ） 禁止所有Telnet访问子网10.10.1.0/24。access-list 15 deny tcp any 10.10.1.0  0.0.0.255 eq 23 </p>
<p>在 Windows 客户机上可使用 ipconfig/release 释放当前 IP 地址</p>
<p>C：＼&gt; nslookup ＞ set type=ptr ＞211.151.91.165 查询 211.151.91.165 到域名的映射</p>
<p>Windows系统下，通过运行  （ ）  命令可以打开Windows管理控制台。mmc</p>
<p>在Linux系统中，利用 （ ） 命令可以<strong>分页显示</strong>文件的内容。more</p>
<p><img src="https://pic.cnitpm.com/upload/image/20170117/20170117161318_3492.jpg" alt="img"></p>
<h2 id="软著"><a href="#软著" class="headerlink" title="软著"></a>软著</h2><p>著作权的保护期限是作者死后<strong>第50年的12月31日。</strong></p>
<p>专利权是指国家根据发明人或设计人的申请，以向社会公开发明创造的内容，以及发明创造对社会具有符合法律规定的利益为前提，根据法定程序在一定期限内授予发明人或设计人的一种排他性权利。</p>
<p>商标权是民事主体享有的在特定的商品或服务上以区分来源为目的排他性使用特定标志的权利，<strong>有效期为10年，但期满前12个月内可申请续展，续展可无限重复进行，因此其有可能无限期地拥有商标权。</strong></p>
<p>知识产权一般都具有法定的保护期限，<strong>一旦保护期限届满，权利将自行终止</strong>，成为社会公众可以自由使用的知识。 <strong>商业秘密权</strong>受法律保护的期限是不确定的，一旦为公众所知悉，即成为公众可以自由使用的知识。</p>
<p>商业秘密权是商业秘密的合法控制人采取了保密措施，<strong>依法对其经营信息和技术信息享有的专有使用权</strong></p>
<p>本题考查知识产权知识。公民为完成法人或者其他组织工作任务所创作的作品是职务作品，职务作品可以是作品分类中的任何一种形式，如文字作品、电影作品、计算机软件等。职务作品的著作权归属分两种情形：<br>一般职务作品的著作权由作者享有。所谓一般职务作品是指虽是为完成工作任务而为，<strong>但非经法人或其他组织主持</strong>，不代表其意志创作，也不由其承担责任的职务作品。对于一股职务作品，法人或其他组织享有在其业务范围内优先使用的权利，期限为两年。优先使用权是专有的，未经单位同意，作者不得许可第三人以与法人或其他组织使用的相同方式使用该作品。在作品完成两年内，如单位在其业务范围内不使用，作者可以要求单位同意由第三人以与法人或其他组织使用的相同方式使用，所获报酬，由作者与单位按约定的比例分配。</p>
<h2 id="软件开发与标准"><a href="#软件开发与标准" class="headerlink" title="软件开发与标准"></a>软件开发与标准</h2><h3 id="背-7"><a href="#背-7" class="headerlink" title="背"></a>背</h3><p>在基于Web的电子商务应用中，访问存储于数据库中的业务对象的常用方式之一是（）。JDBC</p>
<p>软件开发的增量模型( )。是一种能够快速构造可运行产品的好方法 </p>
<p>SOA（面向服务的架构）是一种（）服务架构。粗粒度、松耦合</p>
<p>SNMPc软件支持的4个内置<strong>TCP服务</strong>是 （ ） 。</p>
<p>FTP、SMTP、WEB和TELNET</p>
<p>以下域名服务器中，没有域名数据库的  （ ）  。缓存域名服务器 </p>
<p>网络安全等级保护第三级且是在上一级基础上增加的安全要求是()。</p>
<p>评价系统可靠性通常采用MTBF(Mean Time Between Failures，平均故障间隔时间)和MTTR(Mean Time to Repair，平均修复时间)这两个技术指标。其中MTBF是指系统无故障运行的平均时间，通常以(<strong>小时</strong>)为单位。MTBF 越(<strong>大</strong>)，可靠性也就越高，在实际的网络中，故障难以避免，保证可靠性的技术从两个方面实现，故障检测技术和链路冗余，其中常见的关键链路冗余有接口备份、(<strong>链路聚合</strong>)、(<strong>VRRP</strong>)和双机热备份技术。</p>
<h3 id="系统开发和运行基础"><a href="#系统开发和运行基础" class="headerlink" title="系统开发和运行基础"></a>系统开发和运行基础</h3><p>软件的分类<br>系统软件，如操作系统<br>支撑软件，如开发工具<br>应用软件，如office<br>实时处理软件，一般是工业软件</p>
<p>软件生存周期</p>
<p>软件定义<br>问题定义，落实问题的性质、工程目标和规模，明白要解决什么问题<br>可行性研究，估计系统的成本和效益<br>需求分析，明确系统必须具备哪些功能，用数据字典和简要算法描述系统逻辑性</p>
<p>软件开发<br>概要设计，确立总体结构和模块关系，定义模块之间的接口，设计全局数据结构，制定综合测试计划<br>详细设计，设计模块内的细节，如算法、数据结构和接口信息</p>
<p>编码和单元测试，使用程序设计语言实现模块内功能并测试该模块<br>综合测试</p>
<p>软件开发模型</p>
<ul>
<li><strong>瀑布模型，自顶到下的线性模型，开发后期的测试阶段才能发现问题，增加了开发的风险</strong></li>
<li>快速原型模型</li>
<li><strong>增量模型，先开发核心模块，其他构件逐步附加</strong></li>
<li><strong>螺旋模型，适合于大型复杂项目</strong></li>
<li><strong>喷泉模型，面向对象的典型开发模型</strong></li>
</ul>
<p>结构化设计、面向对象设计<br>耦合度：做到高内聚（模块内）低耦合（模块间）是一个较科学的做法<br>程序控制的三种结构，顺序、选择、循环<br>面向对象方法（OO）=对象+类+继承+通过消息的通信<br>对象是具有特殊属性（数据）和行为方式（方法）的实体<br>类是具有相同属性和行为的一个或多个对象的描述<br>实例是类所描述的一个具体的对象</p>
<p>统一建模语言UML，是一种图示建模语言，UML表示法包括<strong>事务、关系和图三种构造块</strong></p>
<p>软件测试<br>人工测试，也叫代码审查，可调编码错和逻辑错<br>机器测试——白盒测试，要完全理解<strong>程序结构和处理过程，测试逻辑路径</strong>，也称为结构测试，逻辑覆盖是白盒测试的常用方法<br>机器测试——黑盒测试，<strong>测试程序的输入输出</strong>，也叫功能测试，黑盒白盒互为补充</p>
<p>软件调试技术一般有蛮干法、原因排除法（对分查找法、归纳法、演绎法）、回溯法</p>
<p>软件项目管理</p>
<p>软件编码规模=(最大规模+4最可能的规模+最小规模)/6</p>
<p>进度安排工具<br>关键日期表<br><strong>甘特图能直观表明每个任务的计划进度和当前进度</strong><br>网络图，PERT和CPM都采用网络图，网络图找工期要找最长路径<br>软件过程能力评估，ISO9000:2000和CMM（软件成熟度模型），CMM五个级别，级别三为已定义级，CMM5（5级别）达到优化级</p>
<h3 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h3><p>python不是编译型</p>
<h3 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h3><p>数据标准化三个阶段 </p>
<p>业务建模阶段：现实业务过程全面分析和了解；以业务模型为基础；是数据标准化的基础和前题。 </p>
<p>数据规范化阶段：关键和核心；对数据元素进行提取、规范化及管理的过程；是数据标准化的核心和重点。 </p>
<p>文档规范化阶段：是实际应用的关键，是实现离散数据有效合成 的重要途径；是数据标准化的成果有效应用的关键</p>
<p>项目收尾：合同收尾，管理收尾</p>
<p>结构化开发方法是传统的、也是应用较为广泛的一种软件开发方法，它<strong>基于数据流</strong>进行需求分析和软件设计，用抽象模型的概念，按照软件内部数据传递和转换关系，对问题和功能自顶向下逐层分解。Jackson系统开发方法是一种典型的<strong>面向数据结构</strong>的分析和设计方法，以活动为中心，一连串活动的顺序组合成一个完整的工作进程。Booch方法是一种面向对象的软件开发方法。UNL仅仅是一种<strong>建模标准语言</strong>，规定了构成软件的各个元素和构件的图示规范。</p>
<p>软件风险一<strong>般包括不确定性和损失两个特性</strong>，其中不确定性是指风险可能发生，也可能不发生；损失是当风险确实发生时，会引起的不希望的后果和损失</p>
<p>软件测试时，白盒测试不能发现( ) 功能正确</p>
<p>“白盒法”把测试对象看做是一个打开的盒子，测试人员需了解程序的内部结构和处理过程，以检查处理过程的细节为基础，对程序中尽可能多的逻辑路径进行测试，检验内部控制结构和数据结构是否有错，实际的运行状态与预期的状态是否一致。常用的白盒测试用例设计方法有基本路径测试、循环覆盖测试、逻辑覆盖测试。<strong>白盒测试不关心功能需求，故无法确定功能正确与否</strong>。</p>
<p>在面向数据流的设计方法中，一般把数据流图中的数据流划分为 （ ） 两种。变换流和事务流 </p>
<p>依据《数据中心设计规范》，在设计数据中心时，成行排列的机柜，其长度大于()米时，两端应设有通道。<br>A.5<br>B.6<br>C.7<br>D.8<br>信管网参考答案：B</p>
<h3 id="项目流程"><a href="#项目流程" class="headerlink" title="项目流程"></a>项目流程</h3><blockquote>
<p>关键路径从起点开始数到终点最长的那一条就是关键路径；</p>
<p>松弛时间是指值=通过整个活动的最长路径-通过GH整个活动的最长路径</p>
<p>经过GH的最长路径=20-17=3</p>
</blockquote>
<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示该活动所需的天数，则完成该项目的最长时间为 （1）活动BD最多可以晚（2） 一天开始而不会影响整个项目的进度。24，2</p>
<p><img src="https://pic.cnitpm.com/upload/2023/03/img2013/03-16/83c05b44a88344e096acf4f1979380ce.png" alt="img"></p>
<p>某软件项目的活动图如下图所示，其中顶点表示项目里程碑，连接顶点的边表示包含的活动，边上的数字表示活动的持续时间（天）。完成该项目的最少时间为（7）。由于某种原因，现在需要同一个开发人员完成BC和BD，到完成该项目如最少时闻为（8）天。18,20</p>
<p><img src="http://pic.cnitpm.com/upload/img2013/2018-11-12/05737da4a12840788550c3165e5f22d9.png" alt="img"></p>
<p>关键路径：最长的一段（abcefj==abdgfj=18天），bd、bc只能由同一个人来完成，因此最快的方式为，先完成bd再去完成bc（因此相当于此时，关键路径abcefj上推迟了2天完成，因此此时项目完成的最少时间为20天）。</p>
<h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><p>使用PERT图进行进度安排，不能清晰地描述　（1）　，但可以给出哪些任务完成后才能开始另一些任务。下面PERT图所示工程从A到K的关键路径是　（2）　（图中省略了任务的开始和结束时刻）。</p>
<p><img src="http://pic.cnitpm.com/upload/image/20131129/20131129222714_7812.png" alt="img"></p>
<ul>
<li>各任务之间的并行情况</li>
<li>ABEGHJK</li>
</ul>
<p>关键路线(Critical Path)是PERT网络中花费时间最长的事件和活动的序列。</p>
<p>PERT图的特点是通过关键路径法进行包括费用在内的资源最优化考虑，压缩关键路径上的工作，在规定的时间以前把它高效率地完成。PERT图不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出任务之间的关系，即哪些任务完成后才能开始另外一些任务，以及如期完成整个工程的关键路径，但是PERT图不能反映任务之间的并行关系。按照定义，题中的PERT图的关键路线是ABEGHJK。</p>
]]></content>
      <categories>
        <category>计算机,计算机网络,安全,通信,软考,linux,windows</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>计算机网络</tag>
        <tag>安全</tag>
        <tag>通信</tag>
        <tag>软考</tag>
        <tag>linux</tag>
        <tag>windows</tag>
      </tags>
  </entry>
</search>
